/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:58 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDNS(struct soap *soap, struct __tds__GetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDNS = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDNS(struct soap *soap, const struct __tds__GetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetDNS(soap, &a->tds__GetDNS);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDNS(struct soap *soap, const char *tag, int id, const struct __tds__GetDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetDNS(soap, "tds:GetDNS", -1, &a->tds__GetDNS, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDNS * SOAP_FMAC4 soap_in___tds__GetDNS(struct soap *soap, const char *tag, struct __tds__GetDNS *a, const char *type)
{
	size_t soap_flag_tds__GetDNS = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetDNS *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDNS, sizeof(struct __tds__GetDNS), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDNS(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDNS && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetDNS(soap, "tds:GetDNS", &a->tds__GetDNS, ""))
				{	soap_flag_tds__GetDNS--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetDNS * SOAP_FMAC4 soap_new___tds__GetDNS(struct soap *soap, int n)
{
	struct __tds__GetDNS *p;
	struct __tds__GetDNS *a = (struct __tds__GetDNS*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetDNS));
	for (p = a; p && n--; p++)
		soap_default___tds__GetDNS(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDNS(struct soap *soap, const struct __tds__GetDNS *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetDNS(soap, tag ? tag : "-tds:GetDNS", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDNS * SOAP_FMAC4 soap_get___tds__GetDNS(struct soap *soap, struct __tds__GetDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetHostnameFromDHCP(struct soap *soap, struct __tds__SetHostnameFromDHCP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetHostnameFromDHCP = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetHostnameFromDHCP(struct soap *soap, const struct __tds__SetHostnameFromDHCP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetHostnameFromDHCP(soap, &a->tds__SetHostnameFromDHCP);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, int id, const struct __tds__SetHostnameFromDHCP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetHostnameFromDHCP(soap, "tds:SetHostnameFromDHCP", -1, &a->tds__SetHostnameFromDHCP, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetHostnameFromDHCP * SOAP_FMAC4 soap_in___tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, struct __tds__SetHostnameFromDHCP *a, const char *type)
{
	size_t soap_flag_tds__SetHostnameFromDHCP = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetHostnameFromDHCP *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetHostnameFromDHCP, sizeof(struct __tds__SetHostnameFromDHCP), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetHostnameFromDHCP(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetHostnameFromDHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SetHostnameFromDHCP(soap, "tds:SetHostnameFromDHCP", &a->tds__SetHostnameFromDHCP, ""))
				{	soap_flag_tds__SetHostnameFromDHCP--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__SetHostnameFromDHCP * SOAP_FMAC4 soap_new___tds__SetHostnameFromDHCP(struct soap *soap, int n)
{
	struct __tds__SetHostnameFromDHCP *p;
	struct __tds__SetHostnameFromDHCP *a = (struct __tds__SetHostnameFromDHCP*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__SetHostnameFromDHCP));
	for (p = a; p && n--; p++)
		soap_default___tds__SetHostnameFromDHCP(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetHostnameFromDHCP(struct soap *soap, const struct __tds__SetHostnameFromDHCP *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetHostnameFromDHCP(soap, tag ? tag : "-tds:SetHostnameFromDHCP", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetHostnameFromDHCP * SOAP_FMAC4 soap_get___tds__SetHostnameFromDHCP(struct soap *soap, struct __tds__SetHostnameFromDHCP *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetHostnameFromDHCP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetHostname(struct soap *soap, struct __tds__SetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetHostname = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetHostname(struct soap *soap, const struct __tds__SetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetHostname(soap, &a->tds__SetHostname);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetHostname(struct soap *soap, const char *tag, int id, const struct __tds__SetHostname *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetHostname(soap, "tds:SetHostname", -1, &a->tds__SetHostname, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetHostname * SOAP_FMAC4 soap_in___tds__SetHostname(struct soap *soap, const char *tag, struct __tds__SetHostname *a, const char *type)
{
	size_t soap_flag_tds__SetHostname = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetHostname *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetHostname, sizeof(struct __tds__SetHostname), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetHostname(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetHostname && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SetHostname(soap, "tds:SetHostname", &a->tds__SetHostname, ""))
				{	soap_flag_tds__SetHostname--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__SetHostname * SOAP_FMAC4 soap_new___tds__SetHostname(struct soap *soap, int n)
{
	struct __tds__SetHostname *p;
	struct __tds__SetHostname *a = (struct __tds__SetHostname*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__SetHostname));
	for (p = a; p && n--; p++)
		soap_default___tds__SetHostname(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetHostname(struct soap *soap, const struct __tds__SetHostname *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetHostname(soap, tag ? tag : "-tds:SetHostname", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetHostname * SOAP_FMAC4 soap_get___tds__SetHostname(struct soap *soap, struct __tds__SetHostname *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetHostname(struct soap *soap, struct __tds__GetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetHostname = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetHostname(struct soap *soap, const struct __tds__GetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetHostname(soap, &a->tds__GetHostname);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetHostname(struct soap *soap, const char *tag, int id, const struct __tds__GetHostname *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetHostname(soap, "tds:GetHostname", -1, &a->tds__GetHostname, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetHostname * SOAP_FMAC4 soap_in___tds__GetHostname(struct soap *soap, const char *tag, struct __tds__GetHostname *a, const char *type)
{
	size_t soap_flag_tds__GetHostname = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetHostname *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetHostname, sizeof(struct __tds__GetHostname), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetHostname(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetHostname && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetHostname(soap, "tds:GetHostname", &a->tds__GetHostname, ""))
				{	soap_flag_tds__GetHostname--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetHostname * SOAP_FMAC4 soap_new___tds__GetHostname(struct soap *soap, int n)
{
	struct __tds__GetHostname *p;
	struct __tds__GetHostname *a = (struct __tds__GetHostname*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetHostname));
	for (p = a; p && n--; p++)
		soap_default___tds__GetHostname(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetHostname(struct soap *soap, const struct __tds__GetHostname *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetHostname(soap, tag ? tag : "-tds:GetHostname", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetHostname * SOAP_FMAC4 soap_get___tds__GetHostname(struct soap *soap, struct __tds__GetHostname *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetDPAddresses(struct soap *soap, struct __tds__SetDPAddresses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetDPAddresses = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetDPAddresses(struct soap *soap, const struct __tds__SetDPAddresses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetDPAddresses(soap, &a->tds__SetDPAddresses);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetDPAddresses(struct soap *soap, const char *tag, int id, const struct __tds__SetDPAddresses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetDPAddresses(soap, "tds:SetDPAddresses", -1, &a->tds__SetDPAddresses, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDPAddresses * SOAP_FMAC4 soap_in___tds__SetDPAddresses(struct soap *soap, const char *tag, struct __tds__SetDPAddresses *a, const char *type)
{
	size_t soap_flag_tds__SetDPAddresses = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetDPAddresses *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetDPAddresses, sizeof(struct __tds__SetDPAddresses), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetDPAddresses(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetDPAddresses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SetDPAddresses(soap, "tds:SetDPAddresses", &a->tds__SetDPAddresses, ""))
				{	soap_flag_tds__SetDPAddresses--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__SetDPAddresses * SOAP_FMAC4 soap_new___tds__SetDPAddresses(struct soap *soap, int n)
{
	struct __tds__SetDPAddresses *p;
	struct __tds__SetDPAddresses *a = (struct __tds__SetDPAddresses*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__SetDPAddresses));
	for (p = a; p && n--; p++)
		soap_default___tds__SetDPAddresses(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetDPAddresses(struct soap *soap, const struct __tds__SetDPAddresses *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetDPAddresses(soap, tag ? tag : "-tds:SetDPAddresses", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDPAddresses * SOAP_FMAC4 soap_get___tds__SetDPAddresses(struct soap *soap, struct __tds__SetDPAddresses *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetDPAddresses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetCapabilities(struct soap *soap, struct __tds__GetCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetCapabilities(struct soap *soap, const struct __tds__GetCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetCapabilities(soap, &a->tds__GetCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetCapabilities(struct soap *soap, const char *tag, int id, const struct __tds__GetCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetCapabilities(soap, "tds:GetCapabilities", -1, &a->tds__GetCapabilities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCapabilities * SOAP_FMAC4 soap_in___tds__GetCapabilities(struct soap *soap, const char *tag, struct __tds__GetCapabilities *a, const char *type)
{
	size_t soap_flag_tds__GetCapabilities = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetCapabilities *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetCapabilities, sizeof(struct __tds__GetCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetCapabilities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetCapabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetCapabilities(soap, "tds:GetCapabilities", &a->tds__GetCapabilities, ""))
				{	soap_flag_tds__GetCapabilities--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetCapabilities * SOAP_FMAC4 soap_new___tds__GetCapabilities(struct soap *soap, int n)
{
	struct __tds__GetCapabilities *p;
	struct __tds__GetCapabilities *a = (struct __tds__GetCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetCapabilities));
	for (p = a; p && n--; p++)
		soap_default___tds__GetCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetCapabilities(struct soap *soap, const struct __tds__GetCapabilities *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetCapabilities(soap, tag ? tag : "-tds:GetCapabilities", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCapabilities * SOAP_FMAC4 soap_get___tds__GetCapabilities(struct soap *soap, struct __tds__GetCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetWsdlUrl(struct soap *soap, struct __tds__GetWsdlUrl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetWsdlUrl = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetWsdlUrl(struct soap *soap, const struct __tds__GetWsdlUrl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetWsdlUrl(soap, &a->tds__GetWsdlUrl);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetWsdlUrl(struct soap *soap, const char *tag, int id, const struct __tds__GetWsdlUrl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetWsdlUrl(soap, "tds:GetWsdlUrl", -1, &a->tds__GetWsdlUrl, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetWsdlUrl * SOAP_FMAC4 soap_in___tds__GetWsdlUrl(struct soap *soap, const char *tag, struct __tds__GetWsdlUrl *a, const char *type)
{
	size_t soap_flag_tds__GetWsdlUrl = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetWsdlUrl *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetWsdlUrl, sizeof(struct __tds__GetWsdlUrl), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetWsdlUrl(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetWsdlUrl && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetWsdlUrl(soap, "tds:GetWsdlUrl", &a->tds__GetWsdlUrl, ""))
				{	soap_flag_tds__GetWsdlUrl--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetWsdlUrl * SOAP_FMAC4 soap_new___tds__GetWsdlUrl(struct soap *soap, int n)
{
	struct __tds__GetWsdlUrl *p;
	struct __tds__GetWsdlUrl *a = (struct __tds__GetWsdlUrl*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetWsdlUrl));
	for (p = a; p && n--; p++)
		soap_default___tds__GetWsdlUrl(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetWsdlUrl(struct soap *soap, const struct __tds__GetWsdlUrl *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetWsdlUrl(soap, tag ? tag : "-tds:GetWsdlUrl", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetWsdlUrl * SOAP_FMAC4 soap_get___tds__GetWsdlUrl(struct soap *soap, struct __tds__GetWsdlUrl *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetWsdlUrl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetUser(struct soap *soap, struct __tds__SetUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetUser(struct soap *soap, const struct __tds__SetUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetUser(soap, &a->tds__SetUser);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetUser(struct soap *soap, const char *tag, int id, const struct __tds__SetUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetUser(soap, "tds:SetUser", -1, &a->tds__SetUser, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetUser * SOAP_FMAC4 soap_in___tds__SetUser(struct soap *soap, const char *tag, struct __tds__SetUser *a, const char *type)
{
	size_t soap_flag_tds__SetUser = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetUser *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetUser, sizeof(struct __tds__SetUser), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetUser(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetUser && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SetUser(soap, "tds:SetUser", &a->tds__SetUser, ""))
				{	soap_flag_tds__SetUser--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__SetUser * SOAP_FMAC4 soap_new___tds__SetUser(struct soap *soap, int n)
{
	struct __tds__SetUser *p;
	struct __tds__SetUser *a = (struct __tds__SetUser*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__SetUser));
	for (p = a; p && n--; p++)
		soap_default___tds__SetUser(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetUser(struct soap *soap, const struct __tds__SetUser *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetUser(soap, tag ? tag : "-tds:SetUser", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetUser * SOAP_FMAC4 soap_get___tds__SetUser(struct soap *soap, struct __tds__SetUser *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__DeleteUsers(struct soap *soap, struct __tds__DeleteUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__DeleteUsers = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__DeleteUsers(struct soap *soap, const struct __tds__DeleteUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__DeleteUsers(soap, &a->tds__DeleteUsers);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__DeleteUsers(struct soap *soap, const char *tag, int id, const struct __tds__DeleteUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__DeleteUsers(soap, "tds:DeleteUsers", -1, &a->tds__DeleteUsers, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__DeleteUsers * SOAP_FMAC4 soap_in___tds__DeleteUsers(struct soap *soap, const char *tag, struct __tds__DeleteUsers *a, const char *type)
{
	size_t soap_flag_tds__DeleteUsers = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__DeleteUsers *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__DeleteUsers, sizeof(struct __tds__DeleteUsers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__DeleteUsers(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__DeleteUsers && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__DeleteUsers(soap, "tds:DeleteUsers", &a->tds__DeleteUsers, ""))
				{	soap_flag_tds__DeleteUsers--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__DeleteUsers * SOAP_FMAC4 soap_new___tds__DeleteUsers(struct soap *soap, int n)
{
	struct __tds__DeleteUsers *p;
	struct __tds__DeleteUsers *a = (struct __tds__DeleteUsers*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__DeleteUsers));
	for (p = a; p && n--; p++)
		soap_default___tds__DeleteUsers(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__DeleteUsers(struct soap *soap, const struct __tds__DeleteUsers *a, const char *tag, const char *type)
{
	if (soap_out___tds__DeleteUsers(soap, tag ? tag : "-tds:DeleteUsers", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__DeleteUsers * SOAP_FMAC4 soap_get___tds__DeleteUsers(struct soap *soap, struct __tds__DeleteUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__DeleteUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__CreateUsers(struct soap *soap, struct __tds__CreateUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__CreateUsers = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__CreateUsers(struct soap *soap, const struct __tds__CreateUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__CreateUsers(soap, &a->tds__CreateUsers);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__CreateUsers(struct soap *soap, const char *tag, int id, const struct __tds__CreateUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__CreateUsers(soap, "tds:CreateUsers", -1, &a->tds__CreateUsers, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__CreateUsers * SOAP_FMAC4 soap_in___tds__CreateUsers(struct soap *soap, const char *tag, struct __tds__CreateUsers *a, const char *type)
{
	size_t soap_flag_tds__CreateUsers = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__CreateUsers *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__CreateUsers, sizeof(struct __tds__CreateUsers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__CreateUsers(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__CreateUsers && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__CreateUsers(soap, "tds:CreateUsers", &a->tds__CreateUsers, ""))
				{	soap_flag_tds__CreateUsers--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__CreateUsers * SOAP_FMAC4 soap_new___tds__CreateUsers(struct soap *soap, int n)
{
	struct __tds__CreateUsers *p;
	struct __tds__CreateUsers *a = (struct __tds__CreateUsers*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__CreateUsers));
	for (p = a; p && n--; p++)
		soap_default___tds__CreateUsers(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__CreateUsers(struct soap *soap, const struct __tds__CreateUsers *a, const char *tag, const char *type)
{
	if (soap_out___tds__CreateUsers(soap, tag ? tag : "-tds:CreateUsers", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__CreateUsers * SOAP_FMAC4 soap_get___tds__CreateUsers(struct soap *soap, struct __tds__CreateUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__CreateUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetUsers(struct soap *soap, struct __tds__GetUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetUsers = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetUsers(struct soap *soap, const struct __tds__GetUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetUsers(soap, &a->tds__GetUsers);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetUsers(struct soap *soap, const char *tag, int id, const struct __tds__GetUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetUsers(soap, "tds:GetUsers", -1, &a->tds__GetUsers, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetUsers * SOAP_FMAC4 soap_in___tds__GetUsers(struct soap *soap, const char *tag, struct __tds__GetUsers *a, const char *type)
{
	size_t soap_flag_tds__GetUsers = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetUsers *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetUsers, sizeof(struct __tds__GetUsers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetUsers(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetUsers && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetUsers(soap, "tds:GetUsers", &a->tds__GetUsers, ""))
				{	soap_flag_tds__GetUsers--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetUsers * SOAP_FMAC4 soap_new___tds__GetUsers(struct soap *soap, int n)
{
	struct __tds__GetUsers *p;
	struct __tds__GetUsers *a = (struct __tds__GetUsers*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetUsers));
	for (p = a; p && n--; p++)
		soap_default___tds__GetUsers(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetUsers(struct soap *soap, const struct __tds__GetUsers *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetUsers(soap, tag ? tag : "-tds:GetUsers", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetUsers * SOAP_FMAC4 soap_get___tds__GetUsers(struct soap *soap, struct __tds__GetUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetRemoteUser(struct soap *soap, struct __tds__SetRemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetRemoteUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetRemoteUser(struct soap *soap, const struct __tds__SetRemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetRemoteUser(soap, &a->tds__SetRemoteUser);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetRemoteUser(struct soap *soap, const char *tag, int id, const struct __tds__SetRemoteUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetRemoteUser(soap, "tds:SetRemoteUser", -1, &a->tds__SetRemoteUser, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRemoteUser * SOAP_FMAC4 soap_in___tds__SetRemoteUser(struct soap *soap, const char *tag, struct __tds__SetRemoteUser *a, const char *type)
{
	size_t soap_flag_tds__SetRemoteUser = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetRemoteUser *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetRemoteUser, sizeof(struct __tds__SetRemoteUser), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetRemoteUser(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetRemoteUser && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SetRemoteUser(soap, "tds:SetRemoteUser", &a->tds__SetRemoteUser, ""))
				{	soap_flag_tds__SetRemoteUser--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__SetRemoteUser * SOAP_FMAC4 soap_new___tds__SetRemoteUser(struct soap *soap, int n)
{
	struct __tds__SetRemoteUser *p;
	struct __tds__SetRemoteUser *a = (struct __tds__SetRemoteUser*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__SetRemoteUser));
	for (p = a; p && n--; p++)
		soap_default___tds__SetRemoteUser(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetRemoteUser(struct soap *soap, const struct __tds__SetRemoteUser *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetRemoteUser(soap, tag ? tag : "-tds:SetRemoteUser", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRemoteUser * SOAP_FMAC4 soap_get___tds__SetRemoteUser(struct soap *soap, struct __tds__SetRemoteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetRemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetRemoteUser(struct soap *soap, struct __tds__GetRemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetRemoteUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetRemoteUser(struct soap *soap, const struct __tds__GetRemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetRemoteUser(soap, &a->tds__GetRemoteUser);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetRemoteUser(struct soap *soap, const char *tag, int id, const struct __tds__GetRemoteUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetRemoteUser(soap, "tds:GetRemoteUser", -1, &a->tds__GetRemoteUser, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetRemoteUser * SOAP_FMAC4 soap_in___tds__GetRemoteUser(struct soap *soap, const char *tag, struct __tds__GetRemoteUser *a, const char *type)
{
	size_t soap_flag_tds__GetRemoteUser = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetRemoteUser *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetRemoteUser, sizeof(struct __tds__GetRemoteUser), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetRemoteUser(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetRemoteUser && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetRemoteUser(soap, "tds:GetRemoteUser", &a->tds__GetRemoteUser, ""))
				{	soap_flag_tds__GetRemoteUser--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetRemoteUser * SOAP_FMAC4 soap_new___tds__GetRemoteUser(struct soap *soap, int n)
{
	struct __tds__GetRemoteUser *p;
	struct __tds__GetRemoteUser *a = (struct __tds__GetRemoteUser*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetRemoteUser));
	for (p = a; p && n--; p++)
		soap_default___tds__GetRemoteUser(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetRemoteUser(struct soap *soap, const struct __tds__GetRemoteUser *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetRemoteUser(soap, tag ? tag : "-tds:GetRemoteUser", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetRemoteUser * SOAP_FMAC4 soap_get___tds__GetRemoteUser(struct soap *soap, struct __tds__GetRemoteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetRemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetEndpointReference(struct soap *soap, struct __tds__GetEndpointReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetEndpointReference = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetEndpointReference(struct soap *soap, const struct __tds__GetEndpointReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetEndpointReference(soap, &a->tds__GetEndpointReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetEndpointReference(struct soap *soap, const char *tag, int id, const struct __tds__GetEndpointReference *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetEndpointReference(soap, "tds:GetEndpointReference", -1, &a->tds__GetEndpointReference, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetEndpointReference * SOAP_FMAC4 soap_in___tds__GetEndpointReference(struct soap *soap, const char *tag, struct __tds__GetEndpointReference *a, const char *type)
{
	size_t soap_flag_tds__GetEndpointReference = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetEndpointReference *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetEndpointReference, sizeof(struct __tds__GetEndpointReference), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetEndpointReference(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetEndpointReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetEndpointReference(soap, "tds:GetEndpointReference", &a->tds__GetEndpointReference, ""))
				{	soap_flag_tds__GetEndpointReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetEndpointReference * SOAP_FMAC4 soap_new___tds__GetEndpointReference(struct soap *soap, int n)
{
	struct __tds__GetEndpointReference *p;
	struct __tds__GetEndpointReference *a = (struct __tds__GetEndpointReference*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetEndpointReference));
	for (p = a; p && n--; p++)
		soap_default___tds__GetEndpointReference(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetEndpointReference(struct soap *soap, const struct __tds__GetEndpointReference *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetEndpointReference(soap, tag ? tag : "-tds:GetEndpointReference", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetEndpointReference * SOAP_FMAC4 soap_get___tds__GetEndpointReference(struct soap *soap, struct __tds__GetEndpointReference *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetEndpointReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDPAddresses(struct soap *soap, struct __tds__GetDPAddresses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDPAddresses = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDPAddresses(struct soap *soap, const struct __tds__GetDPAddresses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetDPAddresses(soap, &a->tds__GetDPAddresses);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDPAddresses(struct soap *soap, const char *tag, int id, const struct __tds__GetDPAddresses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetDPAddresses(soap, "tds:GetDPAddresses", -1, &a->tds__GetDPAddresses, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDPAddresses * SOAP_FMAC4 soap_in___tds__GetDPAddresses(struct soap *soap, const char *tag, struct __tds__GetDPAddresses *a, const char *type)
{
	size_t soap_flag_tds__GetDPAddresses = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetDPAddresses *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDPAddresses, sizeof(struct __tds__GetDPAddresses), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDPAddresses(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDPAddresses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetDPAddresses(soap, "tds:GetDPAddresses", &a->tds__GetDPAddresses, ""))
				{	soap_flag_tds__GetDPAddresses--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetDPAddresses * SOAP_FMAC4 soap_new___tds__GetDPAddresses(struct soap *soap, int n)
{
	struct __tds__GetDPAddresses *p;
	struct __tds__GetDPAddresses *a = (struct __tds__GetDPAddresses*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetDPAddresses));
	for (p = a; p && n--; p++)
		soap_default___tds__GetDPAddresses(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDPAddresses(struct soap *soap, const struct __tds__GetDPAddresses *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetDPAddresses(soap, tag ? tag : "-tds:GetDPAddresses", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDPAddresses * SOAP_FMAC4 soap_get___tds__GetDPAddresses(struct soap *soap, struct __tds__GetDPAddresses *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDPAddresses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetRemoteDiscoveryMode(struct soap *soap, struct __tds__SetRemoteDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetRemoteDiscoveryMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetRemoteDiscoveryMode(struct soap *soap, const struct __tds__SetRemoteDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetRemoteDiscoveryMode(soap, &a->tds__SetRemoteDiscoveryMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetRemoteDiscoveryMode(struct soap *soap, const char *tag, int id, const struct __tds__SetRemoteDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetRemoteDiscoveryMode(soap, "tds:SetRemoteDiscoveryMode", -1, &a->tds__SetRemoteDiscoveryMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRemoteDiscoveryMode * SOAP_FMAC4 soap_in___tds__SetRemoteDiscoveryMode(struct soap *soap, const char *tag, struct __tds__SetRemoteDiscoveryMode *a, const char *type)
{
	size_t soap_flag_tds__SetRemoteDiscoveryMode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetRemoteDiscoveryMode *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetRemoteDiscoveryMode, sizeof(struct __tds__SetRemoteDiscoveryMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetRemoteDiscoveryMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetRemoteDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SetRemoteDiscoveryMode(soap, "tds:SetRemoteDiscoveryMode", &a->tds__SetRemoteDiscoveryMode, ""))
				{	soap_flag_tds__SetRemoteDiscoveryMode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__SetRemoteDiscoveryMode * SOAP_FMAC4 soap_new___tds__SetRemoteDiscoveryMode(struct soap *soap, int n)
{
	struct __tds__SetRemoteDiscoveryMode *p;
	struct __tds__SetRemoteDiscoveryMode *a = (struct __tds__SetRemoteDiscoveryMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__SetRemoteDiscoveryMode));
	for (p = a; p && n--; p++)
		soap_default___tds__SetRemoteDiscoveryMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetRemoteDiscoveryMode(struct soap *soap, const struct __tds__SetRemoteDiscoveryMode *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetRemoteDiscoveryMode(soap, tag ? tag : "-tds:SetRemoteDiscoveryMode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRemoteDiscoveryMode * SOAP_FMAC4 soap_get___tds__SetRemoteDiscoveryMode(struct soap *soap, struct __tds__SetRemoteDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetRemoteDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetRemoteDiscoveryMode(struct soap *soap, struct __tds__GetRemoteDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetRemoteDiscoveryMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetRemoteDiscoveryMode(struct soap *soap, const struct __tds__GetRemoteDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetRemoteDiscoveryMode(soap, &a->tds__GetRemoteDiscoveryMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetRemoteDiscoveryMode(struct soap *soap, const char *tag, int id, const struct __tds__GetRemoteDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetRemoteDiscoveryMode(soap, "tds:GetRemoteDiscoveryMode", -1, &a->tds__GetRemoteDiscoveryMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetRemoteDiscoveryMode * SOAP_FMAC4 soap_in___tds__GetRemoteDiscoveryMode(struct soap *soap, const char *tag, struct __tds__GetRemoteDiscoveryMode *a, const char *type)
{
	size_t soap_flag_tds__GetRemoteDiscoveryMode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetRemoteDiscoveryMode *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetRemoteDiscoveryMode, sizeof(struct __tds__GetRemoteDiscoveryMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetRemoteDiscoveryMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetRemoteDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetRemoteDiscoveryMode(soap, "tds:GetRemoteDiscoveryMode", &a->tds__GetRemoteDiscoveryMode, ""))
				{	soap_flag_tds__GetRemoteDiscoveryMode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetRemoteDiscoveryMode * SOAP_FMAC4 soap_new___tds__GetRemoteDiscoveryMode(struct soap *soap, int n)
{
	struct __tds__GetRemoteDiscoveryMode *p;
	struct __tds__GetRemoteDiscoveryMode *a = (struct __tds__GetRemoteDiscoveryMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetRemoteDiscoveryMode));
	for (p = a; p && n--; p++)
		soap_default___tds__GetRemoteDiscoveryMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetRemoteDiscoveryMode(struct soap *soap, const struct __tds__GetRemoteDiscoveryMode *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetRemoteDiscoveryMode(soap, tag ? tag : "-tds:GetRemoteDiscoveryMode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetRemoteDiscoveryMode * SOAP_FMAC4 soap_get___tds__GetRemoteDiscoveryMode(struct soap *soap, struct __tds__GetRemoteDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetRemoteDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetDiscoveryMode(struct soap *soap, struct __tds__SetDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetDiscoveryMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetDiscoveryMode(struct soap *soap, const struct __tds__SetDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetDiscoveryMode(soap, &a->tds__SetDiscoveryMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetDiscoveryMode(struct soap *soap, const char *tag, int id, const struct __tds__SetDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetDiscoveryMode(soap, "tds:SetDiscoveryMode", -1, &a->tds__SetDiscoveryMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDiscoveryMode * SOAP_FMAC4 soap_in___tds__SetDiscoveryMode(struct soap *soap, const char *tag, struct __tds__SetDiscoveryMode *a, const char *type)
{
	size_t soap_flag_tds__SetDiscoveryMode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetDiscoveryMode *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetDiscoveryMode, sizeof(struct __tds__SetDiscoveryMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetDiscoveryMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SetDiscoveryMode(soap, "tds:SetDiscoveryMode", &a->tds__SetDiscoveryMode, ""))
				{	soap_flag_tds__SetDiscoveryMode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__SetDiscoveryMode * SOAP_FMAC4 soap_new___tds__SetDiscoveryMode(struct soap *soap, int n)
{
	struct __tds__SetDiscoveryMode *p;
	struct __tds__SetDiscoveryMode *a = (struct __tds__SetDiscoveryMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__SetDiscoveryMode));
	for (p = a; p && n--; p++)
		soap_default___tds__SetDiscoveryMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetDiscoveryMode(struct soap *soap, const struct __tds__SetDiscoveryMode *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetDiscoveryMode(soap, tag ? tag : "-tds:SetDiscoveryMode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDiscoveryMode * SOAP_FMAC4 soap_get___tds__SetDiscoveryMode(struct soap *soap, struct __tds__SetDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDiscoveryMode(struct soap *soap, struct __tds__GetDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDiscoveryMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDiscoveryMode(struct soap *soap, const struct __tds__GetDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetDiscoveryMode(soap, &a->tds__GetDiscoveryMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDiscoveryMode(struct soap *soap, const char *tag, int id, const struct __tds__GetDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetDiscoveryMode(soap, "tds:GetDiscoveryMode", -1, &a->tds__GetDiscoveryMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDiscoveryMode * SOAP_FMAC4 soap_in___tds__GetDiscoveryMode(struct soap *soap, const char *tag, struct __tds__GetDiscoveryMode *a, const char *type)
{
	size_t soap_flag_tds__GetDiscoveryMode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetDiscoveryMode *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDiscoveryMode, sizeof(struct __tds__GetDiscoveryMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDiscoveryMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetDiscoveryMode(soap, "tds:GetDiscoveryMode", &a->tds__GetDiscoveryMode, ""))
				{	soap_flag_tds__GetDiscoveryMode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetDiscoveryMode * SOAP_FMAC4 soap_new___tds__GetDiscoveryMode(struct soap *soap, int n)
{
	struct __tds__GetDiscoveryMode *p;
	struct __tds__GetDiscoveryMode *a = (struct __tds__GetDiscoveryMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetDiscoveryMode));
	for (p = a; p && n--; p++)
		soap_default___tds__GetDiscoveryMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDiscoveryMode(struct soap *soap, const struct __tds__GetDiscoveryMode *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetDiscoveryMode(soap, tag ? tag : "-tds:GetDiscoveryMode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDiscoveryMode * SOAP_FMAC4 soap_get___tds__GetDiscoveryMode(struct soap *soap, struct __tds__GetDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__RemoveScopes(struct soap *soap, struct __tds__RemoveScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__RemoveScopes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__RemoveScopes(struct soap *soap, const struct __tds__RemoveScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__RemoveScopes(soap, &a->tds__RemoveScopes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__RemoveScopes(struct soap *soap, const char *tag, int id, const struct __tds__RemoveScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__RemoveScopes(soap, "tds:RemoveScopes", -1, &a->tds__RemoveScopes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__RemoveScopes * SOAP_FMAC4 soap_in___tds__RemoveScopes(struct soap *soap, const char *tag, struct __tds__RemoveScopes *a, const char *type)
{
	size_t soap_flag_tds__RemoveScopes = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__RemoveScopes *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__RemoveScopes, sizeof(struct __tds__RemoveScopes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__RemoveScopes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__RemoveScopes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__RemoveScopes(soap, "tds:RemoveScopes", &a->tds__RemoveScopes, ""))
				{	soap_flag_tds__RemoveScopes--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__RemoveScopes * SOAP_FMAC4 soap_new___tds__RemoveScopes(struct soap *soap, int n)
{
	struct __tds__RemoveScopes *p;
	struct __tds__RemoveScopes *a = (struct __tds__RemoveScopes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__RemoveScopes));
	for (p = a; p && n--; p++)
		soap_default___tds__RemoveScopes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__RemoveScopes(struct soap *soap, const struct __tds__RemoveScopes *a, const char *tag, const char *type)
{
	if (soap_out___tds__RemoveScopes(soap, tag ? tag : "-tds:RemoveScopes", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__RemoveScopes * SOAP_FMAC4 soap_get___tds__RemoveScopes(struct soap *soap, struct __tds__RemoveScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__RemoveScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__AddScopes(struct soap *soap, struct __tds__AddScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__AddScopes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__AddScopes(struct soap *soap, const struct __tds__AddScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__AddScopes(soap, &a->tds__AddScopes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__AddScopes(struct soap *soap, const char *tag, int id, const struct __tds__AddScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__AddScopes(soap, "tds:AddScopes", -1, &a->tds__AddScopes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__AddScopes * SOAP_FMAC4 soap_in___tds__AddScopes(struct soap *soap, const char *tag, struct __tds__AddScopes *a, const char *type)
{
	size_t soap_flag_tds__AddScopes = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__AddScopes *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__AddScopes, sizeof(struct __tds__AddScopes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__AddScopes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__AddScopes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__AddScopes(soap, "tds:AddScopes", &a->tds__AddScopes, ""))
				{	soap_flag_tds__AddScopes--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__AddScopes * SOAP_FMAC4 soap_new___tds__AddScopes(struct soap *soap, int n)
{
	struct __tds__AddScopes *p;
	struct __tds__AddScopes *a = (struct __tds__AddScopes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__AddScopes));
	for (p = a; p && n--; p++)
		soap_default___tds__AddScopes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__AddScopes(struct soap *soap, const struct __tds__AddScopes *a, const char *tag, const char *type)
{
	if (soap_out___tds__AddScopes(soap, tag ? tag : "-tds:AddScopes", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__AddScopes * SOAP_FMAC4 soap_get___tds__AddScopes(struct soap *soap, struct __tds__AddScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__AddScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetScopes(struct soap *soap, struct __tds__SetScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetScopes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetScopes(struct soap *soap, const struct __tds__SetScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetScopes(soap, &a->tds__SetScopes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetScopes(struct soap *soap, const char *tag, int id, const struct __tds__SetScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetScopes(soap, "tds:SetScopes", -1, &a->tds__SetScopes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetScopes * SOAP_FMAC4 soap_in___tds__SetScopes(struct soap *soap, const char *tag, struct __tds__SetScopes *a, const char *type)
{
	size_t soap_flag_tds__SetScopes = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetScopes *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetScopes, sizeof(struct __tds__SetScopes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetScopes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetScopes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SetScopes(soap, "tds:SetScopes", &a->tds__SetScopes, ""))
				{	soap_flag_tds__SetScopes--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__SetScopes * SOAP_FMAC4 soap_new___tds__SetScopes(struct soap *soap, int n)
{
	struct __tds__SetScopes *p;
	struct __tds__SetScopes *a = (struct __tds__SetScopes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__SetScopes));
	for (p = a; p && n--; p++)
		soap_default___tds__SetScopes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetScopes(struct soap *soap, const struct __tds__SetScopes *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetScopes(soap, tag ? tag : "-tds:SetScopes", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetScopes * SOAP_FMAC4 soap_get___tds__SetScopes(struct soap *soap, struct __tds__SetScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetScopes(struct soap *soap, struct __tds__GetScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetScopes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetScopes(struct soap *soap, const struct __tds__GetScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetScopes(soap, &a->tds__GetScopes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetScopes(struct soap *soap, const char *tag, int id, const struct __tds__GetScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetScopes(soap, "tds:GetScopes", -1, &a->tds__GetScopes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetScopes * SOAP_FMAC4 soap_in___tds__GetScopes(struct soap *soap, const char *tag, struct __tds__GetScopes *a, const char *type)
{
	size_t soap_flag_tds__GetScopes = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetScopes *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetScopes, sizeof(struct __tds__GetScopes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetScopes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetScopes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetScopes(soap, "tds:GetScopes", &a->tds__GetScopes, ""))
				{	soap_flag_tds__GetScopes--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetScopes * SOAP_FMAC4 soap_new___tds__GetScopes(struct soap *soap, int n)
{
	struct __tds__GetScopes *p;
	struct __tds__GetScopes *a = (struct __tds__GetScopes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetScopes));
	for (p = a; p && n--; p++)
		soap_default___tds__GetScopes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetScopes(struct soap *soap, const struct __tds__GetScopes *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetScopes(soap, tag ? tag : "-tds:GetScopes", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetScopes * SOAP_FMAC4 soap_get___tds__GetScopes(struct soap *soap, struct __tds__GetScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetSystemSupportInformation(struct soap *soap, struct __tds__GetSystemSupportInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetSystemSupportInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetSystemSupportInformation(struct soap *soap, const struct __tds__GetSystemSupportInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetSystemSupportInformation(soap, &a->tds__GetSystemSupportInformation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetSystemSupportInformation(struct soap *soap, const char *tag, int id, const struct __tds__GetSystemSupportInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetSystemSupportInformation(soap, "tds:GetSystemSupportInformation", -1, &a->tds__GetSystemSupportInformation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemSupportInformation * SOAP_FMAC4 soap_in___tds__GetSystemSupportInformation(struct soap *soap, const char *tag, struct __tds__GetSystemSupportInformation *a, const char *type)
{
	size_t soap_flag_tds__GetSystemSupportInformation = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetSystemSupportInformation *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetSystemSupportInformation, sizeof(struct __tds__GetSystemSupportInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetSystemSupportInformation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetSystemSupportInformation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetSystemSupportInformation(soap, "tds:GetSystemSupportInformation", &a->tds__GetSystemSupportInformation, ""))
				{	soap_flag_tds__GetSystemSupportInformation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetSystemSupportInformation * SOAP_FMAC4 soap_new___tds__GetSystemSupportInformation(struct soap *soap, int n)
{
	struct __tds__GetSystemSupportInformation *p;
	struct __tds__GetSystemSupportInformation *a = (struct __tds__GetSystemSupportInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetSystemSupportInformation));
	for (p = a; p && n--; p++)
		soap_default___tds__GetSystemSupportInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetSystemSupportInformation(struct soap *soap, const struct __tds__GetSystemSupportInformation *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetSystemSupportInformation(soap, tag ? tag : "-tds:GetSystemSupportInformation", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemSupportInformation * SOAP_FMAC4 soap_get___tds__GetSystemSupportInformation(struct soap *soap, struct __tds__GetSystemSupportInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetSystemSupportInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetSystemLog(struct soap *soap, struct __tds__GetSystemLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetSystemLog = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetSystemLog(struct soap *soap, const struct __tds__GetSystemLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetSystemLog(soap, &a->tds__GetSystemLog);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetSystemLog(struct soap *soap, const char *tag, int id, const struct __tds__GetSystemLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetSystemLog(soap, "tds:GetSystemLog", -1, &a->tds__GetSystemLog, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemLog * SOAP_FMAC4 soap_in___tds__GetSystemLog(struct soap *soap, const char *tag, struct __tds__GetSystemLog *a, const char *type)
{
	size_t soap_flag_tds__GetSystemLog = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetSystemLog *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetSystemLog, sizeof(struct __tds__GetSystemLog), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetSystemLog(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetSystemLog && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetSystemLog(soap, "tds:GetSystemLog", &a->tds__GetSystemLog, ""))
				{	soap_flag_tds__GetSystemLog--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetSystemLog * SOAP_FMAC4 soap_new___tds__GetSystemLog(struct soap *soap, int n)
{
	struct __tds__GetSystemLog *p;
	struct __tds__GetSystemLog *a = (struct __tds__GetSystemLog*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetSystemLog));
	for (p = a; p && n--; p++)
		soap_default___tds__GetSystemLog(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetSystemLog(struct soap *soap, const struct __tds__GetSystemLog *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetSystemLog(soap, tag ? tag : "-tds:GetSystemLog", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemLog * SOAP_FMAC4 soap_get___tds__GetSystemLog(struct soap *soap, struct __tds__GetSystemLog *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetSystemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetSystemBackup(struct soap *soap, struct __tds__GetSystemBackup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetSystemBackup = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetSystemBackup(struct soap *soap, const struct __tds__GetSystemBackup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetSystemBackup(soap, &a->tds__GetSystemBackup);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetSystemBackup(struct soap *soap, const char *tag, int id, const struct __tds__GetSystemBackup *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetSystemBackup(soap, "tds:GetSystemBackup", -1, &a->tds__GetSystemBackup, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemBackup * SOAP_FMAC4 soap_in___tds__GetSystemBackup(struct soap *soap, const char *tag, struct __tds__GetSystemBackup *a, const char *type)
{
	size_t soap_flag_tds__GetSystemBackup = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetSystemBackup *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetSystemBackup, sizeof(struct __tds__GetSystemBackup), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetSystemBackup(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetSystemBackup && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetSystemBackup(soap, "tds:GetSystemBackup", &a->tds__GetSystemBackup, ""))
				{	soap_flag_tds__GetSystemBackup--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetSystemBackup * SOAP_FMAC4 soap_new___tds__GetSystemBackup(struct soap *soap, int n)
{
	struct __tds__GetSystemBackup *p;
	struct __tds__GetSystemBackup *a = (struct __tds__GetSystemBackup*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetSystemBackup));
	for (p = a; p && n--; p++)
		soap_default___tds__GetSystemBackup(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetSystemBackup(struct soap *soap, const struct __tds__GetSystemBackup *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetSystemBackup(soap, tag ? tag : "-tds:GetSystemBackup", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemBackup * SOAP_FMAC4 soap_get___tds__GetSystemBackup(struct soap *soap, struct __tds__GetSystemBackup *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetSystemBackup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__RestoreSystem(struct soap *soap, struct __tds__RestoreSystem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__RestoreSystem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__RestoreSystem(struct soap *soap, const struct __tds__RestoreSystem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__RestoreSystem(soap, &a->tds__RestoreSystem);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__RestoreSystem(struct soap *soap, const char *tag, int id, const struct __tds__RestoreSystem *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__RestoreSystem(soap, "tds:RestoreSystem", -1, &a->tds__RestoreSystem, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__RestoreSystem * SOAP_FMAC4 soap_in___tds__RestoreSystem(struct soap *soap, const char *tag, struct __tds__RestoreSystem *a, const char *type)
{
	size_t soap_flag_tds__RestoreSystem = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__RestoreSystem *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__RestoreSystem, sizeof(struct __tds__RestoreSystem), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__RestoreSystem(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__RestoreSystem && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__RestoreSystem(soap, "tds:RestoreSystem", &a->tds__RestoreSystem, ""))
				{	soap_flag_tds__RestoreSystem--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__RestoreSystem * SOAP_FMAC4 soap_new___tds__RestoreSystem(struct soap *soap, int n)
{
	struct __tds__RestoreSystem *p;
	struct __tds__RestoreSystem *a = (struct __tds__RestoreSystem*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__RestoreSystem));
	for (p = a; p && n--; p++)
		soap_default___tds__RestoreSystem(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__RestoreSystem(struct soap *soap, const struct __tds__RestoreSystem *a, const char *tag, const char *type)
{
	if (soap_out___tds__RestoreSystem(soap, tag ? tag : "-tds:RestoreSystem", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__RestoreSystem * SOAP_FMAC4 soap_get___tds__RestoreSystem(struct soap *soap, struct __tds__RestoreSystem *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__RestoreSystem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SystemReboot(struct soap *soap, struct __tds__SystemReboot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SystemReboot = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SystemReboot(struct soap *soap, const struct __tds__SystemReboot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SystemReboot(soap, &a->tds__SystemReboot);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SystemReboot(struct soap *soap, const char *tag, int id, const struct __tds__SystemReboot *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SystemReboot(soap, "tds:SystemReboot", -1, &a->tds__SystemReboot, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SystemReboot * SOAP_FMAC4 soap_in___tds__SystemReboot(struct soap *soap, const char *tag, struct __tds__SystemReboot *a, const char *type)
{
	size_t soap_flag_tds__SystemReboot = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SystemReboot *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SystemReboot, sizeof(struct __tds__SystemReboot), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SystemReboot(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SystemReboot && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SystemReboot(soap, "tds:SystemReboot", &a->tds__SystemReboot, ""))
				{	soap_flag_tds__SystemReboot--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__SystemReboot * SOAP_FMAC4 soap_new___tds__SystemReboot(struct soap *soap, int n)
{
	struct __tds__SystemReboot *p;
	struct __tds__SystemReboot *a = (struct __tds__SystemReboot*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__SystemReboot));
	for (p = a; p && n--; p++)
		soap_default___tds__SystemReboot(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SystemReboot(struct soap *soap, const struct __tds__SystemReboot *a, const char *tag, const char *type)
{
	if (soap_out___tds__SystemReboot(soap, tag ? tag : "-tds:SystemReboot", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SystemReboot * SOAP_FMAC4 soap_get___tds__SystemReboot(struct soap *soap, struct __tds__SystemReboot *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SystemReboot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__UpgradeSystemFirmware(struct soap *soap, struct __tds__UpgradeSystemFirmware *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__UpgradeSystemFirmware = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__UpgradeSystemFirmware(struct soap *soap, const struct __tds__UpgradeSystemFirmware *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__UpgradeSystemFirmware(soap, &a->tds__UpgradeSystemFirmware);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__UpgradeSystemFirmware(struct soap *soap, const char *tag, int id, const struct __tds__UpgradeSystemFirmware *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__UpgradeSystemFirmware(soap, "tds:UpgradeSystemFirmware", -1, &a->tds__UpgradeSystemFirmware, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__UpgradeSystemFirmware * SOAP_FMAC4 soap_in___tds__UpgradeSystemFirmware(struct soap *soap, const char *tag, struct __tds__UpgradeSystemFirmware *a, const char *type)
{
	size_t soap_flag_tds__UpgradeSystemFirmware = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__UpgradeSystemFirmware *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__UpgradeSystemFirmware, sizeof(struct __tds__UpgradeSystemFirmware), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__UpgradeSystemFirmware(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__UpgradeSystemFirmware && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__UpgradeSystemFirmware(soap, "tds:UpgradeSystemFirmware", &a->tds__UpgradeSystemFirmware, ""))
				{	soap_flag_tds__UpgradeSystemFirmware--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__UpgradeSystemFirmware * SOAP_FMAC4 soap_new___tds__UpgradeSystemFirmware(struct soap *soap, int n)
{
	struct __tds__UpgradeSystemFirmware *p;
	struct __tds__UpgradeSystemFirmware *a = (struct __tds__UpgradeSystemFirmware*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__UpgradeSystemFirmware));
	for (p = a; p && n--; p++)
		soap_default___tds__UpgradeSystemFirmware(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__UpgradeSystemFirmware(struct soap *soap, const struct __tds__UpgradeSystemFirmware *a, const char *tag, const char *type)
{
	if (soap_out___tds__UpgradeSystemFirmware(soap, tag ? tag : "-tds:UpgradeSystemFirmware", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__UpgradeSystemFirmware * SOAP_FMAC4 soap_get___tds__UpgradeSystemFirmware(struct soap *soap, struct __tds__UpgradeSystemFirmware *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__UpgradeSystemFirmware(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetSystemFactoryDefault(struct soap *soap, struct __tds__SetSystemFactoryDefault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetSystemFactoryDefault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetSystemFactoryDefault(struct soap *soap, const struct __tds__SetSystemFactoryDefault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetSystemFactoryDefault(soap, &a->tds__SetSystemFactoryDefault);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, int id, const struct __tds__SetSystemFactoryDefault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetSystemFactoryDefault(soap, "tds:SetSystemFactoryDefault", -1, &a->tds__SetSystemFactoryDefault, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetSystemFactoryDefault * SOAP_FMAC4 soap_in___tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, struct __tds__SetSystemFactoryDefault *a, const char *type)
{
	size_t soap_flag_tds__SetSystemFactoryDefault = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetSystemFactoryDefault *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetSystemFactoryDefault, sizeof(struct __tds__SetSystemFactoryDefault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetSystemFactoryDefault(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetSystemFactoryDefault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SetSystemFactoryDefault(soap, "tds:SetSystemFactoryDefault", &a->tds__SetSystemFactoryDefault, ""))
				{	soap_flag_tds__SetSystemFactoryDefault--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__SetSystemFactoryDefault * SOAP_FMAC4 soap_new___tds__SetSystemFactoryDefault(struct soap *soap, int n)
{
	struct __tds__SetSystemFactoryDefault *p;
	struct __tds__SetSystemFactoryDefault *a = (struct __tds__SetSystemFactoryDefault*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__SetSystemFactoryDefault));
	for (p = a; p && n--; p++)
		soap_default___tds__SetSystemFactoryDefault(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetSystemFactoryDefault(struct soap *soap, const struct __tds__SetSystemFactoryDefault *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetSystemFactoryDefault(soap, tag ? tag : "-tds:SetSystemFactoryDefault", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetSystemFactoryDefault * SOAP_FMAC4 soap_get___tds__SetSystemFactoryDefault(struct soap *soap, struct __tds__SetSystemFactoryDefault *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetSystemFactoryDefault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetSystemDateAndTime(struct soap *soap, struct __tds__GetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetSystemDateAndTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetSystemDateAndTime(struct soap *soap, const struct __tds__GetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetSystemDateAndTime(soap, &a->tds__GetSystemDateAndTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetSystemDateAndTime(struct soap *soap, const char *tag, int id, const struct __tds__GetSystemDateAndTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetSystemDateAndTime(soap, "tds:GetSystemDateAndTime", -1, &a->tds__GetSystemDateAndTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemDateAndTime * SOAP_FMAC4 soap_in___tds__GetSystemDateAndTime(struct soap *soap, const char *tag, struct __tds__GetSystemDateAndTime *a, const char *type)
{
	size_t soap_flag_tds__GetSystemDateAndTime = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetSystemDateAndTime *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetSystemDateAndTime, sizeof(struct __tds__GetSystemDateAndTime), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetSystemDateAndTime(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetSystemDateAndTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetSystemDateAndTime(soap, "tds:GetSystemDateAndTime", &a->tds__GetSystemDateAndTime, ""))
				{	soap_flag_tds__GetSystemDateAndTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetSystemDateAndTime * SOAP_FMAC4 soap_new___tds__GetSystemDateAndTime(struct soap *soap, int n)
{
	struct __tds__GetSystemDateAndTime *p;
	struct __tds__GetSystemDateAndTime *a = (struct __tds__GetSystemDateAndTime*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetSystemDateAndTime));
	for (p = a; p && n--; p++)
		soap_default___tds__GetSystemDateAndTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetSystemDateAndTime(struct soap *soap, const struct __tds__GetSystemDateAndTime *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetSystemDateAndTime(soap, tag ? tag : "-tds:GetSystemDateAndTime", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemDateAndTime * SOAP_FMAC4 soap_get___tds__GetSystemDateAndTime(struct soap *soap, struct __tds__GetSystemDateAndTime *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetSystemDateAndTime(struct soap *soap, struct __tds__SetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetSystemDateAndTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetSystemDateAndTime(struct soap *soap, const struct __tds__SetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetSystemDateAndTime(soap, &a->tds__SetSystemDateAndTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetSystemDateAndTime(struct soap *soap, const char *tag, int id, const struct __tds__SetSystemDateAndTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetSystemDateAndTime(soap, "tds:SetSystemDateAndTime", -1, &a->tds__SetSystemDateAndTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetSystemDateAndTime * SOAP_FMAC4 soap_in___tds__SetSystemDateAndTime(struct soap *soap, const char *tag, struct __tds__SetSystemDateAndTime *a, const char *type)
{
	size_t soap_flag_tds__SetSystemDateAndTime = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetSystemDateAndTime *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetSystemDateAndTime, sizeof(struct __tds__SetSystemDateAndTime), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetSystemDateAndTime(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetSystemDateAndTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SetSystemDateAndTime(soap, "tds:SetSystemDateAndTime", &a->tds__SetSystemDateAndTime, ""))
				{	soap_flag_tds__SetSystemDateAndTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__SetSystemDateAndTime * SOAP_FMAC4 soap_new___tds__SetSystemDateAndTime(struct soap *soap, int n)
{
	struct __tds__SetSystemDateAndTime *p;
	struct __tds__SetSystemDateAndTime *a = (struct __tds__SetSystemDateAndTime*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__SetSystemDateAndTime));
	for (p = a; p && n--; p++)
		soap_default___tds__SetSystemDateAndTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetSystemDateAndTime(struct soap *soap, const struct __tds__SetSystemDateAndTime *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetSystemDateAndTime(soap, tag ? tag : "-tds:SetSystemDateAndTime", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetSystemDateAndTime * SOAP_FMAC4 soap_get___tds__SetSystemDateAndTime(struct soap *soap, struct __tds__SetSystemDateAndTime *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDeviceInformation(struct soap *soap, struct __tds__GetDeviceInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDeviceInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDeviceInformation(struct soap *soap, const struct __tds__GetDeviceInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetDeviceInformation(soap, &a->tds__GetDeviceInformation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDeviceInformation(struct soap *soap, const char *tag, int id, const struct __tds__GetDeviceInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetDeviceInformation(soap, "tds:GetDeviceInformation", -1, &a->tds__GetDeviceInformation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDeviceInformation * SOAP_FMAC4 soap_in___tds__GetDeviceInformation(struct soap *soap, const char *tag, struct __tds__GetDeviceInformation *a, const char *type)
{
	size_t soap_flag_tds__GetDeviceInformation = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetDeviceInformation *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDeviceInformation, sizeof(struct __tds__GetDeviceInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDeviceInformation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDeviceInformation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetDeviceInformation(soap, "tds:GetDeviceInformation", &a->tds__GetDeviceInformation, ""))
				{	soap_flag_tds__GetDeviceInformation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetDeviceInformation * SOAP_FMAC4 soap_new___tds__GetDeviceInformation(struct soap *soap, int n)
{
	struct __tds__GetDeviceInformation *p;
	struct __tds__GetDeviceInformation *a = (struct __tds__GetDeviceInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetDeviceInformation));
	for (p = a; p && n--; p++)
		soap_default___tds__GetDeviceInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDeviceInformation(struct soap *soap, const struct __tds__GetDeviceInformation *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetDeviceInformation(soap, tag ? tag : "-tds:GetDeviceInformation", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDeviceInformation * SOAP_FMAC4 soap_get___tds__GetDeviceInformation(struct soap *soap, struct __tds__GetDeviceInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDeviceInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetServiceCapabilities(struct soap *soap, struct __tds__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetServiceCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetServiceCapabilities(struct soap *soap, const struct __tds__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetServiceCapabilities(soap, &a->tds__GetServiceCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct __tds__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetServiceCapabilities(soap, "tds:GetServiceCapabilities", -1, &a->tds__GetServiceCapabilities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetServiceCapabilities * SOAP_FMAC4 soap_in___tds__GetServiceCapabilities(struct soap *soap, const char *tag, struct __tds__GetServiceCapabilities *a, const char *type)
{
	size_t soap_flag_tds__GetServiceCapabilities = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetServiceCapabilities *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetServiceCapabilities, sizeof(struct __tds__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetServiceCapabilities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetServiceCapabilities(soap, "tds:GetServiceCapabilities", &a->tds__GetServiceCapabilities, ""))
				{	soap_flag_tds__GetServiceCapabilities--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetServiceCapabilities * SOAP_FMAC4 soap_new___tds__GetServiceCapabilities(struct soap *soap, int n)
{
	struct __tds__GetServiceCapabilities *p;
	struct __tds__GetServiceCapabilities *a = (struct __tds__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default___tds__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetServiceCapabilities(struct soap *soap, const struct __tds__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetServiceCapabilities(soap, tag ? tag : "-tds:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetServiceCapabilities * SOAP_FMAC4 soap_get___tds__GetServiceCapabilities(struct soap *soap, struct __tds__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetServices(struct soap *soap, struct __tds__GetServices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetServices = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetServices(struct soap *soap, const struct __tds__GetServices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetServices(soap, &a->tds__GetServices);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetServices(struct soap *soap, const char *tag, int id, const struct __tds__GetServices *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetServices(soap, "tds:GetServices", -1, &a->tds__GetServices, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetServices * SOAP_FMAC4 soap_in___tds__GetServices(struct soap *soap, const char *tag, struct __tds__GetServices *a, const char *type)
{
	size_t soap_flag_tds__GetServices = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetServices *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetServices, sizeof(struct __tds__GetServices), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetServices(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetServices && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetServices(soap, "tds:GetServices", &a->tds__GetServices, ""))
				{	soap_flag_tds__GetServices--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tds__GetServices * SOAP_FMAC4 soap_new___tds__GetServices(struct soap *soap, int n)
{
	struct __tds__GetServices *p;
	struct __tds__GetServices *a = (struct __tds__GetServices*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tds__GetServices));
	for (p = a; p && n--; p++)
		soap_default___tds__GetServices(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetServices(struct soap *soap, const struct __tds__GetServices *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetServices(soap, tag ? tag : "-tds:GetServices", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetServices * SOAP_FMAC4 soap_get___tds__GetServices(struct soap *soap, struct __tds__GetServices *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetServices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tdn__Probe(struct soap *soap, struct __tdn__Probe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsdd__ProbeType(soap, &a->tdn__Probe);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tdn__Probe(struct soap *soap, const struct __tdn__Probe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->tdn__Probe, SOAP_TYPE_wsdd__ProbeType);
	soap_serialize_wsdd__ProbeType(soap, &a->tdn__Probe);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tdn__Probe(struct soap *soap, const char *tag, int id, const struct __tdn__Probe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_wsdd__ProbeType(soap, "tdn:Probe", -1, &a->tdn__Probe, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tdn__Probe * SOAP_FMAC4 soap_in___tdn__Probe(struct soap *soap, const char *tag, struct __tdn__Probe *a, const char *type)
{
	size_t soap_flag_tdn__Probe = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tdn__Probe *)soap_id_enter(soap, "", a, SOAP_TYPE___tdn__Probe, sizeof(struct __tdn__Probe), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tdn__Probe(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tdn__Probe && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wsdd__ProbeType(soap, "tdn:Probe", &a->tdn__Probe, "wsdd:ProbeType"))
				{	soap_flag_tdn__Probe--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_tdn__Probe > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tdn__Probe * SOAP_FMAC4 soap_new___tdn__Probe(struct soap *soap, int n)
{
	struct __tdn__Probe *p;
	struct __tdn__Probe *a = (struct __tdn__Probe*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tdn__Probe));
	for (p = a; p && n--; p++)
		soap_default___tdn__Probe(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tdn__Probe(struct soap *soap, const struct __tdn__Probe *a, const char *tag, const char *type)
{
	if (soap_out___tdn__Probe(soap, tag ? tag : "-tdn:Probe", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tdn__Probe * SOAP_FMAC4 soap_get___tdn__Probe(struct soap *soap, struct __tdn__Probe *p, const char *tag, const char *type)
{
	if ((p = soap_in___tdn__Probe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tdn__Bye(struct soap *soap, struct __tdn__Bye *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsdd__ByeType(soap, &a->tdn__Bye);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tdn__Bye(struct soap *soap, const struct __tdn__Bye *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->tdn__Bye, SOAP_TYPE_wsdd__ByeType);
	soap_serialize_wsdd__ByeType(soap, &a->tdn__Bye);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tdn__Bye(struct soap *soap, const char *tag, int id, const struct __tdn__Bye *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_wsdd__ByeType(soap, "tdn:Bye", -1, &a->tdn__Bye, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tdn__Bye * SOAP_FMAC4 soap_in___tdn__Bye(struct soap *soap, const char *tag, struct __tdn__Bye *a, const char *type)
{
	size_t soap_flag_tdn__Bye = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tdn__Bye *)soap_id_enter(soap, "", a, SOAP_TYPE___tdn__Bye, sizeof(struct __tdn__Bye), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tdn__Bye(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tdn__Bye && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wsdd__ByeType(soap, "tdn:Bye", &a->tdn__Bye, "wsdd:ByeType"))
				{	soap_flag_tdn__Bye--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_tdn__Bye > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tdn__Bye * SOAP_FMAC4 soap_new___tdn__Bye(struct soap *soap, int n)
{
	struct __tdn__Bye *p;
	struct __tdn__Bye *a = (struct __tdn__Bye*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tdn__Bye));
	for (p = a; p && n--; p++)
		soap_default___tdn__Bye(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tdn__Bye(struct soap *soap, const struct __tdn__Bye *a, const char *tag, const char *type)
{
	if (soap_out___tdn__Bye(soap, tag ? tag : "-tdn:Bye", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tdn__Bye * SOAP_FMAC4 soap_get___tdn__Bye(struct soap *soap, struct __tdn__Bye *p, const char *tag, const char *type)
{
	if ((p = soap_in___tdn__Bye(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tdn__Hello(struct soap *soap, struct __tdn__Hello *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsdd__HelloType(soap, &a->tdn__Hello);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tdn__Hello(struct soap *soap, const struct __tdn__Hello *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->tdn__Hello, SOAP_TYPE_wsdd__HelloType);
	soap_serialize_wsdd__HelloType(soap, &a->tdn__Hello);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tdn__Hello(struct soap *soap, const char *tag, int id, const struct __tdn__Hello *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_wsdd__HelloType(soap, "tdn:Hello", -1, &a->tdn__Hello, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tdn__Hello * SOAP_FMAC4 soap_in___tdn__Hello(struct soap *soap, const char *tag, struct __tdn__Hello *a, const char *type)
{
	size_t soap_flag_tdn__Hello = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tdn__Hello *)soap_id_enter(soap, "", a, SOAP_TYPE___tdn__Hello, sizeof(struct __tdn__Hello), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tdn__Hello(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tdn__Hello && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wsdd__HelloType(soap, "tdn:Hello", &a->tdn__Hello, "wsdd:HelloType"))
				{	soap_flag_tdn__Hello--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_tdn__Hello > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tdn__Hello * SOAP_FMAC4 soap_new___tdn__Hello(struct soap *soap, int n)
{
	struct __tdn__Hello *p;
	struct __tdn__Hello *a = (struct __tdn__Hello*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tdn__Hello));
	for (p = a; p && n--; p++)
		soap_default___tdn__Hello(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tdn__Hello(struct soap *soap, const struct __tdn__Hello *a, const char *tag, const char *type)
{
	if (soap_out___tdn__Hello(soap, tag ? tag : "-tdn:Hello", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tdn__Hello * SOAP_FMAC4 soap_get___tdn__Hello(struct soap *soap, struct __tdn__Hello *p, const char *tag, const char *type)
{
	if ((p = soap_in___tdn__Hello(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tan__ModifyAnalyticsModules(struct soap *soap, struct __tan__ModifyAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__ModifyAnalyticsModules = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tan__ModifyAnalyticsModules(struct soap *soap, const struct __tan__ModifyAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tan__ModifyAnalyticsModules(soap, &a->tan__ModifyAnalyticsModules);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tan__ModifyAnalyticsModules(struct soap *soap, const char *tag, int id, const struct __tan__ModifyAnalyticsModules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tan__ModifyAnalyticsModules(soap, "tan:ModifyAnalyticsModules", -1, &a->tan__ModifyAnalyticsModules, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__ModifyAnalyticsModules * SOAP_FMAC4 soap_in___tan__ModifyAnalyticsModules(struct soap *soap, const char *tag, struct __tan__ModifyAnalyticsModules *a, const char *type)
{
	size_t soap_flag_tan__ModifyAnalyticsModules = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tan__ModifyAnalyticsModules *)soap_id_enter(soap, "", a, SOAP_TYPE___tan__ModifyAnalyticsModules, sizeof(struct __tan__ModifyAnalyticsModules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tan__ModifyAnalyticsModules(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__ModifyAnalyticsModules && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tan__ModifyAnalyticsModules(soap, "tan:ModifyAnalyticsModules", &a->tan__ModifyAnalyticsModules, ""))
				{	soap_flag_tan__ModifyAnalyticsModules--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tan__ModifyAnalyticsModules * SOAP_FMAC4 soap_new___tan__ModifyAnalyticsModules(struct soap *soap, int n)
{
	struct __tan__ModifyAnalyticsModules *p;
	struct __tan__ModifyAnalyticsModules *a = (struct __tan__ModifyAnalyticsModules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tan__ModifyAnalyticsModules));
	for (p = a; p && n--; p++)
		soap_default___tan__ModifyAnalyticsModules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tan__ModifyAnalyticsModules(struct soap *soap, const struct __tan__ModifyAnalyticsModules *a, const char *tag, const char *type)
{
	if (soap_out___tan__ModifyAnalyticsModules(soap, tag ? tag : "-tan:ModifyAnalyticsModules", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__ModifyAnalyticsModules * SOAP_FMAC4 soap_get___tan__ModifyAnalyticsModules(struct soap *soap, struct __tan__ModifyAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in___tan__ModifyAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tan__GetAnalyticsModules(struct soap *soap, struct __tan__GetAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__GetAnalyticsModules = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tan__GetAnalyticsModules(struct soap *soap, const struct __tan__GetAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tan__GetAnalyticsModules(soap, &a->tan__GetAnalyticsModules);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tan__GetAnalyticsModules(struct soap *soap, const char *tag, int id, const struct __tan__GetAnalyticsModules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tan__GetAnalyticsModules(soap, "tan:GetAnalyticsModules", -1, &a->tan__GetAnalyticsModules, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__GetAnalyticsModules * SOAP_FMAC4 soap_in___tan__GetAnalyticsModules(struct soap *soap, const char *tag, struct __tan__GetAnalyticsModules *a, const char *type)
{
	size_t soap_flag_tan__GetAnalyticsModules = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tan__GetAnalyticsModules *)soap_id_enter(soap, "", a, SOAP_TYPE___tan__GetAnalyticsModules, sizeof(struct __tan__GetAnalyticsModules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tan__GetAnalyticsModules(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__GetAnalyticsModules && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tan__GetAnalyticsModules(soap, "tan:GetAnalyticsModules", &a->tan__GetAnalyticsModules, ""))
				{	soap_flag_tan__GetAnalyticsModules--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tan__GetAnalyticsModules * SOAP_FMAC4 soap_new___tan__GetAnalyticsModules(struct soap *soap, int n)
{
	struct __tan__GetAnalyticsModules *p;
	struct __tan__GetAnalyticsModules *a = (struct __tan__GetAnalyticsModules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tan__GetAnalyticsModules));
	for (p = a; p && n--; p++)
		soap_default___tan__GetAnalyticsModules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tan__GetAnalyticsModules(struct soap *soap, const struct __tan__GetAnalyticsModules *a, const char *tag, const char *type)
{
	if (soap_out___tan__GetAnalyticsModules(soap, tag ? tag : "-tan:GetAnalyticsModules", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__GetAnalyticsModules * SOAP_FMAC4 soap_get___tan__GetAnalyticsModules(struct soap *soap, struct __tan__GetAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in___tan__GetAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tan__DeleteAnalyticsModules(struct soap *soap, struct __tan__DeleteAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__DeleteAnalyticsModules = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tan__DeleteAnalyticsModules(struct soap *soap, const struct __tan__DeleteAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tan__DeleteAnalyticsModules(soap, &a->tan__DeleteAnalyticsModules);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tan__DeleteAnalyticsModules(struct soap *soap, const char *tag, int id, const struct __tan__DeleteAnalyticsModules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tan__DeleteAnalyticsModules(soap, "tan:DeleteAnalyticsModules", -1, &a->tan__DeleteAnalyticsModules, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__DeleteAnalyticsModules * SOAP_FMAC4 soap_in___tan__DeleteAnalyticsModules(struct soap *soap, const char *tag, struct __tan__DeleteAnalyticsModules *a, const char *type)
{
	size_t soap_flag_tan__DeleteAnalyticsModules = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tan__DeleteAnalyticsModules *)soap_id_enter(soap, "", a, SOAP_TYPE___tan__DeleteAnalyticsModules, sizeof(struct __tan__DeleteAnalyticsModules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tan__DeleteAnalyticsModules(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__DeleteAnalyticsModules && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tan__DeleteAnalyticsModules(soap, "tan:DeleteAnalyticsModules", &a->tan__DeleteAnalyticsModules, ""))
				{	soap_flag_tan__DeleteAnalyticsModules--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tan__DeleteAnalyticsModules * SOAP_FMAC4 soap_new___tan__DeleteAnalyticsModules(struct soap *soap, int n)
{
	struct __tan__DeleteAnalyticsModules *p;
	struct __tan__DeleteAnalyticsModules *a = (struct __tan__DeleteAnalyticsModules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tan__DeleteAnalyticsModules));
	for (p = a; p && n--; p++)
		soap_default___tan__DeleteAnalyticsModules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tan__DeleteAnalyticsModules(struct soap *soap, const struct __tan__DeleteAnalyticsModules *a, const char *tag, const char *type)
{
	if (soap_out___tan__DeleteAnalyticsModules(soap, tag ? tag : "-tan:DeleteAnalyticsModules", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__DeleteAnalyticsModules * SOAP_FMAC4 soap_get___tan__DeleteAnalyticsModules(struct soap *soap, struct __tan__DeleteAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in___tan__DeleteAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tan__CreateAnalyticsModules(struct soap *soap, struct __tan__CreateAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__CreateAnalyticsModules = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tan__CreateAnalyticsModules(struct soap *soap, const struct __tan__CreateAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tan__CreateAnalyticsModules(soap, &a->tan__CreateAnalyticsModules);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tan__CreateAnalyticsModules(struct soap *soap, const char *tag, int id, const struct __tan__CreateAnalyticsModules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tan__CreateAnalyticsModules(soap, "tan:CreateAnalyticsModules", -1, &a->tan__CreateAnalyticsModules, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__CreateAnalyticsModules * SOAP_FMAC4 soap_in___tan__CreateAnalyticsModules(struct soap *soap, const char *tag, struct __tan__CreateAnalyticsModules *a, const char *type)
{
	size_t soap_flag_tan__CreateAnalyticsModules = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tan__CreateAnalyticsModules *)soap_id_enter(soap, "", a, SOAP_TYPE___tan__CreateAnalyticsModules, sizeof(struct __tan__CreateAnalyticsModules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tan__CreateAnalyticsModules(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__CreateAnalyticsModules && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tan__CreateAnalyticsModules(soap, "tan:CreateAnalyticsModules", &a->tan__CreateAnalyticsModules, ""))
				{	soap_flag_tan__CreateAnalyticsModules--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tan__CreateAnalyticsModules * SOAP_FMAC4 soap_new___tan__CreateAnalyticsModules(struct soap *soap, int n)
{
	struct __tan__CreateAnalyticsModules *p;
	struct __tan__CreateAnalyticsModules *a = (struct __tan__CreateAnalyticsModules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tan__CreateAnalyticsModules));
	for (p = a; p && n--; p++)
		soap_default___tan__CreateAnalyticsModules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tan__CreateAnalyticsModules(struct soap *soap, const struct __tan__CreateAnalyticsModules *a, const char *tag, const char *type)
{
	if (soap_out___tan__CreateAnalyticsModules(soap, tag ? tag : "-tan:CreateAnalyticsModules", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__CreateAnalyticsModules * SOAP_FMAC4 soap_get___tan__CreateAnalyticsModules(struct soap *soap, struct __tan__CreateAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in___tan__CreateAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tan__GetSupportedAnalyticsModules(struct soap *soap, struct __tan__GetSupportedAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__GetSupportedAnalyticsModules = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tan__GetSupportedAnalyticsModules(struct soap *soap, const struct __tan__GetSupportedAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tan__GetSupportedAnalyticsModules(soap, &a->tan__GetSupportedAnalyticsModules);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tan__GetSupportedAnalyticsModules(struct soap *soap, const char *tag, int id, const struct __tan__GetSupportedAnalyticsModules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tan__GetSupportedAnalyticsModules(soap, "tan:GetSupportedAnalyticsModules", -1, &a->tan__GetSupportedAnalyticsModules, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__GetSupportedAnalyticsModules * SOAP_FMAC4 soap_in___tan__GetSupportedAnalyticsModules(struct soap *soap, const char *tag, struct __tan__GetSupportedAnalyticsModules *a, const char *type)
{
	size_t soap_flag_tan__GetSupportedAnalyticsModules = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tan__GetSupportedAnalyticsModules *)soap_id_enter(soap, "", a, SOAP_TYPE___tan__GetSupportedAnalyticsModules, sizeof(struct __tan__GetSupportedAnalyticsModules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tan__GetSupportedAnalyticsModules(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__GetSupportedAnalyticsModules && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tan__GetSupportedAnalyticsModules(soap, "tan:GetSupportedAnalyticsModules", &a->tan__GetSupportedAnalyticsModules, ""))
				{	soap_flag_tan__GetSupportedAnalyticsModules--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tan__GetSupportedAnalyticsModules * SOAP_FMAC4 soap_new___tan__GetSupportedAnalyticsModules(struct soap *soap, int n)
{
	struct __tan__GetSupportedAnalyticsModules *p;
	struct __tan__GetSupportedAnalyticsModules *a = (struct __tan__GetSupportedAnalyticsModules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tan__GetSupportedAnalyticsModules));
	for (p = a; p && n--; p++)
		soap_default___tan__GetSupportedAnalyticsModules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tan__GetSupportedAnalyticsModules(struct soap *soap, const struct __tan__GetSupportedAnalyticsModules *a, const char *tag, const char *type)
{
	if (soap_out___tan__GetSupportedAnalyticsModules(soap, tag ? tag : "-tan:GetSupportedAnalyticsModules", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__GetSupportedAnalyticsModules * SOAP_FMAC4 soap_get___tan__GetSupportedAnalyticsModules(struct soap *soap, struct __tan__GetSupportedAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in___tan__GetSupportedAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tan__GetServiceCapabilities(struct soap *soap, struct __tan__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__GetServiceCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tan__GetServiceCapabilities(struct soap *soap, const struct __tan__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tan__GetServiceCapabilities(soap, &a->tan__GetServiceCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tan__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct __tan__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tan__GetServiceCapabilities(soap, "tan:GetServiceCapabilities", -1, &a->tan__GetServiceCapabilities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__GetServiceCapabilities * SOAP_FMAC4 soap_in___tan__GetServiceCapabilities(struct soap *soap, const char *tag, struct __tan__GetServiceCapabilities *a, const char *type)
{
	size_t soap_flag_tan__GetServiceCapabilities = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tan__GetServiceCapabilities *)soap_id_enter(soap, "", a, SOAP_TYPE___tan__GetServiceCapabilities, sizeof(struct __tan__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tan__GetServiceCapabilities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tan__GetServiceCapabilities(soap, "tan:GetServiceCapabilities", &a->tan__GetServiceCapabilities, ""))
				{	soap_flag_tan__GetServiceCapabilities--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tan__GetServiceCapabilities * SOAP_FMAC4 soap_new___tan__GetServiceCapabilities(struct soap *soap, int n)
{
	struct __tan__GetServiceCapabilities *p;
	struct __tan__GetServiceCapabilities *a = (struct __tan__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tan__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default___tan__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tan__GetServiceCapabilities(struct soap *soap, const struct __tan__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out___tan__GetServiceCapabilities(soap, tag ? tag : "-tan:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__GetServiceCapabilities * SOAP_FMAC4 soap_get___tan__GetServiceCapabilities(struct soap *soap, struct __tan__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in___tan__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tan__ModifyRules(struct soap *soap, struct __tan__ModifyRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__ModifyRules = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tan__ModifyRules(struct soap *soap, const struct __tan__ModifyRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tan__ModifyRules(soap, &a->tan__ModifyRules);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tan__ModifyRules(struct soap *soap, const char *tag, int id, const struct __tan__ModifyRules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tan__ModifyRules(soap, "tan:ModifyRules", -1, &a->tan__ModifyRules, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__ModifyRules * SOAP_FMAC4 soap_in___tan__ModifyRules(struct soap *soap, const char *tag, struct __tan__ModifyRules *a, const char *type)
{
	size_t soap_flag_tan__ModifyRules = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tan__ModifyRules *)soap_id_enter(soap, "", a, SOAP_TYPE___tan__ModifyRules, sizeof(struct __tan__ModifyRules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tan__ModifyRules(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__ModifyRules && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tan__ModifyRules(soap, "tan:ModifyRules", &a->tan__ModifyRules, ""))
				{	soap_flag_tan__ModifyRules--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tan__ModifyRules * SOAP_FMAC4 soap_new___tan__ModifyRules(struct soap *soap, int n)
{
	struct __tan__ModifyRules *p;
	struct __tan__ModifyRules *a = (struct __tan__ModifyRules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tan__ModifyRules));
	for (p = a; p && n--; p++)
		soap_default___tan__ModifyRules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tan__ModifyRules(struct soap *soap, const struct __tan__ModifyRules *a, const char *tag, const char *type)
{
	if (soap_out___tan__ModifyRules(soap, tag ? tag : "-tan:ModifyRules", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__ModifyRules * SOAP_FMAC4 soap_get___tan__ModifyRules(struct soap *soap, struct __tan__ModifyRules *p, const char *tag, const char *type)
{
	if ((p = soap_in___tan__ModifyRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tan__GetRules(struct soap *soap, struct __tan__GetRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__GetRules = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tan__GetRules(struct soap *soap, const struct __tan__GetRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tan__GetRules(soap, &a->tan__GetRules);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tan__GetRules(struct soap *soap, const char *tag, int id, const struct __tan__GetRules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tan__GetRules(soap, "tan:GetRules", -1, &a->tan__GetRules, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__GetRules * SOAP_FMAC4 soap_in___tan__GetRules(struct soap *soap, const char *tag, struct __tan__GetRules *a, const char *type)
{
	size_t soap_flag_tan__GetRules = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tan__GetRules *)soap_id_enter(soap, "", a, SOAP_TYPE___tan__GetRules, sizeof(struct __tan__GetRules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tan__GetRules(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__GetRules && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tan__GetRules(soap, "tan:GetRules", &a->tan__GetRules, ""))
				{	soap_flag_tan__GetRules--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tan__GetRules * SOAP_FMAC4 soap_new___tan__GetRules(struct soap *soap, int n)
{
	struct __tan__GetRules *p;
	struct __tan__GetRules *a = (struct __tan__GetRules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tan__GetRules));
	for (p = a; p && n--; p++)
		soap_default___tan__GetRules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tan__GetRules(struct soap *soap, const struct __tan__GetRules *a, const char *tag, const char *type)
{
	if (soap_out___tan__GetRules(soap, tag ? tag : "-tan:GetRules", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__GetRules * SOAP_FMAC4 soap_get___tan__GetRules(struct soap *soap, struct __tan__GetRules *p, const char *tag, const char *type)
{
	if ((p = soap_in___tan__GetRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tan__DeleteRules(struct soap *soap, struct __tan__DeleteRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__DeleteRules = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tan__DeleteRules(struct soap *soap, const struct __tan__DeleteRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tan__DeleteRules(soap, &a->tan__DeleteRules);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tan__DeleteRules(struct soap *soap, const char *tag, int id, const struct __tan__DeleteRules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tan__DeleteRules(soap, "tan:DeleteRules", -1, &a->tan__DeleteRules, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__DeleteRules * SOAP_FMAC4 soap_in___tan__DeleteRules(struct soap *soap, const char *tag, struct __tan__DeleteRules *a, const char *type)
{
	size_t soap_flag_tan__DeleteRules = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tan__DeleteRules *)soap_id_enter(soap, "", a, SOAP_TYPE___tan__DeleteRules, sizeof(struct __tan__DeleteRules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tan__DeleteRules(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__DeleteRules && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tan__DeleteRules(soap, "tan:DeleteRules", &a->tan__DeleteRules, ""))
				{	soap_flag_tan__DeleteRules--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tan__DeleteRules * SOAP_FMAC4 soap_new___tan__DeleteRules(struct soap *soap, int n)
{
	struct __tan__DeleteRules *p;
	struct __tan__DeleteRules *a = (struct __tan__DeleteRules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tan__DeleteRules));
	for (p = a; p && n--; p++)
		soap_default___tan__DeleteRules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tan__DeleteRules(struct soap *soap, const struct __tan__DeleteRules *a, const char *tag, const char *type)
{
	if (soap_out___tan__DeleteRules(soap, tag ? tag : "-tan:DeleteRules", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__DeleteRules * SOAP_FMAC4 soap_get___tan__DeleteRules(struct soap *soap, struct __tan__DeleteRules *p, const char *tag, const char *type)
{
	if ((p = soap_in___tan__DeleteRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tan__CreateRules(struct soap *soap, struct __tan__CreateRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__CreateRules = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tan__CreateRules(struct soap *soap, const struct __tan__CreateRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tan__CreateRules(soap, &a->tan__CreateRules);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tan__CreateRules(struct soap *soap, const char *tag, int id, const struct __tan__CreateRules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tan__CreateRules(soap, "tan:CreateRules", -1, &a->tan__CreateRules, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__CreateRules * SOAP_FMAC4 soap_in___tan__CreateRules(struct soap *soap, const char *tag, struct __tan__CreateRules *a, const char *type)
{
	size_t soap_flag_tan__CreateRules = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tan__CreateRules *)soap_id_enter(soap, "", a, SOAP_TYPE___tan__CreateRules, sizeof(struct __tan__CreateRules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tan__CreateRules(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__CreateRules && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tan__CreateRules(soap, "tan:CreateRules", &a->tan__CreateRules, ""))
				{	soap_flag_tan__CreateRules--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tan__CreateRules * SOAP_FMAC4 soap_new___tan__CreateRules(struct soap *soap, int n)
{
	struct __tan__CreateRules *p;
	struct __tan__CreateRules *a = (struct __tan__CreateRules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tan__CreateRules));
	for (p = a; p && n--; p++)
		soap_default___tan__CreateRules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tan__CreateRules(struct soap *soap, const struct __tan__CreateRules *a, const char *tag, const char *type)
{
	if (soap_out___tan__CreateRules(soap, tag ? tag : "-tan:CreateRules", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__CreateRules * SOAP_FMAC4 soap_get___tan__CreateRules(struct soap *soap, struct __tan__CreateRules *p, const char *tag, const char *type)
{
	if ((p = soap_in___tan__CreateRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tan__GetSupportedRules(struct soap *soap, struct __tan__GetSupportedRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tan__GetSupportedRules = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tan__GetSupportedRules(struct soap *soap, const struct __tan__GetSupportedRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tan__GetSupportedRules(soap, &a->tan__GetSupportedRules);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tan__GetSupportedRules(struct soap *soap, const char *tag, int id, const struct __tan__GetSupportedRules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tan__GetSupportedRules(soap, "tan:GetSupportedRules", -1, &a->tan__GetSupportedRules, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__GetSupportedRules * SOAP_FMAC4 soap_in___tan__GetSupportedRules(struct soap *soap, const char *tag, struct __tan__GetSupportedRules *a, const char *type)
{
	size_t soap_flag_tan__GetSupportedRules = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tan__GetSupportedRules *)soap_id_enter(soap, "", a, SOAP_TYPE___tan__GetSupportedRules, sizeof(struct __tan__GetSupportedRules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tan__GetSupportedRules(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tan__GetSupportedRules && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tan__GetSupportedRules(soap, "tan:GetSupportedRules", &a->tan__GetSupportedRules, ""))
				{	soap_flag_tan__GetSupportedRules--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tan__GetSupportedRules * SOAP_FMAC4 soap_new___tan__GetSupportedRules(struct soap *soap, int n)
{
	struct __tan__GetSupportedRules *p;
	struct __tan__GetSupportedRules *a = (struct __tan__GetSupportedRules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tan__GetSupportedRules));
	for (p = a; p && n--; p++)
		soap_default___tan__GetSupportedRules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tan__GetSupportedRules(struct soap *soap, const struct __tan__GetSupportedRules *a, const char *tag, const char *type)
{
	if (soap_out___tan__GetSupportedRules(soap, tag ? tag : "-tan:GetSupportedRules", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tan__GetSupportedRules * SOAP_FMAC4 soap_get___tan__GetSupportedRules(struct soap *soap, struct __tan__GetSupportedRules *p, const char *tag, const char *type)
{
	if ((p = soap_in___tan__GetSupportedRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tad__GetAnalyticsState(struct soap *soap, struct __tad__GetAnalyticsState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tad__GetAnalyticsState = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tad__GetAnalyticsState(struct soap *soap, const struct __tad__GetAnalyticsState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tad__GetAnalyticsState(soap, &a->tad__GetAnalyticsState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tad__GetAnalyticsState(struct soap *soap, const char *tag, int id, const struct __tad__GetAnalyticsState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tad__GetAnalyticsState(soap, "tad:GetAnalyticsState", -1, &a->tad__GetAnalyticsState, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__GetAnalyticsState * SOAP_FMAC4 soap_in___tad__GetAnalyticsState(struct soap *soap, const char *tag, struct __tad__GetAnalyticsState *a, const char *type)
{
	size_t soap_flag_tad__GetAnalyticsState = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tad__GetAnalyticsState *)soap_id_enter(soap, "", a, SOAP_TYPE___tad__GetAnalyticsState, sizeof(struct __tad__GetAnalyticsState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tad__GetAnalyticsState(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tad__GetAnalyticsState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tad__GetAnalyticsState(soap, "tad:GetAnalyticsState", &a->tad__GetAnalyticsState, ""))
				{	soap_flag_tad__GetAnalyticsState--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __tad__GetAnalyticsState * SOAP_FMAC4 soap_new___tad__GetAnalyticsState(struct soap *soap, int n)
{
	struct __tad__GetAnalyticsState *p;
	struct __tad__GetAnalyticsState *a = (struct __tad__GetAnalyticsState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tad__GetAnalyticsState));
	for (p = a; p && n--; p++)
		soap_default___tad__GetAnalyticsState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tad__GetAnalyticsState(struct soap *soap, const struct __tad__GetAnalyticsState *a, const char *tag, const char *type)
{
	if (soap_out___tad__GetAnalyticsState(soap, tag ? tag : "-tad:GetAnalyticsState", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tad__GetAnalyticsState * SOAP_FMAC4 soap_get___tad__GetAnalyticsState(struct soap *soap, struct __tad__GetAnalyticsState *p, const char *tag, const char *type)
{
	if ((p = soap_in___tad__GetAnalyticsState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
