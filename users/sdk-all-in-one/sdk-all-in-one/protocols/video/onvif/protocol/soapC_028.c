/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:59 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default_tds__NetworkCapabilities(struct soap *soap, struct tds__NetworkCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->IPFilter = NULL;
	a->ZeroConfiguration = NULL;
	a->IPVersion6 = NULL;
	a->DynDNS = NULL;
	a->Dot11Configuration = NULL;
	a->Dot1XConfigurations = NULL;
	a->HostnameFromDHCP = NULL;
	a->NTP = NULL;
	a->DHCPv6 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tds__NetworkCapabilities(struct soap *soap, const struct tds__NetworkCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__NetworkCapabilities(struct soap *soap, const char *tag, int id, const struct tds__NetworkCapabilities *a, const char *type)
{
	if (a->IPFilter)
		soap_set_attr(soap, "IPFilter", soap_xsd__boolean2s(soap, *a->IPFilter), 1);
	if (a->ZeroConfiguration)
		soap_set_attr(soap, "ZeroConfiguration", soap_xsd__boolean2s(soap, *a->ZeroConfiguration), 1);
	if (a->IPVersion6)
		soap_set_attr(soap, "IPVersion6", soap_xsd__boolean2s(soap, *a->IPVersion6), 1);
	if (a->DynDNS)
		soap_set_attr(soap, "DynDNS", soap_xsd__boolean2s(soap, *a->DynDNS), 1);
	if (a->Dot11Configuration)
		soap_set_attr(soap, "Dot11Configuration", soap_xsd__boolean2s(soap, *a->Dot11Configuration), 1);
	if (a->Dot1XConfigurations)
		soap_set_attr(soap, "Dot1XConfigurations", soap_int2s(soap, *a->Dot1XConfigurations), 1);
	if (a->HostnameFromDHCP)
		soap_set_attr(soap, "HostnameFromDHCP", soap_xsd__boolean2s(soap, *a->HostnameFromDHCP), 1);
	if (a->NTP)
		soap_set_attr(soap, "NTP", soap_int2s(soap, *a->NTP), 1);
	if (a->DHCPv6)
		soap_set_attr(soap, "DHCPv6", soap_xsd__boolean2s(soap, *a->DHCPv6), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__NetworkCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tds__NetworkCapabilities * SOAP_FMAC4 soap_in_tds__NetworkCapabilities(struct soap *soap, const char *tag, struct tds__NetworkCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tds__NetworkCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__NetworkCapabilities, sizeof(struct tds__NetworkCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tds__NetworkCapabilities(soap, a);
	{	const char *t = soap_attr_value(soap, "IPFilter", 0);
		if (t)
		{
			if (!(a->IPFilter = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->IPFilter))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "ZeroConfiguration", 0);
		if (t)
		{
			if (!(a->ZeroConfiguration = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->ZeroConfiguration))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "IPVersion6", 0);
		if (t)
		{
			if (!(a->IPVersion6 = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->IPVersion6))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "DynDNS", 0);
		if (t)
		{
			if (!(a->DynDNS = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->DynDNS))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Dot11Configuration", 0);
		if (t)
		{
			if (!(a->Dot11Configuration = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->Dot11Configuration))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Dot1XConfigurations", 0);
		if (t)
		{
			if (!(a->Dot1XConfigurations = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->Dot1XConfigurations))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "HostnameFromDHCP", 0);
		if (t)
		{
			if (!(a->HostnameFromDHCP = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->HostnameFromDHCP))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "NTP", 0);
		if (t)
		{
			if (!(a->NTP = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->NTP))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "DHCPv6", 0);
		if (t)
		{
			if (!(a->DHCPv6 = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->DHCPv6))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tds__NetworkCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__NetworkCapabilities, SOAP_TYPE_tds__NetworkCapabilities, sizeof(struct tds__NetworkCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tds__NetworkCapabilities * SOAP_FMAC4 soap_new_tds__NetworkCapabilities(struct soap *soap, int n)
{
	struct tds__NetworkCapabilities *p;
	struct tds__NetworkCapabilities *a = (struct tds__NetworkCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tds__NetworkCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tds__NetworkCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tds__NetworkCapabilities(struct soap *soap, const struct tds__NetworkCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tds__NetworkCapabilities(soap, tag ? tag : "tds:NetworkCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__NetworkCapabilities * SOAP_FMAC4 soap_get_tds__NetworkCapabilities(struct soap *soap, struct tds__NetworkCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__NetworkCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tds__DeviceServiceCapabilities(struct soap *soap, struct tds__DeviceServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Network = NULL;
	a->Security = NULL;
	a->System = NULL;
	a->Misc = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tds__DeviceServiceCapabilities(struct soap *soap, const struct tds__DeviceServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotds__NetworkCapabilities(soap, &a->Network);
	soap_serialize_PointerTotds__SecurityCapabilities(soap, &a->Security);
	soap_serialize_PointerTotds__SystemCapabilities(soap, &a->System);
	soap_serialize_PointerTotds__MiscCapabilities(soap, &a->Misc);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__DeviceServiceCapabilities(struct soap *soap, const char *tag, int id, const struct tds__DeviceServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__DeviceServiceCapabilities), type))
		return soap->error;
	if (!a->Network)
	{	if (soap_element_nil(soap, "tds:Network"))
			return soap->error;
	}
	else
	if (soap_out_PointerTotds__NetworkCapabilities(soap, "tds:Network", -1, &a->Network, ""))
		return soap->error;
	if (!a->Security)
	{	if (soap_element_nil(soap, "tds:Security"))
			return soap->error;
	}
	else
	if (soap_out_PointerTotds__SecurityCapabilities(soap, "tds:Security", -1, &a->Security, ""))
		return soap->error;
	if (!a->System)
	{	if (soap_element_nil(soap, "tds:System"))
			return soap->error;
	}
	else
	if (soap_out_PointerTotds__SystemCapabilities(soap, "tds:System", -1, &a->System, ""))
		return soap->error;
	if (soap_out_PointerTotds__MiscCapabilities(soap, "tds:Misc", -1, &a->Misc, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tds__DeviceServiceCapabilities * SOAP_FMAC4 soap_in_tds__DeviceServiceCapabilities(struct soap *soap, const char *tag, struct tds__DeviceServiceCapabilities *a, const char *type)
{
	size_t soap_flag_Network = 1;
	size_t soap_flag_Security = 1;
	size_t soap_flag_System = 1;
	size_t soap_flag_Misc = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tds__DeviceServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__DeviceServiceCapabilities, sizeof(struct tds__DeviceServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tds__DeviceServiceCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Network && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotds__NetworkCapabilities(soap, "tds:Network", &a->Network, "tds:NetworkCapabilities"))
				{	soap_flag_Network--;
					continue;
				}
			if (soap_flag_Security && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotds__SecurityCapabilities(soap, "tds:Security", &a->Security, "tds:SecurityCapabilities"))
				{	soap_flag_Security--;
					continue;
				}
			if (soap_flag_System && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotds__SystemCapabilities(soap, "tds:System", &a->System, "tds:SystemCapabilities"))
				{	soap_flag_System--;
					continue;
				}
			if (soap_flag_Misc && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotds__MiscCapabilities(soap, "tds:Misc", &a->Misc, "tds:MiscCapabilities"))
				{	soap_flag_Misc--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Network > 0 || soap_flag_Security > 0 || soap_flag_System > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tds__DeviceServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__DeviceServiceCapabilities, SOAP_TYPE_tds__DeviceServiceCapabilities, sizeof(struct tds__DeviceServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tds__DeviceServiceCapabilities * SOAP_FMAC4 soap_new_tds__DeviceServiceCapabilities(struct soap *soap, int n)
{
	struct tds__DeviceServiceCapabilities *p;
	struct tds__DeviceServiceCapabilities *a = (struct tds__DeviceServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tds__DeviceServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tds__DeviceServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tds__DeviceServiceCapabilities(struct soap *soap, const struct tds__DeviceServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tds__DeviceServiceCapabilities(soap, tag ? tag : "tds:DeviceServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__DeviceServiceCapabilities * SOAP_FMAC4 soap_get_tds__DeviceServiceCapabilities(struct soap *soap, struct tds__DeviceServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__DeviceServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__Service_Capabilities(struct soap *soap, struct _tds__Service_Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__Service_Capabilities(struct soap *soap, const struct _tds__Service_Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__Service_Capabilities(struct soap *soap, const char *tag, int id, const struct _tds__Service_Capabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__Service_Capabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__Service_Capabilities * SOAP_FMAC4 soap_in__tds__Service_Capabilities(struct soap *soap, const char *tag, struct _tds__Service_Capabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__Service_Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__Service_Capabilities, sizeof(struct _tds__Service_Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__Service_Capabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__Service_Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__Service_Capabilities, SOAP_TYPE__tds__Service_Capabilities, sizeof(struct _tds__Service_Capabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__Service_Capabilities * SOAP_FMAC4 soap_new__tds__Service_Capabilities(struct soap *soap, int n)
{
	struct _tds__Service_Capabilities *p;
	struct _tds__Service_Capabilities *a = (struct _tds__Service_Capabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__Service_Capabilities));
	for (p = a; p && n--; p++)
		soap_default__tds__Service_Capabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__Service_Capabilities(struct soap *soap, const struct _tds__Service_Capabilities *a, const char *tag, const char *type)
{
	if (soap_out__tds__Service_Capabilities(soap, tag ? tag : "tds:Service-Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__Service_Capabilities * SOAP_FMAC4 soap_get__tds__Service_Capabilities(struct soap *soap, struct _tds__Service_Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__Service_Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tds__Service(struct soap *soap, struct tds__Service *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->Namespace);
	soap_default_xsd__anyURI(soap, &a->XAddr);
	a->Capabilities = NULL;
	a->Version = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tds__Service(struct soap *soap, const struct tds__Service *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->Namespace);
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->XAddr);
	soap_serialize_PointerTo_tds__Service_Capabilities(soap, &a->Capabilities);
	soap_serialize_PointerTott__OnvifVersion(soap, &a->Version);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__Service(struct soap *soap, const char *tag, int id, const struct tds__Service *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__Service), type))
		return soap->error;
	if (!a->Namespace)
	{	if (soap_element_nil(soap, "tds:Namespace"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "tds:Namespace", -1, (char*const*)&a->Namespace, ""))
		return soap->error;
	if (!a->XAddr)
	{	if (soap_element_nil(soap, "tds:XAddr"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "tds:XAddr", -1, (char*const*)&a->XAddr, ""))
		return soap->error;
	if (soap_out_PointerTo_tds__Service_Capabilities(soap, "tds:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	if (!a->Version)
	{	if (soap_element_nil(soap, "tds:Version"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__OnvifVersion(soap, "tds:Version", -1, &a->Version, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tds__Service * SOAP_FMAC4 soap_in_tds__Service(struct soap *soap, const char *tag, struct tds__Service *a, const char *type)
{
	size_t soap_flag_Namespace = 1;
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_Capabilities = 1;
	size_t soap_flag_Version = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tds__Service *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__Service, sizeof(struct tds__Service), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tds__Service(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Namespace && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tds:Namespace", (char**)&a->Namespace, "xsd:anyURI"))
				{	soap_flag_Namespace--;
					continue;
				}
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tds:XAddr", (char**)&a->XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__Service_Capabilities(soap, "tds:Capabilities", &a->Capabilities, ""))
				{	soap_flag_Capabilities--;
					continue;
				}
			if (soap_flag_Version && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__OnvifVersion(soap, "tds:Version", &a->Version, "tt:OnvifVersion"))
				{	soap_flag_Version--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Namespace > 0 || soap_flag_XAddr > 0 || soap_flag_Version > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tds__Service *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__Service, SOAP_TYPE_tds__Service, sizeof(struct tds__Service), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tds__Service * SOAP_FMAC4 soap_new_tds__Service(struct soap *soap, int n)
{
	struct tds__Service *p;
	struct tds__Service *a = (struct tds__Service*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tds__Service));
	for (p = a; p && n--; p++)
		soap_default_tds__Service(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tds__Service(struct soap *soap, const struct tds__Service *a, const char *tag, const char *type)
{
	if (soap_out_tds__Service(soap, tag ? tag : "tds:Service", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__Service * SOAP_FMAC4 soap_get_tds__Service(struct soap *soap, struct tds__Service *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__Service(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetAnalyticsStateResponse(struct soap *soap, struct _tad__GetAnalyticsStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->State = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetAnalyticsStateResponse(struct soap *soap, const struct _tad__GetAnalyticsStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AnalyticsStateInformation(soap, &a->State);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetAnalyticsStateResponse(struct soap *soap, const char *tag, int id, const struct _tad__GetAnalyticsStateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetAnalyticsStateResponse), type))
		return soap->error;
	if (a->State)
		soap_element_result(soap, "tad:State");
	if (!a->State)
	{	if (soap_element_nil(soap, "tad:State"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__AnalyticsStateInformation(soap, "tad:State", -1, &a->State, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetAnalyticsStateResponse * SOAP_FMAC4 soap_in__tad__GetAnalyticsStateResponse(struct soap *soap, const char *tag, struct _tad__GetAnalyticsStateResponse *a, const char *type)
{
	size_t soap_flag_State = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tad__GetAnalyticsStateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsStateResponse, sizeof(struct _tad__GetAnalyticsStateResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetAnalyticsStateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_State && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AnalyticsStateInformation(soap, "tad:State", &a->State, "tt:AnalyticsStateInformation"))
				{	soap_flag_State--;
					continue;
				}
			soap_check_result(soap, "tad:State");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_State > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsStateResponse, SOAP_TYPE__tad__GetAnalyticsStateResponse, sizeof(struct _tad__GetAnalyticsStateResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetAnalyticsStateResponse * SOAP_FMAC4 soap_new__tad__GetAnalyticsStateResponse(struct soap *soap, int n)
{
	struct _tad__GetAnalyticsStateResponse *p;
	struct _tad__GetAnalyticsStateResponse *a = (struct _tad__GetAnalyticsStateResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetAnalyticsStateResponse));
	for (p = a; p && n--; p++)
		soap_default__tad__GetAnalyticsStateResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetAnalyticsStateResponse(struct soap *soap, const struct _tad__GetAnalyticsStateResponse *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetAnalyticsStateResponse(soap, tag ? tag : "tad:GetAnalyticsStateResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsStateResponse * SOAP_FMAC4 soap_get__tad__GetAnalyticsStateResponse(struct soap *soap, struct _tad__GetAnalyticsStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetAnalyticsStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetAnalyticsState(struct soap *soap, struct _tad__GetAnalyticsState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->AnalyticsEngineControlToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetAnalyticsState(struct soap *soap, const struct _tad__GetAnalyticsState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->AnalyticsEngineControlToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetAnalyticsState(struct soap *soap, const char *tag, int id, const struct _tad__GetAnalyticsState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetAnalyticsState), type))
		return soap->error;
	if (!a->AnalyticsEngineControlToken)
	{	if (soap_element_nil(soap, "tad:AnalyticsEngineControlToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tad:AnalyticsEngineControlToken", -1, (char*const*)&a->AnalyticsEngineControlToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetAnalyticsState * SOAP_FMAC4 soap_in__tad__GetAnalyticsState(struct soap *soap, const char *tag, struct _tad__GetAnalyticsState *a, const char *type)
{
	size_t soap_flag_AnalyticsEngineControlToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tad__GetAnalyticsState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsState, sizeof(struct _tad__GetAnalyticsState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetAnalyticsState(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AnalyticsEngineControlToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tad:AnalyticsEngineControlToken", (char**)&a->AnalyticsEngineControlToken, "tt:ReferenceToken"))
				{	soap_flag_AnalyticsEngineControlToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AnalyticsEngineControlToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsState, SOAP_TYPE__tad__GetAnalyticsState, sizeof(struct _tad__GetAnalyticsState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetAnalyticsState * SOAP_FMAC4 soap_new__tad__GetAnalyticsState(struct soap *soap, int n)
{
	struct _tad__GetAnalyticsState *p;
	struct _tad__GetAnalyticsState *a = (struct _tad__GetAnalyticsState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetAnalyticsState));
	for (p = a; p && n--; p++)
		soap_default__tad__GetAnalyticsState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetAnalyticsState(struct soap *soap, const struct _tad__GetAnalyticsState *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetAnalyticsState(soap, tag ? tag : "tad:GetAnalyticsState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsState * SOAP_FMAC4 soap_get__tad__GetAnalyticsState(struct soap *soap, struct _tad__GetAnalyticsState *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetAnalyticsState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__DeleteAnalyticsEngineInputsResponse(struct soap *soap, struct _tad__DeleteAnalyticsEngineInputsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__DeleteAnalyticsEngineInputsResponse(struct soap *soap, const struct _tad__DeleteAnalyticsEngineInputsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__DeleteAnalyticsEngineInputsResponse(struct soap *soap, const char *tag, int id, const struct _tad__DeleteAnalyticsEngineInputsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__DeleteAnalyticsEngineInputsResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineInputsResponse * SOAP_FMAC4 soap_in__tad__DeleteAnalyticsEngineInputsResponse(struct soap *soap, const char *tag, struct _tad__DeleteAnalyticsEngineInputsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tad__DeleteAnalyticsEngineInputsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__DeleteAnalyticsEngineInputsResponse, sizeof(struct _tad__DeleteAnalyticsEngineInputsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__DeleteAnalyticsEngineInputsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tad__DeleteAnalyticsEngineInputsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__DeleteAnalyticsEngineInputsResponse, SOAP_TYPE__tad__DeleteAnalyticsEngineInputsResponse, sizeof(struct _tad__DeleteAnalyticsEngineInputsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineInputsResponse * SOAP_FMAC4 soap_new__tad__DeleteAnalyticsEngineInputsResponse(struct soap *soap, int n)
{
	struct _tad__DeleteAnalyticsEngineInputsResponse *p;
	struct _tad__DeleteAnalyticsEngineInputsResponse *a = (struct _tad__DeleteAnalyticsEngineInputsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__DeleteAnalyticsEngineInputsResponse));
	for (p = a; p && n--; p++)
		soap_default__tad__DeleteAnalyticsEngineInputsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__DeleteAnalyticsEngineInputsResponse(struct soap *soap, const struct _tad__DeleteAnalyticsEngineInputsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tad__DeleteAnalyticsEngineInputsResponse(soap, tag ? tag : "tad:DeleteAnalyticsEngineInputsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineInputsResponse * SOAP_FMAC4 soap_get__tad__DeleteAnalyticsEngineInputsResponse(struct soap *soap, struct _tad__DeleteAnalyticsEngineInputsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__DeleteAnalyticsEngineInputsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__DeleteAnalyticsEngineInputs(struct soap *soap, struct _tad__DeleteAnalyticsEngineInputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfigurationToken = 0;
	a->ConfigurationToken = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__DeleteAnalyticsEngineInputs(struct soap *soap, const struct _tad__DeleteAnalyticsEngineInputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ConfigurationToken)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurationToken; i++)
		{
			soap_serialize_tt__ReferenceToken(soap, (char*const*)(a->ConfigurationToken + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__DeleteAnalyticsEngineInputs(struct soap *soap, const char *tag, int id, const struct _tad__DeleteAnalyticsEngineInputs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__DeleteAnalyticsEngineInputs), type))
		return soap->error;
	if (a->ConfigurationToken)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfigurationToken; i++)
			soap_out_string(soap, "tad:ConfigurationToken", -1, (char*const*)(a->ConfigurationToken + i), "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineInputs * SOAP_FMAC4 soap_in__tad__DeleteAnalyticsEngineInputs(struct soap *soap, const char *tag, struct _tad__DeleteAnalyticsEngineInputs *a, const char *type)
{
	struct soap_blist *soap_blist_ConfigurationToken = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tad__DeleteAnalyticsEngineInputs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__DeleteAnalyticsEngineInputs, sizeof(struct _tad__DeleteAnalyticsEngineInputs), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__DeleteAnalyticsEngineInputs(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tad:ConfigurationToken", 1, NULL))
			{	if (a->ConfigurationToken == NULL)
				{	if (soap_blist_ConfigurationToken == NULL)
						soap_blist_ConfigurationToken = soap_alloc_block(soap);
					a->ConfigurationToken = (char **)soap_push_block_max(soap, soap_blist_ConfigurationToken, sizeof(char *));
					if (a->ConfigurationToken == NULL)
						return NULL;
					*a->ConfigurationToken = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__ReferenceToken(soap, "tad:ConfigurationToken", (char**)a->ConfigurationToken, "tt:ReferenceToken"))
				{	a->__sizeConfigurationToken++;
					a->ConfigurationToken = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ConfigurationToken)
			soap_pop_block(soap, soap_blist_ConfigurationToken);
		if (a->__sizeConfigurationToken)
		{	a->ConfigurationToken = (char **)soap_save_block(soap, soap_blist_ConfigurationToken, NULL, 1);
		}
		else
		{	a->ConfigurationToken = NULL;
			if (soap_blist_ConfigurationToken)
				soap_end_block(soap, soap_blist_ConfigurationToken);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeConfigurationToken < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__DeleteAnalyticsEngineInputs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__DeleteAnalyticsEngineInputs, SOAP_TYPE__tad__DeleteAnalyticsEngineInputs, sizeof(struct _tad__DeleteAnalyticsEngineInputs), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineInputs * SOAP_FMAC4 soap_new__tad__DeleteAnalyticsEngineInputs(struct soap *soap, int n)
{
	struct _tad__DeleteAnalyticsEngineInputs *p;
	struct _tad__DeleteAnalyticsEngineInputs *a = (struct _tad__DeleteAnalyticsEngineInputs*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__DeleteAnalyticsEngineInputs));
	for (p = a; p && n--; p++)
		soap_default__tad__DeleteAnalyticsEngineInputs(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__DeleteAnalyticsEngineInputs(struct soap *soap, const struct _tad__DeleteAnalyticsEngineInputs *a, const char *tag, const char *type)
{
	if (soap_out__tad__DeleteAnalyticsEngineInputs(soap, tag ? tag : "tad:DeleteAnalyticsEngineInputs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineInputs * SOAP_FMAC4 soap_get__tad__DeleteAnalyticsEngineInputs(struct soap *soap, struct _tad__DeleteAnalyticsEngineInputs *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__DeleteAnalyticsEngineInputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetVideoAnalyticsConfigurationResponse(struct soap *soap, struct _tad__GetVideoAnalyticsConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetVideoAnalyticsConfigurationResponse(struct soap *soap, const struct _tad__GetVideoAnalyticsConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__VideoAnalyticsConfiguration(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tad__GetVideoAnalyticsConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetVideoAnalyticsConfigurationResponse), type))
		return soap->error;
	if (a->Configuration)
		soap_element_result(soap, "tad:Configuration");
	if (!a->Configuration)
	{	if (soap_element_nil(soap, "tad:Configuration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__VideoAnalyticsConfiguration(soap, "tad:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetVideoAnalyticsConfigurationResponse * SOAP_FMAC4 soap_in__tad__GetVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, struct _tad__GetVideoAnalyticsConfigurationResponse *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tad__GetVideoAnalyticsConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetVideoAnalyticsConfigurationResponse, sizeof(struct _tad__GetVideoAnalyticsConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetVideoAnalyticsConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoAnalyticsConfiguration(soap, "tad:Configuration", &a->Configuration, "tt:VideoAnalyticsConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			soap_check_result(soap, "tad:Configuration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__GetVideoAnalyticsConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetVideoAnalyticsConfigurationResponse, SOAP_TYPE__tad__GetVideoAnalyticsConfigurationResponse, sizeof(struct _tad__GetVideoAnalyticsConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetVideoAnalyticsConfigurationResponse * SOAP_FMAC4 soap_new__tad__GetVideoAnalyticsConfigurationResponse(struct soap *soap, int n)
{
	struct _tad__GetVideoAnalyticsConfigurationResponse *p;
	struct _tad__GetVideoAnalyticsConfigurationResponse *a = (struct _tad__GetVideoAnalyticsConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetVideoAnalyticsConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tad__GetVideoAnalyticsConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetVideoAnalyticsConfigurationResponse(struct soap *soap, const struct _tad__GetVideoAnalyticsConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetVideoAnalyticsConfigurationResponse(soap, tag ? tag : "tad:GetVideoAnalyticsConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetVideoAnalyticsConfigurationResponse * SOAP_FMAC4 soap_get__tad__GetVideoAnalyticsConfigurationResponse(struct soap *soap, struct _tad__GetVideoAnalyticsConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetVideoAnalyticsConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetVideoAnalyticsConfiguration(struct soap *soap, struct _tad__GetVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetVideoAnalyticsConfiguration(struct soap *soap, const struct _tad__GetVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, const struct _tad__GetVideoAnalyticsConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetVideoAnalyticsConfiguration), type))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_nil(soap, "tad:ConfigurationToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tad:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetVideoAnalyticsConfiguration * SOAP_FMAC4 soap_in__tad__GetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct _tad__GetVideoAnalyticsConfiguration *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tad__GetVideoAnalyticsConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetVideoAnalyticsConfiguration, sizeof(struct _tad__GetVideoAnalyticsConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetVideoAnalyticsConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tad:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__GetVideoAnalyticsConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetVideoAnalyticsConfiguration, SOAP_TYPE__tad__GetVideoAnalyticsConfiguration, sizeof(struct _tad__GetVideoAnalyticsConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetVideoAnalyticsConfiguration * SOAP_FMAC4 soap_new__tad__GetVideoAnalyticsConfiguration(struct soap *soap, int n)
{
	struct _tad__GetVideoAnalyticsConfiguration *p;
	struct _tad__GetVideoAnalyticsConfiguration *a = (struct _tad__GetVideoAnalyticsConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetVideoAnalyticsConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tad__GetVideoAnalyticsConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetVideoAnalyticsConfiguration(struct soap *soap, const struct _tad__GetVideoAnalyticsConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetVideoAnalyticsConfiguration(soap, tag ? tag : "tad:GetVideoAnalyticsConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetVideoAnalyticsConfiguration * SOAP_FMAC4 soap_get__tad__GetVideoAnalyticsConfiguration(struct soap *soap, struct _tad__GetVideoAnalyticsConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetAnalyticsDeviceStreamUriResponse(struct soap *soap, struct _tad__GetAnalyticsDeviceStreamUriResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->Uri);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetAnalyticsDeviceStreamUriResponse(struct soap *soap, const struct _tad__GetAnalyticsDeviceStreamUriResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->Uri);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetAnalyticsDeviceStreamUriResponse(struct soap *soap, const char *tag, int id, const struct _tad__GetAnalyticsDeviceStreamUriResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetAnalyticsDeviceStreamUriResponse), type))
		return soap->error;
	if (a->Uri)
		soap_element_result(soap, "tad:Uri");
	if (!a->Uri)
	{	if (soap_element_nil(soap, "tad:Uri"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "tad:Uri", -1, (char*const*)&a->Uri, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetAnalyticsDeviceStreamUriResponse * SOAP_FMAC4 soap_in__tad__GetAnalyticsDeviceStreamUriResponse(struct soap *soap, const char *tag, struct _tad__GetAnalyticsDeviceStreamUriResponse *a, const char *type)
{
	size_t soap_flag_Uri = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tad__GetAnalyticsDeviceStreamUriResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsDeviceStreamUriResponse, sizeof(struct _tad__GetAnalyticsDeviceStreamUriResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetAnalyticsDeviceStreamUriResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tad:Uri", (char**)&a->Uri, "xsd:anyURI"))
				{	soap_flag_Uri--;
					continue;
				}
			soap_check_result(soap, "tad:Uri");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Uri > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsDeviceStreamUriResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsDeviceStreamUriResponse, SOAP_TYPE__tad__GetAnalyticsDeviceStreamUriResponse, sizeof(struct _tad__GetAnalyticsDeviceStreamUriResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetAnalyticsDeviceStreamUriResponse * SOAP_FMAC4 soap_new__tad__GetAnalyticsDeviceStreamUriResponse(struct soap *soap, int n)
{
	struct _tad__GetAnalyticsDeviceStreamUriResponse *p;
	struct _tad__GetAnalyticsDeviceStreamUriResponse *a = (struct _tad__GetAnalyticsDeviceStreamUriResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetAnalyticsDeviceStreamUriResponse));
	for (p = a; p && n--; p++)
		soap_default__tad__GetAnalyticsDeviceStreamUriResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetAnalyticsDeviceStreamUriResponse(struct soap *soap, const struct _tad__GetAnalyticsDeviceStreamUriResponse *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetAnalyticsDeviceStreamUriResponse(soap, tag ? tag : "tad:GetAnalyticsDeviceStreamUriResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsDeviceStreamUriResponse * SOAP_FMAC4 soap_get__tad__GetAnalyticsDeviceStreamUriResponse(struct soap *soap, struct _tad__GetAnalyticsDeviceStreamUriResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetAnalyticsDeviceStreamUriResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetAnalyticsDeviceStreamUri(struct soap *soap, struct _tad__GetAnalyticsDeviceStreamUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->StreamSetup = NULL;
	soap_default_tt__ReferenceToken(soap, &a->AnalyticsEngineControlToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetAnalyticsDeviceStreamUri(struct soap *soap, const struct _tad__GetAnalyticsDeviceStreamUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__StreamSetup(soap, &a->StreamSetup);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->AnalyticsEngineControlToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetAnalyticsDeviceStreamUri(struct soap *soap, const char *tag, int id, const struct _tad__GetAnalyticsDeviceStreamUri *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetAnalyticsDeviceStreamUri), type))
		return soap->error;
	if (!a->StreamSetup)
	{	if (soap_element_nil(soap, "tad:StreamSetup"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__StreamSetup(soap, "tad:StreamSetup", -1, &a->StreamSetup, ""))
		return soap->error;
	if (!a->AnalyticsEngineControlToken)
	{	if (soap_element_nil(soap, "tad:AnalyticsEngineControlToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tad:AnalyticsEngineControlToken", -1, (char*const*)&a->AnalyticsEngineControlToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetAnalyticsDeviceStreamUri * SOAP_FMAC4 soap_in__tad__GetAnalyticsDeviceStreamUri(struct soap *soap, const char *tag, struct _tad__GetAnalyticsDeviceStreamUri *a, const char *type)
{
	size_t soap_flag_StreamSetup = 1;
	size_t soap_flag_AnalyticsEngineControlToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tad__GetAnalyticsDeviceStreamUri *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsDeviceStreamUri, sizeof(struct _tad__GetAnalyticsDeviceStreamUri), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetAnalyticsDeviceStreamUri(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StreamSetup && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__StreamSetup(soap, "tad:StreamSetup", &a->StreamSetup, "tt:StreamSetup"))
				{	soap_flag_StreamSetup--;
					continue;
				}
			if (soap_flag_AnalyticsEngineControlToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tad:AnalyticsEngineControlToken", (char**)&a->AnalyticsEngineControlToken, "tt:ReferenceToken"))
				{	soap_flag_AnalyticsEngineControlToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StreamSetup > 0 || soap_flag_AnalyticsEngineControlToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsDeviceStreamUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsDeviceStreamUri, SOAP_TYPE__tad__GetAnalyticsDeviceStreamUri, sizeof(struct _tad__GetAnalyticsDeviceStreamUri), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetAnalyticsDeviceStreamUri * SOAP_FMAC4 soap_new__tad__GetAnalyticsDeviceStreamUri(struct soap *soap, int n)
{
	struct _tad__GetAnalyticsDeviceStreamUri *p;
	struct _tad__GetAnalyticsDeviceStreamUri *a = (struct _tad__GetAnalyticsDeviceStreamUri*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetAnalyticsDeviceStreamUri));
	for (p = a; p && n--; p++)
		soap_default__tad__GetAnalyticsDeviceStreamUri(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetAnalyticsDeviceStreamUri(struct soap *soap, const struct _tad__GetAnalyticsDeviceStreamUri *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetAnalyticsDeviceStreamUri(soap, tag ? tag : "tad:GetAnalyticsDeviceStreamUri", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsDeviceStreamUri * SOAP_FMAC4 soap_get__tad__GetAnalyticsDeviceStreamUri(struct soap *soap, struct _tad__GetAnalyticsDeviceStreamUri *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetAnalyticsDeviceStreamUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetAnalyticsEngineInputsResponse(struct soap *soap, struct _tad__GetAnalyticsEngineInputsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfiguration = 0;
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetAnalyticsEngineInputsResponse(struct soap *soap, const struct _tad__GetAnalyticsEngineInputsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Configuration)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfiguration; i++)
		{
			soap_embedded(soap, a->Configuration + i, SOAP_TYPE_tt__AnalyticsEngineInput);
			soap_serialize_tt__AnalyticsEngineInput(soap, a->Configuration + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetAnalyticsEngineInputsResponse(struct soap *soap, const char *tag, int id, const struct _tad__GetAnalyticsEngineInputsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetAnalyticsEngineInputsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfiguration");
	if (a->Configuration)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfiguration; i++)
			if (soap_out_tt__AnalyticsEngineInput(soap, "tad:Configuration", -1, a->Configuration + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineInputsResponse * SOAP_FMAC4 soap_in__tad__GetAnalyticsEngineInputsResponse(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEngineInputsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configuration = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tad__GetAnalyticsEngineInputsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEngineInputsResponse, sizeof(struct _tad__GetAnalyticsEngineInputsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetAnalyticsEngineInputsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tad:Configuration", 1, NULL))
			{	if (a->Configuration == NULL)
				{	if (soap_blist_Configuration == NULL)
						soap_blist_Configuration = soap_alloc_block(soap);
					a->Configuration = (struct tt__AnalyticsEngineInput *)soap_push_block_max(soap, soap_blist_Configuration, sizeof(struct tt__AnalyticsEngineInput));
					if (a->Configuration == NULL)
						return NULL;
					soap_default_tt__AnalyticsEngineInput(soap, a->Configuration);
				}
				soap_revert(soap);
				if (soap_in_tt__AnalyticsEngineInput(soap, "tad:Configuration", a->Configuration, "tt:AnalyticsEngineInput"))
				{	a->__sizeConfiguration++;
					a->Configuration = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configuration)
			soap_pop_block(soap, soap_blist_Configuration);
		if (a->__sizeConfiguration)
		{	a->Configuration = (struct tt__AnalyticsEngineInput *)soap_save_block(soap, soap_blist_Configuration, NULL, 1);
		}
		else
		{	a->Configuration = NULL;
			if (soap_blist_Configuration)
				soap_end_block(soap, soap_blist_Configuration);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeConfiguration < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEngineInputsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEngineInputsResponse, SOAP_TYPE__tad__GetAnalyticsEngineInputsResponse, sizeof(struct _tad__GetAnalyticsEngineInputsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineInputsResponse * SOAP_FMAC4 soap_new__tad__GetAnalyticsEngineInputsResponse(struct soap *soap, int n)
{
	struct _tad__GetAnalyticsEngineInputsResponse *p;
	struct _tad__GetAnalyticsEngineInputsResponse *a = (struct _tad__GetAnalyticsEngineInputsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetAnalyticsEngineInputsResponse));
	for (p = a; p && n--; p++)
		soap_default__tad__GetAnalyticsEngineInputsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetAnalyticsEngineInputsResponse(struct soap *soap, const struct _tad__GetAnalyticsEngineInputsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetAnalyticsEngineInputsResponse(soap, tag ? tag : "tad:GetAnalyticsEngineInputsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineInputsResponse * SOAP_FMAC4 soap_get__tad__GetAnalyticsEngineInputsResponse(struct soap *soap, struct _tad__GetAnalyticsEngineInputsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetAnalyticsEngineInputsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetAnalyticsEngineInputs(struct soap *soap, struct _tad__GetAnalyticsEngineInputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetAnalyticsEngineInputs(struct soap *soap, const struct _tad__GetAnalyticsEngineInputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetAnalyticsEngineInputs(struct soap *soap, const char *tag, int id, const struct _tad__GetAnalyticsEngineInputs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetAnalyticsEngineInputs), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineInputs * SOAP_FMAC4 soap_in__tad__GetAnalyticsEngineInputs(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEngineInputs *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tad__GetAnalyticsEngineInputs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEngineInputs, sizeof(struct _tad__GetAnalyticsEngineInputs), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetAnalyticsEngineInputs(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEngineInputs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEngineInputs, SOAP_TYPE__tad__GetAnalyticsEngineInputs, sizeof(struct _tad__GetAnalyticsEngineInputs), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineInputs * SOAP_FMAC4 soap_new__tad__GetAnalyticsEngineInputs(struct soap *soap, int n)
{
	struct _tad__GetAnalyticsEngineInputs *p;
	struct _tad__GetAnalyticsEngineInputs *a = (struct _tad__GetAnalyticsEngineInputs*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetAnalyticsEngineInputs));
	for (p = a; p && n--; p++)
		soap_default__tad__GetAnalyticsEngineInputs(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetAnalyticsEngineInputs(struct soap *soap, const struct _tad__GetAnalyticsEngineInputs *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetAnalyticsEngineInputs(soap, tag ? tag : "tad:GetAnalyticsEngineInputs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineInputs * SOAP_FMAC4 soap_get__tad__GetAnalyticsEngineInputs(struct soap *soap, struct _tad__GetAnalyticsEngineInputs *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetAnalyticsEngineInputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetAnalyticsEngineInputResponse(struct soap *soap, struct _tad__GetAnalyticsEngineInputResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetAnalyticsEngineInputResponse(struct soap *soap, const struct _tad__GetAnalyticsEngineInputResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AnalyticsEngineInput(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetAnalyticsEngineInputResponse(struct soap *soap, const char *tag, int id, const struct _tad__GetAnalyticsEngineInputResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetAnalyticsEngineInputResponse), type))
		return soap->error;
	if (a->Configuration)
		soap_element_result(soap, "tad:Configuration");
	if (!a->Configuration)
	{	if (soap_element_nil(soap, "tad:Configuration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__AnalyticsEngineInput(soap, "tad:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineInputResponse * SOAP_FMAC4 soap_in__tad__GetAnalyticsEngineInputResponse(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEngineInputResponse *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tad__GetAnalyticsEngineInputResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEngineInputResponse, sizeof(struct _tad__GetAnalyticsEngineInputResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetAnalyticsEngineInputResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AnalyticsEngineInput(soap, "tad:Configuration", &a->Configuration, "tt:AnalyticsEngineInput"))
				{	soap_flag_Configuration--;
					continue;
				}
			soap_check_result(soap, "tad:Configuration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEngineInputResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEngineInputResponse, SOAP_TYPE__tad__GetAnalyticsEngineInputResponse, sizeof(struct _tad__GetAnalyticsEngineInputResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineInputResponse * SOAP_FMAC4 soap_new__tad__GetAnalyticsEngineInputResponse(struct soap *soap, int n)
{
	struct _tad__GetAnalyticsEngineInputResponse *p;
	struct _tad__GetAnalyticsEngineInputResponse *a = (struct _tad__GetAnalyticsEngineInputResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetAnalyticsEngineInputResponse));
	for (p = a; p && n--; p++)
		soap_default__tad__GetAnalyticsEngineInputResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetAnalyticsEngineInputResponse(struct soap *soap, const struct _tad__GetAnalyticsEngineInputResponse *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetAnalyticsEngineInputResponse(soap, tag ? tag : "tad:GetAnalyticsEngineInputResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineInputResponse * SOAP_FMAC4 soap_get__tad__GetAnalyticsEngineInputResponse(struct soap *soap, struct _tad__GetAnalyticsEngineInputResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetAnalyticsEngineInputResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetAnalyticsEngineInput(struct soap *soap, struct _tad__GetAnalyticsEngineInput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetAnalyticsEngineInput(struct soap *soap, const struct _tad__GetAnalyticsEngineInput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetAnalyticsEngineInput(struct soap *soap, const char *tag, int id, const struct _tad__GetAnalyticsEngineInput *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetAnalyticsEngineInput), type))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_nil(soap, "tad:ConfigurationToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tad:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineInput * SOAP_FMAC4 soap_in__tad__GetAnalyticsEngineInput(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEngineInput *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tad__GetAnalyticsEngineInput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEngineInput, sizeof(struct _tad__GetAnalyticsEngineInput), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetAnalyticsEngineInput(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tad:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEngineInput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEngineInput, SOAP_TYPE__tad__GetAnalyticsEngineInput, sizeof(struct _tad__GetAnalyticsEngineInput), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineInput * SOAP_FMAC4 soap_new__tad__GetAnalyticsEngineInput(struct soap *soap, int n)
{
	struct _tad__GetAnalyticsEngineInput *p;
	struct _tad__GetAnalyticsEngineInput *a = (struct _tad__GetAnalyticsEngineInput*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetAnalyticsEngineInput));
	for (p = a; p && n--; p++)
		soap_default__tad__GetAnalyticsEngineInput(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetAnalyticsEngineInput(struct soap *soap, const struct _tad__GetAnalyticsEngineInput *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetAnalyticsEngineInput(soap, tag ? tag : "tad:GetAnalyticsEngineInput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineInput * SOAP_FMAC4 soap_get__tad__GetAnalyticsEngineInput(struct soap *soap, struct _tad__GetAnalyticsEngineInput *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetAnalyticsEngineInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__SetAnalyticsEngineInputResponse(struct soap *soap, struct _tad__SetAnalyticsEngineInputResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__SetAnalyticsEngineInputResponse(struct soap *soap, const struct _tad__SetAnalyticsEngineInputResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__SetAnalyticsEngineInputResponse(struct soap *soap, const char *tag, int id, const struct _tad__SetAnalyticsEngineInputResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__SetAnalyticsEngineInputResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__SetAnalyticsEngineInputResponse * SOAP_FMAC4 soap_in__tad__SetAnalyticsEngineInputResponse(struct soap *soap, const char *tag, struct _tad__SetAnalyticsEngineInputResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tad__SetAnalyticsEngineInputResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__SetAnalyticsEngineInputResponse, sizeof(struct _tad__SetAnalyticsEngineInputResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__SetAnalyticsEngineInputResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tad__SetAnalyticsEngineInputResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__SetAnalyticsEngineInputResponse, SOAP_TYPE__tad__SetAnalyticsEngineInputResponse, sizeof(struct _tad__SetAnalyticsEngineInputResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__SetAnalyticsEngineInputResponse * SOAP_FMAC4 soap_new__tad__SetAnalyticsEngineInputResponse(struct soap *soap, int n)
{
	struct _tad__SetAnalyticsEngineInputResponse *p;
	struct _tad__SetAnalyticsEngineInputResponse *a = (struct _tad__SetAnalyticsEngineInputResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__SetAnalyticsEngineInputResponse));
	for (p = a; p && n--; p++)
		soap_default__tad__SetAnalyticsEngineInputResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__SetAnalyticsEngineInputResponse(struct soap *soap, const struct _tad__SetAnalyticsEngineInputResponse *a, const char *tag, const char *type)
{
	if (soap_out__tad__SetAnalyticsEngineInputResponse(soap, tag ? tag : "tad:SetAnalyticsEngineInputResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__SetAnalyticsEngineInputResponse * SOAP_FMAC4 soap_get__tad__SetAnalyticsEngineInputResponse(struct soap *soap, struct _tad__SetAnalyticsEngineInputResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__SetAnalyticsEngineInputResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__SetAnalyticsEngineInput(struct soap *soap, struct _tad__SetAnalyticsEngineInput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
	soap_default_xsd__boolean(soap, &a->ForcePersistence);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__SetAnalyticsEngineInput(struct soap *soap, const struct _tad__SetAnalyticsEngineInput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AnalyticsEngineInput(soap, &a->Configuration);
	soap_embedded(soap, &a->ForcePersistence, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__SetAnalyticsEngineInput(struct soap *soap, const char *tag, int id, const struct _tad__SetAnalyticsEngineInput *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__SetAnalyticsEngineInput), type))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_nil(soap, "tad:Configuration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__AnalyticsEngineInput(soap, "tad:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tad:ForcePersistence", -1, &a->ForcePersistence, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__SetAnalyticsEngineInput * SOAP_FMAC4 soap_in__tad__SetAnalyticsEngineInput(struct soap *soap, const char *tag, struct _tad__SetAnalyticsEngineInput *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	size_t soap_flag_ForcePersistence = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tad__SetAnalyticsEngineInput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__SetAnalyticsEngineInput, sizeof(struct _tad__SetAnalyticsEngineInput), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__SetAnalyticsEngineInput(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AnalyticsEngineInput(soap, "tad:Configuration", &a->Configuration, "tt:AnalyticsEngineInput"))
				{	soap_flag_Configuration--;
					continue;
				}
			if (soap_flag_ForcePersistence && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tad:ForcePersistence", &a->ForcePersistence, "xsd:boolean"))
				{	soap_flag_ForcePersistence--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0 || soap_flag_ForcePersistence > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__SetAnalyticsEngineInput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__SetAnalyticsEngineInput, SOAP_TYPE__tad__SetAnalyticsEngineInput, sizeof(struct _tad__SetAnalyticsEngineInput), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__SetAnalyticsEngineInput * SOAP_FMAC4 soap_new__tad__SetAnalyticsEngineInput(struct soap *soap, int n)
{
	struct _tad__SetAnalyticsEngineInput *p;
	struct _tad__SetAnalyticsEngineInput *a = (struct _tad__SetAnalyticsEngineInput*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__SetAnalyticsEngineInput));
	for (p = a; p && n--; p++)
		soap_default__tad__SetAnalyticsEngineInput(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__SetAnalyticsEngineInput(struct soap *soap, const struct _tad__SetAnalyticsEngineInput *a, const char *tag, const char *type)
{
	if (soap_out__tad__SetAnalyticsEngineInput(soap, tag ? tag : "tad:SetAnalyticsEngineInput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__SetAnalyticsEngineInput * SOAP_FMAC4 soap_get__tad__SetAnalyticsEngineInput(struct soap *soap, struct _tad__SetAnalyticsEngineInput *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__SetAnalyticsEngineInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__SetVideoAnalyticsConfigurationResponse(struct soap *soap, struct _tad__SetVideoAnalyticsConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__SetVideoAnalyticsConfigurationResponse(struct soap *soap, const struct _tad__SetVideoAnalyticsConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__SetVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tad__SetVideoAnalyticsConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__SetVideoAnalyticsConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__SetVideoAnalyticsConfigurationResponse * SOAP_FMAC4 soap_in__tad__SetVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, struct _tad__SetVideoAnalyticsConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tad__SetVideoAnalyticsConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__SetVideoAnalyticsConfigurationResponse, sizeof(struct _tad__SetVideoAnalyticsConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__SetVideoAnalyticsConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tad__SetVideoAnalyticsConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__SetVideoAnalyticsConfigurationResponse, SOAP_TYPE__tad__SetVideoAnalyticsConfigurationResponse, sizeof(struct _tad__SetVideoAnalyticsConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__SetVideoAnalyticsConfigurationResponse * SOAP_FMAC4 soap_new__tad__SetVideoAnalyticsConfigurationResponse(struct soap *soap, int n)
{
	struct _tad__SetVideoAnalyticsConfigurationResponse *p;
	struct _tad__SetVideoAnalyticsConfigurationResponse *a = (struct _tad__SetVideoAnalyticsConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__SetVideoAnalyticsConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tad__SetVideoAnalyticsConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__SetVideoAnalyticsConfigurationResponse(struct soap *soap, const struct _tad__SetVideoAnalyticsConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tad__SetVideoAnalyticsConfigurationResponse(soap, tag ? tag : "tad:SetVideoAnalyticsConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__SetVideoAnalyticsConfigurationResponse * SOAP_FMAC4 soap_get__tad__SetVideoAnalyticsConfigurationResponse(struct soap *soap, struct _tad__SetVideoAnalyticsConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__SetVideoAnalyticsConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__SetVideoAnalyticsConfiguration(struct soap *soap, struct _tad__SetVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
	soap_default_xsd__boolean(soap, &a->ForcePersistence);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__SetVideoAnalyticsConfiguration(struct soap *soap, const struct _tad__SetVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__VideoAnalyticsConfiguration(soap, &a->Configuration);
	soap_embedded(soap, &a->ForcePersistence, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__SetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, const struct _tad__SetVideoAnalyticsConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__SetVideoAnalyticsConfiguration), type))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_nil(soap, "tad:Configuration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__VideoAnalyticsConfiguration(soap, "tad:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tad:ForcePersistence", -1, &a->ForcePersistence, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__SetVideoAnalyticsConfiguration * SOAP_FMAC4 soap_in__tad__SetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct _tad__SetVideoAnalyticsConfiguration *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	size_t soap_flag_ForcePersistence = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tad__SetVideoAnalyticsConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__SetVideoAnalyticsConfiguration, sizeof(struct _tad__SetVideoAnalyticsConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__SetVideoAnalyticsConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoAnalyticsConfiguration(soap, "tad:Configuration", &a->Configuration, "tt:VideoAnalyticsConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			if (soap_flag_ForcePersistence && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tad:ForcePersistence", &a->ForcePersistence, "xsd:boolean"))
				{	soap_flag_ForcePersistence--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0 || soap_flag_ForcePersistence > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__SetVideoAnalyticsConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__SetVideoAnalyticsConfiguration, SOAP_TYPE__tad__SetVideoAnalyticsConfiguration, sizeof(struct _tad__SetVideoAnalyticsConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__SetVideoAnalyticsConfiguration * SOAP_FMAC4 soap_new__tad__SetVideoAnalyticsConfiguration(struct soap *soap, int n)
{
	struct _tad__SetVideoAnalyticsConfiguration *p;
	struct _tad__SetVideoAnalyticsConfiguration *a = (struct _tad__SetVideoAnalyticsConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__SetVideoAnalyticsConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tad__SetVideoAnalyticsConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__SetVideoAnalyticsConfiguration(struct soap *soap, const struct _tad__SetVideoAnalyticsConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tad__SetVideoAnalyticsConfiguration(soap, tag ? tag : "tad:SetVideoAnalyticsConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__SetVideoAnalyticsConfiguration * SOAP_FMAC4 soap_get__tad__SetVideoAnalyticsConfiguration(struct soap *soap, struct _tad__SetVideoAnalyticsConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__SetVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetAnalyticsEnginesResponse(struct soap *soap, struct _tad__GetAnalyticsEnginesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfiguration = 0;
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetAnalyticsEnginesResponse(struct soap *soap, const struct _tad__GetAnalyticsEnginesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Configuration)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfiguration; i++)
		{
			soap_embedded(soap, a->Configuration + i, SOAP_TYPE_tt__AnalyticsEngine);
			soap_serialize_tt__AnalyticsEngine(soap, a->Configuration + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetAnalyticsEnginesResponse(struct soap *soap, const char *tag, int id, const struct _tad__GetAnalyticsEnginesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetAnalyticsEnginesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfiguration");
	if (a->Configuration)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfiguration; i++)
			if (soap_out_tt__AnalyticsEngine(soap, "tad:Configuration", -1, a->Configuration + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEnginesResponse * SOAP_FMAC4 soap_in__tad__GetAnalyticsEnginesResponse(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEnginesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configuration = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tad__GetAnalyticsEnginesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEnginesResponse, sizeof(struct _tad__GetAnalyticsEnginesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetAnalyticsEnginesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tad:Configuration", 1, NULL))
			{	if (a->Configuration == NULL)
				{	if (soap_blist_Configuration == NULL)
						soap_blist_Configuration = soap_alloc_block(soap);
					a->Configuration = (struct tt__AnalyticsEngine *)soap_push_block_max(soap, soap_blist_Configuration, sizeof(struct tt__AnalyticsEngine));
					if (a->Configuration == NULL)
						return NULL;
					soap_default_tt__AnalyticsEngine(soap, a->Configuration);
				}
				soap_revert(soap);
				if (soap_in_tt__AnalyticsEngine(soap, "tad:Configuration", a->Configuration, "tt:AnalyticsEngine"))
				{	a->__sizeConfiguration++;
					a->Configuration = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configuration)
			soap_pop_block(soap, soap_blist_Configuration);
		if (a->__sizeConfiguration)
		{	a->Configuration = (struct tt__AnalyticsEngine *)soap_save_block(soap, soap_blist_Configuration, NULL, 1);
		}
		else
		{	a->Configuration = NULL;
			if (soap_blist_Configuration)
				soap_end_block(soap, soap_blist_Configuration);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeConfiguration < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEnginesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEnginesResponse, SOAP_TYPE__tad__GetAnalyticsEnginesResponse, sizeof(struct _tad__GetAnalyticsEnginesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetAnalyticsEnginesResponse * SOAP_FMAC4 soap_new__tad__GetAnalyticsEnginesResponse(struct soap *soap, int n)
{
	struct _tad__GetAnalyticsEnginesResponse *p;
	struct _tad__GetAnalyticsEnginesResponse *a = (struct _tad__GetAnalyticsEnginesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetAnalyticsEnginesResponse));
	for (p = a; p && n--; p++)
		soap_default__tad__GetAnalyticsEnginesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetAnalyticsEnginesResponse(struct soap *soap, const struct _tad__GetAnalyticsEnginesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetAnalyticsEnginesResponse(soap, tag ? tag : "tad:GetAnalyticsEnginesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEnginesResponse * SOAP_FMAC4 soap_get__tad__GetAnalyticsEnginesResponse(struct soap *soap, struct _tad__GetAnalyticsEnginesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetAnalyticsEnginesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetAnalyticsEngines(struct soap *soap, struct _tad__GetAnalyticsEngines *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetAnalyticsEngines(struct soap *soap, const struct _tad__GetAnalyticsEngines *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetAnalyticsEngines(struct soap *soap, const char *tag, int id, const struct _tad__GetAnalyticsEngines *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetAnalyticsEngines), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngines * SOAP_FMAC4 soap_in__tad__GetAnalyticsEngines(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEngines *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tad__GetAnalyticsEngines *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEngines, sizeof(struct _tad__GetAnalyticsEngines), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetAnalyticsEngines(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEngines *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEngines, SOAP_TYPE__tad__GetAnalyticsEngines, sizeof(struct _tad__GetAnalyticsEngines), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngines * SOAP_FMAC4 soap_new__tad__GetAnalyticsEngines(struct soap *soap, int n)
{
	struct _tad__GetAnalyticsEngines *p;
	struct _tad__GetAnalyticsEngines *a = (struct _tad__GetAnalyticsEngines*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetAnalyticsEngines));
	for (p = a; p && n--; p++)
		soap_default__tad__GetAnalyticsEngines(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetAnalyticsEngines(struct soap *soap, const struct _tad__GetAnalyticsEngines *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetAnalyticsEngines(soap, tag ? tag : "tad:GetAnalyticsEngines", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngines * SOAP_FMAC4 soap_get__tad__GetAnalyticsEngines(struct soap *soap, struct _tad__GetAnalyticsEngines *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetAnalyticsEngines(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsEngine(struct soap *soap, struct tt__AnalyticsEngine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->AnalyticsEngineConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsEngine(struct soap *soap, const struct tt__AnalyticsEngine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_PointerTott__AnalyticsDeviceEngineConfiguration(soap, &a->AnalyticsEngineConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngine(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsEngine *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, a->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngine), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "tt:Name"))
			return soap->error;
	}
	else
	if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (!a->AnalyticsEngineConfiguration)
	{	if (soap_element_nil(soap, "tt:AnalyticsEngineConfiguration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__AnalyticsDeviceEngineConfiguration(soap, "tt:AnalyticsEngineConfiguration", -1, &a->AnalyticsEngineConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsEngine * SOAP_FMAC4 soap_in_tt__AnalyticsEngine(struct soap *soap, const char *tag, struct tt__AnalyticsEngine *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_AnalyticsEngineConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AnalyticsEngine *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngine, sizeof(struct tt__AnalyticsEngine), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsEngine(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			if (soap_flag_AnalyticsEngineConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AnalyticsDeviceEngineConfiguration(soap, "tt:AnalyticsEngineConfiguration", &a->AnalyticsEngineConfiguration, "tt:AnalyticsDeviceEngineConfiguration"))
				{	soap_flag_AnalyticsEngineConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_AnalyticsEngineConfiguration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngine *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngine, SOAP_TYPE_tt__AnalyticsEngine, sizeof(struct tt__AnalyticsEngine), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnalyticsEngine * SOAP_FMAC4 soap_new_tt__AnalyticsEngine(struct soap *soap, int n)
{
	struct tt__AnalyticsEngine *p;
	struct tt__AnalyticsEngine *a = (struct tt__AnalyticsEngine*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnalyticsEngine));
	for (p = a; p && n--; p++)
		soap_default_tt__AnalyticsEngine(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsEngine(struct soap *soap, const struct tt__AnalyticsEngine *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnalyticsEngine(soap, tag ? tag : "tt:AnalyticsEngine", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngine * SOAP_FMAC4 soap_get_tt__AnalyticsEngine(struct soap *soap, struct tt__AnalyticsEngine *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetAnalyticsEngineResponse(struct soap *soap, struct _tad__GetAnalyticsEngineResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetAnalyticsEngineResponse(struct soap *soap, const struct _tad__GetAnalyticsEngineResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AnalyticsEngine(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetAnalyticsEngineResponse(struct soap *soap, const char *tag, int id, const struct _tad__GetAnalyticsEngineResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetAnalyticsEngineResponse), type))
		return soap->error;
	if (a->Configuration)
		soap_element_result(soap, "tad:Configuration");
	if (!a->Configuration)
	{	if (soap_element_nil(soap, "tad:Configuration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__AnalyticsEngine(soap, "tad:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineResponse * SOAP_FMAC4 soap_in__tad__GetAnalyticsEngineResponse(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEngineResponse *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tad__GetAnalyticsEngineResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEngineResponse, sizeof(struct _tad__GetAnalyticsEngineResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetAnalyticsEngineResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AnalyticsEngine(soap, "tad:Configuration", &a->Configuration, "tt:AnalyticsEngine"))
				{	soap_flag_Configuration--;
					continue;
				}
			soap_check_result(soap, "tad:Configuration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEngineResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEngineResponse, SOAP_TYPE__tad__GetAnalyticsEngineResponse, sizeof(struct _tad__GetAnalyticsEngineResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineResponse * SOAP_FMAC4 soap_new__tad__GetAnalyticsEngineResponse(struct soap *soap, int n)
{
	struct _tad__GetAnalyticsEngineResponse *p;
	struct _tad__GetAnalyticsEngineResponse *a = (struct _tad__GetAnalyticsEngineResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetAnalyticsEngineResponse));
	for (p = a; p && n--; p++)
		soap_default__tad__GetAnalyticsEngineResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetAnalyticsEngineResponse(struct soap *soap, const struct _tad__GetAnalyticsEngineResponse *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetAnalyticsEngineResponse(soap, tag ? tag : "tad:GetAnalyticsEngineResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineResponse * SOAP_FMAC4 soap_get__tad__GetAnalyticsEngineResponse(struct soap *soap, struct _tad__GetAnalyticsEngineResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetAnalyticsEngineResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetAnalyticsEngine(struct soap *soap, struct _tad__GetAnalyticsEngine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetAnalyticsEngine(struct soap *soap, const struct _tad__GetAnalyticsEngine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetAnalyticsEngine(struct soap *soap, const char *tag, int id, const struct _tad__GetAnalyticsEngine *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetAnalyticsEngine), type))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_nil(soap, "tad:ConfigurationToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tad:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngine * SOAP_FMAC4 soap_in__tad__GetAnalyticsEngine(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEngine *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tad__GetAnalyticsEngine *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEngine, sizeof(struct _tad__GetAnalyticsEngine), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetAnalyticsEngine(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tad:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEngine *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEngine, SOAP_TYPE__tad__GetAnalyticsEngine, sizeof(struct _tad__GetAnalyticsEngine), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngine * SOAP_FMAC4 soap_new__tad__GetAnalyticsEngine(struct soap *soap, int n)
{
	struct _tad__GetAnalyticsEngine *p;
	struct _tad__GetAnalyticsEngine *a = (struct _tad__GetAnalyticsEngine*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetAnalyticsEngine));
	for (p = a; p && n--; p++)
		soap_default__tad__GetAnalyticsEngine(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetAnalyticsEngine(struct soap *soap, const struct _tad__GetAnalyticsEngine *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetAnalyticsEngine(soap, tag ? tag : "tad:GetAnalyticsEngine", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngine * SOAP_FMAC4 soap_get__tad__GetAnalyticsEngine(struct soap *soap, struct _tad__GetAnalyticsEngine *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetAnalyticsEngine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetAnalyticsEngineControlsResponse(struct soap *soap, struct _tad__GetAnalyticsEngineControlsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAnalyticsEngineControls = 0;
	a->AnalyticsEngineControls = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetAnalyticsEngineControlsResponse(struct soap *soap, const struct _tad__GetAnalyticsEngineControlsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->AnalyticsEngineControls)
	{	int i;
		for (i = 0; i < (int)a->__sizeAnalyticsEngineControls; i++)
		{
			soap_embedded(soap, a->AnalyticsEngineControls + i, SOAP_TYPE_tt__AnalyticsEngineControl);
			soap_serialize_tt__AnalyticsEngineControl(soap, a->AnalyticsEngineControls + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetAnalyticsEngineControlsResponse(struct soap *soap, const char *tag, int id, const struct _tad__GetAnalyticsEngineControlsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetAnalyticsEngineControlsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeAnalyticsEngineControls");
	if (a->AnalyticsEngineControls)
	{	int i;
		for (i = 0; i < (int)a->__sizeAnalyticsEngineControls; i++)
			if (soap_out_tt__AnalyticsEngineControl(soap, "tad:AnalyticsEngineControls", -1, a->AnalyticsEngineControls + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineControlsResponse * SOAP_FMAC4 soap_in__tad__GetAnalyticsEngineControlsResponse(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEngineControlsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_AnalyticsEngineControls = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tad__GetAnalyticsEngineControlsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEngineControlsResponse, sizeof(struct _tad__GetAnalyticsEngineControlsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetAnalyticsEngineControlsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tad:AnalyticsEngineControls", 1, NULL))
			{	if (a->AnalyticsEngineControls == NULL)
				{	if (soap_blist_AnalyticsEngineControls == NULL)
						soap_blist_AnalyticsEngineControls = soap_alloc_block(soap);
					a->AnalyticsEngineControls = (struct tt__AnalyticsEngineControl *)soap_push_block_max(soap, soap_blist_AnalyticsEngineControls, sizeof(struct tt__AnalyticsEngineControl));
					if (a->AnalyticsEngineControls == NULL)
						return NULL;
					soap_default_tt__AnalyticsEngineControl(soap, a->AnalyticsEngineControls);
				}
				soap_revert(soap);
				if (soap_in_tt__AnalyticsEngineControl(soap, "tad:AnalyticsEngineControls", a->AnalyticsEngineControls, "tt:AnalyticsEngineControl"))
				{	a->__sizeAnalyticsEngineControls++;
					a->AnalyticsEngineControls = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeAnalyticsEngineControls");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AnalyticsEngineControls)
			soap_pop_block(soap, soap_blist_AnalyticsEngineControls);
		if (a->__sizeAnalyticsEngineControls)
		{	a->AnalyticsEngineControls = (struct tt__AnalyticsEngineControl *)soap_save_block(soap, soap_blist_AnalyticsEngineControls, NULL, 1);
		}
		else
		{	a->AnalyticsEngineControls = NULL;
			if (soap_blist_AnalyticsEngineControls)
				soap_end_block(soap, soap_blist_AnalyticsEngineControls);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeAnalyticsEngineControls < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEngineControlsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEngineControlsResponse, SOAP_TYPE__tad__GetAnalyticsEngineControlsResponse, sizeof(struct _tad__GetAnalyticsEngineControlsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineControlsResponse * SOAP_FMAC4 soap_new__tad__GetAnalyticsEngineControlsResponse(struct soap *soap, int n)
{
	struct _tad__GetAnalyticsEngineControlsResponse *p;
	struct _tad__GetAnalyticsEngineControlsResponse *a = (struct _tad__GetAnalyticsEngineControlsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetAnalyticsEngineControlsResponse));
	for (p = a; p && n--; p++)
		soap_default__tad__GetAnalyticsEngineControlsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetAnalyticsEngineControlsResponse(struct soap *soap, const struct _tad__GetAnalyticsEngineControlsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetAnalyticsEngineControlsResponse(soap, tag ? tag : "tad:GetAnalyticsEngineControlsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineControlsResponse * SOAP_FMAC4 soap_get__tad__GetAnalyticsEngineControlsResponse(struct soap *soap, struct _tad__GetAnalyticsEngineControlsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetAnalyticsEngineControlsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetAnalyticsEngineControls(struct soap *soap, struct _tad__GetAnalyticsEngineControls *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetAnalyticsEngineControls(struct soap *soap, const struct _tad__GetAnalyticsEngineControls *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetAnalyticsEngineControls(struct soap *soap, const char *tag, int id, const struct _tad__GetAnalyticsEngineControls *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetAnalyticsEngineControls), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineControls * SOAP_FMAC4 soap_in__tad__GetAnalyticsEngineControls(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEngineControls *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tad__GetAnalyticsEngineControls *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEngineControls, sizeof(struct _tad__GetAnalyticsEngineControls), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetAnalyticsEngineControls(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEngineControls *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEngineControls, SOAP_TYPE__tad__GetAnalyticsEngineControls, sizeof(struct _tad__GetAnalyticsEngineControls), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineControls * SOAP_FMAC4 soap_new__tad__GetAnalyticsEngineControls(struct soap *soap, int n)
{
	struct _tad__GetAnalyticsEngineControls *p;
	struct _tad__GetAnalyticsEngineControls *a = (struct _tad__GetAnalyticsEngineControls*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetAnalyticsEngineControls));
	for (p = a; p && n--; p++)
		soap_default__tad__GetAnalyticsEngineControls(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetAnalyticsEngineControls(struct soap *soap, const struct _tad__GetAnalyticsEngineControls *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetAnalyticsEngineControls(soap, tag ? tag : "tad:GetAnalyticsEngineControls", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineControls * SOAP_FMAC4 soap_get__tad__GetAnalyticsEngineControls(struct soap *soap, struct _tad__GetAnalyticsEngineControls *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetAnalyticsEngineControls(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetAnalyticsEngineControlResponse(struct soap *soap, struct _tad__GetAnalyticsEngineControlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetAnalyticsEngineControlResponse(struct soap *soap, const struct _tad__GetAnalyticsEngineControlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AnalyticsEngineControl(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetAnalyticsEngineControlResponse(struct soap *soap, const char *tag, int id, const struct _tad__GetAnalyticsEngineControlResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetAnalyticsEngineControlResponse), type))
		return soap->error;
	if (a->Configuration)
		soap_element_result(soap, "tad:Configuration");
	if (!a->Configuration)
	{	if (soap_element_nil(soap, "tad:Configuration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__AnalyticsEngineControl(soap, "tad:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineControlResponse * SOAP_FMAC4 soap_in__tad__GetAnalyticsEngineControlResponse(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEngineControlResponse *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tad__GetAnalyticsEngineControlResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEngineControlResponse, sizeof(struct _tad__GetAnalyticsEngineControlResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetAnalyticsEngineControlResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AnalyticsEngineControl(soap, "tad:Configuration", &a->Configuration, "tt:AnalyticsEngineControl"))
				{	soap_flag_Configuration--;
					continue;
				}
			soap_check_result(soap, "tad:Configuration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEngineControlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEngineControlResponse, SOAP_TYPE__tad__GetAnalyticsEngineControlResponse, sizeof(struct _tad__GetAnalyticsEngineControlResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineControlResponse * SOAP_FMAC4 soap_new__tad__GetAnalyticsEngineControlResponse(struct soap *soap, int n)
{
	struct _tad__GetAnalyticsEngineControlResponse *p;
	struct _tad__GetAnalyticsEngineControlResponse *a = (struct _tad__GetAnalyticsEngineControlResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetAnalyticsEngineControlResponse));
	for (p = a; p && n--; p++)
		soap_default__tad__GetAnalyticsEngineControlResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetAnalyticsEngineControlResponse(struct soap *soap, const struct _tad__GetAnalyticsEngineControlResponse *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetAnalyticsEngineControlResponse(soap, tag ? tag : "tad:GetAnalyticsEngineControlResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineControlResponse * SOAP_FMAC4 soap_get__tad__GetAnalyticsEngineControlResponse(struct soap *soap, struct _tad__GetAnalyticsEngineControlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetAnalyticsEngineControlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetAnalyticsEngineControl(struct soap *soap, struct _tad__GetAnalyticsEngineControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetAnalyticsEngineControl(struct soap *soap, const struct _tad__GetAnalyticsEngineControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetAnalyticsEngineControl(struct soap *soap, const char *tag, int id, const struct _tad__GetAnalyticsEngineControl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetAnalyticsEngineControl), type))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_nil(soap, "tad:ConfigurationToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tad:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineControl * SOAP_FMAC4 soap_in__tad__GetAnalyticsEngineControl(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEngineControl *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tad__GetAnalyticsEngineControl *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetAnalyticsEngineControl, sizeof(struct _tad__GetAnalyticsEngineControl), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetAnalyticsEngineControl(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tad:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEngineControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetAnalyticsEngineControl, SOAP_TYPE__tad__GetAnalyticsEngineControl, sizeof(struct _tad__GetAnalyticsEngineControl), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineControl * SOAP_FMAC4 soap_new__tad__GetAnalyticsEngineControl(struct soap *soap, int n)
{
	struct _tad__GetAnalyticsEngineControl *p;
	struct _tad__GetAnalyticsEngineControl *a = (struct _tad__GetAnalyticsEngineControl*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetAnalyticsEngineControl));
	for (p = a; p && n--; p++)
		soap_default__tad__GetAnalyticsEngineControl(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetAnalyticsEngineControl(struct soap *soap, const struct _tad__GetAnalyticsEngineControl *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetAnalyticsEngineControl(soap, tag ? tag : "tad:GetAnalyticsEngineControl", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineControl * SOAP_FMAC4 soap_get__tad__GetAnalyticsEngineControl(struct soap *soap, struct _tad__GetAnalyticsEngineControl *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetAnalyticsEngineControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__SetAnalyticsEngineControlResponse(struct soap *soap, struct _tad__SetAnalyticsEngineControlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__SetAnalyticsEngineControlResponse(struct soap *soap, const struct _tad__SetAnalyticsEngineControlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__SetAnalyticsEngineControlResponse(struct soap *soap, const char *tag, int id, const struct _tad__SetAnalyticsEngineControlResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__SetAnalyticsEngineControlResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__SetAnalyticsEngineControlResponse * SOAP_FMAC4 soap_in__tad__SetAnalyticsEngineControlResponse(struct soap *soap, const char *tag, struct _tad__SetAnalyticsEngineControlResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tad__SetAnalyticsEngineControlResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__SetAnalyticsEngineControlResponse, sizeof(struct _tad__SetAnalyticsEngineControlResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__SetAnalyticsEngineControlResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tad__SetAnalyticsEngineControlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__SetAnalyticsEngineControlResponse, SOAP_TYPE__tad__SetAnalyticsEngineControlResponse, sizeof(struct _tad__SetAnalyticsEngineControlResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__SetAnalyticsEngineControlResponse * SOAP_FMAC4 soap_new__tad__SetAnalyticsEngineControlResponse(struct soap *soap, int n)
{
	struct _tad__SetAnalyticsEngineControlResponse *p;
	struct _tad__SetAnalyticsEngineControlResponse *a = (struct _tad__SetAnalyticsEngineControlResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__SetAnalyticsEngineControlResponse));
	for (p = a; p && n--; p++)
		soap_default__tad__SetAnalyticsEngineControlResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__SetAnalyticsEngineControlResponse(struct soap *soap, const struct _tad__SetAnalyticsEngineControlResponse *a, const char *tag, const char *type)
{
	if (soap_out__tad__SetAnalyticsEngineControlResponse(soap, tag ? tag : "tad:SetAnalyticsEngineControlResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__SetAnalyticsEngineControlResponse * SOAP_FMAC4 soap_get__tad__SetAnalyticsEngineControlResponse(struct soap *soap, struct _tad__SetAnalyticsEngineControlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__SetAnalyticsEngineControlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__SetAnalyticsEngineControl(struct soap *soap, struct _tad__SetAnalyticsEngineControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
	soap_default_xsd__boolean(soap, &a->ForcePersistence);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__SetAnalyticsEngineControl(struct soap *soap, const struct _tad__SetAnalyticsEngineControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AnalyticsEngineControl(soap, &a->Configuration);
	soap_embedded(soap, &a->ForcePersistence, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__SetAnalyticsEngineControl(struct soap *soap, const char *tag, int id, const struct _tad__SetAnalyticsEngineControl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__SetAnalyticsEngineControl), type))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_nil(soap, "tad:Configuration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__AnalyticsEngineControl(soap, "tad:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tad:ForcePersistence", -1, &a->ForcePersistence, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__SetAnalyticsEngineControl * SOAP_FMAC4 soap_in__tad__SetAnalyticsEngineControl(struct soap *soap, const char *tag, struct _tad__SetAnalyticsEngineControl *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	size_t soap_flag_ForcePersistence = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tad__SetAnalyticsEngineControl *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__SetAnalyticsEngineControl, sizeof(struct _tad__SetAnalyticsEngineControl), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__SetAnalyticsEngineControl(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AnalyticsEngineControl(soap, "tad:Configuration", &a->Configuration, "tt:AnalyticsEngineControl"))
				{	soap_flag_Configuration--;
					continue;
				}
			if (soap_flag_ForcePersistence && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tad:ForcePersistence", &a->ForcePersistence, "xsd:boolean"))
				{	soap_flag_ForcePersistence--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0 || soap_flag_ForcePersistence > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__SetAnalyticsEngineControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__SetAnalyticsEngineControl, SOAP_TYPE__tad__SetAnalyticsEngineControl, sizeof(struct _tad__SetAnalyticsEngineControl), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__SetAnalyticsEngineControl * SOAP_FMAC4 soap_new__tad__SetAnalyticsEngineControl(struct soap *soap, int n)
{
	struct _tad__SetAnalyticsEngineControl *p;
	struct _tad__SetAnalyticsEngineControl *a = (struct _tad__SetAnalyticsEngineControl*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__SetAnalyticsEngineControl));
	for (p = a; p && n--; p++)
		soap_default__tad__SetAnalyticsEngineControl(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__SetAnalyticsEngineControl(struct soap *soap, const struct _tad__SetAnalyticsEngineControl *a, const char *tag, const char *type)
{
	if (soap_out__tad__SetAnalyticsEngineControl(soap, tag ? tag : "tad:SetAnalyticsEngineControl", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__SetAnalyticsEngineControl * SOAP_FMAC4 soap_get__tad__SetAnalyticsEngineControl(struct soap *soap, struct _tad__SetAnalyticsEngineControl *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__SetAnalyticsEngineControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__CreateAnalyticsEngineControlResponse(struct soap *soap, struct _tad__CreateAnalyticsEngineControlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfiguration = 0;
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__CreateAnalyticsEngineControlResponse(struct soap *soap, const struct _tad__CreateAnalyticsEngineControlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Configuration)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfiguration; i++)
		{
			soap_embedded(soap, a->Configuration + i, SOAP_TYPE_tt__AnalyticsEngineInput);
			soap_serialize_tt__AnalyticsEngineInput(soap, a->Configuration + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__CreateAnalyticsEngineControlResponse(struct soap *soap, const char *tag, int id, const struct _tad__CreateAnalyticsEngineControlResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__CreateAnalyticsEngineControlResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfiguration");
	if (a->Configuration)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfiguration; i++)
			if (soap_out_tt__AnalyticsEngineInput(soap, "tad:Configuration", -1, a->Configuration + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineControlResponse * SOAP_FMAC4 soap_in__tad__CreateAnalyticsEngineControlResponse(struct soap *soap, const char *tag, struct _tad__CreateAnalyticsEngineControlResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configuration = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tad__CreateAnalyticsEngineControlResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__CreateAnalyticsEngineControlResponse, sizeof(struct _tad__CreateAnalyticsEngineControlResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__CreateAnalyticsEngineControlResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tad:Configuration", 1, NULL))
			{	if (a->Configuration == NULL)
				{	if (soap_blist_Configuration == NULL)
						soap_blist_Configuration = soap_alloc_block(soap);
					a->Configuration = (struct tt__AnalyticsEngineInput *)soap_push_block_max(soap, soap_blist_Configuration, sizeof(struct tt__AnalyticsEngineInput));
					if (a->Configuration == NULL)
						return NULL;
					soap_default_tt__AnalyticsEngineInput(soap, a->Configuration);
				}
				soap_revert(soap);
				if (soap_in_tt__AnalyticsEngineInput(soap, "tad:Configuration", a->Configuration, "tt:AnalyticsEngineInput"))
				{	a->__sizeConfiguration++;
					a->Configuration = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configuration)
			soap_pop_block(soap, soap_blist_Configuration);
		if (a->__sizeConfiguration)
		{	a->Configuration = (struct tt__AnalyticsEngineInput *)soap_save_block(soap, soap_blist_Configuration, NULL, 1);
		}
		else
		{	a->Configuration = NULL;
			if (soap_blist_Configuration)
				soap_end_block(soap, soap_blist_Configuration);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeConfiguration < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__CreateAnalyticsEngineControlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__CreateAnalyticsEngineControlResponse, SOAP_TYPE__tad__CreateAnalyticsEngineControlResponse, sizeof(struct _tad__CreateAnalyticsEngineControlResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineControlResponse * SOAP_FMAC4 soap_new__tad__CreateAnalyticsEngineControlResponse(struct soap *soap, int n)
{
	struct _tad__CreateAnalyticsEngineControlResponse *p;
	struct _tad__CreateAnalyticsEngineControlResponse *a = (struct _tad__CreateAnalyticsEngineControlResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__CreateAnalyticsEngineControlResponse));
	for (p = a; p && n--; p++)
		soap_default__tad__CreateAnalyticsEngineControlResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__CreateAnalyticsEngineControlResponse(struct soap *soap, const struct _tad__CreateAnalyticsEngineControlResponse *a, const char *tag, const char *type)
{
	if (soap_out__tad__CreateAnalyticsEngineControlResponse(soap, tag ? tag : "tad:CreateAnalyticsEngineControlResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineControlResponse * SOAP_FMAC4 soap_get__tad__CreateAnalyticsEngineControlResponse(struct soap *soap, struct _tad__CreateAnalyticsEngineControlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__CreateAnalyticsEngineControlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsEngineControl(struct soap *soap, struct tt__AnalyticsEngineControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_tt__ReferenceToken(soap, &a->EngineToken);
	soap_default_tt__ReferenceToken(soap, &a->EngineConfigToken);
	a->__sizeInputToken = 0;
	a->InputToken = NULL;
	a->__sizeReceiverToken = 0;
	a->ReceiverToken = NULL;
	a->Multicast = NULL;
	a->Subscription = NULL;
	soap_default_tt__ModeOfOperation(soap, &a->Mode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsEngineControl(struct soap *soap, const struct tt__AnalyticsEngineControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->EngineToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->EngineConfigToken);
	if (a->InputToken)
	{	int i;
		for (i = 0; i < (int)a->__sizeInputToken; i++)
		{
			soap_serialize_tt__ReferenceToken(soap, (char*const*)(a->InputToken + i));
		}
	}
	if (a->ReceiverToken)
	{	int i;
		for (i = 0; i < (int)a->__sizeReceiverToken; i++)
		{
			soap_serialize_tt__ReferenceToken(soap, (char*const*)(a->ReceiverToken + i));
		}
	}
	soap_serialize_PointerTott__MulticastConfiguration(soap, &a->Multicast);
	soap_serialize_PointerTott__Config(soap, &a->Subscription);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngineControl(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsEngineControl *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, a->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngineControl), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "tt:Name"))
			return soap->error;
	}
	else
	if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (!a->EngineToken)
	{	if (soap_element_nil(soap, "tt:EngineToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tt:EngineToken", -1, (char*const*)&a->EngineToken, ""))
		return soap->error;
	if (!a->EngineConfigToken)
	{	if (soap_element_nil(soap, "tt:EngineConfigToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tt:EngineConfigToken", -1, (char*const*)&a->EngineConfigToken, ""))
		return soap->error;
	if (a->InputToken)
	{	int i;
		for (i = 0; i < (int)a->__sizeInputToken; i++)
			soap_out_string(soap, "tt:InputToken", -1, (char*const*)(a->InputToken + i), "");
	}
	if (a->ReceiverToken)
	{	int i;
		for (i = 0; i < (int)a->__sizeReceiverToken; i++)
			soap_out_string(soap, "tt:ReceiverToken", -1, (char*const*)(a->ReceiverToken + i), "");
	}
	if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->Multicast, ""))
		return soap->error;
	if (!a->Subscription)
	{	if (soap_element_nil(soap, "tt:Subscription"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__Config(soap, "tt:Subscription", -1, &a->Subscription, ""))
		return soap->error;
	if (soap_out_tt__ModeOfOperation(soap, "tt:Mode", -1, &a->Mode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsEngineControl * SOAP_FMAC4 soap_in_tt__AnalyticsEngineControl(struct soap *soap, const char *tag, struct tt__AnalyticsEngineControl *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_EngineToken = 1;
	size_t soap_flag_EngineConfigToken = 1;
	struct soap_blist *soap_blist_InputToken = NULL;
	struct soap_blist *soap_blist_ReceiverToken = NULL;
	size_t soap_flag_Multicast = 1;
	size_t soap_flag_Subscription = 1;
	size_t soap_flag_Mode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AnalyticsEngineControl *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineControl, sizeof(struct tt__AnalyticsEngineControl), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsEngineControl(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			if (soap_flag_EngineToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:EngineToken", (char**)&a->EngineToken, "tt:ReferenceToken"))
				{	soap_flag_EngineToken--;
					continue;
				}
			if (soap_flag_EngineConfigToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:EngineConfigToken", (char**)&a->EngineConfigToken, "tt:ReferenceToken"))
				{	soap_flag_EngineConfigToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:InputToken", 1, NULL))
			{	if (a->InputToken == NULL)
				{	if (soap_blist_InputToken == NULL)
						soap_blist_InputToken = soap_alloc_block(soap);
					a->InputToken = (char **)soap_push_block_max(soap, soap_blist_InputToken, sizeof(char *));
					if (a->InputToken == NULL)
						return NULL;
					*a->InputToken = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__ReferenceToken(soap, "tt:InputToken", (char**)a->InputToken, "tt:ReferenceToken"))
				{	a->__sizeInputToken++;
					a->InputToken = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ReceiverToken", 1, NULL))
			{	if (a->ReceiverToken == NULL)
				{	if (soap_blist_ReceiverToken == NULL)
						soap_blist_ReceiverToken = soap_alloc_block(soap);
					a->ReceiverToken = (char **)soap_push_block_max(soap, soap_blist_ReceiverToken, sizeof(char *));
					if (a->ReceiverToken == NULL)
						return NULL;
					*a->ReceiverToken = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__ReferenceToken(soap, "tt:ReceiverToken", (char**)a->ReceiverToken, "tt:ReferenceToken"))
				{	a->__sizeReceiverToken++;
					a->ReceiverToken = NULL;
					continue;
				}
			}
			if (soap_flag_Multicast && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &a->Multicast, "tt:MulticastConfiguration"))
				{	soap_flag_Multicast--;
					continue;
				}
			if (soap_flag_Subscription && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Config(soap, "tt:Subscription", &a->Subscription, "tt:Config"))
				{	soap_flag_Subscription--;
					continue;
				}
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__ModeOfOperation(soap, "tt:Mode", &a->Mode, "tt:ModeOfOperation"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->InputToken)
			soap_pop_block(soap, soap_blist_InputToken);
		if (a->__sizeInputToken)
		{	a->InputToken = (char **)soap_save_block(soap, soap_blist_InputToken, NULL, 1);
		}
		else
		{	a->InputToken = NULL;
			if (soap_blist_InputToken)
				soap_end_block(soap, soap_blist_InputToken);
		}
		if (a->ReceiverToken)
			soap_pop_block(soap, soap_blist_ReceiverToken);
		if (a->__sizeReceiverToken)
		{	a->ReceiverToken = (char **)soap_save_block(soap, soap_blist_ReceiverToken, NULL, 1);
		}
		else
		{	a->ReceiverToken = NULL;
			if (soap_blist_ReceiverToken)
				soap_end_block(soap, soap_blist_ReceiverToken);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_EngineToken > 0 || soap_flag_EngineConfigToken > 0 || a->__sizeInputToken < 1 || a->__sizeReceiverToken < 1 || soap_flag_Subscription > 0 || soap_flag_Mode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineControl, SOAP_TYPE_tt__AnalyticsEngineControl, sizeof(struct tt__AnalyticsEngineControl), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnalyticsEngineControl * SOAP_FMAC4 soap_new_tt__AnalyticsEngineControl(struct soap *soap, int n)
{
	struct tt__AnalyticsEngineControl *p;
	struct tt__AnalyticsEngineControl *a = (struct tt__AnalyticsEngineControl*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnalyticsEngineControl));
	for (p = a; p && n--; p++)
		soap_default_tt__AnalyticsEngineControl(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsEngineControl(struct soap *soap, const struct tt__AnalyticsEngineControl *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnalyticsEngineControl(soap, tag ? tag : "tt:AnalyticsEngineControl", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineControl * SOAP_FMAC4 soap_get_tt__AnalyticsEngineControl(struct soap *soap, struct tt__AnalyticsEngineControl *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngineControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__CreateAnalyticsEngineControl(struct soap *soap, struct _tad__CreateAnalyticsEngineControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__CreateAnalyticsEngineControl(struct soap *soap, const struct _tad__CreateAnalyticsEngineControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AnalyticsEngineControl(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__CreateAnalyticsEngineControl(struct soap *soap, const char *tag, int id, const struct _tad__CreateAnalyticsEngineControl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__CreateAnalyticsEngineControl), type))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_nil(soap, "tad:Configuration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__AnalyticsEngineControl(soap, "tad:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineControl * SOAP_FMAC4 soap_in__tad__CreateAnalyticsEngineControl(struct soap *soap, const char *tag, struct _tad__CreateAnalyticsEngineControl *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tad__CreateAnalyticsEngineControl *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__CreateAnalyticsEngineControl, sizeof(struct _tad__CreateAnalyticsEngineControl), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__CreateAnalyticsEngineControl(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AnalyticsEngineControl(soap, "tad:Configuration", &a->Configuration, "tt:AnalyticsEngineControl"))
				{	soap_flag_Configuration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__CreateAnalyticsEngineControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__CreateAnalyticsEngineControl, SOAP_TYPE__tad__CreateAnalyticsEngineControl, sizeof(struct _tad__CreateAnalyticsEngineControl), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineControl * SOAP_FMAC4 soap_new__tad__CreateAnalyticsEngineControl(struct soap *soap, int n)
{
	struct _tad__CreateAnalyticsEngineControl *p;
	struct _tad__CreateAnalyticsEngineControl *a = (struct _tad__CreateAnalyticsEngineControl*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__CreateAnalyticsEngineControl));
	for (p = a; p && n--; p++)
		soap_default__tad__CreateAnalyticsEngineControl(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__CreateAnalyticsEngineControl(struct soap *soap, const struct _tad__CreateAnalyticsEngineControl *a, const char *tag, const char *type)
{
	if (soap_out__tad__CreateAnalyticsEngineControl(soap, tag ? tag : "tad:CreateAnalyticsEngineControl", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineControl * SOAP_FMAC4 soap_get__tad__CreateAnalyticsEngineControl(struct soap *soap, struct _tad__CreateAnalyticsEngineControl *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__CreateAnalyticsEngineControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__CreateAnalyticsEngineInputsResponse(struct soap *soap, struct _tad__CreateAnalyticsEngineInputsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfiguration = 0;
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__CreateAnalyticsEngineInputsResponse(struct soap *soap, const struct _tad__CreateAnalyticsEngineInputsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Configuration)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfiguration; i++)
		{
			soap_embedded(soap, a->Configuration + i, SOAP_TYPE_tt__AnalyticsEngineInput);
			soap_serialize_tt__AnalyticsEngineInput(soap, a->Configuration + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__CreateAnalyticsEngineInputsResponse(struct soap *soap, const char *tag, int id, const struct _tad__CreateAnalyticsEngineInputsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__CreateAnalyticsEngineInputsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeConfiguration");
	if (a->Configuration)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfiguration; i++)
			if (soap_out_tt__AnalyticsEngineInput(soap, "tad:Configuration", -1, a->Configuration + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineInputsResponse * SOAP_FMAC4 soap_in__tad__CreateAnalyticsEngineInputsResponse(struct soap *soap, const char *tag, struct _tad__CreateAnalyticsEngineInputsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Configuration = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tad__CreateAnalyticsEngineInputsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__CreateAnalyticsEngineInputsResponse, sizeof(struct _tad__CreateAnalyticsEngineInputsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__CreateAnalyticsEngineInputsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tad:Configuration", 1, NULL))
			{	if (a->Configuration == NULL)
				{	if (soap_blist_Configuration == NULL)
						soap_blist_Configuration = soap_alloc_block(soap);
					a->Configuration = (struct tt__AnalyticsEngineInput *)soap_push_block_max(soap, soap_blist_Configuration, sizeof(struct tt__AnalyticsEngineInput));
					if (a->Configuration == NULL)
						return NULL;
					soap_default_tt__AnalyticsEngineInput(soap, a->Configuration);
				}
				soap_revert(soap);
				if (soap_in_tt__AnalyticsEngineInput(soap, "tad:Configuration", a->Configuration, "tt:AnalyticsEngineInput"))
				{	a->__sizeConfiguration++;
					a->Configuration = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configuration)
			soap_pop_block(soap, soap_blist_Configuration);
		if (a->__sizeConfiguration)
		{	a->Configuration = (struct tt__AnalyticsEngineInput *)soap_save_block(soap, soap_blist_Configuration, NULL, 1);
		}
		else
		{	a->Configuration = NULL;
			if (soap_blist_Configuration)
				soap_end_block(soap, soap_blist_Configuration);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeConfiguration < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__CreateAnalyticsEngineInputsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__CreateAnalyticsEngineInputsResponse, SOAP_TYPE__tad__CreateAnalyticsEngineInputsResponse, sizeof(struct _tad__CreateAnalyticsEngineInputsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineInputsResponse * SOAP_FMAC4 soap_new__tad__CreateAnalyticsEngineInputsResponse(struct soap *soap, int n)
{
	struct _tad__CreateAnalyticsEngineInputsResponse *p;
	struct _tad__CreateAnalyticsEngineInputsResponse *a = (struct _tad__CreateAnalyticsEngineInputsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__CreateAnalyticsEngineInputsResponse));
	for (p = a; p && n--; p++)
		soap_default__tad__CreateAnalyticsEngineInputsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__CreateAnalyticsEngineInputsResponse(struct soap *soap, const struct _tad__CreateAnalyticsEngineInputsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tad__CreateAnalyticsEngineInputsResponse(soap, tag ? tag : "tad:CreateAnalyticsEngineInputsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineInputsResponse * SOAP_FMAC4 soap_get__tad__CreateAnalyticsEngineInputsResponse(struct soap *soap, struct _tad__CreateAnalyticsEngineInputsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__CreateAnalyticsEngineInputsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsEngineInput(struct soap *soap, struct tt__AnalyticsEngineInput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->SourceIdentification = NULL;
	a->VideoInput = NULL;
	a->MetadataInput = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsEngineInput(struct soap *soap, const struct tt__AnalyticsEngineInput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_PointerTott__SourceIdentification(soap, &a->SourceIdentification);
	soap_serialize_PointerTott__VideoEncoderConfiguration(soap, &a->VideoInput);
	soap_serialize_PointerTott__MetadataInput(soap, &a->MetadataInput);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngineInput(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsEngineInput *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, a->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngineInput), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "tt:Name"))
			return soap->error;
	}
	else
	if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (!a->SourceIdentification)
	{	if (soap_element_nil(soap, "tt:SourceIdentification"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__SourceIdentification(soap, "tt:SourceIdentification", -1, &a->SourceIdentification, ""))
		return soap->error;
	if (!a->VideoInput)
	{	if (soap_element_nil(soap, "tt:VideoInput"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__VideoEncoderConfiguration(soap, "tt:VideoInput", -1, &a->VideoInput, ""))
		return soap->error;
	if (!a->MetadataInput)
	{	if (soap_element_nil(soap, "tt:MetadataInput"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__MetadataInput(soap, "tt:MetadataInput", -1, &a->MetadataInput, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInput * SOAP_FMAC4 soap_in_tt__AnalyticsEngineInput(struct soap *soap, const char *tag, struct tt__AnalyticsEngineInput *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_SourceIdentification = 1;
	size_t soap_flag_VideoInput = 1;
	size_t soap_flag_MetadataInput = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AnalyticsEngineInput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineInput, sizeof(struct tt__AnalyticsEngineInput), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsEngineInput(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			if (soap_flag_SourceIdentification && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SourceIdentification(soap, "tt:SourceIdentification", &a->SourceIdentification, "tt:SourceIdentification"))
				{	soap_flag_SourceIdentification--;
					continue;
				}
			if (soap_flag_VideoInput && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoEncoderConfiguration(soap, "tt:VideoInput", &a->VideoInput, "tt:VideoEncoderConfiguration"))
				{	soap_flag_VideoInput--;
					continue;
				}
			if (soap_flag_MetadataInput && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MetadataInput(soap, "tt:MetadataInput", &a->MetadataInput, "tt:MetadataInput"))
				{	soap_flag_MetadataInput--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_SourceIdentification > 0 || soap_flag_VideoInput > 0 || soap_flag_MetadataInput > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineInput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineInput, SOAP_TYPE_tt__AnalyticsEngineInput, sizeof(struct tt__AnalyticsEngineInput), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnalyticsEngineInput * SOAP_FMAC4 soap_new_tt__AnalyticsEngineInput(struct soap *soap, int n)
{
	struct tt__AnalyticsEngineInput *p;
	struct tt__AnalyticsEngineInput *a = (struct tt__AnalyticsEngineInput*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnalyticsEngineInput));
	for (p = a; p && n--; p++)
		soap_default_tt__AnalyticsEngineInput(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsEngineInput(struct soap *soap, const struct tt__AnalyticsEngineInput *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnalyticsEngineInput(soap, tag ? tag : "tt:AnalyticsEngineInput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInput * SOAP_FMAC4 soap_get_tt__AnalyticsEngineInput(struct soap *soap, struct tt__AnalyticsEngineInput *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngineInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__CreateAnalyticsEngineInputs(struct soap *soap, struct _tad__CreateAnalyticsEngineInputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfiguration = 0;
	a->Configuration = NULL;
	a->__sizeForcePersistence = 0;
	a->ForcePersistence = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__CreateAnalyticsEngineInputs(struct soap *soap, const struct _tad__CreateAnalyticsEngineInputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Configuration)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfiguration; i++)
		{
			soap_embedded(soap, a->Configuration + i, SOAP_TYPE_tt__AnalyticsEngineInput);
			soap_serialize_tt__AnalyticsEngineInput(soap, a->Configuration + i);
		}
	}
	if (a->ForcePersistence)
	{	int i;
		for (i = 0; i < (int)a->__sizeForcePersistence; i++)
		{
			soap_embedded(soap, a->ForcePersistence + i, SOAP_TYPE_xsd__boolean);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__CreateAnalyticsEngineInputs(struct soap *soap, const char *tag, int id, const struct _tad__CreateAnalyticsEngineInputs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__CreateAnalyticsEngineInputs), type))
		return soap->error;
	if (a->Configuration)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfiguration; i++)
			if (soap_out_tt__AnalyticsEngineInput(soap, "tad:Configuration", -1, a->Configuration + i, ""))
				return soap->error;
	}
	if (a->ForcePersistence)
	{	int i;
		for (i = 0; i < (int)a->__sizeForcePersistence; i++)
			if (soap_out_xsd__boolean(soap, "tad:ForcePersistence", -1, a->ForcePersistence + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineInputs * SOAP_FMAC4 soap_in__tad__CreateAnalyticsEngineInputs(struct soap *soap, const char *tag, struct _tad__CreateAnalyticsEngineInputs *a, const char *type)
{
	struct soap_blist *soap_blist_Configuration = NULL;
	struct soap_blist *soap_blist_ForcePersistence = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tad__CreateAnalyticsEngineInputs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__CreateAnalyticsEngineInputs, sizeof(struct _tad__CreateAnalyticsEngineInputs), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__CreateAnalyticsEngineInputs(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tad:Configuration", 1, NULL))
			{	if (a->Configuration == NULL)
				{	if (soap_blist_Configuration == NULL)
						soap_blist_Configuration = soap_alloc_block(soap);
					a->Configuration = (struct tt__AnalyticsEngineInput *)soap_push_block_max(soap, soap_blist_Configuration, sizeof(struct tt__AnalyticsEngineInput));
					if (a->Configuration == NULL)
						return NULL;
					soap_default_tt__AnalyticsEngineInput(soap, a->Configuration);
				}
				soap_revert(soap);
				if (soap_in_tt__AnalyticsEngineInput(soap, "tad:Configuration", a->Configuration, "tt:AnalyticsEngineInput"))
				{	a->__sizeConfiguration++;
					a->Configuration = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tad:ForcePersistence", 1, NULL))
			{	if (a->ForcePersistence == NULL)
				{	if (soap_blist_ForcePersistence == NULL)
						soap_blist_ForcePersistence = soap_alloc_block(soap);
					a->ForcePersistence = (enum xsd__boolean *)soap_push_block_max(soap, soap_blist_ForcePersistence, sizeof(enum xsd__boolean));
					if (a->ForcePersistence == NULL)
						return NULL;
					soap_default_xsd__boolean(soap, a->ForcePersistence);
				}
				soap_revert(soap);
				if (soap_in_xsd__boolean(soap, "tad:ForcePersistence", a->ForcePersistence, "xsd:boolean"))
				{	a->__sizeForcePersistence++;
					a->ForcePersistence = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Configuration)
			soap_pop_block(soap, soap_blist_Configuration);
		if (a->__sizeConfiguration)
		{	a->Configuration = (struct tt__AnalyticsEngineInput *)soap_save_block(soap, soap_blist_Configuration, NULL, 1);
		}
		else
		{	a->Configuration = NULL;
			if (soap_blist_Configuration)
				soap_end_block(soap, soap_blist_Configuration);
		}
		if (a->ForcePersistence)
			soap_pop_block(soap, soap_blist_ForcePersistence);
		if (a->__sizeForcePersistence)
		{	a->ForcePersistence = (enum xsd__boolean *)soap_save_block(soap, soap_blist_ForcePersistence, NULL, 1);
		}
		else
		{	a->ForcePersistence = NULL;
			if (soap_blist_ForcePersistence)
				soap_end_block(soap, soap_blist_ForcePersistence);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeConfiguration < 1 || a->__sizeForcePersistence < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__CreateAnalyticsEngineInputs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__CreateAnalyticsEngineInputs, SOAP_TYPE__tad__CreateAnalyticsEngineInputs, sizeof(struct _tad__CreateAnalyticsEngineInputs), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineInputs * SOAP_FMAC4 soap_new__tad__CreateAnalyticsEngineInputs(struct soap *soap, int n)
{
	struct _tad__CreateAnalyticsEngineInputs *p;
	struct _tad__CreateAnalyticsEngineInputs *a = (struct _tad__CreateAnalyticsEngineInputs*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__CreateAnalyticsEngineInputs));
	for (p = a; p && n--; p++)
		soap_default__tad__CreateAnalyticsEngineInputs(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__CreateAnalyticsEngineInputs(struct soap *soap, const struct _tad__CreateAnalyticsEngineInputs *a, const char *tag, const char *type)
{
	if (soap_out__tad__CreateAnalyticsEngineInputs(soap, tag ? tag : "tad:CreateAnalyticsEngineInputs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineInputs * SOAP_FMAC4 soap_get__tad__CreateAnalyticsEngineInputs(struct soap *soap, struct _tad__CreateAnalyticsEngineInputs *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__CreateAnalyticsEngineInputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__DeleteAnalyticsEngineControlResponse(struct soap *soap, struct _tad__DeleteAnalyticsEngineControlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__DeleteAnalyticsEngineControlResponse(struct soap *soap, const struct _tad__DeleteAnalyticsEngineControlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__DeleteAnalyticsEngineControlResponse(struct soap *soap, const char *tag, int id, const struct _tad__DeleteAnalyticsEngineControlResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__DeleteAnalyticsEngineControlResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineControlResponse * SOAP_FMAC4 soap_in__tad__DeleteAnalyticsEngineControlResponse(struct soap *soap, const char *tag, struct _tad__DeleteAnalyticsEngineControlResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tad__DeleteAnalyticsEngineControlResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__DeleteAnalyticsEngineControlResponse, sizeof(struct _tad__DeleteAnalyticsEngineControlResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__DeleteAnalyticsEngineControlResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tad__DeleteAnalyticsEngineControlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__DeleteAnalyticsEngineControlResponse, SOAP_TYPE__tad__DeleteAnalyticsEngineControlResponse, sizeof(struct _tad__DeleteAnalyticsEngineControlResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineControlResponse * SOAP_FMAC4 soap_new__tad__DeleteAnalyticsEngineControlResponse(struct soap *soap, int n)
{
	struct _tad__DeleteAnalyticsEngineControlResponse *p;
	struct _tad__DeleteAnalyticsEngineControlResponse *a = (struct _tad__DeleteAnalyticsEngineControlResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__DeleteAnalyticsEngineControlResponse));
	for (p = a; p && n--; p++)
		soap_default__tad__DeleteAnalyticsEngineControlResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__DeleteAnalyticsEngineControlResponse(struct soap *soap, const struct _tad__DeleteAnalyticsEngineControlResponse *a, const char *tag, const char *type)
{
	if (soap_out__tad__DeleteAnalyticsEngineControlResponse(soap, tag ? tag : "tad:DeleteAnalyticsEngineControlResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineControlResponse * SOAP_FMAC4 soap_get__tad__DeleteAnalyticsEngineControlResponse(struct soap *soap, struct _tad__DeleteAnalyticsEngineControlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__DeleteAnalyticsEngineControlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__DeleteAnalyticsEngineControl(struct soap *soap, struct _tad__DeleteAnalyticsEngineControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__DeleteAnalyticsEngineControl(struct soap *soap, const struct _tad__DeleteAnalyticsEngineControl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__DeleteAnalyticsEngineControl(struct soap *soap, const char *tag, int id, const struct _tad__DeleteAnalyticsEngineControl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__DeleteAnalyticsEngineControl), type))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_nil(soap, "tad:ConfigurationToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tad:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineControl * SOAP_FMAC4 soap_in__tad__DeleteAnalyticsEngineControl(struct soap *soap, const char *tag, struct _tad__DeleteAnalyticsEngineControl *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tad__DeleteAnalyticsEngineControl *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__DeleteAnalyticsEngineControl, sizeof(struct _tad__DeleteAnalyticsEngineControl), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__DeleteAnalyticsEngineControl(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tad:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__DeleteAnalyticsEngineControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__DeleteAnalyticsEngineControl, SOAP_TYPE__tad__DeleteAnalyticsEngineControl, sizeof(struct _tad__DeleteAnalyticsEngineControl), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineControl * SOAP_FMAC4 soap_new__tad__DeleteAnalyticsEngineControl(struct soap *soap, int n)
{
	struct _tad__DeleteAnalyticsEngineControl *p;
	struct _tad__DeleteAnalyticsEngineControl *a = (struct _tad__DeleteAnalyticsEngineControl*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__DeleteAnalyticsEngineControl));
	for (p = a; p && n--; p++)
		soap_default__tad__DeleteAnalyticsEngineControl(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__DeleteAnalyticsEngineControl(struct soap *soap, const struct _tad__DeleteAnalyticsEngineControl *a, const char *tag, const char *type)
{
	if (soap_out__tad__DeleteAnalyticsEngineControl(soap, tag ? tag : "tad:DeleteAnalyticsEngineControl", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineControl * SOAP_FMAC4 soap_get__tad__DeleteAnalyticsEngineControl(struct soap *soap, struct _tad__DeleteAnalyticsEngineControl *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__DeleteAnalyticsEngineControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetServiceCapabilitiesResponse(struct soap *soap, struct _tad__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tad__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotad__Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _tad__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tad:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_nil(soap, "tad:Capabilities"))
			return soap->error;
	}
	else
	if (soap_out_PointerTotad__Capabilities(soap, "tad:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__tad__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tad__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tad__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetServiceCapabilitiesResponse, sizeof(struct _tad__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotad__Capabilities(soap, "tad:Capabilities", &a->Capabilities, "tad:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			soap_check_result(soap, "tad:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tad__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetServiceCapabilitiesResponse, SOAP_TYPE__tad__GetServiceCapabilitiesResponse, sizeof(struct _tad__GetServiceCapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_new__tad__GetServiceCapabilitiesResponse(struct soap *soap, int n)
{
	struct _tad__GetServiceCapabilitiesResponse *p;
	struct _tad__GetServiceCapabilitiesResponse *a = (struct _tad__GetServiceCapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetServiceCapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__tad__GetServiceCapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tad__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetServiceCapabilitiesResponse(soap, tag ? tag : "tad:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__tad__GetServiceCapabilitiesResponse(struct soap *soap, struct _tad__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tad__GetServiceCapabilities(struct soap *soap, struct _tad__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tad__GetServiceCapabilities(struct soap *soap, const struct _tad__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tad__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _tad__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tad__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tad__GetServiceCapabilities * SOAP_FMAC4 soap_in__tad__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tad__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tad__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tad__GetServiceCapabilities, sizeof(struct _tad__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tad__GetServiceCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tad__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tad__GetServiceCapabilities, SOAP_TYPE__tad__GetServiceCapabilities, sizeof(struct _tad__GetServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tad__GetServiceCapabilities * SOAP_FMAC4 soap_new__tad__GetServiceCapabilities(struct soap *soap, int n)
{
	struct _tad__GetServiceCapabilities *p;
	struct _tad__GetServiceCapabilities *a = (struct _tad__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tad__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default__tad__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tad__GetServiceCapabilities(struct soap *soap, const struct _tad__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__tad__GetServiceCapabilities(soap, tag ? tag : "tad:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetServiceCapabilities * SOAP_FMAC4 soap_get__tad__GetServiceCapabilities(struct soap *soap, struct _tad__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tad__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tad__Capabilities(struct soap *soap, struct tad__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tad__Capabilities(struct soap *soap, const struct tad__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tad__Capabilities(struct soap *soap, const char *tag, int id, const struct tad__Capabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tad__Capabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tad__Capabilities * SOAP_FMAC4 soap_in_tad__Capabilities(struct soap *soap, const char *tag, struct tad__Capabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tad__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tad__Capabilities, sizeof(struct tad__Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tad__Capabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tad__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tad__Capabilities, SOAP_TYPE_tad__Capabilities, sizeof(struct tad__Capabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tad__Capabilities * SOAP_FMAC4 soap_new_tad__Capabilities(struct soap *soap, int n)
{
	struct tad__Capabilities *p;
	struct tad__Capabilities *a = (struct tad__Capabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tad__Capabilities));
	for (p = a; p && n--; p++)
		soap_default_tad__Capabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tad__Capabilities(struct soap *soap, const struct tad__Capabilities *a, const char *tag, const char *type)
{
	if (soap_out_tad__Capabilities(soap, tag ? tag : "tad:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tad__Capabilities * SOAP_FMAC4 soap_get_tad__Capabilities(struct soap *soap, struct tad__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tad__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__GetAnalyticsModulesResponse(struct soap *soap, struct _tan__GetAnalyticsModulesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAnalyticsModule = 0;
	a->AnalyticsModule = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__GetAnalyticsModulesResponse(struct soap *soap, const struct _tan__GetAnalyticsModulesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->AnalyticsModule)
	{	int i;
		for (i = 0; i < (int)a->__sizeAnalyticsModule; i++)
		{
			soap_embedded(soap, a->AnalyticsModule + i, SOAP_TYPE_tt__Config);
			soap_serialize_tt__Config(soap, a->AnalyticsModule + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__GetAnalyticsModulesResponse(struct soap *soap, const char *tag, int id, const struct _tan__GetAnalyticsModulesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__GetAnalyticsModulesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeAnalyticsModule");
	if (a->AnalyticsModule)
	{	int i;
		for (i = 0; i < (int)a->__sizeAnalyticsModule; i++)
			if (soap_out_tt__Config(soap, "tan:AnalyticsModule", -1, a->AnalyticsModule + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__GetAnalyticsModulesResponse * SOAP_FMAC4 soap_in__tan__GetAnalyticsModulesResponse(struct soap *soap, const char *tag, struct _tan__GetAnalyticsModulesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_AnalyticsModule = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tan__GetAnalyticsModulesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetAnalyticsModulesResponse, sizeof(struct _tan__GetAnalyticsModulesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__GetAnalyticsModulesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tan:AnalyticsModule", 1, NULL))
			{	if (a->AnalyticsModule == NULL)
				{	if (soap_blist_AnalyticsModule == NULL)
						soap_blist_AnalyticsModule = soap_alloc_block(soap);
					a->AnalyticsModule = (struct tt__Config *)soap_push_block_max(soap, soap_blist_AnalyticsModule, sizeof(struct tt__Config));
					if (a->AnalyticsModule == NULL)
						return NULL;
					soap_default_tt__Config(soap, a->AnalyticsModule);
				}
				soap_revert(soap);
				if (soap_in_tt__Config(soap, "tan:AnalyticsModule", a->AnalyticsModule, "tt:Config"))
				{	a->__sizeAnalyticsModule++;
					a->AnalyticsModule = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeAnalyticsModule");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AnalyticsModule)
			soap_pop_block(soap, soap_blist_AnalyticsModule);
		if (a->__sizeAnalyticsModule)
		{	a->AnalyticsModule = (struct tt__Config *)soap_save_block(soap, soap_blist_AnalyticsModule, NULL, 1);
		}
		else
		{	a->AnalyticsModule = NULL;
			if (soap_blist_AnalyticsModule)
				soap_end_block(soap, soap_blist_AnalyticsModule);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tan__GetAnalyticsModulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetAnalyticsModulesResponse, SOAP_TYPE__tan__GetAnalyticsModulesResponse, sizeof(struct _tan__GetAnalyticsModulesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__GetAnalyticsModulesResponse * SOAP_FMAC4 soap_new__tan__GetAnalyticsModulesResponse(struct soap *soap, int n)
{
	struct _tan__GetAnalyticsModulesResponse *p;
	struct _tan__GetAnalyticsModulesResponse *a = (struct _tan__GetAnalyticsModulesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__GetAnalyticsModulesResponse));
	for (p = a; p && n--; p++)
		soap_default__tan__GetAnalyticsModulesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__GetAnalyticsModulesResponse(struct soap *soap, const struct _tan__GetAnalyticsModulesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tan__GetAnalyticsModulesResponse(soap, tag ? tag : "tan:GetAnalyticsModulesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetAnalyticsModulesResponse * SOAP_FMAC4 soap_get__tan__GetAnalyticsModulesResponse(struct soap *soap, struct _tan__GetAnalyticsModulesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__GetAnalyticsModulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__GetAnalyticsModules(struct soap *soap, struct _tan__GetAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__GetAnalyticsModules(struct soap *soap, const struct _tan__GetAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__GetAnalyticsModules(struct soap *soap, const char *tag, int id, const struct _tan__GetAnalyticsModules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__GetAnalyticsModules), type))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_nil(soap, "tan:ConfigurationToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tan:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__GetAnalyticsModules * SOAP_FMAC4 soap_in__tan__GetAnalyticsModules(struct soap *soap, const char *tag, struct _tan__GetAnalyticsModules *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tan__GetAnalyticsModules *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__GetAnalyticsModules, sizeof(struct _tan__GetAnalyticsModules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__GetAnalyticsModules(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tan:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tan__GetAnalyticsModules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__GetAnalyticsModules, SOAP_TYPE__tan__GetAnalyticsModules, sizeof(struct _tan__GetAnalyticsModules), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__GetAnalyticsModules * SOAP_FMAC4 soap_new__tan__GetAnalyticsModules(struct soap *soap, int n)
{
	struct _tan__GetAnalyticsModules *p;
	struct _tan__GetAnalyticsModules *a = (struct _tan__GetAnalyticsModules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__GetAnalyticsModules));
	for (p = a; p && n--; p++)
		soap_default__tan__GetAnalyticsModules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__GetAnalyticsModules(struct soap *soap, const struct _tan__GetAnalyticsModules *a, const char *tag, const char *type)
{
	if (soap_out__tan__GetAnalyticsModules(soap, tag ? tag : "tan:GetAnalyticsModules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetAnalyticsModules * SOAP_FMAC4 soap_get__tan__GetAnalyticsModules(struct soap *soap, struct _tan__GetAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__GetAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__ModifyAnalyticsModulesResponse(struct soap *soap, struct _tan__ModifyAnalyticsModulesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__ModifyAnalyticsModulesResponse(struct soap *soap, const struct _tan__ModifyAnalyticsModulesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__ModifyAnalyticsModulesResponse(struct soap *soap, const char *tag, int id, const struct _tan__ModifyAnalyticsModulesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__ModifyAnalyticsModulesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__ModifyAnalyticsModulesResponse * SOAP_FMAC4 soap_in__tan__ModifyAnalyticsModulesResponse(struct soap *soap, const char *tag, struct _tan__ModifyAnalyticsModulesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tan__ModifyAnalyticsModulesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__ModifyAnalyticsModulesResponse, sizeof(struct _tan__ModifyAnalyticsModulesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__ModifyAnalyticsModulesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tan__ModifyAnalyticsModulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__ModifyAnalyticsModulesResponse, SOAP_TYPE__tan__ModifyAnalyticsModulesResponse, sizeof(struct _tan__ModifyAnalyticsModulesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__ModifyAnalyticsModulesResponse * SOAP_FMAC4 soap_new__tan__ModifyAnalyticsModulesResponse(struct soap *soap, int n)
{
	struct _tan__ModifyAnalyticsModulesResponse *p;
	struct _tan__ModifyAnalyticsModulesResponse *a = (struct _tan__ModifyAnalyticsModulesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__ModifyAnalyticsModulesResponse));
	for (p = a; p && n--; p++)
		soap_default__tan__ModifyAnalyticsModulesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__ModifyAnalyticsModulesResponse(struct soap *soap, const struct _tan__ModifyAnalyticsModulesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tan__ModifyAnalyticsModulesResponse(soap, tag ? tag : "tan:ModifyAnalyticsModulesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__ModifyAnalyticsModulesResponse * SOAP_FMAC4 soap_get__tan__ModifyAnalyticsModulesResponse(struct soap *soap, struct _tan__ModifyAnalyticsModulesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__ModifyAnalyticsModulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__ModifyAnalyticsModules(struct soap *soap, struct _tan__ModifyAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
	a->__sizeAnalyticsModule = 0;
	a->AnalyticsModule = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__ModifyAnalyticsModules(struct soap *soap, const struct _tan__ModifyAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
	if (a->AnalyticsModule)
	{	int i;
		for (i = 0; i < (int)a->__sizeAnalyticsModule; i++)
		{
			soap_embedded(soap, a->AnalyticsModule + i, SOAP_TYPE_tt__Config);
			soap_serialize_tt__Config(soap, a->AnalyticsModule + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__ModifyAnalyticsModules(struct soap *soap, const char *tag, int id, const struct _tan__ModifyAnalyticsModules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__ModifyAnalyticsModules), type))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_nil(soap, "tan:ConfigurationToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tan:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	if (a->AnalyticsModule)
	{	int i;
		for (i = 0; i < (int)a->__sizeAnalyticsModule; i++)
			if (soap_out_tt__Config(soap, "tan:AnalyticsModule", -1, a->AnalyticsModule + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__ModifyAnalyticsModules * SOAP_FMAC4 soap_in__tan__ModifyAnalyticsModules(struct soap *soap, const char *tag, struct _tan__ModifyAnalyticsModules *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	struct soap_blist *soap_blist_AnalyticsModule = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tan__ModifyAnalyticsModules *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__ModifyAnalyticsModules, sizeof(struct _tan__ModifyAnalyticsModules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__ModifyAnalyticsModules(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tan:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tan:AnalyticsModule", 1, NULL))
			{	if (a->AnalyticsModule == NULL)
				{	if (soap_blist_AnalyticsModule == NULL)
						soap_blist_AnalyticsModule = soap_alloc_block(soap);
					a->AnalyticsModule = (struct tt__Config *)soap_push_block_max(soap, soap_blist_AnalyticsModule, sizeof(struct tt__Config));
					if (a->AnalyticsModule == NULL)
						return NULL;
					soap_default_tt__Config(soap, a->AnalyticsModule);
				}
				soap_revert(soap);
				if (soap_in_tt__Config(soap, "tan:AnalyticsModule", a->AnalyticsModule, "tt:Config"))
				{	a->__sizeAnalyticsModule++;
					a->AnalyticsModule = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AnalyticsModule)
			soap_pop_block(soap, soap_blist_AnalyticsModule);
		if (a->__sizeAnalyticsModule)
		{	a->AnalyticsModule = (struct tt__Config *)soap_save_block(soap, soap_blist_AnalyticsModule, NULL, 1);
		}
		else
		{	a->AnalyticsModule = NULL;
			if (soap_blist_AnalyticsModule)
				soap_end_block(soap, soap_blist_AnalyticsModule);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken > 0 || a->__sizeAnalyticsModule < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tan__ModifyAnalyticsModules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__ModifyAnalyticsModules, SOAP_TYPE__tan__ModifyAnalyticsModules, sizeof(struct _tan__ModifyAnalyticsModules), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__ModifyAnalyticsModules * SOAP_FMAC4 soap_new__tan__ModifyAnalyticsModules(struct soap *soap, int n)
{
	struct _tan__ModifyAnalyticsModules *p;
	struct _tan__ModifyAnalyticsModules *a = (struct _tan__ModifyAnalyticsModules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__ModifyAnalyticsModules));
	for (p = a; p && n--; p++)
		soap_default__tan__ModifyAnalyticsModules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__ModifyAnalyticsModules(struct soap *soap, const struct _tan__ModifyAnalyticsModules *a, const char *tag, const char *type)
{
	if (soap_out__tan__ModifyAnalyticsModules(soap, tag ? tag : "tan:ModifyAnalyticsModules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__ModifyAnalyticsModules * SOAP_FMAC4 soap_get__tan__ModifyAnalyticsModules(struct soap *soap, struct _tan__ModifyAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__ModifyAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__DeleteAnalyticsModulesResponse(struct soap *soap, struct _tan__DeleteAnalyticsModulesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__DeleteAnalyticsModulesResponse(struct soap *soap, const struct _tan__DeleteAnalyticsModulesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__DeleteAnalyticsModulesResponse(struct soap *soap, const char *tag, int id, const struct _tan__DeleteAnalyticsModulesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__DeleteAnalyticsModulesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__DeleteAnalyticsModulesResponse * SOAP_FMAC4 soap_in__tan__DeleteAnalyticsModulesResponse(struct soap *soap, const char *tag, struct _tan__DeleteAnalyticsModulesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tan__DeleteAnalyticsModulesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__DeleteAnalyticsModulesResponse, sizeof(struct _tan__DeleteAnalyticsModulesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__DeleteAnalyticsModulesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tan__DeleteAnalyticsModulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__DeleteAnalyticsModulesResponse, SOAP_TYPE__tan__DeleteAnalyticsModulesResponse, sizeof(struct _tan__DeleteAnalyticsModulesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__DeleteAnalyticsModulesResponse * SOAP_FMAC4 soap_new__tan__DeleteAnalyticsModulesResponse(struct soap *soap, int n)
{
	struct _tan__DeleteAnalyticsModulesResponse *p;
	struct _tan__DeleteAnalyticsModulesResponse *a = (struct _tan__DeleteAnalyticsModulesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__DeleteAnalyticsModulesResponse));
	for (p = a; p && n--; p++)
		soap_default__tan__DeleteAnalyticsModulesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__DeleteAnalyticsModulesResponse(struct soap *soap, const struct _tan__DeleteAnalyticsModulesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tan__DeleteAnalyticsModulesResponse(soap, tag ? tag : "tan:DeleteAnalyticsModulesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__DeleteAnalyticsModulesResponse * SOAP_FMAC4 soap_get__tan__DeleteAnalyticsModulesResponse(struct soap *soap, struct _tan__DeleteAnalyticsModulesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__DeleteAnalyticsModulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__DeleteAnalyticsModules(struct soap *soap, struct _tan__DeleteAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
	a->__sizeAnalyticsModuleName = 0;
	a->AnalyticsModuleName = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__DeleteAnalyticsModules(struct soap *soap, const struct _tan__DeleteAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
	if (a->AnalyticsModuleName)
	{	int i;
		for (i = 0; i < (int)a->__sizeAnalyticsModuleName; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->AnalyticsModuleName + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__DeleteAnalyticsModules(struct soap *soap, const char *tag, int id, const struct _tan__DeleteAnalyticsModules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__DeleteAnalyticsModules), type))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_nil(soap, "tan:ConfigurationToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tan:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	if (a->AnalyticsModuleName)
	{	int i;
		for (i = 0; i < (int)a->__sizeAnalyticsModuleName; i++)
			soap_out_string(soap, "tan:AnalyticsModuleName", -1, (char*const*)(a->AnalyticsModuleName + i), "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__DeleteAnalyticsModules * SOAP_FMAC4 soap_in__tan__DeleteAnalyticsModules(struct soap *soap, const char *tag, struct _tan__DeleteAnalyticsModules *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	struct soap_blist *soap_blist_AnalyticsModuleName = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tan__DeleteAnalyticsModules *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__DeleteAnalyticsModules, sizeof(struct _tan__DeleteAnalyticsModules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__DeleteAnalyticsModules(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tan:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tan:AnalyticsModuleName", 1, NULL))
			{	if (a->AnalyticsModuleName == NULL)
				{	if (soap_blist_AnalyticsModuleName == NULL)
						soap_blist_AnalyticsModuleName = soap_alloc_block(soap);
					a->AnalyticsModuleName = (char **)soap_push_block_max(soap, soap_blist_AnalyticsModuleName, sizeof(char *));
					if (a->AnalyticsModuleName == NULL)
						return NULL;
					*a->AnalyticsModuleName = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "tan:AnalyticsModuleName", (char**)a->AnalyticsModuleName, "xsd:string"))
				{	a->__sizeAnalyticsModuleName++;
					a->AnalyticsModuleName = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AnalyticsModuleName)
			soap_pop_block(soap, soap_blist_AnalyticsModuleName);
		if (a->__sizeAnalyticsModuleName)
		{	a->AnalyticsModuleName = (char **)soap_save_block(soap, soap_blist_AnalyticsModuleName, NULL, 1);
		}
		else
		{	a->AnalyticsModuleName = NULL;
			if (soap_blist_AnalyticsModuleName)
				soap_end_block(soap, soap_blist_AnalyticsModuleName);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken > 0 || a->__sizeAnalyticsModuleName < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tan__DeleteAnalyticsModules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__DeleteAnalyticsModules, SOAP_TYPE__tan__DeleteAnalyticsModules, sizeof(struct _tan__DeleteAnalyticsModules), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__DeleteAnalyticsModules * SOAP_FMAC4 soap_new__tan__DeleteAnalyticsModules(struct soap *soap, int n)
{
	struct _tan__DeleteAnalyticsModules *p;
	struct _tan__DeleteAnalyticsModules *a = (struct _tan__DeleteAnalyticsModules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__DeleteAnalyticsModules));
	for (p = a; p && n--; p++)
		soap_default__tan__DeleteAnalyticsModules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__DeleteAnalyticsModules(struct soap *soap, const struct _tan__DeleteAnalyticsModules *a, const char *tag, const char *type)
{
	if (soap_out__tan__DeleteAnalyticsModules(soap, tag ? tag : "tan:DeleteAnalyticsModules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__DeleteAnalyticsModules * SOAP_FMAC4 soap_get__tan__DeleteAnalyticsModules(struct soap *soap, struct _tan__DeleteAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__DeleteAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__CreateAnalyticsModulesResponse(struct soap *soap, struct _tan__CreateAnalyticsModulesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__CreateAnalyticsModulesResponse(struct soap *soap, const struct _tan__CreateAnalyticsModulesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__CreateAnalyticsModulesResponse(struct soap *soap, const char *tag, int id, const struct _tan__CreateAnalyticsModulesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__CreateAnalyticsModulesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__CreateAnalyticsModulesResponse * SOAP_FMAC4 soap_in__tan__CreateAnalyticsModulesResponse(struct soap *soap, const char *tag, struct _tan__CreateAnalyticsModulesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tan__CreateAnalyticsModulesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__CreateAnalyticsModulesResponse, sizeof(struct _tan__CreateAnalyticsModulesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__CreateAnalyticsModulesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tan__CreateAnalyticsModulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__CreateAnalyticsModulesResponse, SOAP_TYPE__tan__CreateAnalyticsModulesResponse, sizeof(struct _tan__CreateAnalyticsModulesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__CreateAnalyticsModulesResponse * SOAP_FMAC4 soap_new__tan__CreateAnalyticsModulesResponse(struct soap *soap, int n)
{
	struct _tan__CreateAnalyticsModulesResponse *p;
	struct _tan__CreateAnalyticsModulesResponse *a = (struct _tan__CreateAnalyticsModulesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__CreateAnalyticsModulesResponse));
	for (p = a; p && n--; p++)
		soap_default__tan__CreateAnalyticsModulesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__CreateAnalyticsModulesResponse(struct soap *soap, const struct _tan__CreateAnalyticsModulesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tan__CreateAnalyticsModulesResponse(soap, tag ? tag : "tan:CreateAnalyticsModulesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__CreateAnalyticsModulesResponse * SOAP_FMAC4 soap_get__tan__CreateAnalyticsModulesResponse(struct soap *soap, struct _tan__CreateAnalyticsModulesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__CreateAnalyticsModulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tan__CreateAnalyticsModules(struct soap *soap, struct _tan__CreateAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
	a->__sizeAnalyticsModule = 0;
	a->AnalyticsModule = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tan__CreateAnalyticsModules(struct soap *soap, const struct _tan__CreateAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
	if (a->AnalyticsModule)
	{	int i;
		for (i = 0; i < (int)a->__sizeAnalyticsModule; i++)
		{
			soap_embedded(soap, a->AnalyticsModule + i, SOAP_TYPE_tt__Config);
			soap_serialize_tt__Config(soap, a->AnalyticsModule + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tan__CreateAnalyticsModules(struct soap *soap, const char *tag, int id, const struct _tan__CreateAnalyticsModules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tan__CreateAnalyticsModules), type))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_nil(soap, "tan:ConfigurationToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tan:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	if (a->AnalyticsModule)
	{	int i;
		for (i = 0; i < (int)a->__sizeAnalyticsModule; i++)
			if (soap_out_tt__Config(soap, "tan:AnalyticsModule", -1, a->AnalyticsModule + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tan__CreateAnalyticsModules * SOAP_FMAC4 soap_in__tan__CreateAnalyticsModules(struct soap *soap, const char *tag, struct _tan__CreateAnalyticsModules *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	struct soap_blist *soap_blist_AnalyticsModule = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tan__CreateAnalyticsModules *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tan__CreateAnalyticsModules, sizeof(struct _tan__CreateAnalyticsModules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tan__CreateAnalyticsModules(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tan:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tan:AnalyticsModule", 1, NULL))
			{	if (a->AnalyticsModule == NULL)
				{	if (soap_blist_AnalyticsModule == NULL)
						soap_blist_AnalyticsModule = soap_alloc_block(soap);
					a->AnalyticsModule = (struct tt__Config *)soap_push_block_max(soap, soap_blist_AnalyticsModule, sizeof(struct tt__Config));
					if (a->AnalyticsModule == NULL)
						return NULL;
					soap_default_tt__Config(soap, a->AnalyticsModule);
				}
				soap_revert(soap);
				if (soap_in_tt__Config(soap, "tan:AnalyticsModule", a->AnalyticsModule, "tt:Config"))
				{	a->__sizeAnalyticsModule++;
					a->AnalyticsModule = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AnalyticsModule)
			soap_pop_block(soap, soap_blist_AnalyticsModule);
		if (a->__sizeAnalyticsModule)
		{	a->AnalyticsModule = (struct tt__Config *)soap_save_block(soap, soap_blist_AnalyticsModule, NULL, 1);
		}
		else
		{	a->AnalyticsModule = NULL;
			if (soap_blist_AnalyticsModule)
				soap_end_block(soap, soap_blist_AnalyticsModule);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken > 0 || a->__sizeAnalyticsModule < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tan__CreateAnalyticsModules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tan__CreateAnalyticsModules, SOAP_TYPE__tan__CreateAnalyticsModules, sizeof(struct _tan__CreateAnalyticsModules), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tan__CreateAnalyticsModules * SOAP_FMAC4 soap_new__tan__CreateAnalyticsModules(struct soap *soap, int n)
{
	struct _tan__CreateAnalyticsModules *p;
	struct _tan__CreateAnalyticsModules *a = (struct _tan__CreateAnalyticsModules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tan__CreateAnalyticsModules));
	for (p = a; p && n--; p++)
		soap_default__tan__CreateAnalyticsModules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tan__CreateAnalyticsModules(struct soap *soap, const struct _tan__CreateAnalyticsModules *a, const char *tag, const char *type)
{
	if (soap_out__tan__CreateAnalyticsModules(soap, tag ? tag : "tan:CreateAnalyticsModules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__CreateAnalyticsModules * SOAP_FMAC4 soap_get__tan__CreateAnalyticsModules(struct soap *soap, struct _tan__CreateAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in__tan__CreateAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
