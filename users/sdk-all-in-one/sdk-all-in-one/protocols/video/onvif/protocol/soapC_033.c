/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:59 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ColorDescriptorExtension(struct soap *soap, struct tt__ColorDescriptorExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ColorDescriptorExtension(struct soap *soap, const struct tt__ColorDescriptorExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ColorDescriptorExtension(struct soap *soap, const char *tag, int id, const struct tt__ColorDescriptorExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ColorDescriptorExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ColorDescriptorExtension * SOAP_FMAC4 soap_in_tt__ColorDescriptorExtension(struct soap *soap, const char *tag, struct tt__ColorDescriptorExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ColorDescriptorExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ColorDescriptorExtension, sizeof(struct tt__ColorDescriptorExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ColorDescriptorExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ColorDescriptorExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ColorDescriptorExtension, SOAP_TYPE_tt__ColorDescriptorExtension, sizeof(struct tt__ColorDescriptorExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ColorDescriptorExtension * SOAP_FMAC4 soap_new_tt__ColorDescriptorExtension(struct soap *soap, int n)
{
	struct tt__ColorDescriptorExtension *p;
	struct tt__ColorDescriptorExtension *a = (struct tt__ColorDescriptorExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ColorDescriptorExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ColorDescriptorExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ColorDescriptorExtension(struct soap *soap, const struct tt__ColorDescriptorExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ColorDescriptorExtension(soap, tag ? tag : "tt:ColorDescriptorExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ColorDescriptorExtension * SOAP_FMAC4 soap_get_tt__ColorDescriptorExtension(struct soap *soap, struct tt__ColorDescriptorExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ColorDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__ColorDescriptor_ColorCluster(struct soap *soap, struct _tt__ColorDescriptor_ColorCluster *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Color = NULL;
	a->Weight = NULL;
	a->Covariance = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__ColorDescriptor_ColorCluster(struct soap *soap, const struct _tt__ColorDescriptor_ColorCluster *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Color(soap, &a->Color);
	soap_serialize_PointerTofloat(soap, &a->Weight);
	soap_serialize_PointerTott__ColorCovariance(soap, &a->Covariance);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ColorDescriptor_ColorCluster(struct soap *soap, const char *tag, int id, const struct _tt__ColorDescriptor_ColorCluster *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ColorDescriptor_ColorCluster), type))
		return soap->error;
	if (!a->Color)
	{	if (soap_element_nil(soap, "tt:Color"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__Color(soap, "tt:Color", -1, &a->Color, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Weight", -1, &a->Weight, ""))
		return soap->error;
	if (soap_out_PointerTott__ColorCovariance(soap, "tt:Covariance", -1, &a->Covariance, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__ColorDescriptor_ColorCluster * SOAP_FMAC4 soap_in__tt__ColorDescriptor_ColorCluster(struct soap *soap, const char *tag, struct _tt__ColorDescriptor_ColorCluster *a, const char *type)
{
	size_t soap_flag_Color = 1;
	size_t soap_flag_Weight = 1;
	size_t soap_flag_Covariance = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tt__ColorDescriptor_ColorCluster *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ColorDescriptor_ColorCluster, sizeof(struct _tt__ColorDescriptor_ColorCluster), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__ColorDescriptor_ColorCluster(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Color && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Color(soap, "tt:Color", &a->Color, "tt:Color"))
				{	soap_flag_Color--;
					continue;
				}
			if (soap_flag_Weight && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:Weight", &a->Weight, "xsd:float"))
				{	soap_flag_Weight--;
					continue;
				}
			if (soap_flag_Covariance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ColorCovariance(soap, "tt:Covariance", &a->Covariance, "tt:ColorCovariance"))
				{	soap_flag_Covariance--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Color > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tt__ColorDescriptor_ColorCluster *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ColorDescriptor_ColorCluster, SOAP_TYPE__tt__ColorDescriptor_ColorCluster, sizeof(struct _tt__ColorDescriptor_ColorCluster), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tt__ColorDescriptor_ColorCluster * SOAP_FMAC4 soap_new__tt__ColorDescriptor_ColorCluster(struct soap *soap, int n)
{
	struct _tt__ColorDescriptor_ColorCluster *p;
	struct _tt__ColorDescriptor_ColorCluster *a = (struct _tt__ColorDescriptor_ColorCluster*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tt__ColorDescriptor_ColorCluster));
	for (p = a; p && n--; p++)
		soap_default__tt__ColorDescriptor_ColorCluster(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__ColorDescriptor_ColorCluster(struct soap *soap, const struct _tt__ColorDescriptor_ColorCluster *a, const char *tag, const char *type)
{
	if (soap_out__tt__ColorDescriptor_ColorCluster(soap, tag ? tag : "tt:ColorDescriptor-ColorCluster", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ColorDescriptor_ColorCluster * SOAP_FMAC4 soap_get__tt__ColorDescriptor_ColorCluster(struct soap *soap, struct _tt__ColorDescriptor_ColorCluster *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ColorDescriptor_ColorCluster(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ShapeDescriptorExtension(struct soap *soap, struct tt__ShapeDescriptorExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ShapeDescriptorExtension(struct soap *soap, const struct tt__ShapeDescriptorExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ShapeDescriptorExtension(struct soap *soap, const char *tag, int id, const struct tt__ShapeDescriptorExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ShapeDescriptorExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ShapeDescriptorExtension * SOAP_FMAC4 soap_in_tt__ShapeDescriptorExtension(struct soap *soap, const char *tag, struct tt__ShapeDescriptorExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ShapeDescriptorExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ShapeDescriptorExtension, sizeof(struct tt__ShapeDescriptorExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ShapeDescriptorExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ShapeDescriptorExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ShapeDescriptorExtension, SOAP_TYPE_tt__ShapeDescriptorExtension, sizeof(struct tt__ShapeDescriptorExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ShapeDescriptorExtension * SOAP_FMAC4 soap_new_tt__ShapeDescriptorExtension(struct soap *soap, int n)
{
	struct tt__ShapeDescriptorExtension *p;
	struct tt__ShapeDescriptorExtension *a = (struct tt__ShapeDescriptorExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ShapeDescriptorExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ShapeDescriptorExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ShapeDescriptorExtension(struct soap *soap, const struct tt__ShapeDescriptorExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ShapeDescriptorExtension(soap, tag ? tag : "tt:ShapeDescriptorExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ShapeDescriptorExtension * SOAP_FMAC4 soap_get_tt__ShapeDescriptorExtension(struct soap *soap, struct tt__ShapeDescriptorExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ShapeDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AppearanceExtension(struct soap *soap, struct tt__AppearanceExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AppearanceExtension(struct soap *soap, const struct tt__AppearanceExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AppearanceExtension(struct soap *soap, const char *tag, int id, const struct tt__AppearanceExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AppearanceExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AppearanceExtension * SOAP_FMAC4 soap_in_tt__AppearanceExtension(struct soap *soap, const char *tag, struct tt__AppearanceExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AppearanceExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AppearanceExtension, sizeof(struct tt__AppearanceExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AppearanceExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AppearanceExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AppearanceExtension, SOAP_TYPE_tt__AppearanceExtension, sizeof(struct tt__AppearanceExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AppearanceExtension * SOAP_FMAC4 soap_new_tt__AppearanceExtension(struct soap *soap, int n)
{
	struct tt__AppearanceExtension *p;
	struct tt__AppearanceExtension *a = (struct tt__AppearanceExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AppearanceExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__AppearanceExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AppearanceExtension(struct soap *soap, const struct tt__AppearanceExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__AppearanceExtension(soap, tag ? tag : "tt:AppearanceExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AppearanceExtension * SOAP_FMAC4 soap_get_tt__AppearanceExtension(struct soap *soap, struct tt__AppearanceExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AppearanceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ClassDescriptor(struct soap *soap, struct tt__ClassDescriptor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeClassCandidate = 0;
	a->ClassCandidate = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ClassDescriptor(struct soap *soap, const struct tt__ClassDescriptor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ClassCandidate)
	{	int i;
		for (i = 0; i < (int)a->__sizeClassCandidate; i++)
		{
			soap_embedded(soap, a->ClassCandidate + i, SOAP_TYPE__tt__ClassDescriptor_ClassCandidate);
			soap_serialize__tt__ClassDescriptor_ClassCandidate(soap, a->ClassCandidate + i);
		}
	}
	soap_serialize_PointerTott__ClassDescriptorExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ClassDescriptor(struct soap *soap, const char *tag, int id, const struct tt__ClassDescriptor *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ClassDescriptor), type))
		return soap->error;
	if (a->ClassCandidate)
	{	int i;
		for (i = 0; i < (int)a->__sizeClassCandidate; i++)
			if (soap_out__tt__ClassDescriptor_ClassCandidate(soap, "tt:ClassCandidate", -1, a->ClassCandidate + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ClassDescriptorExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ClassDescriptor * SOAP_FMAC4 soap_in_tt__ClassDescriptor(struct soap *soap, const char *tag, struct tt__ClassDescriptor *a, const char *type)
{
	struct soap_blist *soap_blist_ClassCandidate = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ClassDescriptor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ClassDescriptor, sizeof(struct tt__ClassDescriptor), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ClassDescriptor(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ClassCandidate", 1, NULL))
			{	if (a->ClassCandidate == NULL)
				{	if (soap_blist_ClassCandidate == NULL)
						soap_blist_ClassCandidate = soap_alloc_block(soap);
					a->ClassCandidate = (struct _tt__ClassDescriptor_ClassCandidate *)soap_push_block_max(soap, soap_blist_ClassCandidate, sizeof(struct _tt__ClassDescriptor_ClassCandidate));
					if (a->ClassCandidate == NULL)
						return NULL;
					soap_default__tt__ClassDescriptor_ClassCandidate(soap, a->ClassCandidate);
				}
				soap_revert(soap);
				if (soap_in__tt__ClassDescriptor_ClassCandidate(soap, "tt:ClassCandidate", a->ClassCandidate, ""))
				{	a->__sizeClassCandidate++;
					a->ClassCandidate = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ClassDescriptorExtension(soap, "tt:Extension", &a->Extension, "tt:ClassDescriptorExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ClassCandidate)
			soap_pop_block(soap, soap_blist_ClassCandidate);
		if (a->__sizeClassCandidate)
		{	a->ClassCandidate = (struct _tt__ClassDescriptor_ClassCandidate *)soap_save_block(soap, soap_blist_ClassCandidate, NULL, 1);
		}
		else
		{	a->ClassCandidate = NULL;
			if (soap_blist_ClassCandidate)
				soap_end_block(soap, soap_blist_ClassCandidate);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ClassDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ClassDescriptor, SOAP_TYPE_tt__ClassDescriptor, sizeof(struct tt__ClassDescriptor), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ClassDescriptor * SOAP_FMAC4 soap_new_tt__ClassDescriptor(struct soap *soap, int n)
{
	struct tt__ClassDescriptor *p;
	struct tt__ClassDescriptor *a = (struct tt__ClassDescriptor*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ClassDescriptor));
	for (p = a; p && n--; p++)
		soap_default_tt__ClassDescriptor(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ClassDescriptor(struct soap *soap, const struct tt__ClassDescriptor *a, const char *tag, const char *type)
{
	if (soap_out_tt__ClassDescriptor(soap, tag ? tag : "tt:ClassDescriptor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ClassDescriptor * SOAP_FMAC4 soap_get_tt__ClassDescriptor(struct soap *soap, struct tt__ClassDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ClassDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ColorDescriptor(struct soap *soap, struct tt__ColorDescriptor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeColorCluster = 0;
	a->ColorCluster = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ColorDescriptor(struct soap *soap, const struct tt__ColorDescriptor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ColorCluster)
	{	int i;
		for (i = 0; i < (int)a->__sizeColorCluster; i++)
		{
			soap_embedded(soap, a->ColorCluster + i, SOAP_TYPE__tt__ColorDescriptor_ColorCluster);
			soap_serialize__tt__ColorDescriptor_ColorCluster(soap, a->ColorCluster + i);
		}
	}
	soap_serialize_PointerTott__ColorDescriptorExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ColorDescriptor(struct soap *soap, const char *tag, int id, const struct tt__ColorDescriptor *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ColorDescriptor), type))
		return soap->error;
	if (a->ColorCluster)
	{	int i;
		for (i = 0; i < (int)a->__sizeColorCluster; i++)
			if (soap_out__tt__ColorDescriptor_ColorCluster(soap, "tt:ColorCluster", -1, a->ColorCluster + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ColorDescriptorExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ColorDescriptor * SOAP_FMAC4 soap_in_tt__ColorDescriptor(struct soap *soap, const char *tag, struct tt__ColorDescriptor *a, const char *type)
{
	struct soap_blist *soap_blist_ColorCluster = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ColorDescriptor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ColorDescriptor, sizeof(struct tt__ColorDescriptor), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ColorDescriptor(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ColorCluster", 1, NULL))
			{	if (a->ColorCluster == NULL)
				{	if (soap_blist_ColorCluster == NULL)
						soap_blist_ColorCluster = soap_alloc_block(soap);
					a->ColorCluster = (struct _tt__ColorDescriptor_ColorCluster *)soap_push_block_max(soap, soap_blist_ColorCluster, sizeof(struct _tt__ColorDescriptor_ColorCluster));
					if (a->ColorCluster == NULL)
						return NULL;
					soap_default__tt__ColorDescriptor_ColorCluster(soap, a->ColorCluster);
				}
				soap_revert(soap);
				if (soap_in__tt__ColorDescriptor_ColorCluster(soap, "tt:ColorCluster", a->ColorCluster, ""))
				{	a->__sizeColorCluster++;
					a->ColorCluster = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ColorDescriptorExtension(soap, "tt:Extension", &a->Extension, "tt:ColorDescriptorExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ColorCluster)
			soap_pop_block(soap, soap_blist_ColorCluster);
		if (a->__sizeColorCluster)
		{	a->ColorCluster = (struct _tt__ColorDescriptor_ColorCluster *)soap_save_block(soap, soap_blist_ColorCluster, NULL, 1);
		}
		else
		{	a->ColorCluster = NULL;
			if (soap_blist_ColorCluster)
				soap_end_block(soap, soap_blist_ColorCluster);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ColorDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ColorDescriptor, SOAP_TYPE_tt__ColorDescriptor, sizeof(struct tt__ColorDescriptor), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ColorDescriptor * SOAP_FMAC4 soap_new_tt__ColorDescriptor(struct soap *soap, int n)
{
	struct tt__ColorDescriptor *p;
	struct tt__ColorDescriptor *a = (struct tt__ColorDescriptor*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ColorDescriptor));
	for (p = a; p && n--; p++)
		soap_default_tt__ColorDescriptor(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ColorDescriptor(struct soap *soap, const struct tt__ColorDescriptor *a, const char *tag, const char *type)
{
	if (soap_out_tt__ColorDescriptor(soap, tag ? tag : "tt:ColorDescriptor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ColorDescriptor * SOAP_FMAC4 soap_get_tt__ColorDescriptor(struct soap *soap, struct tt__ColorDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ColorDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ShapeDescriptor(struct soap *soap, struct tt__ShapeDescriptor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->BoundingBox = NULL;
	a->CenterOfGravity = NULL;
	a->__sizePolygon = 0;
	a->Polygon = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ShapeDescriptor(struct soap *soap, const struct tt__ShapeDescriptor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Rectangle(soap, &a->BoundingBox);
	soap_serialize_PointerTott__Vector(soap, &a->CenterOfGravity);
	if (a->Polygon)
	{	int i;
		for (i = 0; i < (int)a->__sizePolygon; i++)
		{
			soap_embedded(soap, a->Polygon + i, SOAP_TYPE_tt__Polygon);
			soap_serialize_tt__Polygon(soap, a->Polygon + i);
		}
	}
	soap_serialize_PointerTott__ShapeDescriptorExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ShapeDescriptor(struct soap *soap, const char *tag, int id, const struct tt__ShapeDescriptor *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ShapeDescriptor), type))
		return soap->error;
	if (!a->BoundingBox)
	{	if (soap_element_nil(soap, "tt:BoundingBox"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__Rectangle(soap, "tt:BoundingBox", -1, &a->BoundingBox, ""))
		return soap->error;
	if (!a->CenterOfGravity)
	{	if (soap_element_nil(soap, "tt:CenterOfGravity"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__Vector(soap, "tt:CenterOfGravity", -1, &a->CenterOfGravity, ""))
		return soap->error;
	if (a->Polygon)
	{	int i;
		for (i = 0; i < (int)a->__sizePolygon; i++)
			if (soap_out_tt__Polygon(soap, "tt:Polygon", -1, a->Polygon + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ShapeDescriptorExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ShapeDescriptor * SOAP_FMAC4 soap_in_tt__ShapeDescriptor(struct soap *soap, const char *tag, struct tt__ShapeDescriptor *a, const char *type)
{
	size_t soap_flag_BoundingBox = 1;
	size_t soap_flag_CenterOfGravity = 1;
	struct soap_blist *soap_blist_Polygon = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ShapeDescriptor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ShapeDescriptor, sizeof(struct tt__ShapeDescriptor), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ShapeDescriptor(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BoundingBox && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Rectangle(soap, "tt:BoundingBox", &a->BoundingBox, "tt:Rectangle"))
				{	soap_flag_BoundingBox--;
					continue;
				}
			if (soap_flag_CenterOfGravity && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Vector(soap, "tt:CenterOfGravity", &a->CenterOfGravity, "tt:Vector"))
				{	soap_flag_CenterOfGravity--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Polygon", 1, NULL))
			{	if (a->Polygon == NULL)
				{	if (soap_blist_Polygon == NULL)
						soap_blist_Polygon = soap_alloc_block(soap);
					a->Polygon = (struct tt__Polygon *)soap_push_block_max(soap, soap_blist_Polygon, sizeof(struct tt__Polygon));
					if (a->Polygon == NULL)
						return NULL;
					soap_default_tt__Polygon(soap, a->Polygon);
				}
				soap_revert(soap);
				if (soap_in_tt__Polygon(soap, "tt:Polygon", a->Polygon, "tt:Polygon"))
				{	a->__sizePolygon++;
					a->Polygon = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ShapeDescriptorExtension(soap, "tt:Extension", &a->Extension, "tt:ShapeDescriptorExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Polygon)
			soap_pop_block(soap, soap_blist_Polygon);
		if (a->__sizePolygon)
		{	a->Polygon = (struct tt__Polygon *)soap_save_block(soap, soap_blist_Polygon, NULL, 1);
		}
		else
		{	a->Polygon = NULL;
			if (soap_blist_Polygon)
				soap_end_block(soap, soap_blist_Polygon);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_BoundingBox > 0 || soap_flag_CenterOfGravity > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ShapeDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ShapeDescriptor, SOAP_TYPE_tt__ShapeDescriptor, sizeof(struct tt__ShapeDescriptor), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ShapeDescriptor * SOAP_FMAC4 soap_new_tt__ShapeDescriptor(struct soap *soap, int n)
{
	struct tt__ShapeDescriptor *p;
	struct tt__ShapeDescriptor *a = (struct tt__ShapeDescriptor*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ShapeDescriptor));
	for (p = a; p && n--; p++)
		soap_default_tt__ShapeDescriptor(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ShapeDescriptor(struct soap *soap, const struct tt__ShapeDescriptor *a, const char *tag, const char *type)
{
	if (soap_out_tt__ShapeDescriptor(soap, tag ? tag : "tt:ShapeDescriptor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ShapeDescriptor * SOAP_FMAC4 soap_get_tt__ShapeDescriptor(struct soap *soap, struct tt__ShapeDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ShapeDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Transformation(struct soap *soap, struct tt__Transformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Translate = NULL;
	a->Scale = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Transformation(struct soap *soap, const struct tt__Transformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Vector(soap, &a->Translate);
	soap_serialize_PointerTott__Vector(soap, &a->Scale);
	soap_serialize_PointerTott__TransformationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Transformation(struct soap *soap, const char *tag, int id, const struct tt__Transformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Transformation), type))
		return soap->error;
	if (soap_out_PointerTott__Vector(soap, "tt:Translate", -1, &a->Translate, ""))
		return soap->error;
	if (soap_out_PointerTott__Vector(soap, "tt:Scale", -1, &a->Scale, ""))
		return soap->error;
	if (soap_out_PointerTott__TransformationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Transformation * SOAP_FMAC4 soap_in_tt__Transformation(struct soap *soap, const char *tag, struct tt__Transformation *a, const char *type)
{
	size_t soap_flag_Translate = 1;
	size_t soap_flag_Scale = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Transformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Transformation, sizeof(struct tt__Transformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Transformation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Translate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Vector(soap, "tt:Translate", &a->Translate, "tt:Vector"))
				{	soap_flag_Translate--;
					continue;
				}
			if (soap_flag_Scale && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Vector(soap, "tt:Scale", &a->Scale, "tt:Vector"))
				{	soap_flag_Scale--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__TransformationExtension(soap, "tt:Extension", &a->Extension, "tt:TransformationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Transformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Transformation, SOAP_TYPE_tt__Transformation, sizeof(struct tt__Transformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Transformation * SOAP_FMAC4 soap_new_tt__Transformation(struct soap *soap, int n)
{
	struct tt__Transformation *p;
	struct tt__Transformation *a = (struct tt__Transformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Transformation));
	for (p = a; p && n--; p++)
		soap_default_tt__Transformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Transformation(struct soap *soap, const struct tt__Transformation *a, const char *tag, const char *type)
{
	if (soap_out_tt__Transformation(soap, tag ? tag : "tt:Transformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Transformation * SOAP_FMAC4 soap_get_tt__Transformation(struct soap *soap, struct tt__Transformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Transformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Appearance(struct soap *soap, struct tt__Appearance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transformation = NULL;
	a->Shape = NULL;
	a->Color = NULL;
	a->Class = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Appearance(struct soap *soap, const struct tt__Appearance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Transformation(soap, &a->Transformation);
	soap_serialize_PointerTott__ShapeDescriptor(soap, &a->Shape);
	soap_serialize_PointerTott__ColorDescriptor(soap, &a->Color);
	soap_serialize_PointerTott__ClassDescriptor(soap, &a->Class);
	soap_serialize_PointerTott__AppearanceExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Appearance(struct soap *soap, const char *tag, int id, const struct tt__Appearance *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Appearance), type))
		return soap->error;
	if (soap_out_PointerTott__Transformation(soap, "tt:Transformation", -1, &a->Transformation, ""))
		return soap->error;
	if (soap_out_PointerTott__ShapeDescriptor(soap, "tt:Shape", -1, &a->Shape, ""))
		return soap->error;
	if (soap_out_PointerTott__ColorDescriptor(soap, "tt:Color", -1, &a->Color, ""))
		return soap->error;
	if (soap_out_PointerTott__ClassDescriptor(soap, "tt:Class", -1, &a->Class, ""))
		return soap->error;
	if (soap_out_PointerTott__AppearanceExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Appearance * SOAP_FMAC4 soap_in_tt__Appearance(struct soap *soap, const char *tag, struct tt__Appearance *a, const char *type)
{
	size_t soap_flag_Transformation = 1;
	size_t soap_flag_Shape = 1;
	size_t soap_flag_Color = 1;
	size_t soap_flag_Class = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Appearance *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Appearance, sizeof(struct tt__Appearance), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Appearance(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transformation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Transformation(soap, "tt:Transformation", &a->Transformation, "tt:Transformation"))
				{	soap_flag_Transformation--;
					continue;
				}
			if (soap_flag_Shape && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ShapeDescriptor(soap, "tt:Shape", &a->Shape, "tt:ShapeDescriptor"))
				{	soap_flag_Shape--;
					continue;
				}
			if (soap_flag_Color && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ColorDescriptor(soap, "tt:Color", &a->Color, "tt:ColorDescriptor"))
				{	soap_flag_Color--;
					continue;
				}
			if (soap_flag_Class && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ClassDescriptor(soap, "tt:Class", &a->Class, "tt:ClassDescriptor"))
				{	soap_flag_Class--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AppearanceExtension(soap, "tt:Extension", &a->Extension, "tt:AppearanceExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Appearance *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Appearance, SOAP_TYPE_tt__Appearance, sizeof(struct tt__Appearance), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Appearance * SOAP_FMAC4 soap_new_tt__Appearance(struct soap *soap, int n)
{
	struct tt__Appearance *p;
	struct tt__Appearance *a = (struct tt__Appearance*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Appearance));
	for (p = a; p && n--; p++)
		soap_default_tt__Appearance(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Appearance(struct soap *soap, const struct tt__Appearance *a, const char *tag, const char *type)
{
	if (soap_out_tt__Appearance(soap, tag ? tag : "tt:Appearance", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Appearance * SOAP_FMAC4 soap_get_tt__Appearance(struct soap *soap, struct tt__Appearance *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Appearance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ColorCovariance(struct soap *soap, struct tt__ColorCovariance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->XX);
	soap_default_float(soap, &a->YY);
	soap_default_float(soap, &a->ZZ);
	a->XY = NULL;
	a->XZ = NULL;
	a->YZ = NULL;
	soap_default_xsd__anyURI(soap, &a->Colorspace);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ColorCovariance(struct soap *soap, const struct tt__ColorCovariance *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ColorCovariance(struct soap *soap, const char *tag, int id, const struct tt__ColorCovariance *a, const char *type)
{
	soap_set_attr(soap, "XX", soap_float2s(soap, a->XX), 1);
	soap_set_attr(soap, "YY", soap_float2s(soap, a->YY), 1);
	soap_set_attr(soap, "ZZ", soap_float2s(soap, a->ZZ), 1);
	if (a->XY)
		soap_set_attr(soap, "XY", soap_float2s(soap, *a->XY), 1);
	if (a->XZ)
		soap_set_attr(soap, "XZ", soap_float2s(soap, *a->XZ), 1);
	if (a->YZ)
		soap_set_attr(soap, "YZ", soap_float2s(soap, *a->YZ), 1);
	if (a->Colorspace)
		soap_set_attr(soap, "Colorspace", soap_xsd__anyURI2s(soap, a->Colorspace), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ColorCovariance), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ColorCovariance * SOAP_FMAC4 soap_in_tt__ColorCovariance(struct soap *soap, const char *tag, struct tt__ColorCovariance *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ColorCovariance *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ColorCovariance, sizeof(struct tt__ColorCovariance), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ColorCovariance(soap, a);
	if (soap_s2float(soap, soap_attr_value(soap, "XX", 1), &a->XX))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "YY", 1), &a->YY))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "ZZ", 1), &a->ZZ))
		return NULL;
	{	const char *t = soap_attr_value(soap, "XY", 0);
		if (t)
		{
			if (!(a->XY = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->XY))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "XZ", 0);
		if (t)
		{
			if (!(a->XZ = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->XZ))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "YZ", 0);
		if (t)
		{
			if (!(a->YZ = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->YZ))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Colorspace", 0), &a->Colorspace))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ColorCovariance *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ColorCovariance, SOAP_TYPE_tt__ColorCovariance, sizeof(struct tt__ColorCovariance), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ColorCovariance * SOAP_FMAC4 soap_new_tt__ColorCovariance(struct soap *soap, int n)
{
	struct tt__ColorCovariance *p;
	struct tt__ColorCovariance *a = (struct tt__ColorCovariance*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ColorCovariance));
	for (p = a; p && n--; p++)
		soap_default_tt__ColorCovariance(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ColorCovariance(struct soap *soap, const struct tt__ColorCovariance *a, const char *tag, const char *type)
{
	if (soap_out_tt__ColorCovariance(soap, tag ? tag : "tt:ColorCovariance", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ColorCovariance * SOAP_FMAC4 soap_get_tt__ColorCovariance(struct soap *soap, struct tt__ColorCovariance *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ColorCovariance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Color(struct soap *soap, struct tt__Color *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_float(soap, &a->X);
	soap_default_float(soap, &a->Y);
	soap_default_float(soap, &a->Z);
	soap_default_xsd__anyURI(soap, &a->Colorspace);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Color(struct soap *soap, const struct tt__Color *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Color(struct soap *soap, const char *tag, int id, const struct tt__Color *a, const char *type)
{
	soap_set_attr(soap, "X", soap_float2s(soap, a->X), 1);
	soap_set_attr(soap, "Y", soap_float2s(soap, a->Y), 1);
	soap_set_attr(soap, "Z", soap_float2s(soap, a->Z), 1);
	if (a->Colorspace)
		soap_set_attr(soap, "Colorspace", soap_xsd__anyURI2s(soap, a->Colorspace), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Color), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Color * SOAP_FMAC4 soap_in_tt__Color(struct soap *soap, const char *tag, struct tt__Color *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Color *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Color, sizeof(struct tt__Color), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Color(soap, a);
	if (soap_s2float(soap, soap_attr_value(soap, "X", 1), &a->X))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "Y", 1), &a->Y))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "Z", 1), &a->Z))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "Colorspace", 0), &a->Colorspace))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Color *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Color, SOAP_TYPE_tt__Color, sizeof(struct tt__Color), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Color * SOAP_FMAC4 soap_new_tt__Color(struct soap *soap, int n)
{
	struct tt__Color *p;
	struct tt__Color *a = (struct tt__Color*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Color));
	for (p = a; p && n--; p++)
		soap_default_tt__Color(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Color(struct soap *soap, const struct tt__Color *a, const char *tag, const char *type)
{
	if (soap_out_tt__Color(soap, tag ? tag : "tt:Color", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Color * SOAP_FMAC4 soap_get_tt__Color(struct soap *soap, struct tt__Color *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Color(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Polyline(struct soap *soap, struct tt__Polyline *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePoint = 0;
	a->Point = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Polyline(struct soap *soap, const struct tt__Polyline *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Point)
	{	int i;
		for (i = 0; i < (int)a->__sizePoint; i++)
		{
			soap_embedded(soap, a->Point + i, SOAP_TYPE_tt__Vector);
			soap_serialize_tt__Vector(soap, a->Point + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Polyline(struct soap *soap, const char *tag, int id, const struct tt__Polyline *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Polyline), type))
		return soap->error;
	if (a->Point)
	{	int i;
		for (i = 0; i < (int)a->__sizePoint; i++)
			if (soap_out_tt__Vector(soap, "tt:Point", -1, a->Point + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Polyline * SOAP_FMAC4 soap_in_tt__Polyline(struct soap *soap, const char *tag, struct tt__Polyline *a, const char *type)
{
	struct soap_blist *soap_blist_Point = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Polyline *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Polyline, sizeof(struct tt__Polyline), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Polyline(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Point", 1, NULL))
			{	if (a->Point == NULL)
				{	if (soap_blist_Point == NULL)
						soap_blist_Point = soap_alloc_block(soap);
					a->Point = (struct tt__Vector *)soap_push_block_max(soap, soap_blist_Point, sizeof(struct tt__Vector));
					if (a->Point == NULL)
						return NULL;
					soap_default_tt__Vector(soap, a->Point);
				}
				soap_revert(soap);
				if (soap_in_tt__Vector(soap, "tt:Point", a->Point, "tt:Vector"))
				{	a->__sizePoint++;
					a->Point = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Point)
			soap_pop_block(soap, soap_blist_Point);
		if (a->__sizePoint)
		{	a->Point = (struct tt__Vector *)soap_save_block(soap, soap_blist_Point, NULL, 1);
		}
		else
		{	a->Point = NULL;
			if (soap_blist_Point)
				soap_end_block(soap, soap_blist_Point);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizePoint < 2))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Polyline *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Polyline, SOAP_TYPE_tt__Polyline, sizeof(struct tt__Polyline), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Polyline * SOAP_FMAC4 soap_new_tt__Polyline(struct soap *soap, int n)
{
	struct tt__Polyline *p;
	struct tt__Polyline *a = (struct tt__Polyline*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Polyline));
	for (p = a; p && n--; p++)
		soap_default_tt__Polyline(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Polyline(struct soap *soap, const struct tt__Polyline *a, const char *tag, const char *type)
{
	if (soap_out_tt__Polyline(soap, tag ? tag : "tt:Polyline", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Polyline * SOAP_FMAC4 soap_get_tt__Polyline(struct soap *soap, struct tt__Polyline *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Polyline(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Polygon(struct soap *soap, struct tt__Polygon *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePoint = 0;
	a->Point = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Polygon(struct soap *soap, const struct tt__Polygon *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Point)
	{	int i;
		for (i = 0; i < (int)a->__sizePoint; i++)
		{
			soap_embedded(soap, a->Point + i, SOAP_TYPE_tt__Vector);
			soap_serialize_tt__Vector(soap, a->Point + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Polygon(struct soap *soap, const char *tag, int id, const struct tt__Polygon *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Polygon), type))
		return soap->error;
	if (a->Point)
	{	int i;
		for (i = 0; i < (int)a->__sizePoint; i++)
			if (soap_out_tt__Vector(soap, "tt:Point", -1, a->Point + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Polygon * SOAP_FMAC4 soap_in_tt__Polygon(struct soap *soap, const char *tag, struct tt__Polygon *a, const char *type)
{
	struct soap_blist *soap_blist_Point = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Polygon *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Polygon, sizeof(struct tt__Polygon), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Polygon(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Point", 1, NULL))
			{	if (a->Point == NULL)
				{	if (soap_blist_Point == NULL)
						soap_blist_Point = soap_alloc_block(soap);
					a->Point = (struct tt__Vector *)soap_push_block_max(soap, soap_blist_Point, sizeof(struct tt__Vector));
					if (a->Point == NULL)
						return NULL;
					soap_default_tt__Vector(soap, a->Point);
				}
				soap_revert(soap);
				if (soap_in_tt__Vector(soap, "tt:Point", a->Point, "tt:Vector"))
				{	a->__sizePoint++;
					a->Point = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Point)
			soap_pop_block(soap, soap_blist_Point);
		if (a->__sizePoint)
		{	a->Point = (struct tt__Vector *)soap_save_block(soap, soap_blist_Point, NULL, 1);
		}
		else
		{	a->Point = NULL;
			if (soap_blist_Point)
				soap_end_block(soap, soap_blist_Point);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizePoint < 3))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Polygon *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Polygon, SOAP_TYPE_tt__Polygon, sizeof(struct tt__Polygon), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Polygon * SOAP_FMAC4 soap_new_tt__Polygon(struct soap *soap, int n)
{
	struct tt__Polygon *p;
	struct tt__Polygon *a = (struct tt__Polygon*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Polygon));
	for (p = a; p && n--; p++)
		soap_default_tt__Polygon(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Polygon(struct soap *soap, const struct tt__Polygon *a, const char *tag, const char *type)
{
	if (soap_out_tt__Polygon(soap, tag ? tag : "tt:Polygon", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Polygon * SOAP_FMAC4 soap_get_tt__Polygon(struct soap *soap, struct tt__Polygon *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Polygon(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Vector(struct soap *soap, struct tt__Vector *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->x = NULL;
	a->y = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Vector(struct soap *soap, const struct tt__Vector *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Vector(struct soap *soap, const char *tag, int id, const struct tt__Vector *a, const char *type)
{
	if (a->x)
		soap_set_attr(soap, "x", soap_float2s(soap, *a->x), 1);
	if (a->y)
		soap_set_attr(soap, "y", soap_float2s(soap, *a->y), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Vector), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Vector * SOAP_FMAC4 soap_in_tt__Vector(struct soap *soap, const char *tag, struct tt__Vector *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Vector *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Vector, sizeof(struct tt__Vector), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Vector(soap, a);
	{	const char *t = soap_attr_value(soap, "x", 0);
		if (t)
		{
			if (!(a->x = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->x))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "y", 0);
		if (t)
		{
			if (!(a->y = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->y))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Vector *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Vector, SOAP_TYPE_tt__Vector, sizeof(struct tt__Vector), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Vector * SOAP_FMAC4 soap_new_tt__Vector(struct soap *soap, int n)
{
	struct tt__Vector *p;
	struct tt__Vector *a = (struct tt__Vector*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Vector));
	for (p = a; p && n--; p++)
		soap_default_tt__Vector(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Vector(struct soap *soap, const struct tt__Vector *a, const char *tag, const char *type)
{
	if (soap_out_tt__Vector(soap, tag ? tag : "tt:Vector", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Vector * SOAP_FMAC4 soap_get_tt__Vector(struct soap *soap, struct tt__Vector *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Vector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ItemListDescriptionExtension(struct soap *soap, struct tt__ItemListDescriptionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ItemListDescriptionExtension(struct soap *soap, const struct tt__ItemListDescriptionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ItemListDescriptionExtension(struct soap *soap, const char *tag, int id, const struct tt__ItemListDescriptionExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ItemListDescriptionExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ItemListDescriptionExtension * SOAP_FMAC4 soap_in_tt__ItemListDescriptionExtension(struct soap *soap, const char *tag, struct tt__ItemListDescriptionExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ItemListDescriptionExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ItemListDescriptionExtension, sizeof(struct tt__ItemListDescriptionExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ItemListDescriptionExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ItemListDescriptionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ItemListDescriptionExtension, SOAP_TYPE_tt__ItemListDescriptionExtension, sizeof(struct tt__ItemListDescriptionExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ItemListDescriptionExtension * SOAP_FMAC4 soap_new_tt__ItemListDescriptionExtension(struct soap *soap, int n)
{
	struct tt__ItemListDescriptionExtension *p;
	struct tt__ItemListDescriptionExtension *a = (struct tt__ItemListDescriptionExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ItemListDescriptionExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ItemListDescriptionExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ItemListDescriptionExtension(struct soap *soap, const struct tt__ItemListDescriptionExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ItemListDescriptionExtension(soap, tag ? tag : "tt:ItemListDescriptionExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemListDescriptionExtension * SOAP_FMAC4 soap_get_tt__ItemListDescriptionExtension(struct soap *soap, struct tt__ItemListDescriptionExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ItemListDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__ItemListDescription_ElementItemDescription(struct soap *soap, struct _tt__ItemListDescription_ElementItemDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
	soap_default__QName(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__ItemListDescription_ElementItemDescription(struct soap *soap, const struct _tt__ItemListDescription_ElementItemDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ItemListDescription_ElementItemDescription(struct soap *soap, const char *tag, int id, const struct _tt__ItemListDescription_ElementItemDescription *a, const char *type)
{
	if (a->Name)
		soap_set_attr(soap, "Name", soap_string2s(soap, a->Name), 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap__QName2s(soap, a->Type), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__ItemListDescription_ElementItemDescription * SOAP_FMAC4 soap_in__tt__ItemListDescription_ElementItemDescription(struct soap *soap, const char *tag, struct _tt__ItemListDescription_ElementItemDescription *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tt__ItemListDescription_ElementItemDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription, sizeof(struct _tt__ItemListDescription_ElementItemDescription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__ItemListDescription_ElementItemDescription(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1), &a->Name))
		return NULL;
	if (soap_s2_QName(soap, soap_attr_value(soap, "Type", 1), &a->Type))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemListDescription_ElementItemDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription, sizeof(struct _tt__ItemListDescription_ElementItemDescription), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tt__ItemListDescription_ElementItemDescription * SOAP_FMAC4 soap_new__tt__ItemListDescription_ElementItemDescription(struct soap *soap, int n)
{
	struct _tt__ItemListDescription_ElementItemDescription *p;
	struct _tt__ItemListDescription_ElementItemDescription *a = (struct _tt__ItemListDescription_ElementItemDescription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tt__ItemListDescription_ElementItemDescription));
	for (p = a; p && n--; p++)
		soap_default__tt__ItemListDescription_ElementItemDescription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__ItemListDescription_ElementItemDescription(struct soap *soap, const struct _tt__ItemListDescription_ElementItemDescription *a, const char *tag, const char *type)
{
	if (soap_out__tt__ItemListDescription_ElementItemDescription(soap, tag ? tag : "tt:ItemListDescription-ElementItemDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemListDescription_ElementItemDescription * SOAP_FMAC4 soap_get__tt__ItemListDescription_ElementItemDescription(struct soap *soap, struct _tt__ItemListDescription_ElementItemDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ItemListDescription_ElementItemDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__ItemListDescription_SimpleItemDescription(struct soap *soap, struct _tt__ItemListDescription_SimpleItemDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
	soap_default__QName(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const struct _tt__ItemListDescription_SimpleItemDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const char *tag, int id, const struct _tt__ItemListDescription_SimpleItemDescription *a, const char *type)
{
	if (a->Name)
		soap_set_attr(soap, "Name", soap_string2s(soap, a->Name), 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap__QName2s(soap, a->Type), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__ItemListDescription_SimpleItemDescription * SOAP_FMAC4 soap_in__tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const char *tag, struct _tt__ItemListDescription_SimpleItemDescription *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tt__ItemListDescription_SimpleItemDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription, sizeof(struct _tt__ItemListDescription_SimpleItemDescription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__ItemListDescription_SimpleItemDescription(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1), &a->Name))
		return NULL;
	if (soap_s2_QName(soap, soap_attr_value(soap, "Type", 1), &a->Type))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemListDescription_SimpleItemDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription, sizeof(struct _tt__ItemListDescription_SimpleItemDescription), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tt__ItemListDescription_SimpleItemDescription * SOAP_FMAC4 soap_new__tt__ItemListDescription_SimpleItemDescription(struct soap *soap, int n)
{
	struct _tt__ItemListDescription_SimpleItemDescription *p;
	struct _tt__ItemListDescription_SimpleItemDescription *a = (struct _tt__ItemListDescription_SimpleItemDescription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tt__ItemListDescription_SimpleItemDescription));
	for (p = a; p && n--; p++)
		soap_default__tt__ItemListDescription_SimpleItemDescription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const struct _tt__ItemListDescription_SimpleItemDescription *a, const char *tag, const char *type)
{
	if (soap_out__tt__ItemListDescription_SimpleItemDescription(soap, tag ? tag : "tt:ItemListDescription-SimpleItemDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemListDescription_SimpleItemDescription * SOAP_FMAC4 soap_get__tt__ItemListDescription_SimpleItemDescription(struct soap *soap, struct _tt__ItemListDescription_SimpleItemDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ItemListDescription_SimpleItemDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MessageDescriptionExtension(struct soap *soap, struct tt__MessageDescriptionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MessageDescriptionExtension(struct soap *soap, const struct tt__MessageDescriptionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MessageDescriptionExtension(struct soap *soap, const char *tag, int id, const struct tt__MessageDescriptionExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MessageDescriptionExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MessageDescriptionExtension * SOAP_FMAC4 soap_in_tt__MessageDescriptionExtension(struct soap *soap, const char *tag, struct tt__MessageDescriptionExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MessageDescriptionExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MessageDescriptionExtension, sizeof(struct tt__MessageDescriptionExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MessageDescriptionExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MessageDescriptionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MessageDescriptionExtension, SOAP_TYPE_tt__MessageDescriptionExtension, sizeof(struct tt__MessageDescriptionExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MessageDescriptionExtension * SOAP_FMAC4 soap_new_tt__MessageDescriptionExtension(struct soap *soap, int n)
{
	struct tt__MessageDescriptionExtension *p;
	struct tt__MessageDescriptionExtension *a = (struct tt__MessageDescriptionExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MessageDescriptionExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__MessageDescriptionExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MessageDescriptionExtension(struct soap *soap, const struct tt__MessageDescriptionExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__MessageDescriptionExtension(soap, tag ? tag : "tt:MessageDescriptionExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MessageDescriptionExtension * SOAP_FMAC4 soap_get_tt__MessageDescriptionExtension(struct soap *soap, struct tt__MessageDescriptionExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MessageDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MessageDescription(struct soap *soap, struct tt__MessageDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Source = NULL;
	a->Key = NULL;
	a->Data = NULL;
	a->Extension = NULL;
	a->IsProperty = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MessageDescription(struct soap *soap, const struct tt__MessageDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ItemListDescription(soap, &a->Source);
	soap_serialize_PointerTott__ItemListDescription(soap, &a->Key);
	soap_serialize_PointerTott__ItemListDescription(soap, &a->Data);
	soap_serialize_PointerTott__MessageDescriptionExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MessageDescription(struct soap *soap, const char *tag, int id, const struct tt__MessageDescription *a, const char *type)
{
	if (a->IsProperty)
		soap_set_attr(soap, "IsProperty", soap_xsd__boolean2s(soap, *a->IsProperty), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MessageDescription), type))
		return soap->error;
	if (soap_out_PointerTott__ItemListDescription(soap, "tt:Source", -1, &a->Source, ""))
		return soap->error;
	if (soap_out_PointerTott__ItemListDescription(soap, "tt:Key", -1, &a->Key, ""))
		return soap->error;
	if (soap_out_PointerTott__ItemListDescription(soap, "tt:Data", -1, &a->Data, ""))
		return soap->error;
	if (soap_out_PointerTott__MessageDescriptionExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MessageDescription * SOAP_FMAC4 soap_in_tt__MessageDescription(struct soap *soap, const char *tag, struct tt__MessageDescription *a, const char *type)
{
	size_t soap_flag_Source = 1;
	size_t soap_flag_Key = 1;
	size_t soap_flag_Data = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MessageDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MessageDescription, sizeof(struct tt__MessageDescription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MessageDescription(soap, a);
	{	const char *t = soap_attr_value(soap, "IsProperty", 0);
		if (t)
		{
			if (!(a->IsProperty = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->IsProperty))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Source && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemListDescription(soap, "tt:Source", &a->Source, "tt:ItemListDescription"))
				{	soap_flag_Source--;
					continue;
				}
			if (soap_flag_Key && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemListDescription(soap, "tt:Key", &a->Key, "tt:ItemListDescription"))
				{	soap_flag_Key--;
					continue;
				}
			if (soap_flag_Data && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemListDescription(soap, "tt:Data", &a->Data, "tt:ItemListDescription"))
				{	soap_flag_Data--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MessageDescriptionExtension(soap, "tt:Extension", &a->Extension, "tt:MessageDescriptionExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MessageDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MessageDescription, SOAP_TYPE_tt__MessageDescription, sizeof(struct tt__MessageDescription), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MessageDescription * SOAP_FMAC4 soap_new_tt__MessageDescription(struct soap *soap, int n)
{
	struct tt__MessageDescription *p;
	struct tt__MessageDescription *a = (struct tt__MessageDescription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MessageDescription));
	for (p = a; p && n--; p++)
		soap_default_tt__MessageDescription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MessageDescription(struct soap *soap, const struct tt__MessageDescription *a, const char *tag, const char *type)
{
	if (soap_out_tt__MessageDescription(soap, tag ? tag : "tt:MessageDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MessageDescription * SOAP_FMAC4 soap_get_tt__MessageDescription(struct soap *soap, struct tt__MessageDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MessageDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ItemListExtension(struct soap *soap, struct tt__ItemListExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ItemListExtension(struct soap *soap, const struct tt__ItemListExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ItemListExtension(struct soap *soap, const char *tag, int id, const struct tt__ItemListExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ItemListExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ItemListExtension * SOAP_FMAC4 soap_in_tt__ItemListExtension(struct soap *soap, const char *tag, struct tt__ItemListExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ItemListExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ItemListExtension, sizeof(struct tt__ItemListExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ItemListExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ItemListExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ItemListExtension, SOAP_TYPE_tt__ItemListExtension, sizeof(struct tt__ItemListExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ItemListExtension * SOAP_FMAC4 soap_new_tt__ItemListExtension(struct soap *soap, int n)
{
	struct tt__ItemListExtension *p;
	struct tt__ItemListExtension *a = (struct tt__ItemListExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ItemListExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ItemListExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ItemListExtension(struct soap *soap, const struct tt__ItemListExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ItemListExtension(soap, tag ? tag : "tt:ItemListExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemListExtension * SOAP_FMAC4 soap_get_tt__ItemListExtension(struct soap *soap, struct tt__ItemListExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ItemListExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__ItemList_ElementItem(struct soap *soap, struct _tt__ItemList_ElementItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__ItemList_ElementItem(struct soap *soap, const struct _tt__ItemList_ElementItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ItemList_ElementItem(struct soap *soap, const char *tag, int id, const struct _tt__ItemList_ElementItem *a, const char *type)
{
	if (a->Name)
		soap_set_attr(soap, "Name", soap_string2s(soap, a->Name), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ItemList_ElementItem), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__ItemList_ElementItem * SOAP_FMAC4 soap_in__tt__ItemList_ElementItem(struct soap *soap, const char *tag, struct _tt__ItemList_ElementItem *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tt__ItemList_ElementItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ItemList_ElementItem, sizeof(struct _tt__ItemList_ElementItem), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__ItemList_ElementItem(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1), &a->Name))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemList_ElementItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ItemList_ElementItem, SOAP_TYPE__tt__ItemList_ElementItem, sizeof(struct _tt__ItemList_ElementItem), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tt__ItemList_ElementItem * SOAP_FMAC4 soap_new__tt__ItemList_ElementItem(struct soap *soap, int n)
{
	struct _tt__ItemList_ElementItem *p;
	struct _tt__ItemList_ElementItem *a = (struct _tt__ItemList_ElementItem*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tt__ItemList_ElementItem));
	for (p = a; p && n--; p++)
		soap_default__tt__ItemList_ElementItem(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__ItemList_ElementItem(struct soap *soap, const struct _tt__ItemList_ElementItem *a, const char *tag, const char *type)
{
	if (soap_out__tt__ItemList_ElementItem(soap, tag ? tag : "tt:ItemList-ElementItem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemList_ElementItem * SOAP_FMAC4 soap_get__tt__ItemList_ElementItem(struct soap *soap, struct _tt__ItemList_ElementItem *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ItemList_ElementItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__ItemList_SimpleItem(struct soap *soap, struct _tt__ItemList_SimpleItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
	soap_default_xsd__anySimpleType(soap, &a->Value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__ItemList_SimpleItem(struct soap *soap, const struct _tt__ItemList_SimpleItem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ItemList_SimpleItem(struct soap *soap, const char *tag, int id, const struct _tt__ItemList_SimpleItem *a, const char *type)
{
	if (a->Name)
		soap_set_attr(soap, "Name", soap_string2s(soap, a->Name), 1);
	if (a->Value)
		soap_set_attr(soap, "Value", soap_xsd__anySimpleType2s(soap, a->Value), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ItemList_SimpleItem), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__ItemList_SimpleItem * SOAP_FMAC4 soap_in__tt__ItemList_SimpleItem(struct soap *soap, const char *tag, struct _tt__ItemList_SimpleItem *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tt__ItemList_SimpleItem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ItemList_SimpleItem, sizeof(struct _tt__ItemList_SimpleItem), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__ItemList_SimpleItem(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1), &a->Name))
		return NULL;
	if (soap_s2xsd__anySimpleType(soap, soap_attr_value(soap, "Value", 1), &a->Value))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemList_SimpleItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ItemList_SimpleItem, SOAP_TYPE__tt__ItemList_SimpleItem, sizeof(struct _tt__ItemList_SimpleItem), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tt__ItemList_SimpleItem * SOAP_FMAC4 soap_new__tt__ItemList_SimpleItem(struct soap *soap, int n)
{
	struct _tt__ItemList_SimpleItem *p;
	struct _tt__ItemList_SimpleItem *a = (struct _tt__ItemList_SimpleItem*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tt__ItemList_SimpleItem));
	for (p = a; p && n--; p++)
		soap_default__tt__ItemList_SimpleItem(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__ItemList_SimpleItem(struct soap *soap, const struct _tt__ItemList_SimpleItem *a, const char *tag, const char *type)
{
	if (soap_out__tt__ItemList_SimpleItem(soap, tag ? tag : "tt:ItemList-SimpleItem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemList_SimpleItem * SOAP_FMAC4 soap_get__tt__ItemList_SimpleItem(struct soap *soap, struct _tt__ItemList_SimpleItem *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ItemList_SimpleItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MessageExtension(struct soap *soap, struct tt__MessageExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MessageExtension(struct soap *soap, const struct tt__MessageExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MessageExtension(struct soap *soap, const char *tag, int id, const struct tt__MessageExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MessageExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MessageExtension * SOAP_FMAC4 soap_in_tt__MessageExtension(struct soap *soap, const char *tag, struct tt__MessageExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MessageExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MessageExtension, sizeof(struct tt__MessageExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MessageExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MessageExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MessageExtension, SOAP_TYPE_tt__MessageExtension, sizeof(struct tt__MessageExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MessageExtension * SOAP_FMAC4 soap_new_tt__MessageExtension(struct soap *soap, int n)
{
	struct tt__MessageExtension *p;
	struct tt__MessageExtension *a = (struct tt__MessageExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MessageExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__MessageExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MessageExtension(struct soap *soap, const struct tt__MessageExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__MessageExtension(soap, tag ? tag : "tt:MessageExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MessageExtension * SOAP_FMAC4 soap_get_tt__MessageExtension(struct soap *soap, struct tt__MessageExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MessageExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FocusOptions20Extension(struct soap *soap, struct tt__FocusOptions20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FocusOptions20Extension(struct soap *soap, const struct tt__FocusOptions20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusOptions20Extension(struct soap *soap, const char *tag, int id, const struct tt__FocusOptions20Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusOptions20Extension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FocusOptions20Extension * SOAP_FMAC4 soap_in_tt__FocusOptions20Extension(struct soap *soap, const char *tag, struct tt__FocusOptions20Extension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FocusOptions20Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusOptions20Extension, sizeof(struct tt__FocusOptions20Extension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FocusOptions20Extension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__FocusOptions20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusOptions20Extension, SOAP_TYPE_tt__FocusOptions20Extension, sizeof(struct tt__FocusOptions20Extension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FocusOptions20Extension * SOAP_FMAC4 soap_new_tt__FocusOptions20Extension(struct soap *soap, int n)
{
	struct tt__FocusOptions20Extension *p;
	struct tt__FocusOptions20Extension *a = (struct tt__FocusOptions20Extension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FocusOptions20Extension));
	for (p = a; p && n--; p++)
		soap_default_tt__FocusOptions20Extension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FocusOptions20Extension(struct soap *soap, const struct tt__FocusOptions20Extension *a, const char *tag, const char *type)
{
	if (soap_out_tt__FocusOptions20Extension(soap, tag ? tag : "tt:FocusOptions20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusOptions20Extension * SOAP_FMAC4 soap_get_tt__FocusOptions20Extension(struct soap *soap, struct tt__FocusOptions20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__WhiteBalanceOptions20Extension(struct soap *soap, struct tt__WhiteBalanceOptions20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__WhiteBalanceOptions20Extension(struct soap *soap, const struct tt__WhiteBalanceOptions20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalanceOptions20Extension(struct soap *soap, const char *tag, int id, const struct tt__WhiteBalanceOptions20Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalanceOptions20Extension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions20Extension * SOAP_FMAC4 soap_in_tt__WhiteBalanceOptions20Extension(struct soap *soap, const char *tag, struct tt__WhiteBalanceOptions20Extension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__WhiteBalanceOptions20Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, sizeof(struct tt__WhiteBalanceOptions20Extension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__WhiteBalanceOptions20Extension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__WhiteBalanceOptions20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, sizeof(struct tt__WhiteBalanceOptions20Extension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions20Extension * SOAP_FMAC4 soap_new_tt__WhiteBalanceOptions20Extension(struct soap *soap, int n)
{
	struct tt__WhiteBalanceOptions20Extension *p;
	struct tt__WhiteBalanceOptions20Extension *a = (struct tt__WhiteBalanceOptions20Extension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__WhiteBalanceOptions20Extension));
	for (p = a; p && n--; p++)
		soap_default_tt__WhiteBalanceOptions20Extension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WhiteBalanceOptions20Extension(struct soap *soap, const struct tt__WhiteBalanceOptions20Extension *a, const char *tag, const char *type)
{
	if (soap_out_tt__WhiteBalanceOptions20Extension(soap, tag ? tag : "tt:WhiteBalanceOptions20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions20Extension * SOAP_FMAC4 soap_get_tt__WhiteBalanceOptions20Extension(struct soap *soap, struct tt__WhiteBalanceOptions20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalanceOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FocusConfiguration20Extension(struct soap *soap, struct tt__FocusConfiguration20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FocusConfiguration20Extension(struct soap *soap, const struct tt__FocusConfiguration20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusConfiguration20Extension(struct soap *soap, const char *tag, int id, const struct tt__FocusConfiguration20Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusConfiguration20Extension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FocusConfiguration20Extension * SOAP_FMAC4 soap_in_tt__FocusConfiguration20Extension(struct soap *soap, const char *tag, struct tt__FocusConfiguration20Extension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FocusConfiguration20Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusConfiguration20Extension, sizeof(struct tt__FocusConfiguration20Extension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FocusConfiguration20Extension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__FocusConfiguration20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusConfiguration20Extension, SOAP_TYPE_tt__FocusConfiguration20Extension, sizeof(struct tt__FocusConfiguration20Extension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FocusConfiguration20Extension * SOAP_FMAC4 soap_new_tt__FocusConfiguration20Extension(struct soap *soap, int n)
{
	struct tt__FocusConfiguration20Extension *p;
	struct tt__FocusConfiguration20Extension *a = (struct tt__FocusConfiguration20Extension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FocusConfiguration20Extension));
	for (p = a; p && n--; p++)
		soap_default_tt__FocusConfiguration20Extension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FocusConfiguration20Extension(struct soap *soap, const struct tt__FocusConfiguration20Extension *a, const char *tag, const char *type)
{
	if (soap_out_tt__FocusConfiguration20Extension(soap, tag ? tag : "tt:FocusConfiguration20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusConfiguration20Extension * SOAP_FMAC4 soap_get_tt__FocusConfiguration20Extension(struct soap *soap, struct tt__FocusConfiguration20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusConfiguration20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__WhiteBalance20Extension(struct soap *soap, struct tt__WhiteBalance20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__WhiteBalance20Extension(struct soap *soap, const struct tt__WhiteBalance20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalance20Extension(struct soap *soap, const char *tag, int id, const struct tt__WhiteBalance20Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalance20Extension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__WhiteBalance20Extension * SOAP_FMAC4 soap_in_tt__WhiteBalance20Extension(struct soap *soap, const char *tag, struct tt__WhiteBalance20Extension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__WhiteBalance20Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalance20Extension, sizeof(struct tt__WhiteBalance20Extension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__WhiteBalance20Extension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__WhiteBalance20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalance20Extension, SOAP_TYPE_tt__WhiteBalance20Extension, sizeof(struct tt__WhiteBalance20Extension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__WhiteBalance20Extension * SOAP_FMAC4 soap_new_tt__WhiteBalance20Extension(struct soap *soap, int n)
{
	struct tt__WhiteBalance20Extension *p;
	struct tt__WhiteBalance20Extension *a = (struct tt__WhiteBalance20Extension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__WhiteBalance20Extension));
	for (p = a; p && n--; p++)
		soap_default_tt__WhiteBalance20Extension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WhiteBalance20Extension(struct soap *soap, const struct tt__WhiteBalance20Extension *a, const char *tag, const char *type)
{
	if (soap_out_tt__WhiteBalance20Extension(soap, tag ? tag : "tt:WhiteBalance20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalance20Extension * SOAP_FMAC4 soap_get_tt__WhiteBalance20Extension(struct soap *soap, struct tt__WhiteBalance20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalance20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RelativeFocusOptions20(struct soap *soap, struct tt__RelativeFocusOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Distance = NULL;
	a->Speed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RelativeFocusOptions20(struct soap *soap, const struct tt__RelativeFocusOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__FloatRange(soap, &a->Distance);
	soap_serialize_PointerTott__FloatRange(soap, &a->Speed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelativeFocusOptions20(struct soap *soap, const char *tag, int id, const struct tt__RelativeFocusOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelativeFocusOptions20), type))
		return soap->error;
	if (!a->Distance)
	{	if (soap_element_nil(soap, "tt:Distance"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__FloatRange(soap, "tt:Distance", -1, &a->Distance, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Speed", -1, &a->Speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RelativeFocusOptions20 * SOAP_FMAC4 soap_in_tt__RelativeFocusOptions20(struct soap *soap, const char *tag, struct tt__RelativeFocusOptions20 *a, const char *type)
{
	size_t soap_flag_Distance = 1;
	size_t soap_flag_Speed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RelativeFocusOptions20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelativeFocusOptions20, sizeof(struct tt__RelativeFocusOptions20), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RelativeFocusOptions20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Distance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Distance", &a->Distance, "tt:FloatRange"))
				{	soap_flag_Distance--;
					continue;
				}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Speed", &a->Speed, "tt:FloatRange"))
				{	soap_flag_Speed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Distance > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__RelativeFocusOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelativeFocusOptions20, SOAP_TYPE_tt__RelativeFocusOptions20, sizeof(struct tt__RelativeFocusOptions20), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RelativeFocusOptions20 * SOAP_FMAC4 soap_new_tt__RelativeFocusOptions20(struct soap *soap, int n)
{
	struct tt__RelativeFocusOptions20 *p;
	struct tt__RelativeFocusOptions20 *a = (struct tt__RelativeFocusOptions20*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RelativeFocusOptions20));
	for (p = a; p && n--; p++)
		soap_default_tt__RelativeFocusOptions20(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RelativeFocusOptions20(struct soap *soap, const struct tt__RelativeFocusOptions20 *a, const char *tag, const char *type)
{
	if (soap_out_tt__RelativeFocusOptions20(soap, tag ? tag : "tt:RelativeFocusOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RelativeFocusOptions20 * SOAP_FMAC4 soap_get_tt__RelativeFocusOptions20(struct soap *soap, struct tt__RelativeFocusOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelativeFocusOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MoveOptions20(struct soap *soap, struct tt__MoveOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Absolute = NULL;
	a->Relative = NULL;
	a->Continuous = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MoveOptions20(struct soap *soap, const struct tt__MoveOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AbsoluteFocusOptions(soap, &a->Absolute);
	soap_serialize_PointerTott__RelativeFocusOptions20(soap, &a->Relative);
	soap_serialize_PointerTott__ContinuousFocusOptions(soap, &a->Continuous);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MoveOptions20(struct soap *soap, const char *tag, int id, const struct tt__MoveOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MoveOptions20), type))
		return soap->error;
	if (soap_out_PointerTott__AbsoluteFocusOptions(soap, "tt:Absolute", -1, &a->Absolute, ""))
		return soap->error;
	if (soap_out_PointerTott__RelativeFocusOptions20(soap, "tt:Relative", -1, &a->Relative, ""))
		return soap->error;
	if (soap_out_PointerTott__ContinuousFocusOptions(soap, "tt:Continuous", -1, &a->Continuous, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MoveOptions20 * SOAP_FMAC4 soap_in_tt__MoveOptions20(struct soap *soap, const char *tag, struct tt__MoveOptions20 *a, const char *type)
{
	size_t soap_flag_Absolute = 1;
	size_t soap_flag_Relative = 1;
	size_t soap_flag_Continuous = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MoveOptions20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MoveOptions20, sizeof(struct tt__MoveOptions20), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MoveOptions20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Absolute && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AbsoluteFocusOptions(soap, "tt:Absolute", &a->Absolute, "tt:AbsoluteFocusOptions"))
				{	soap_flag_Absolute--;
					continue;
				}
			if (soap_flag_Relative && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RelativeFocusOptions20(soap, "tt:Relative", &a->Relative, "tt:RelativeFocusOptions20"))
				{	soap_flag_Relative--;
					continue;
				}
			if (soap_flag_Continuous && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ContinuousFocusOptions(soap, "tt:Continuous", &a->Continuous, "tt:ContinuousFocusOptions"))
				{	soap_flag_Continuous--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MoveOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MoveOptions20, SOAP_TYPE_tt__MoveOptions20, sizeof(struct tt__MoveOptions20), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MoveOptions20 * SOAP_FMAC4 soap_new_tt__MoveOptions20(struct soap *soap, int n)
{
	struct tt__MoveOptions20 *p;
	struct tt__MoveOptions20 *a = (struct tt__MoveOptions20*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MoveOptions20));
	for (p = a; p && n--; p++)
		soap_default_tt__MoveOptions20(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MoveOptions20(struct soap *soap, const struct tt__MoveOptions20 *a, const char *tag, const char *type)
{
	if (soap_out_tt__MoveOptions20(soap, tag ? tag : "tt:MoveOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MoveOptions20 * SOAP_FMAC4 soap_get_tt__MoveOptions20(struct soap *soap, struct tt__MoveOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MoveOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, struct tt__IrCutFilterAutoAdjustmentOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, const struct tt__IrCutFilterAutoAdjustmentOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__IrCutFilterAutoAdjustmentOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IrCutFilterAutoAdjustmentOptionsExtension * SOAP_FMAC4 soap_in_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, const char *tag, struct tt__IrCutFilterAutoAdjustmentOptionsExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IrCutFilterAutoAdjustmentOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension, sizeof(struct tt__IrCutFilterAutoAdjustmentOptionsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__IrCutFilterAutoAdjustmentOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension, sizeof(struct tt__IrCutFilterAutoAdjustmentOptionsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__IrCutFilterAutoAdjustmentOptionsExtension * SOAP_FMAC4 soap_new_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, int n)
{
	struct tt__IrCutFilterAutoAdjustmentOptionsExtension *p;
	struct tt__IrCutFilterAutoAdjustmentOptionsExtension *a = (struct tt__IrCutFilterAutoAdjustmentOptionsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__IrCutFilterAutoAdjustmentOptionsExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, const struct tt__IrCutFilterAutoAdjustmentOptionsExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, tag ? tag : "tt:IrCutFilterAutoAdjustmentOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IrCutFilterAutoAdjustmentOptionsExtension * SOAP_FMAC4 soap_get_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, struct tt__IrCutFilterAutoAdjustmentOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImageStabilizationOptionsExtension(struct soap *soap, struct tt__ImageStabilizationOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImageStabilizationOptionsExtension(struct soap *soap, const struct tt__ImageStabilizationOptionsExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImageStabilizationOptionsExtension(struct soap *soap, const char *tag, int id, const struct tt__ImageStabilizationOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImageStabilizationOptionsExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImageStabilizationOptionsExtension * SOAP_FMAC4 soap_in_tt__ImageStabilizationOptionsExtension(struct soap *soap, const char *tag, struct tt__ImageStabilizationOptionsExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ImageStabilizationOptionsExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImageStabilizationOptionsExtension, sizeof(struct tt__ImageStabilizationOptionsExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImageStabilizationOptionsExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ImageStabilizationOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImageStabilizationOptionsExtension, SOAP_TYPE_tt__ImageStabilizationOptionsExtension, sizeof(struct tt__ImageStabilizationOptionsExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ImageStabilizationOptionsExtension * SOAP_FMAC4 soap_new_tt__ImageStabilizationOptionsExtension(struct soap *soap, int n)
{
	struct tt__ImageStabilizationOptionsExtension *p;
	struct tt__ImageStabilizationOptionsExtension *a = (struct tt__ImageStabilizationOptionsExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ImageStabilizationOptionsExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ImageStabilizationOptionsExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImageStabilizationOptionsExtension(struct soap *soap, const struct tt__ImageStabilizationOptionsExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ImageStabilizationOptionsExtension(soap, tag ? tag : "tt:ImageStabilizationOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImageStabilizationOptionsExtension * SOAP_FMAC4 soap_get_tt__ImageStabilizationOptionsExtension(struct soap *soap, struct tt__ImageStabilizationOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImageStabilizationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingOptions20Extension4(struct soap *soap, struct tt__ImagingOptions20Extension4 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingOptions20Extension4(struct soap *soap, const struct tt__ImagingOptions20Extension4 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions20Extension4(struct soap *soap, const char *tag, int id, const struct tt__ImagingOptions20Extension4 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingOptions20Extension4), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension4 * SOAP_FMAC4 soap_in_tt__ImagingOptions20Extension4(struct soap *soap, const char *tag, struct tt__ImagingOptions20Extension4 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ImagingOptions20Extension4 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions20Extension4, sizeof(struct tt__ImagingOptions20Extension4), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImagingOptions20Extension4(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingOptions20Extension4 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions20Extension4, SOAP_TYPE_tt__ImagingOptions20Extension4, sizeof(struct tt__ImagingOptions20Extension4), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension4 * SOAP_FMAC4 soap_new_tt__ImagingOptions20Extension4(struct soap *soap, int n)
{
	struct tt__ImagingOptions20Extension4 *p;
	struct tt__ImagingOptions20Extension4 *a = (struct tt__ImagingOptions20Extension4*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ImagingOptions20Extension4));
	for (p = a; p && n--; p++)
		soap_default_tt__ImagingOptions20Extension4(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingOptions20Extension4(struct soap *soap, const struct tt__ImagingOptions20Extension4 *a, const char *tag, const char *type)
{
	if (soap_out_tt__ImagingOptions20Extension4(soap, tag ? tag : "tt:ImagingOptions20Extension4", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension4 * SOAP_FMAC4 soap_get_tt__ImagingOptions20Extension4(struct soap *soap, struct tt__ImagingOptions20Extension4 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingOptions20Extension4(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NoiseReductionOptions(struct soap *soap, struct tt__NoiseReductionOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->Level);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NoiseReductionOptions(struct soap *soap, const struct tt__NoiseReductionOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Level, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NoiseReductionOptions(struct soap *soap, const char *tag, int id, const struct tt__NoiseReductionOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NoiseReductionOptions), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:Level", -1, &a->Level, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NoiseReductionOptions * SOAP_FMAC4 soap_in_tt__NoiseReductionOptions(struct soap *soap, const char *tag, struct tt__NoiseReductionOptions *a, const char *type)
{
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NoiseReductionOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NoiseReductionOptions, sizeof(struct tt__NoiseReductionOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NoiseReductionOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:Level", &a->Level, "xsd:boolean"))
				{	soap_flag_Level--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Level > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__NoiseReductionOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NoiseReductionOptions, SOAP_TYPE_tt__NoiseReductionOptions, sizeof(struct tt__NoiseReductionOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__NoiseReductionOptions * SOAP_FMAC4 soap_new_tt__NoiseReductionOptions(struct soap *soap, int n)
{
	struct tt__NoiseReductionOptions *p;
	struct tt__NoiseReductionOptions *a = (struct tt__NoiseReductionOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__NoiseReductionOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__NoiseReductionOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NoiseReductionOptions(struct soap *soap, const struct tt__NoiseReductionOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__NoiseReductionOptions(soap, tag ? tag : "tt:NoiseReductionOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NoiseReductionOptions * SOAP_FMAC4 soap_get_tt__NoiseReductionOptions(struct soap *soap, struct tt__NoiseReductionOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NoiseReductionOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DefoggingOptions(struct soap *soap, struct tt__DefoggingOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	soap_default_xsd__boolean(soap, &a->Level);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DefoggingOptions(struct soap *soap, const struct tt__DefoggingOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->Mode + i));
		}
	}
	soap_embedded(soap, &a->Level, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DefoggingOptions(struct soap *soap, const char *tag, int id, const struct tt__DefoggingOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DefoggingOptions), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
			soap_out_string(soap, "tt:Mode", -1, (char*const*)(a->Mode + i), "");
	}
	if (soap_out_xsd__boolean(soap, "tt:Level", -1, &a->Level, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DefoggingOptions * SOAP_FMAC4 soap_in_tt__DefoggingOptions(struct soap *soap, const char *tag, struct tt__DefoggingOptions *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DefoggingOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DefoggingOptions, sizeof(struct tt__DefoggingOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DefoggingOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_alloc_block(soap);
					a->Mode = (char **)soap_push_block_max(soap, soap_blist_Mode, sizeof(char *));
					if (a->Mode == NULL)
						return NULL;
					*a->Mode = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "tt:Mode", (char**)a->Mode, "xsd:string"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:Level", &a->Level, "xsd:boolean"))
				{	soap_flag_Level--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
		{	a->Mode = (char **)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		}
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1 || soap_flag_Level > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__DefoggingOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DefoggingOptions, SOAP_TYPE_tt__DefoggingOptions, sizeof(struct tt__DefoggingOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__DefoggingOptions * SOAP_FMAC4 soap_new_tt__DefoggingOptions(struct soap *soap, int n)
{
	struct tt__DefoggingOptions *p;
	struct tt__DefoggingOptions *a = (struct tt__DefoggingOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__DefoggingOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__DefoggingOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DefoggingOptions(struct soap *soap, const struct tt__DefoggingOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__DefoggingOptions(soap, tag ? tag : "tt:DefoggingOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DefoggingOptions * SOAP_FMAC4 soap_get_tt__DefoggingOptions(struct soap *soap, struct tt__DefoggingOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DefoggingOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ToneCompensationOptions(struct soap *soap, struct tt__ToneCompensationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	soap_default_xsd__boolean(soap, &a->Level);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ToneCompensationOptions(struct soap *soap, const struct tt__ToneCompensationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->Mode + i));
		}
	}
	soap_embedded(soap, &a->Level, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ToneCompensationOptions(struct soap *soap, const char *tag, int id, const struct tt__ToneCompensationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ToneCompensationOptions), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
			soap_out_string(soap, "tt:Mode", -1, (char*const*)(a->Mode + i), "");
	}
	if (soap_out_xsd__boolean(soap, "tt:Level", -1, &a->Level, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ToneCompensationOptions * SOAP_FMAC4 soap_in_tt__ToneCompensationOptions(struct soap *soap, const char *tag, struct tt__ToneCompensationOptions *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ToneCompensationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ToneCompensationOptions, sizeof(struct tt__ToneCompensationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ToneCompensationOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_alloc_block(soap);
					a->Mode = (char **)soap_push_block_max(soap, soap_blist_Mode, sizeof(char *));
					if (a->Mode == NULL)
						return NULL;
					*a->Mode = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "tt:Mode", (char**)a->Mode, "xsd:string"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:Level", &a->Level, "xsd:boolean"))
				{	soap_flag_Level--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
		{	a->Mode = (char **)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		}
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1 || soap_flag_Level > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ToneCompensationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ToneCompensationOptions, SOAP_TYPE_tt__ToneCompensationOptions, sizeof(struct tt__ToneCompensationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ToneCompensationOptions * SOAP_FMAC4 soap_new_tt__ToneCompensationOptions(struct soap *soap, int n)
{
	struct tt__ToneCompensationOptions *p;
	struct tt__ToneCompensationOptions *a = (struct tt__ToneCompensationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ToneCompensationOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__ToneCompensationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ToneCompensationOptions(struct soap *soap, const struct tt__ToneCompensationOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__ToneCompensationOptions(soap, tag ? tag : "tt:ToneCompensationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ToneCompensationOptions * SOAP_FMAC4 soap_get_tt__ToneCompensationOptions(struct soap *soap, struct tt__ToneCompensationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ToneCompensationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingOptions20Extension3(struct soap *soap, struct tt__ImagingOptions20Extension3 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ToneCompensationOptions = NULL;
	a->DefoggingOptions = NULL;
	a->NoiseReductionOptions = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingOptions20Extension3(struct soap *soap, const struct tt__ImagingOptions20Extension3 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ToneCompensationOptions(soap, &a->ToneCompensationOptions);
	soap_serialize_PointerTott__DefoggingOptions(soap, &a->DefoggingOptions);
	soap_serialize_PointerTott__NoiseReductionOptions(soap, &a->NoiseReductionOptions);
	soap_serialize_PointerTott__ImagingOptions20Extension4(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions20Extension3(struct soap *soap, const char *tag, int id, const struct tt__ImagingOptions20Extension3 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingOptions20Extension3), type))
		return soap->error;
	if (soap_out_PointerTott__ToneCompensationOptions(soap, "tt:ToneCompensationOptions", -1, &a->ToneCompensationOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__DefoggingOptions(soap, "tt:DefoggingOptions", -1, &a->DefoggingOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__NoiseReductionOptions(soap, "tt:NoiseReductionOptions", -1, &a->NoiseReductionOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingOptions20Extension4(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension3 * SOAP_FMAC4 soap_in_tt__ImagingOptions20Extension3(struct soap *soap, const char *tag, struct tt__ImagingOptions20Extension3 *a, const char *type)
{
	size_t soap_flag_ToneCompensationOptions = 1;
	size_t soap_flag_DefoggingOptions = 1;
	size_t soap_flag_NoiseReductionOptions = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ImagingOptions20Extension3 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions20Extension3, sizeof(struct tt__ImagingOptions20Extension3), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImagingOptions20Extension3(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ToneCompensationOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ToneCompensationOptions(soap, "tt:ToneCompensationOptions", &a->ToneCompensationOptions, "tt:ToneCompensationOptions"))
				{	soap_flag_ToneCompensationOptions--;
					continue;
				}
			if (soap_flag_DefoggingOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DefoggingOptions(soap, "tt:DefoggingOptions", &a->DefoggingOptions, "tt:DefoggingOptions"))
				{	soap_flag_DefoggingOptions--;
					continue;
				}
			if (soap_flag_NoiseReductionOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NoiseReductionOptions(soap, "tt:NoiseReductionOptions", &a->NoiseReductionOptions, "tt:NoiseReductionOptions"))
				{	soap_flag_NoiseReductionOptions--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ImagingOptions20Extension4(soap, "tt:Extension", &a->Extension, "tt:ImagingOptions20Extension4"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingOptions20Extension3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions20Extension3, SOAP_TYPE_tt__ImagingOptions20Extension3, sizeof(struct tt__ImagingOptions20Extension3), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension3 * SOAP_FMAC4 soap_new_tt__ImagingOptions20Extension3(struct soap *soap, int n)
{
	struct tt__ImagingOptions20Extension3 *p;
	struct tt__ImagingOptions20Extension3 *a = (struct tt__ImagingOptions20Extension3*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ImagingOptions20Extension3));
	for (p = a; p && n--; p++)
		soap_default_tt__ImagingOptions20Extension3(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingOptions20Extension3(struct soap *soap, const struct tt__ImagingOptions20Extension3 *a, const char *tag, const char *type)
{
	if (soap_out_tt__ImagingOptions20Extension3(soap, tag ? tag : "tt:ImagingOptions20Extension3", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension3 * SOAP_FMAC4 soap_get_tt__ImagingOptions20Extension3(struct soap *soap, struct tt__ImagingOptions20Extension3 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingOptions20Extension3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, struct tt__IrCutFilterAutoAdjustmentOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeBoundaryType = 0;
	a->BoundaryType = NULL;
	a->BoundaryOffset = NULL;
	a->ResponseTimeRange = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, const struct tt__IrCutFilterAutoAdjustmentOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->BoundaryType)
	{	int i;
		for (i = 0; i < (int)a->__sizeBoundaryType; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->BoundaryType + i));
		}
	}
	soap_serialize_PointerToxsd__boolean(soap, &a->BoundaryOffset);
	soap_serialize_PointerTott__DurationRange(soap, &a->ResponseTimeRange);
	soap_serialize_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, const char *tag, int id, const struct tt__IrCutFilterAutoAdjustmentOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions), type))
		return soap->error;
	if (a->BoundaryType)
	{	int i;
		for (i = 0; i < (int)a->__sizeBoundaryType; i++)
			soap_out_string(soap, "tt:BoundaryType", -1, (char*const*)(a->BoundaryType + i), "");
	}
	if (soap_out_PointerToxsd__boolean(soap, "tt:BoundaryOffset", -1, &a->BoundaryOffset, ""))
		return soap->error;
	if (soap_out_PointerTott__DurationRange(soap, "tt:ResponseTimeRange", -1, &a->ResponseTimeRange, ""))
		return soap->error;
	if (soap_out_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IrCutFilterAutoAdjustmentOptions * SOAP_FMAC4 soap_in_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, const char *tag, struct tt__IrCutFilterAutoAdjustmentOptions *a, const char *type)
{
	struct soap_blist *soap_blist_BoundaryType = NULL;
	size_t soap_flag_BoundaryOffset = 1;
	size_t soap_flag_ResponseTimeRange = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IrCutFilterAutoAdjustmentOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions, sizeof(struct tt__IrCutFilterAutoAdjustmentOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IrCutFilterAutoAdjustmentOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:BoundaryType", 1, NULL))
			{	if (a->BoundaryType == NULL)
				{	if (soap_blist_BoundaryType == NULL)
						soap_blist_BoundaryType = soap_alloc_block(soap);
					a->BoundaryType = (char **)soap_push_block_max(soap, soap_blist_BoundaryType, sizeof(char *));
					if (a->BoundaryType == NULL)
						return NULL;
					*a->BoundaryType = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "tt:BoundaryType", (char**)a->BoundaryType, "xsd:string"))
				{	a->__sizeBoundaryType++;
					a->BoundaryType = NULL;
					continue;
				}
			}
			if (soap_flag_BoundaryOffset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "tt:BoundaryOffset", &a->BoundaryOffset, "xsd:boolean"))
				{	soap_flag_BoundaryOffset--;
					continue;
				}
			if (soap_flag_ResponseTimeRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DurationRange(soap, "tt:ResponseTimeRange", &a->ResponseTimeRange, "tt:DurationRange"))
				{	soap_flag_ResponseTimeRange--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:IrCutFilterAutoAdjustmentOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->BoundaryType)
			soap_pop_block(soap, soap_blist_BoundaryType);
		if (a->__sizeBoundaryType)
		{	a->BoundaryType = (char **)soap_save_block(soap, soap_blist_BoundaryType, NULL, 1);
		}
		else
		{	a->BoundaryType = NULL;
			if (soap_blist_BoundaryType)
				soap_end_block(soap, soap_blist_BoundaryType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeBoundaryType < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__IrCutFilterAutoAdjustmentOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions, sizeof(struct tt__IrCutFilterAutoAdjustmentOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__IrCutFilterAutoAdjustmentOptions * SOAP_FMAC4 soap_new_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, int n)
{
	struct tt__IrCutFilterAutoAdjustmentOptions *p;
	struct tt__IrCutFilterAutoAdjustmentOptions *a = (struct tt__IrCutFilterAutoAdjustmentOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__IrCutFilterAutoAdjustmentOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__IrCutFilterAutoAdjustmentOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, const struct tt__IrCutFilterAutoAdjustmentOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__IrCutFilterAutoAdjustmentOptions(soap, tag ? tag : "tt:IrCutFilterAutoAdjustmentOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IrCutFilterAutoAdjustmentOptions * SOAP_FMAC4 soap_get_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, struct tt__IrCutFilterAutoAdjustmentOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IrCutFilterAutoAdjustmentOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingOptions20Extension2(struct soap *soap, struct tt__ImagingOptions20Extension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->IrCutFilterAutoAdjustment = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingOptions20Extension2(struct soap *soap, const struct tt__ImagingOptions20Extension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IrCutFilterAutoAdjustmentOptions(soap, &a->IrCutFilterAutoAdjustment);
	soap_serialize_PointerTott__ImagingOptions20Extension3(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions20Extension2(struct soap *soap, const char *tag, int id, const struct tt__ImagingOptions20Extension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingOptions20Extension2), type))
		return soap->error;
	if (soap_out_PointerTott__IrCutFilterAutoAdjustmentOptions(soap, "tt:IrCutFilterAutoAdjustment", -1, &a->IrCutFilterAutoAdjustment, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingOptions20Extension3(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension2 * SOAP_FMAC4 soap_in_tt__ImagingOptions20Extension2(struct soap *soap, const char *tag, struct tt__ImagingOptions20Extension2 *a, const char *type)
{
	size_t soap_flag_IrCutFilterAutoAdjustment = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ImagingOptions20Extension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions20Extension2, sizeof(struct tt__ImagingOptions20Extension2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImagingOptions20Extension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IrCutFilterAutoAdjustment && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IrCutFilterAutoAdjustmentOptions(soap, "tt:IrCutFilterAutoAdjustment", &a->IrCutFilterAutoAdjustment, "tt:IrCutFilterAutoAdjustmentOptions"))
				{	soap_flag_IrCutFilterAutoAdjustment--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ImagingOptions20Extension3(soap, "tt:Extension", &a->Extension, "tt:ImagingOptions20Extension3"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingOptions20Extension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions20Extension2, SOAP_TYPE_tt__ImagingOptions20Extension2, sizeof(struct tt__ImagingOptions20Extension2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension2 * SOAP_FMAC4 soap_new_tt__ImagingOptions20Extension2(struct soap *soap, int n)
{
	struct tt__ImagingOptions20Extension2 *p;
	struct tt__ImagingOptions20Extension2 *a = (struct tt__ImagingOptions20Extension2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ImagingOptions20Extension2));
	for (p = a; p && n--; p++)
		soap_default_tt__ImagingOptions20Extension2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingOptions20Extension2(struct soap *soap, const struct tt__ImagingOptions20Extension2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__ImagingOptions20Extension2(soap, tag ? tag : "tt:ImagingOptions20Extension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension2 * SOAP_FMAC4 soap_get_tt__ImagingOptions20Extension2(struct soap *soap, struct tt__ImagingOptions20Extension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingOptions20Extension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImageStabilizationOptions(struct soap *soap, struct tt__ImageStabilizationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->Level = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImageStabilizationOptions(struct soap *soap, const struct tt__ImageStabilizationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_tt__ImageStabilizationMode);
		}
	}
	soap_serialize_PointerTott__FloatRange(soap, &a->Level);
	soap_serialize_PointerTott__ImageStabilizationOptionsExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImageStabilizationOptions(struct soap *soap, const char *tag, int id, const struct tt__ImageStabilizationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImageStabilizationOptions), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
			if (soap_out_tt__ImageStabilizationMode(soap, "tt:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__FloatRange(soap, "tt:Level", -1, &a->Level, ""))
		return soap->error;
	if (soap_out_PointerTott__ImageStabilizationOptionsExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImageStabilizationOptions * SOAP_FMAC4 soap_in_tt__ImageStabilizationOptions(struct soap *soap, const char *tag, struct tt__ImageStabilizationOptions *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	size_t soap_flag_Level = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ImageStabilizationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImageStabilizationOptions, sizeof(struct tt__ImageStabilizationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImageStabilizationOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_alloc_block(soap);
					a->Mode = (enum tt__ImageStabilizationMode *)soap_push_block_max(soap, soap_blist_Mode, sizeof(enum tt__ImageStabilizationMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_tt__ImageStabilizationMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_tt__ImageStabilizationMode(soap, "tt:Mode", a->Mode, "tt:ImageStabilizationMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Level", &a->Level, "tt:FloatRange"))
				{	soap_flag_Level--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ImageStabilizationOptionsExtension(soap, "tt:Extension", &a->Extension, "tt:ImageStabilizationOptionsExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
		{	a->Mode = (enum tt__ImageStabilizationMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		}
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ImageStabilizationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImageStabilizationOptions, SOAP_TYPE_tt__ImageStabilizationOptions, sizeof(struct tt__ImageStabilizationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ImageStabilizationOptions * SOAP_FMAC4 soap_new_tt__ImageStabilizationOptions(struct soap *soap, int n)
{
	struct tt__ImageStabilizationOptions *p;
	struct tt__ImageStabilizationOptions *a = (struct tt__ImageStabilizationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ImageStabilizationOptions));
	for (p = a; p && n--; p++)
		soap_default_tt__ImageStabilizationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImageStabilizationOptions(struct soap *soap, const struct tt__ImageStabilizationOptions *a, const char *tag, const char *type)
{
	if (soap_out_tt__ImageStabilizationOptions(soap, tag ? tag : "tt:ImageStabilizationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImageStabilizationOptions * SOAP_FMAC4 soap_get_tt__ImageStabilizationOptions(struct soap *soap, struct tt__ImageStabilizationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImageStabilizationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingOptions20Extension(struct soap *soap, struct tt__ImagingOptions20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ImageStabilization = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingOptions20Extension(struct soap *soap, const struct tt__ImagingOptions20Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ImageStabilizationOptions(soap, &a->ImageStabilization);
	soap_serialize_PointerTott__ImagingOptions20Extension2(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions20Extension(struct soap *soap, const char *tag, int id, const struct tt__ImagingOptions20Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingOptions20Extension), type))
		return soap->error;
	if (soap_out_PointerTott__ImageStabilizationOptions(soap, "tt:ImageStabilization", -1, &a->ImageStabilization, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingOptions20Extension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension * SOAP_FMAC4 soap_in_tt__ImagingOptions20Extension(struct soap *soap, const char *tag, struct tt__ImagingOptions20Extension *a, const char *type)
{
	size_t soap_flag_ImageStabilization = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ImagingOptions20Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions20Extension, sizeof(struct tt__ImagingOptions20Extension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImagingOptions20Extension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ImageStabilization && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ImageStabilizationOptions(soap, "tt:ImageStabilization", &a->ImageStabilization, "tt:ImageStabilizationOptions"))
				{	soap_flag_ImageStabilization--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ImagingOptions20Extension2(soap, "tt:Extension", &a->Extension, "tt:ImagingOptions20Extension2"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingOptions20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions20Extension, SOAP_TYPE_tt__ImagingOptions20Extension, sizeof(struct tt__ImagingOptions20Extension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension * SOAP_FMAC4 soap_new_tt__ImagingOptions20Extension(struct soap *soap, int n)
{
	struct tt__ImagingOptions20Extension *p;
	struct tt__ImagingOptions20Extension *a = (struct tt__ImagingOptions20Extension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ImagingOptions20Extension));
	for (p = a; p && n--; p++)
		soap_default_tt__ImagingOptions20Extension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingOptions20Extension(struct soap *soap, const struct tt__ImagingOptions20Extension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ImagingOptions20Extension(soap, tag ? tag : "tt:ImagingOptions20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension * SOAP_FMAC4 soap_get_tt__ImagingOptions20Extension(struct soap *soap, struct tt__ImagingOptions20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__WhiteBalanceOptions20(struct soap *soap, struct tt__WhiteBalanceOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->YrGain = NULL;
	a->YbGain = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__WhiteBalanceOptions20(struct soap *soap, const struct tt__WhiteBalanceOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_tt__WhiteBalanceMode);
		}
	}
	soap_serialize_PointerTott__FloatRange(soap, &a->YrGain);
	soap_serialize_PointerTott__FloatRange(soap, &a->YbGain);
	soap_serialize_PointerTott__WhiteBalanceOptions20Extension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalanceOptions20(struct soap *soap, const char *tag, int id, const struct tt__WhiteBalanceOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalanceOptions20), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
			if (soap_out_tt__WhiteBalanceMode(soap, "tt:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__FloatRange(soap, "tt:YrGain", -1, &a->YrGain, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:YbGain", -1, &a->YbGain, ""))
		return soap->error;
	if (soap_out_PointerTott__WhiteBalanceOptions20Extension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions20 * SOAP_FMAC4 soap_in_tt__WhiteBalanceOptions20(struct soap *soap, const char *tag, struct tt__WhiteBalanceOptions20 *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	size_t soap_flag_YrGain = 1;
	size_t soap_flag_YbGain = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__WhiteBalanceOptions20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalanceOptions20, sizeof(struct tt__WhiteBalanceOptions20), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__WhiteBalanceOptions20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_alloc_block(soap);
					a->Mode = (enum tt__WhiteBalanceMode *)soap_push_block_max(soap, soap_blist_Mode, sizeof(enum tt__WhiteBalanceMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_tt__WhiteBalanceMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_tt__WhiteBalanceMode(soap, "tt:Mode", a->Mode, "tt:WhiteBalanceMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap_flag_YrGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:YrGain", &a->YrGain, "tt:FloatRange"))
				{	soap_flag_YrGain--;
					continue;
				}
			if (soap_flag_YbGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:YbGain", &a->YbGain, "tt:FloatRange"))
				{	soap_flag_YbGain--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__WhiteBalanceOptions20Extension(soap, "tt:Extension", &a->Extension, "tt:WhiteBalanceOptions20Extension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
		{	a->Mode = (enum tt__WhiteBalanceMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		}
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__WhiteBalanceOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalanceOptions20, SOAP_TYPE_tt__WhiteBalanceOptions20, sizeof(struct tt__WhiteBalanceOptions20), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions20 * SOAP_FMAC4 soap_new_tt__WhiteBalanceOptions20(struct soap *soap, int n)
{
	struct tt__WhiteBalanceOptions20 *p;
	struct tt__WhiteBalanceOptions20 *a = (struct tt__WhiteBalanceOptions20*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__WhiteBalanceOptions20));
	for (p = a; p && n--; p++)
		soap_default_tt__WhiteBalanceOptions20(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WhiteBalanceOptions20(struct soap *soap, const struct tt__WhiteBalanceOptions20 *a, const char *tag, const char *type)
{
	if (soap_out_tt__WhiteBalanceOptions20(soap, tag ? tag : "tt:WhiteBalanceOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions20 * SOAP_FMAC4 soap_get_tt__WhiteBalanceOptions20(struct soap *soap, struct tt__WhiteBalanceOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalanceOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__WideDynamicRangeOptions20(struct soap *soap, struct tt__WideDynamicRangeOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->Level = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__WideDynamicRangeOptions20(struct soap *soap, const struct tt__WideDynamicRangeOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_tt__WideDynamicMode);
		}
	}
	soap_serialize_PointerTott__FloatRange(soap, &a->Level);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WideDynamicRangeOptions20(struct soap *soap, const char *tag, int id, const struct tt__WideDynamicRangeOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WideDynamicRangeOptions20), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
			if (soap_out_tt__WideDynamicMode(soap, "tt:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__FloatRange(soap, "tt:Level", -1, &a->Level, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__WideDynamicRangeOptions20 * SOAP_FMAC4 soap_in_tt__WideDynamicRangeOptions20(struct soap *soap, const char *tag, struct tt__WideDynamicRangeOptions20 *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__WideDynamicRangeOptions20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WideDynamicRangeOptions20, sizeof(struct tt__WideDynamicRangeOptions20), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__WideDynamicRangeOptions20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_alloc_block(soap);
					a->Mode = (enum tt__WideDynamicMode *)soap_push_block_max(soap, soap_blist_Mode, sizeof(enum tt__WideDynamicMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_tt__WideDynamicMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_tt__WideDynamicMode(soap, "tt:Mode", a->Mode, "tt:WideDynamicMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Level", &a->Level, "tt:FloatRange"))
				{	soap_flag_Level--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
		{	a->Mode = (enum tt__WideDynamicMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		}
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__WideDynamicRangeOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WideDynamicRangeOptions20, SOAP_TYPE_tt__WideDynamicRangeOptions20, sizeof(struct tt__WideDynamicRangeOptions20), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__WideDynamicRangeOptions20 * SOAP_FMAC4 soap_new_tt__WideDynamicRangeOptions20(struct soap *soap, int n)
{
	struct tt__WideDynamicRangeOptions20 *p;
	struct tt__WideDynamicRangeOptions20 *a = (struct tt__WideDynamicRangeOptions20*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__WideDynamicRangeOptions20));
	for (p = a; p && n--; p++)
		soap_default_tt__WideDynamicRangeOptions20(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__WideDynamicRangeOptions20(struct soap *soap, const struct tt__WideDynamicRangeOptions20 *a, const char *tag, const char *type)
{
	if (soap_out_tt__WideDynamicRangeOptions20(soap, tag ? tag : "tt:WideDynamicRangeOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WideDynamicRangeOptions20 * SOAP_FMAC4 soap_get_tt__WideDynamicRangeOptions20(struct soap *soap, struct tt__WideDynamicRangeOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WideDynamicRangeOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FocusOptions20(struct soap *soap, struct tt__FocusOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAutoFocusModes = 0;
	a->AutoFocusModes = NULL;
	a->DefaultSpeed = NULL;
	a->NearLimit = NULL;
	a->FarLimit = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FocusOptions20(struct soap *soap, const struct tt__FocusOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->AutoFocusModes)
	{	int i;
		for (i = 0; i < (int)a->__sizeAutoFocusModes; i++)
		{
			soap_embedded(soap, a->AutoFocusModes + i, SOAP_TYPE_tt__AutoFocusMode);
		}
	}
	soap_serialize_PointerTott__FloatRange(soap, &a->DefaultSpeed);
	soap_serialize_PointerTott__FloatRange(soap, &a->NearLimit);
	soap_serialize_PointerTott__FloatRange(soap, &a->FarLimit);
	soap_serialize_PointerTott__FocusOptions20Extension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusOptions20(struct soap *soap, const char *tag, int id, const struct tt__FocusOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusOptions20), type))
		return soap->error;
	if (a->AutoFocusModes)
	{	int i;
		for (i = 0; i < (int)a->__sizeAutoFocusModes; i++)
			if (soap_out_tt__AutoFocusMode(soap, "tt:AutoFocusModes", -1, a->AutoFocusModes + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__FloatRange(soap, "tt:DefaultSpeed", -1, &a->DefaultSpeed, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:NearLimit", -1, &a->NearLimit, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:FarLimit", -1, &a->FarLimit, ""))
		return soap->error;
	if (soap_out_PointerTott__FocusOptions20Extension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FocusOptions20 * SOAP_FMAC4 soap_in_tt__FocusOptions20(struct soap *soap, const char *tag, struct tt__FocusOptions20 *a, const char *type)
{
	struct soap_blist *soap_blist_AutoFocusModes = NULL;
	size_t soap_flag_DefaultSpeed = 1;
	size_t soap_flag_NearLimit = 1;
	size_t soap_flag_FarLimit = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FocusOptions20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusOptions20, sizeof(struct tt__FocusOptions20), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FocusOptions20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AutoFocusModes", 1, NULL))
			{	if (a->AutoFocusModes == NULL)
				{	if (soap_blist_AutoFocusModes == NULL)
						soap_blist_AutoFocusModes = soap_alloc_block(soap);
					a->AutoFocusModes = (enum tt__AutoFocusMode *)soap_push_block_max(soap, soap_blist_AutoFocusModes, sizeof(enum tt__AutoFocusMode));
					if (a->AutoFocusModes == NULL)
						return NULL;
					soap_default_tt__AutoFocusMode(soap, a->AutoFocusModes);
				}
				soap_revert(soap);
				if (soap_in_tt__AutoFocusMode(soap, "tt:AutoFocusModes", a->AutoFocusModes, "tt:AutoFocusMode"))
				{	a->__sizeAutoFocusModes++;
					a->AutoFocusModes = NULL;
					continue;
				}
			}
			if (soap_flag_DefaultSpeed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:DefaultSpeed", &a->DefaultSpeed, "tt:FloatRange"))
				{	soap_flag_DefaultSpeed--;
					continue;
				}
			if (soap_flag_NearLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:NearLimit", &a->NearLimit, "tt:FloatRange"))
				{	soap_flag_NearLimit--;
					continue;
				}
			if (soap_flag_FarLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:FarLimit", &a->FarLimit, "tt:FloatRange"))
				{	soap_flag_FarLimit--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FocusOptions20Extension(soap, "tt:Extension", &a->Extension, "tt:FocusOptions20Extension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AutoFocusModes)
			soap_pop_block(soap, soap_blist_AutoFocusModes);
		if (a->__sizeAutoFocusModes)
		{	a->AutoFocusModes = (enum tt__AutoFocusMode *)soap_save_block(soap, soap_blist_AutoFocusModes, NULL, 1);
		}
		else
		{	a->AutoFocusModes = NULL;
			if (soap_blist_AutoFocusModes)
				soap_end_block(soap, soap_blist_AutoFocusModes);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__FocusOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusOptions20, SOAP_TYPE_tt__FocusOptions20, sizeof(struct tt__FocusOptions20), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FocusOptions20 * SOAP_FMAC4 soap_new_tt__FocusOptions20(struct soap *soap, int n)
{
	struct tt__FocusOptions20 *p;
	struct tt__FocusOptions20 *a = (struct tt__FocusOptions20*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FocusOptions20));
	for (p = a; p && n--; p++)
		soap_default_tt__FocusOptions20(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FocusOptions20(struct soap *soap, const struct tt__FocusOptions20 *a, const char *tag, const char *type)
{
	if (soap_out_tt__FocusOptions20(soap, tag ? tag : "tt:FocusOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusOptions20 * SOAP_FMAC4 soap_get_tt__FocusOptions20(struct soap *soap, struct tt__FocusOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ExposureOptions20(struct soap *soap, struct tt__ExposureOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->__sizePriority = 0;
	a->Priority = NULL;
	a->MinExposureTime = NULL;
	a->MaxExposureTime = NULL;
	a->MinGain = NULL;
	a->MaxGain = NULL;
	a->MinIris = NULL;
	a->MaxIris = NULL;
	a->ExposureTime = NULL;
	a->Gain = NULL;
	a->Iris = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ExposureOptions20(struct soap *soap, const struct tt__ExposureOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_tt__ExposureMode);
		}
	}
	if (a->Priority)
	{	int i;
		for (i = 0; i < (int)a->__sizePriority; i++)
		{
			soap_embedded(soap, a->Priority + i, SOAP_TYPE_tt__ExposurePriority);
		}
	}
	soap_serialize_PointerTott__FloatRange(soap, &a->MinExposureTime);
	soap_serialize_PointerTott__FloatRange(soap, &a->MaxExposureTime);
	soap_serialize_PointerTott__FloatRange(soap, &a->MinGain);
	soap_serialize_PointerTott__FloatRange(soap, &a->MaxGain);
	soap_serialize_PointerTott__FloatRange(soap, &a->MinIris);
	soap_serialize_PointerTott__FloatRange(soap, &a->MaxIris);
	soap_serialize_PointerTott__FloatRange(soap, &a->ExposureTime);
	soap_serialize_PointerTott__FloatRange(soap, &a->Gain);
	soap_serialize_PointerTott__FloatRange(soap, &a->Iris);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ExposureOptions20(struct soap *soap, const char *tag, int id, const struct tt__ExposureOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ExposureOptions20), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
			if (soap_out_tt__ExposureMode(soap, "tt:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (a->Priority)
	{	int i;
		for (i = 0; i < (int)a->__sizePriority; i++)
			if (soap_out_tt__ExposurePriority(soap, "tt:Priority", -1, a->Priority + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__FloatRange(soap, "tt:MinExposureTime", -1, &a->MinExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MaxExposureTime", -1, &a->MaxExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MinGain", -1, &a->MinGain, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MaxGain", -1, &a->MaxGain, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MinIris", -1, &a->MinIris, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MaxIris", -1, &a->MaxIris, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:ExposureTime", -1, &a->ExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Gain", -1, &a->Gain, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Iris", -1, &a->Iris, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ExposureOptions20 * SOAP_FMAC4 soap_in_tt__ExposureOptions20(struct soap *soap, const char *tag, struct tt__ExposureOptions20 *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	struct soap_blist *soap_blist_Priority = NULL;
	size_t soap_flag_MinExposureTime = 1;
	size_t soap_flag_MaxExposureTime = 1;
	size_t soap_flag_MinGain = 1;
	size_t soap_flag_MaxGain = 1;
	size_t soap_flag_MinIris = 1;
	size_t soap_flag_MaxIris = 1;
	size_t soap_flag_ExposureTime = 1;
	size_t soap_flag_Gain = 1;
	size_t soap_flag_Iris = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ExposureOptions20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ExposureOptions20, sizeof(struct tt__ExposureOptions20), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ExposureOptions20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_alloc_block(soap);
					a->Mode = (enum tt__ExposureMode *)soap_push_block_max(soap, soap_blist_Mode, sizeof(enum tt__ExposureMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_tt__ExposureMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_tt__ExposureMode(soap, "tt:Mode", a->Mode, "tt:ExposureMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Priority", 1, NULL))
			{	if (a->Priority == NULL)
				{	if (soap_blist_Priority == NULL)
						soap_blist_Priority = soap_alloc_block(soap);
					a->Priority = (enum tt__ExposurePriority *)soap_push_block_max(soap, soap_blist_Priority, sizeof(enum tt__ExposurePriority));
					if (a->Priority == NULL)
						return NULL;
					soap_default_tt__ExposurePriority(soap, a->Priority);
				}
				soap_revert(soap);
				if (soap_in_tt__ExposurePriority(soap, "tt:Priority", a->Priority, "tt:ExposurePriority"))
				{	a->__sizePriority++;
					a->Priority = NULL;
					continue;
				}
			}
			if (soap_flag_MinExposureTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:MinExposureTime", &a->MinExposureTime, "tt:FloatRange"))
				{	soap_flag_MinExposureTime--;
					continue;
				}
			if (soap_flag_MaxExposureTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:MaxExposureTime", &a->MaxExposureTime, "tt:FloatRange"))
				{	soap_flag_MaxExposureTime--;
					continue;
				}
			if (soap_flag_MinGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:MinGain", &a->MinGain, "tt:FloatRange"))
				{	soap_flag_MinGain--;
					continue;
				}
			if (soap_flag_MaxGain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:MaxGain", &a->MaxGain, "tt:FloatRange"))
				{	soap_flag_MaxGain--;
					continue;
				}
			if (soap_flag_MinIris && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:MinIris", &a->MinIris, "tt:FloatRange"))
				{	soap_flag_MinIris--;
					continue;
				}
			if (soap_flag_MaxIris && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:MaxIris", &a->MaxIris, "tt:FloatRange"))
				{	soap_flag_MaxIris--;
					continue;
				}
			if (soap_flag_ExposureTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:ExposureTime", &a->ExposureTime, "tt:FloatRange"))
				{	soap_flag_ExposureTime--;
					continue;
				}
			if (soap_flag_Gain && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Gain", &a->Gain, "tt:FloatRange"))
				{	soap_flag_Gain--;
					continue;
				}
			if (soap_flag_Iris && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Iris", &a->Iris, "tt:FloatRange"))
				{	soap_flag_Iris--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
		{	a->Mode = (enum tt__ExposureMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		}
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (a->Priority)
			soap_pop_block(soap, soap_blist_Priority);
		if (a->__sizePriority)
		{	a->Priority = (enum tt__ExposurePriority *)soap_save_block(soap, soap_blist_Priority, NULL, 1);
		}
		else
		{	a->Priority = NULL;
			if (soap_blist_Priority)
				soap_end_block(soap, soap_blist_Priority);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ExposureOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ExposureOptions20, SOAP_TYPE_tt__ExposureOptions20, sizeof(struct tt__ExposureOptions20), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ExposureOptions20 * SOAP_FMAC4 soap_new_tt__ExposureOptions20(struct soap *soap, int n)
{
	struct tt__ExposureOptions20 *p;
	struct tt__ExposureOptions20 *a = (struct tt__ExposureOptions20*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ExposureOptions20));
	for (p = a; p && n--; p++)
		soap_default_tt__ExposureOptions20(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ExposureOptions20(struct soap *soap, const struct tt__ExposureOptions20 *a, const char *tag, const char *type)
{
	if (soap_out_tt__ExposureOptions20(soap, tag ? tag : "tt:ExposureOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ExposureOptions20 * SOAP_FMAC4 soap_get_tt__ExposureOptions20(struct soap *soap, struct tt__ExposureOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ExposureOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__BacklightCompensationOptions20(struct soap *soap, struct tt__BacklightCompensationOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMode = 0;
	a->Mode = NULL;
	a->Level = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__BacklightCompensationOptions20(struct soap *soap, const struct tt__BacklightCompensationOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
		{
			soap_embedded(soap, a->Mode + i, SOAP_TYPE_tt__BacklightCompensationMode);
		}
	}
	soap_serialize_PointerTott__FloatRange(soap, &a->Level);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BacklightCompensationOptions20(struct soap *soap, const char *tag, int id, const struct tt__BacklightCompensationOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BacklightCompensationOptions20), type))
		return soap->error;
	if (a->Mode)
	{	int i;
		for (i = 0; i < (int)a->__sizeMode; i++)
			if (soap_out_tt__BacklightCompensationMode(soap, "tt:Mode", -1, a->Mode + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__FloatRange(soap, "tt:Level", -1, &a->Level, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__BacklightCompensationOptions20 * SOAP_FMAC4 soap_in_tt__BacklightCompensationOptions20(struct soap *soap, const char *tag, struct tt__BacklightCompensationOptions20 *a, const char *type)
{
	struct soap_blist *soap_blist_Mode = NULL;
	size_t soap_flag_Level = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__BacklightCompensationOptions20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BacklightCompensationOptions20, sizeof(struct tt__BacklightCompensationOptions20), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__BacklightCompensationOptions20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
			{	if (a->Mode == NULL)
				{	if (soap_blist_Mode == NULL)
						soap_blist_Mode = soap_alloc_block(soap);
					a->Mode = (enum tt__BacklightCompensationMode *)soap_push_block_max(soap, soap_blist_Mode, sizeof(enum tt__BacklightCompensationMode));
					if (a->Mode == NULL)
						return NULL;
					soap_default_tt__BacklightCompensationMode(soap, a->Mode);
				}
				soap_revert(soap);
				if (soap_in_tt__BacklightCompensationMode(soap, "tt:Mode", a->Mode, "tt:BacklightCompensationMode"))
				{	a->__sizeMode++;
					a->Mode = NULL;
					continue;
				}
			}
			if (soap_flag_Level && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Level", &a->Level, "tt:FloatRange"))
				{	soap_flag_Level--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Mode)
			soap_pop_block(soap, soap_blist_Mode);
		if (a->__sizeMode)
		{	a->Mode = (enum tt__BacklightCompensationMode *)soap_save_block(soap, soap_blist_Mode, NULL, 1);
		}
		else
		{	a->Mode = NULL;
			if (soap_blist_Mode)
				soap_end_block(soap, soap_blist_Mode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeMode < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__BacklightCompensationOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BacklightCompensationOptions20, SOAP_TYPE_tt__BacklightCompensationOptions20, sizeof(struct tt__BacklightCompensationOptions20), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__BacklightCompensationOptions20 * SOAP_FMAC4 soap_new_tt__BacklightCompensationOptions20(struct soap *soap, int n)
{
	struct tt__BacklightCompensationOptions20 *p;
	struct tt__BacklightCompensationOptions20 *a = (struct tt__BacklightCompensationOptions20*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__BacklightCompensationOptions20));
	for (p = a; p && n--; p++)
		soap_default_tt__BacklightCompensationOptions20(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__BacklightCompensationOptions20(struct soap *soap, const struct tt__BacklightCompensationOptions20 *a, const char *tag, const char *type)
{
	if (soap_out_tt__BacklightCompensationOptions20(soap, tag ? tag : "tt:BacklightCompensationOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BacklightCompensationOptions20 * SOAP_FMAC4 soap_get_tt__BacklightCompensationOptions20(struct soap *soap, struct tt__BacklightCompensationOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BacklightCompensationOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImagingOptions20(struct soap *soap, struct tt__ImagingOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->BacklightCompensation = NULL;
	a->Brightness = NULL;
	a->ColorSaturation = NULL;
	a->Contrast = NULL;
	a->Exposure = NULL;
	a->Focus = NULL;
	a->__sizeIrCutFilterModes = 0;
	a->IrCutFilterModes = NULL;
	a->Sharpness = NULL;
	a->WideDynamicRange = NULL;
	a->WhiteBalance = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImagingOptions20(struct soap *soap, const struct tt__ImagingOptions20 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__BacklightCompensationOptions20(soap, &a->BacklightCompensation);
	soap_serialize_PointerTott__FloatRange(soap, &a->Brightness);
	soap_serialize_PointerTott__FloatRange(soap, &a->ColorSaturation);
	soap_serialize_PointerTott__FloatRange(soap, &a->Contrast);
	soap_serialize_PointerTott__ExposureOptions20(soap, &a->Exposure);
	soap_serialize_PointerTott__FocusOptions20(soap, &a->Focus);
	if (a->IrCutFilterModes)
	{	int i;
		for (i = 0; i < (int)a->__sizeIrCutFilterModes; i++)
		{
			soap_embedded(soap, a->IrCutFilterModes + i, SOAP_TYPE_tt__IrCutFilterMode);
		}
	}
	soap_serialize_PointerTott__FloatRange(soap, &a->Sharpness);
	soap_serialize_PointerTott__WideDynamicRangeOptions20(soap, &a->WideDynamicRange);
	soap_serialize_PointerTott__WhiteBalanceOptions20(soap, &a->WhiteBalance);
	soap_serialize_PointerTott__ImagingOptions20Extension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions20(struct soap *soap, const char *tag, int id, const struct tt__ImagingOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingOptions20), type))
		return soap->error;
	if (soap_out_PointerTott__BacklightCompensationOptions20(soap, "tt:BacklightCompensation", -1, &a->BacklightCompensation, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Brightness", -1, &a->Brightness, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:ColorSaturation", -1, &a->ColorSaturation, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Contrast", -1, &a->Contrast, ""))
		return soap->error;
	if (soap_out_PointerTott__ExposureOptions20(soap, "tt:Exposure", -1, &a->Exposure, ""))
		return soap->error;
	if (soap_out_PointerTott__FocusOptions20(soap, "tt:Focus", -1, &a->Focus, ""))
		return soap->error;
	if (a->IrCutFilterModes)
	{	int i;
		for (i = 0; i < (int)a->__sizeIrCutFilterModes; i++)
			if (soap_out_tt__IrCutFilterMode(soap, "tt:IrCutFilterModes", -1, a->IrCutFilterModes + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__FloatRange(soap, "tt:Sharpness", -1, &a->Sharpness, ""))
		return soap->error;
	if (soap_out_PointerTott__WideDynamicRangeOptions20(soap, "tt:WideDynamicRange", -1, &a->WideDynamicRange, ""))
		return soap->error;
	if (soap_out_PointerTott__WhiteBalanceOptions20(soap, "tt:WhiteBalance", -1, &a->WhiteBalance, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingOptions20Extension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImagingOptions20 * SOAP_FMAC4 soap_in_tt__ImagingOptions20(struct soap *soap, const char *tag, struct tt__ImagingOptions20 *a, const char *type)
{
	size_t soap_flag_BacklightCompensation = 1;
	size_t soap_flag_Brightness = 1;
	size_t soap_flag_ColorSaturation = 1;
	size_t soap_flag_Contrast = 1;
	size_t soap_flag_Exposure = 1;
	size_t soap_flag_Focus = 1;
	struct soap_blist *soap_blist_IrCutFilterModes = NULL;
	size_t soap_flag_Sharpness = 1;
	size_t soap_flag_WideDynamicRange = 1;
	size_t soap_flag_WhiteBalance = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ImagingOptions20 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions20, sizeof(struct tt__ImagingOptions20), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImagingOptions20(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BacklightCompensation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__BacklightCompensationOptions20(soap, "tt:BacklightCompensation", &a->BacklightCompensation, "tt:BacklightCompensationOptions20"))
				{	soap_flag_BacklightCompensation--;
					continue;
				}
			if (soap_flag_Brightness && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Brightness", &a->Brightness, "tt:FloatRange"))
				{	soap_flag_Brightness--;
					continue;
				}
			if (soap_flag_ColorSaturation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:ColorSaturation", &a->ColorSaturation, "tt:FloatRange"))
				{	soap_flag_ColorSaturation--;
					continue;
				}
			if (soap_flag_Contrast && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Contrast", &a->Contrast, "tt:FloatRange"))
				{	soap_flag_Contrast--;
					continue;
				}
			if (soap_flag_Exposure && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ExposureOptions20(soap, "tt:Exposure", &a->Exposure, "tt:ExposureOptions20"))
				{	soap_flag_Exposure--;
					continue;
				}
			if (soap_flag_Focus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FocusOptions20(soap, "tt:Focus", &a->Focus, "tt:FocusOptions20"))
				{	soap_flag_Focus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:IrCutFilterModes", 1, NULL))
			{	if (a->IrCutFilterModes == NULL)
				{	if (soap_blist_IrCutFilterModes == NULL)
						soap_blist_IrCutFilterModes = soap_alloc_block(soap);
					a->IrCutFilterModes = (enum tt__IrCutFilterMode *)soap_push_block_max(soap, soap_blist_IrCutFilterModes, sizeof(enum tt__IrCutFilterMode));
					if (a->IrCutFilterModes == NULL)
						return NULL;
					soap_default_tt__IrCutFilterMode(soap, a->IrCutFilterModes);
				}
				soap_revert(soap);
				if (soap_in_tt__IrCutFilterMode(soap, "tt:IrCutFilterModes", a->IrCutFilterModes, "tt:IrCutFilterMode"))
				{	a->__sizeIrCutFilterModes++;
					a->IrCutFilterModes = NULL;
					continue;
				}
			}
			if (soap_flag_Sharpness && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FloatRange(soap, "tt:Sharpness", &a->Sharpness, "tt:FloatRange"))
				{	soap_flag_Sharpness--;
					continue;
				}
			if (soap_flag_WideDynamicRange && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__WideDynamicRangeOptions20(soap, "tt:WideDynamicRange", &a->WideDynamicRange, "tt:WideDynamicRangeOptions20"))
				{	soap_flag_WideDynamicRange--;
					continue;
				}
			if (soap_flag_WhiteBalance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__WhiteBalanceOptions20(soap, "tt:WhiteBalance", &a->WhiteBalance, "tt:WhiteBalanceOptions20"))
				{	soap_flag_WhiteBalance--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ImagingOptions20Extension(soap, "tt:Extension", &a->Extension, "tt:ImagingOptions20Extension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->IrCutFilterModes)
			soap_pop_block(soap, soap_blist_IrCutFilterModes);
		if (a->__sizeIrCutFilterModes)
		{	a->IrCutFilterModes = (enum tt__IrCutFilterMode *)soap_save_block(soap, soap_blist_IrCutFilterModes, NULL, 1);
		}
		else
		{	a->IrCutFilterModes = NULL;
			if (soap_blist_IrCutFilterModes)
				soap_end_block(soap, soap_blist_IrCutFilterModes);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions20, SOAP_TYPE_tt__ImagingOptions20, sizeof(struct tt__ImagingOptions20), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ImagingOptions20 * SOAP_FMAC4 soap_new_tt__ImagingOptions20(struct soap *soap, int n)
{
	struct tt__ImagingOptions20 *p;
	struct tt__ImagingOptions20 *a = (struct tt__ImagingOptions20*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ImagingOptions20));
	for (p = a; p && n--; p++)
		soap_default_tt__ImagingOptions20(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImagingOptions20(struct soap *soap, const struct tt__ImagingOptions20 *a, const char *tag, const char *type)
{
	if (soap_out_tt__ImagingOptions20(soap, tag ? tag : "tt:ImagingOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingOptions20 * SOAP_FMAC4 soap_get_tt__ImagingOptions20(struct soap *soap, struct tt__ImagingOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DefoggingExtension(struct soap *soap, struct tt__DefoggingExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DefoggingExtension(struct soap *soap, const struct tt__DefoggingExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DefoggingExtension(struct soap *soap, const char *tag, int id, const struct tt__DefoggingExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DefoggingExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DefoggingExtension * SOAP_FMAC4 soap_in_tt__DefoggingExtension(struct soap *soap, const char *tag, struct tt__DefoggingExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DefoggingExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DefoggingExtension, sizeof(struct tt__DefoggingExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DefoggingExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__DefoggingExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DefoggingExtension, SOAP_TYPE_tt__DefoggingExtension, sizeof(struct tt__DefoggingExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__DefoggingExtension * SOAP_FMAC4 soap_new_tt__DefoggingExtension(struct soap *soap, int n)
{
	struct tt__DefoggingExtension *p;
	struct tt__DefoggingExtension *a = (struct tt__DefoggingExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__DefoggingExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__DefoggingExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DefoggingExtension(struct soap *soap, const struct tt__DefoggingExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__DefoggingExtension(soap, tag ? tag : "tt:DefoggingExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DefoggingExtension * SOAP_FMAC4 soap_get_tt__DefoggingExtension(struct soap *soap, struct tt__DefoggingExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DefoggingExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ToneCompensationExtension(struct soap *soap, struct tt__ToneCompensationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ToneCompensationExtension(struct soap *soap, const struct tt__ToneCompensationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ToneCompensationExtension(struct soap *soap, const char *tag, int id, const struct tt__ToneCompensationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ToneCompensationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ToneCompensationExtension * SOAP_FMAC4 soap_in_tt__ToneCompensationExtension(struct soap *soap, const char *tag, struct tt__ToneCompensationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ToneCompensationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ToneCompensationExtension, sizeof(struct tt__ToneCompensationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ToneCompensationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ToneCompensationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ToneCompensationExtension, SOAP_TYPE_tt__ToneCompensationExtension, sizeof(struct tt__ToneCompensationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ToneCompensationExtension * SOAP_FMAC4 soap_new_tt__ToneCompensationExtension(struct soap *soap, int n)
{
	struct tt__ToneCompensationExtension *p;
	struct tt__ToneCompensationExtension *a = (struct tt__ToneCompensationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ToneCompensationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ToneCompensationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ToneCompensationExtension(struct soap *soap, const struct tt__ToneCompensationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ToneCompensationExtension(soap, tag ? tag : "tt:ToneCompensationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ToneCompensationExtension * SOAP_FMAC4 soap_get_tt__ToneCompensationExtension(struct soap *soap, struct tt__ToneCompensationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ToneCompensationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, struct tt__IrCutFilterAutoAdjustmentExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, const struct tt__IrCutFilterAutoAdjustmentExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, const char *tag, int id, const struct tt__IrCutFilterAutoAdjustmentExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IrCutFilterAutoAdjustmentExtension * SOAP_FMAC4 soap_in_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, const char *tag, struct tt__IrCutFilterAutoAdjustmentExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IrCutFilterAutoAdjustmentExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension, sizeof(struct tt__IrCutFilterAutoAdjustmentExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IrCutFilterAutoAdjustmentExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__IrCutFilterAutoAdjustmentExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension, sizeof(struct tt__IrCutFilterAutoAdjustmentExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__IrCutFilterAutoAdjustmentExtension * SOAP_FMAC4 soap_new_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, int n)
{
	struct tt__IrCutFilterAutoAdjustmentExtension *p;
	struct tt__IrCutFilterAutoAdjustmentExtension *a = (struct tt__IrCutFilterAutoAdjustmentExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__IrCutFilterAutoAdjustmentExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__IrCutFilterAutoAdjustmentExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, const struct tt__IrCutFilterAutoAdjustmentExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__IrCutFilterAutoAdjustmentExtension(soap, tag ? tag : "tt:IrCutFilterAutoAdjustmentExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IrCutFilterAutoAdjustmentExtension * SOAP_FMAC4 soap_get_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, struct tt__IrCutFilterAutoAdjustmentExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IrCutFilterAutoAdjustmentExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ImageStabilizationExtension(struct soap *soap, struct tt__ImageStabilizationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ImageStabilizationExtension(struct soap *soap, const struct tt__ImageStabilizationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImageStabilizationExtension(struct soap *soap, const char *tag, int id, const struct tt__ImageStabilizationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImageStabilizationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ImageStabilizationExtension * SOAP_FMAC4 soap_in_tt__ImageStabilizationExtension(struct soap *soap, const char *tag, struct tt__ImageStabilizationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ImageStabilizationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImageStabilizationExtension, sizeof(struct tt__ImageStabilizationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ImageStabilizationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ImageStabilizationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImageStabilizationExtension, SOAP_TYPE_tt__ImageStabilizationExtension, sizeof(struct tt__ImageStabilizationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ImageStabilizationExtension * SOAP_FMAC4 soap_new_tt__ImageStabilizationExtension(struct soap *soap, int n)
{
	struct tt__ImageStabilizationExtension *p;
	struct tt__ImageStabilizationExtension *a = (struct tt__ImageStabilizationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ImageStabilizationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ImageStabilizationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ImageStabilizationExtension(struct soap *soap, const struct tt__ImageStabilizationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ImageStabilizationExtension(soap, tag ? tag : "tt:ImageStabilizationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImageStabilizationExtension * SOAP_FMAC4 soap_get_tt__ImageStabilizationExtension(struct soap *soap, struct tt__ImageStabilizationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImageStabilizationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
