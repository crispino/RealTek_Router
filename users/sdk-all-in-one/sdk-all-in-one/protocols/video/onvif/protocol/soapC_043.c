/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:59 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AttributeStatementType(struct soap *soap, struct saml1__AttributeStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml1__Subject = NULL;
	a->__sizeAttribute = 0;
	a->saml1__Attribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AttributeStatementType(struct soap *soap, const struct saml1__AttributeStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml1__SubjectType(soap, &a->saml1__Subject);
	if (a->saml1__Attribute)
	{	int i;
		for (i = 0; i < (int)a->__sizeAttribute; i++)
		{
			soap_embedded(soap, a->saml1__Attribute + i, SOAP_TYPE_saml1__AttributeType);
			soap_serialize_saml1__AttributeType(soap, a->saml1__Attribute + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AttributeStatementType(struct soap *soap, const char *tag, int id, const struct saml1__AttributeStatementType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AttributeStatementType), type))
		return soap->error;
	if (!a->saml1__Subject)
	{	if (soap_element_nil(soap, "saml1:Subject"))
			return soap->error;
	}
	else
	if (soap_out_PointerTosaml1__SubjectType(soap, "saml1:Subject", -1, &a->saml1__Subject, ""))
		return soap->error;
	if (a->saml1__Attribute)
	{	int i;
		for (i = 0; i < (int)a->__sizeAttribute; i++)
			if (soap_out_saml1__AttributeType(soap, "saml1:Attribute", -1, a->saml1__Attribute + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AttributeStatementType * SOAP_FMAC4 soap_in_saml1__AttributeStatementType(struct soap *soap, const char *tag, struct saml1__AttributeStatementType *a, const char *type)
{
	size_t soap_flag_saml1__Subject = 1;
	struct soap_blist *soap_blist_saml1__Attribute = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml1__AttributeStatementType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AttributeStatementType, sizeof(struct saml1__AttributeStatementType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AttributeStatementType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__Subject && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml1__SubjectType(soap, "saml1:Subject", &a->saml1__Subject, "saml1:SubjectType"))
				{	soap_flag_saml1__Subject--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml1:Attribute", 1, NULL))
			{	if (a->saml1__Attribute == NULL)
				{	if (soap_blist_saml1__Attribute == NULL)
						soap_blist_saml1__Attribute = soap_alloc_block(soap);
					a->saml1__Attribute = (struct saml1__AttributeType *)soap_push_block_max(soap, soap_blist_saml1__Attribute, sizeof(struct saml1__AttributeType));
					if (a->saml1__Attribute == NULL)
						return NULL;
					soap_default_saml1__AttributeType(soap, a->saml1__Attribute);
				}
				soap_revert(soap);
				if (soap_in_saml1__AttributeType(soap, "saml1:Attribute", a->saml1__Attribute, "saml1:AttributeType"))
				{	a->__sizeAttribute++;
					a->saml1__Attribute = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml1__Attribute)
			soap_pop_block(soap, soap_blist_saml1__Attribute);
		if (a->__sizeAttribute)
		{	a->saml1__Attribute = (struct saml1__AttributeType *)soap_save_block(soap, soap_blist_saml1__Attribute, NULL, 1);
		}
		else
		{	a->saml1__Attribute = NULL;
			if (soap_blist_saml1__Attribute)
				soap_end_block(soap, soap_blist_saml1__Attribute);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_saml1__Subject > 0 || a->__sizeAttribute < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml1__AttributeStatementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AttributeStatementType, SOAP_TYPE_saml1__AttributeStatementType, sizeof(struct saml1__AttributeStatementType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__AttributeStatementType * SOAP_FMAC4 soap_new_saml1__AttributeStatementType(struct soap *soap, int n)
{
	struct saml1__AttributeStatementType *p;
	struct saml1__AttributeStatementType *a = (struct saml1__AttributeStatementType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__AttributeStatementType));
	for (p = a; p && n--; p++)
		soap_default_saml1__AttributeStatementType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AttributeStatementType(struct soap *soap, const struct saml1__AttributeStatementType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AttributeStatementType(soap, tag ? tag : "saml1:AttributeStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AttributeStatementType * SOAP_FMAC4 soap_get_saml1__AttributeStatementType(struct soap *soap, struct saml1__AttributeStatementType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AttributeStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__EvidenceType(struct soap *soap, struct saml1__EvidenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_EvidenceType = 0;
	a->__union_EvidenceType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__EvidenceType(struct soap *soap, const struct saml1__EvidenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_EvidenceType)
	{	int i;
		for (i = 0; i < (int)a->__size_EvidenceType; i++)
		{
			soap_serialize___saml1__union_EvidenceType(soap, a->__union_EvidenceType + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__EvidenceType(struct soap *soap, const char *tag, int id, const struct saml1__EvidenceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__EvidenceType), type))
		return soap->error;
	if (a->__union_EvidenceType)
	{	int i;
		for (i = 0; i < (int)a->__size_EvidenceType; i++)
			if (soap_out___saml1__union_EvidenceType(soap, "-union-EvidenceType", -1, a->__union_EvidenceType + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__EvidenceType * SOAP_FMAC4 soap_in_saml1__EvidenceType(struct soap *soap, const char *tag, struct saml1__EvidenceType *a, const char *type)
{
	struct soap_blist *soap_blist___union_EvidenceType = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml1__EvidenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__EvidenceType, sizeof(struct saml1__EvidenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__EvidenceType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_EvidenceType == NULL)
				{	if (soap_blist___union_EvidenceType == NULL)
						soap_blist___union_EvidenceType = soap_alloc_block(soap);
					a->__union_EvidenceType = (struct __saml1__union_EvidenceType *)soap_push_block_max(soap, soap_blist___union_EvidenceType, sizeof(struct __saml1__union_EvidenceType));
					if (a->__union_EvidenceType == NULL)
						return NULL;
					soap_default___saml1__union_EvidenceType(soap, a->__union_EvidenceType);
				}
				if (soap_in___saml1__union_EvidenceType(soap, "-union-EvidenceType", a->__union_EvidenceType, "-saml1:union-EvidenceType"))
				{	a->__size_EvidenceType++;
					a->__union_EvidenceType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_EvidenceType)
			soap_pop_block(soap, soap_blist___union_EvidenceType);
		if (a->__size_EvidenceType)
		{	a->__union_EvidenceType = (struct __saml1__union_EvidenceType *)soap_save_block(soap, soap_blist___union_EvidenceType, NULL, 1);
		}
		else
		{	a->__union_EvidenceType = NULL;
			if (soap_blist___union_EvidenceType)
				soap_end_block(soap, soap_blist___union_EvidenceType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__EvidenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__EvidenceType, SOAP_TYPE_saml1__EvidenceType, sizeof(struct saml1__EvidenceType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__EvidenceType * SOAP_FMAC4 soap_new_saml1__EvidenceType(struct soap *soap, int n)
{
	struct saml1__EvidenceType *p;
	struct saml1__EvidenceType *a = (struct saml1__EvidenceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__EvidenceType));
	for (p = a; p && n--; p++)
		soap_default_saml1__EvidenceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__EvidenceType(struct soap *soap, const struct saml1__EvidenceType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__EvidenceType(soap, tag ? tag : "saml1:EvidenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__EvidenceType * SOAP_FMAC4 soap_get_saml1__EvidenceType(struct soap *soap, struct saml1__EvidenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__EvidenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__ActionType(struct soap *soap, struct saml1__ActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->Namespace);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__ActionType(struct soap *soap, const struct saml1__ActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__ActionType(struct soap *soap, const char *tag, int id, const struct saml1__ActionType *a, const char *type)
{
	if (a->Namespace)
		soap_set_attr(soap, "Namespace", soap_string2s(soap, a->Namespace), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct saml1__ActionType * SOAP_FMAC4 soap_in_saml1__ActionType(struct soap *soap, const char *tag, struct saml1__ActionType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct saml1__ActionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__ActionType, sizeof(struct saml1__ActionType), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_saml1__ActionType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Namespace", 0), &a->Namespace))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "saml1:ActionType"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct saml1__ActionType * SOAP_FMAC4 soap_new_saml1__ActionType(struct soap *soap, int n)
{
	struct saml1__ActionType *p;
	struct saml1__ActionType *a = (struct saml1__ActionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__ActionType));
	for (p = a; p && n--; p++)
		soap_default_saml1__ActionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__ActionType(struct soap *soap, const struct saml1__ActionType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__ActionType(soap, tag ? tag : "saml1:ActionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__ActionType * SOAP_FMAC4 soap_get_saml1__ActionType(struct soap *soap, struct saml1__ActionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__ActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AuthorizationDecisionStatementType(struct soap *soap, struct saml1__AuthorizationDecisionStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml1__Subject = NULL;
	a->__sizeAction = 0;
	a->saml1__Action = NULL;
	a->saml1__Evidence = NULL;
	soap_default_string(soap, &a->Resource);
	soap_default_saml1__DecisionType(soap, &a->Decision);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AuthorizationDecisionStatementType(struct soap *soap, const struct saml1__AuthorizationDecisionStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml1__SubjectType(soap, &a->saml1__Subject);
	if (a->saml1__Action)
	{	int i;
		for (i = 0; i < (int)a->__sizeAction; i++)
		{
			soap_embedded(soap, a->saml1__Action + i, SOAP_TYPE_saml1__ActionType);
			soap_serialize_saml1__ActionType(soap, a->saml1__Action + i);
		}
	}
	soap_serialize_PointerTosaml1__EvidenceType(soap, &a->saml1__Evidence);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AuthorizationDecisionStatementType(struct soap *soap, const char *tag, int id, const struct saml1__AuthorizationDecisionStatementType *a, const char *type)
{
	if (a->Resource)
		soap_set_attr(soap, "Resource", soap_string2s(soap, a->Resource), 1);
	soap_set_attr(soap, "Decision", soap_saml1__DecisionType2s(soap, a->Decision), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AuthorizationDecisionStatementType), type))
		return soap->error;
	if (!a->saml1__Subject)
	{	if (soap_element_nil(soap, "saml1:Subject"))
			return soap->error;
	}
	else
	if (soap_out_PointerTosaml1__SubjectType(soap, "saml1:Subject", -1, &a->saml1__Subject, ""))
		return soap->error;
	if (a->saml1__Action)
	{	int i;
		for (i = 0; i < (int)a->__sizeAction; i++)
			if (soap_out_saml1__ActionType(soap, "saml1:Action", -1, a->saml1__Action + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTosaml1__EvidenceType(soap, "saml1:Evidence", -1, &a->saml1__Evidence, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AuthorizationDecisionStatementType * SOAP_FMAC4 soap_in_saml1__AuthorizationDecisionStatementType(struct soap *soap, const char *tag, struct saml1__AuthorizationDecisionStatementType *a, const char *type)
{
	size_t soap_flag_saml1__Subject = 1;
	struct soap_blist *soap_blist_saml1__Action = NULL;
	size_t soap_flag_saml1__Evidence = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml1__AuthorizationDecisionStatementType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AuthorizationDecisionStatementType, sizeof(struct saml1__AuthorizationDecisionStatementType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AuthorizationDecisionStatementType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Resource", 1), &a->Resource))
		return NULL;
	if (soap_s2saml1__DecisionType(soap, soap_attr_value(soap, "Decision", 1), &a->Decision))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__Subject && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml1__SubjectType(soap, "saml1:Subject", &a->saml1__Subject, "saml1:SubjectType"))
				{	soap_flag_saml1__Subject--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml1:Action", 1, NULL))
			{	if (a->saml1__Action == NULL)
				{	if (soap_blist_saml1__Action == NULL)
						soap_blist_saml1__Action = soap_alloc_block(soap);
					a->saml1__Action = (struct saml1__ActionType *)soap_push_block_max(soap, soap_blist_saml1__Action, sizeof(struct saml1__ActionType));
					if (a->saml1__Action == NULL)
						return NULL;
					soap_default_saml1__ActionType(soap, a->saml1__Action);
				}
				soap_revert(soap);
				if (soap_in_saml1__ActionType(soap, "saml1:Action", a->saml1__Action, "saml1:ActionType"))
				{	a->__sizeAction++;
					a->saml1__Action = NULL;
					continue;
				}
			}
			if (soap_flag_saml1__Evidence && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml1__EvidenceType(soap, "saml1:Evidence", &a->saml1__Evidence, "saml1:EvidenceType"))
				{	soap_flag_saml1__Evidence--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml1__Action)
			soap_pop_block(soap, soap_blist_saml1__Action);
		if (a->__sizeAction)
		{	a->saml1__Action = (struct saml1__ActionType *)soap_save_block(soap, soap_blist_saml1__Action, NULL, 1);
		}
		else
		{	a->saml1__Action = NULL;
			if (soap_blist_saml1__Action)
				soap_end_block(soap, soap_blist_saml1__Action);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_saml1__Subject > 0 || a->__sizeAction < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml1__AuthorizationDecisionStatementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AuthorizationDecisionStatementType, SOAP_TYPE_saml1__AuthorizationDecisionStatementType, sizeof(struct saml1__AuthorizationDecisionStatementType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__AuthorizationDecisionStatementType * SOAP_FMAC4 soap_new_saml1__AuthorizationDecisionStatementType(struct soap *soap, int n)
{
	struct saml1__AuthorizationDecisionStatementType *p;
	struct saml1__AuthorizationDecisionStatementType *a = (struct saml1__AuthorizationDecisionStatementType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__AuthorizationDecisionStatementType));
	for (p = a; p && n--; p++)
		soap_default_saml1__AuthorizationDecisionStatementType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AuthorizationDecisionStatementType(struct soap *soap, const struct saml1__AuthorizationDecisionStatementType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AuthorizationDecisionStatementType(soap, tag ? tag : "saml1:AuthorizationDecisionStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AuthorizationDecisionStatementType * SOAP_FMAC4 soap_get_saml1__AuthorizationDecisionStatementType(struct soap *soap, struct saml1__AuthorizationDecisionStatementType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AuthorizationDecisionStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AuthorityBindingType(struct soap *soap, struct saml1__AuthorityBindingType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->AuthorityKind);
	soap_default_string(soap, &a->Location);
	soap_default_string(soap, &a->Binding);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AuthorityBindingType(struct soap *soap, const struct saml1__AuthorityBindingType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AuthorityBindingType(struct soap *soap, const char *tag, int id, const struct saml1__AuthorityBindingType *a, const char *type)
{
	if (a->AuthorityKind)
		soap_set_attr(soap, "AuthorityKind", soap__QName2s(soap, a->AuthorityKind), 1);
	if (a->Location)
		soap_set_attr(soap, "Location", soap_string2s(soap, a->Location), 1);
	if (a->Binding)
		soap_set_attr(soap, "Binding", soap_string2s(soap, a->Binding), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AuthorityBindingType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AuthorityBindingType * SOAP_FMAC4 soap_in_saml1__AuthorityBindingType(struct soap *soap, const char *tag, struct saml1__AuthorityBindingType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml1__AuthorityBindingType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AuthorityBindingType, sizeof(struct saml1__AuthorityBindingType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AuthorityBindingType(soap, a);
	if (soap_s2_QName(soap, soap_attr_value(soap, "AuthorityKind", 1), &a->AuthorityKind))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Location", 1), &a->Location))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Binding", 1), &a->Binding))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__AuthorityBindingType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AuthorityBindingType, SOAP_TYPE_saml1__AuthorityBindingType, sizeof(struct saml1__AuthorityBindingType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__AuthorityBindingType * SOAP_FMAC4 soap_new_saml1__AuthorityBindingType(struct soap *soap, int n)
{
	struct saml1__AuthorityBindingType *p;
	struct saml1__AuthorityBindingType *a = (struct saml1__AuthorityBindingType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__AuthorityBindingType));
	for (p = a; p && n--; p++)
		soap_default_saml1__AuthorityBindingType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AuthorityBindingType(struct soap *soap, const struct saml1__AuthorityBindingType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AuthorityBindingType(soap, tag ? tag : "saml1:AuthorityBindingType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AuthorityBindingType * SOAP_FMAC4 soap_get_saml1__AuthorityBindingType(struct soap *soap, struct saml1__AuthorityBindingType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AuthorityBindingType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__SubjectLocalityType(struct soap *soap, struct saml1__SubjectLocalityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->IPAddress);
	soap_default_string(soap, &a->DNSAddress);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__SubjectLocalityType(struct soap *soap, const struct saml1__SubjectLocalityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__SubjectLocalityType(struct soap *soap, const char *tag, int id, const struct saml1__SubjectLocalityType *a, const char *type)
{
	if (a->IPAddress)
		soap_set_attr(soap, "IPAddress", soap_string2s(soap, a->IPAddress), 1);
	if (a->DNSAddress)
		soap_set_attr(soap, "DNSAddress", soap_string2s(soap, a->DNSAddress), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__SubjectLocalityType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__SubjectLocalityType * SOAP_FMAC4 soap_in_saml1__SubjectLocalityType(struct soap *soap, const char *tag, struct saml1__SubjectLocalityType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml1__SubjectLocalityType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__SubjectLocalityType, sizeof(struct saml1__SubjectLocalityType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__SubjectLocalityType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "IPAddress", 0), &a->IPAddress))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "DNSAddress", 0), &a->DNSAddress))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__SubjectLocalityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__SubjectLocalityType, SOAP_TYPE_saml1__SubjectLocalityType, sizeof(struct saml1__SubjectLocalityType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__SubjectLocalityType * SOAP_FMAC4 soap_new_saml1__SubjectLocalityType(struct soap *soap, int n)
{
	struct saml1__SubjectLocalityType *p;
	struct saml1__SubjectLocalityType *a = (struct saml1__SubjectLocalityType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__SubjectLocalityType));
	for (p = a; p && n--; p++)
		soap_default_saml1__SubjectLocalityType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__SubjectLocalityType(struct soap *soap, const struct saml1__SubjectLocalityType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__SubjectLocalityType(soap, tag ? tag : "saml1:SubjectLocalityType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__SubjectLocalityType * SOAP_FMAC4 soap_get_saml1__SubjectLocalityType(struct soap *soap, struct saml1__SubjectLocalityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__SubjectLocalityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AuthenticationStatementType(struct soap *soap, struct saml1__AuthenticationStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml1__Subject = NULL;
	a->saml1__SubjectLocality = NULL;
	a->__sizeAuthorityBinding = 0;
	a->saml1__AuthorityBinding = NULL;
	soap_default_string(soap, &a->AuthenticationMethod);
	soap_default_dateTime(soap, &a->AuthenticationInstant);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AuthenticationStatementType(struct soap *soap, const struct saml1__AuthenticationStatementType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml1__SubjectType(soap, &a->saml1__Subject);
	soap_serialize_PointerTosaml1__SubjectLocalityType(soap, &a->saml1__SubjectLocality);
	if (a->saml1__AuthorityBinding)
	{	int i;
		for (i = 0; i < (int)a->__sizeAuthorityBinding; i++)
		{
			soap_embedded(soap, a->saml1__AuthorityBinding + i, SOAP_TYPE_saml1__AuthorityBindingType);
			soap_serialize_saml1__AuthorityBindingType(soap, a->saml1__AuthorityBinding + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AuthenticationStatementType(struct soap *soap, const char *tag, int id, const struct saml1__AuthenticationStatementType *a, const char *type)
{
	if (a->AuthenticationMethod)
		soap_set_attr(soap, "AuthenticationMethod", soap_string2s(soap, a->AuthenticationMethod), 1);
	soap_set_attr(soap, "AuthenticationInstant", soap_dateTime2s(soap, a->AuthenticationInstant), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AuthenticationStatementType), type))
		return soap->error;
	if (!a->saml1__Subject)
	{	if (soap_element_nil(soap, "saml1:Subject"))
			return soap->error;
	}
	else
	if (soap_out_PointerTosaml1__SubjectType(soap, "saml1:Subject", -1, &a->saml1__Subject, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__SubjectLocalityType(soap, "saml1:SubjectLocality", -1, &a->saml1__SubjectLocality, ""))
		return soap->error;
	if (a->saml1__AuthorityBinding)
	{	int i;
		for (i = 0; i < (int)a->__sizeAuthorityBinding; i++)
			if (soap_out_saml1__AuthorityBindingType(soap, "saml1:AuthorityBinding", -1, a->saml1__AuthorityBinding + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AuthenticationStatementType * SOAP_FMAC4 soap_in_saml1__AuthenticationStatementType(struct soap *soap, const char *tag, struct saml1__AuthenticationStatementType *a, const char *type)
{
	size_t soap_flag_saml1__Subject = 1;
	size_t soap_flag_saml1__SubjectLocality = 1;
	struct soap_blist *soap_blist_saml1__AuthorityBinding = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml1__AuthenticationStatementType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AuthenticationStatementType, sizeof(struct saml1__AuthenticationStatementType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AuthenticationStatementType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "AuthenticationMethod", 1), &a->AuthenticationMethod))
		return NULL;
	if (soap_s2dateTime(soap, soap_attr_value(soap, "AuthenticationInstant", 1), &a->AuthenticationInstant))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__Subject && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml1__SubjectType(soap, "saml1:Subject", &a->saml1__Subject, "saml1:SubjectType"))
				{	soap_flag_saml1__Subject--;
					continue;
				}
			if (soap_flag_saml1__SubjectLocality && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml1__SubjectLocalityType(soap, "saml1:SubjectLocality", &a->saml1__SubjectLocality, "saml1:SubjectLocalityType"))
				{	soap_flag_saml1__SubjectLocality--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml1:AuthorityBinding", 1, NULL))
			{	if (a->saml1__AuthorityBinding == NULL)
				{	if (soap_blist_saml1__AuthorityBinding == NULL)
						soap_blist_saml1__AuthorityBinding = soap_alloc_block(soap);
					a->saml1__AuthorityBinding = (struct saml1__AuthorityBindingType *)soap_push_block_max(soap, soap_blist_saml1__AuthorityBinding, sizeof(struct saml1__AuthorityBindingType));
					if (a->saml1__AuthorityBinding == NULL)
						return NULL;
					soap_default_saml1__AuthorityBindingType(soap, a->saml1__AuthorityBinding);
				}
				soap_revert(soap);
				if (soap_in_saml1__AuthorityBindingType(soap, "saml1:AuthorityBinding", a->saml1__AuthorityBinding, "saml1:AuthorityBindingType"))
				{	a->__sizeAuthorityBinding++;
					a->saml1__AuthorityBinding = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml1__AuthorityBinding)
			soap_pop_block(soap, soap_blist_saml1__AuthorityBinding);
		if (a->__sizeAuthorityBinding)
		{	a->saml1__AuthorityBinding = (struct saml1__AuthorityBindingType *)soap_save_block(soap, soap_blist_saml1__AuthorityBinding, NULL, 1);
		}
		else
		{	a->saml1__AuthorityBinding = NULL;
			if (soap_blist_saml1__AuthorityBinding)
				soap_end_block(soap, soap_blist_saml1__AuthorityBinding);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_saml1__Subject > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml1__AuthenticationStatementType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AuthenticationStatementType, SOAP_TYPE_saml1__AuthenticationStatementType, sizeof(struct saml1__AuthenticationStatementType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__AuthenticationStatementType * SOAP_FMAC4 soap_new_saml1__AuthenticationStatementType(struct soap *soap, int n)
{
	struct saml1__AuthenticationStatementType *p;
	struct saml1__AuthenticationStatementType *a = (struct saml1__AuthenticationStatementType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__AuthenticationStatementType));
	for (p = a; p && n--; p++)
		soap_default_saml1__AuthenticationStatementType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AuthenticationStatementType(struct soap *soap, const struct saml1__AuthenticationStatementType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AuthenticationStatementType(soap, tag ? tag : "saml1:AuthenticationStatementType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AuthenticationStatementType * SOAP_FMAC4 soap_get_saml1__AuthenticationStatementType(struct soap *soap, struct saml1__AuthenticationStatementType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AuthenticationStatementType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__SubjectConfirmationType(struct soap *soap, struct saml1__SubjectConfirmationType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeConfirmationMethod = 0;
	a->saml1__ConfirmationMethod = NULL;
	a->saml1__SubjectConfirmationData = NULL;
	a->ds__KeyInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__SubjectConfirmationType(struct soap *soap, const struct saml1__SubjectConfirmationType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->saml1__ConfirmationMethod)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfirmationMethod; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->saml1__ConfirmationMethod + i));
		}
	}
	soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__SubjectConfirmationType(struct soap *soap, const char *tag, int id, const struct saml1__SubjectConfirmationType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__SubjectConfirmationType), type))
		return soap->error;
	if (a->saml1__ConfirmationMethod)
	{	int i;
		for (i = 0; i < (int)a->__sizeConfirmationMethod; i++)
			soap_out_string(soap, "saml1:ConfirmationMethod", -1, (char*const*)(a->saml1__ConfirmationMethod + i), "");
	}
	soap_outliteral(soap, "saml1:SubjectConfirmationData", (char*const*)&a->saml1__SubjectConfirmationData, NULL);
	if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__SubjectConfirmationType * SOAP_FMAC4 soap_in_saml1__SubjectConfirmationType(struct soap *soap, const char *tag, struct saml1__SubjectConfirmationType *a, const char *type)
{
	struct soap_blist *soap_blist_saml1__ConfirmationMethod = NULL;
	size_t soap_flag_saml1__SubjectConfirmationData = 1;
	size_t soap_flag_ds__KeyInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml1__SubjectConfirmationType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__SubjectConfirmationType, sizeof(struct saml1__SubjectConfirmationType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__SubjectConfirmationType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml1:ConfirmationMethod", 1, NULL))
			{	if (a->saml1__ConfirmationMethod == NULL)
				{	if (soap_blist_saml1__ConfirmationMethod == NULL)
						soap_blist_saml1__ConfirmationMethod = soap_alloc_block(soap);
					a->saml1__ConfirmationMethod = (char **)soap_push_block_max(soap, soap_blist_saml1__ConfirmationMethod, sizeof(char *));
					if (a->saml1__ConfirmationMethod == NULL)
						return NULL;
					*a->saml1__ConfirmationMethod = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "saml1:ConfirmationMethod", (char**)a->saml1__ConfirmationMethod, "xsd:string"))
				{	a->__sizeConfirmationMethod++;
					a->saml1__ConfirmationMethod = NULL;
					continue;
				}
			}
			if (soap_flag_saml1__SubjectConfirmationData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "saml1:SubjectConfirmationData", (char**)&a->saml1__SubjectConfirmationData))
				{	soap_flag_saml1__SubjectConfirmationData--;
					continue;
				}
			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, ""))
				{	soap_flag_ds__KeyInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml1__ConfirmationMethod)
			soap_pop_block(soap, soap_blist_saml1__ConfirmationMethod);
		if (a->__sizeConfirmationMethod)
		{	a->saml1__ConfirmationMethod = (char **)soap_save_block(soap, soap_blist_saml1__ConfirmationMethod, NULL, 1);
		}
		else
		{	a->saml1__ConfirmationMethod = NULL;
			if (soap_blist_saml1__ConfirmationMethod)
				soap_end_block(soap, soap_blist_saml1__ConfirmationMethod);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeConfirmationMethod < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml1__SubjectConfirmationType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__SubjectConfirmationType, SOAP_TYPE_saml1__SubjectConfirmationType, sizeof(struct saml1__SubjectConfirmationType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__SubjectConfirmationType * SOAP_FMAC4 soap_new_saml1__SubjectConfirmationType(struct soap *soap, int n)
{
	struct saml1__SubjectConfirmationType *p;
	struct saml1__SubjectConfirmationType *a = (struct saml1__SubjectConfirmationType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__SubjectConfirmationType));
	for (p = a; p && n--; p++)
		soap_default_saml1__SubjectConfirmationType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__SubjectConfirmationType(struct soap *soap, const struct saml1__SubjectConfirmationType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__SubjectConfirmationType(soap, tag ? tag : "saml1:SubjectConfirmationType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__SubjectConfirmationType * SOAP_FMAC4 soap_get_saml1__SubjectConfirmationType(struct soap *soap, struct saml1__SubjectConfirmationType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__SubjectConfirmationType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__NameIdentifierType(struct soap *soap, struct saml1__NameIdentifierType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->NameQualifier);
	soap_default_string(soap, &a->Format);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__NameIdentifierType(struct soap *soap, const struct saml1__NameIdentifierType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__NameIdentifierType(struct soap *soap, const char *tag, int id, const struct saml1__NameIdentifierType *a, const char *type)
{
	if (a->NameQualifier)
		soap_set_attr(soap, "NameQualifier", soap_string2s(soap, a->NameQualifier), 1);
	if (a->Format)
		soap_set_attr(soap, "Format", soap_string2s(soap, a->Format), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct saml1__NameIdentifierType * SOAP_FMAC4 soap_in_saml1__NameIdentifierType(struct soap *soap, const char *tag, struct saml1__NameIdentifierType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct saml1__NameIdentifierType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__NameIdentifierType, sizeof(struct saml1__NameIdentifierType), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_saml1__NameIdentifierType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "NameQualifier", 0), &a->NameQualifier))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Format", 0), &a->Format))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "saml1:NameIdentifierType"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct saml1__NameIdentifierType * SOAP_FMAC4 soap_new_saml1__NameIdentifierType(struct soap *soap, int n)
{
	struct saml1__NameIdentifierType *p;
	struct saml1__NameIdentifierType *a = (struct saml1__NameIdentifierType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__NameIdentifierType));
	for (p = a; p && n--; p++)
		soap_default_saml1__NameIdentifierType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__NameIdentifierType(struct soap *soap, const struct saml1__NameIdentifierType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__NameIdentifierType(soap, tag ? tag : "saml1:NameIdentifierType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__NameIdentifierType * SOAP_FMAC4 soap_get_saml1__NameIdentifierType(struct soap *soap, struct saml1__NameIdentifierType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__NameIdentifierType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__SubjectType(struct soap *soap, struct saml1__SubjectType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml1__NameIdentifier = NULL;
	a->saml1__SubjectConfirmation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__SubjectType(struct soap *soap, const struct saml1__SubjectType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml1__NameIdentifierType(soap, &a->saml1__NameIdentifier);
	soap_serialize_PointerTosaml1__SubjectConfirmationType(soap, &a->saml1__SubjectConfirmation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__SubjectType(struct soap *soap, const char *tag, int id, const struct saml1__SubjectType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__SubjectType), type))
		return soap->error;
	if (soap_out_PointerTosaml1__NameIdentifierType(soap, "saml1:NameIdentifier", -1, &a->saml1__NameIdentifier, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__SubjectConfirmationType(soap, "saml1:SubjectConfirmation", -1, &a->saml1__SubjectConfirmation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__SubjectType * SOAP_FMAC4 soap_in_saml1__SubjectType(struct soap *soap, const char *tag, struct saml1__SubjectType *a, const char *type)
{
	size_t soap_flag_saml1__NameIdentifier = 1;
	size_t soap_flag_saml1__SubjectConfirmation = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml1__SubjectType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__SubjectType, sizeof(struct saml1__SubjectType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__SubjectType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__NameIdentifier && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml1__NameIdentifierType(soap, "saml1:NameIdentifier", &a->saml1__NameIdentifier, "saml1:NameIdentifierType"))
				{	soap_flag_saml1__NameIdentifier--;
					continue;
				}
			if (soap_flag_saml1__SubjectConfirmation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml1__SubjectConfirmationType(soap, "saml1:SubjectConfirmation", &a->saml1__SubjectConfirmation, "saml1:SubjectConfirmationType"))
				{	soap_flag_saml1__SubjectConfirmation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__SubjectType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__SubjectType, SOAP_TYPE_saml1__SubjectType, sizeof(struct saml1__SubjectType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__SubjectType * SOAP_FMAC4 soap_new_saml1__SubjectType(struct soap *soap, int n)
{
	struct saml1__SubjectType *p;
	struct saml1__SubjectType *a = (struct saml1__SubjectType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__SubjectType));
	for (p = a; p && n--; p++)
		soap_default_saml1__SubjectType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__SubjectType(struct soap *soap, const struct saml1__SubjectType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__SubjectType(soap, tag ? tag : "saml1:SubjectType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__SubjectType * SOAP_FMAC4 soap_get_saml1__SubjectType(struct soap *soap, struct saml1__SubjectType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__SubjectType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__SubjectStatementAbstractType(struct soap *soap, struct saml1__SubjectStatementAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml1__Subject = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__SubjectStatementAbstractType(struct soap *soap, const struct saml1__SubjectStatementAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml1__SubjectType(soap, &a->saml1__Subject);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__SubjectStatementAbstractType(struct soap *soap, const char *tag, int id, const struct saml1__SubjectStatementAbstractType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__SubjectStatementAbstractType), type))
		return soap->error;
	if (!a->saml1__Subject)
	{	if (soap_element_nil(soap, "saml1:Subject"))
			return soap->error;
	}
	else
	if (soap_out_PointerTosaml1__SubjectType(soap, "saml1:Subject", -1, &a->saml1__Subject, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__SubjectStatementAbstractType * SOAP_FMAC4 soap_in_saml1__SubjectStatementAbstractType(struct soap *soap, const char *tag, struct saml1__SubjectStatementAbstractType *a, const char *type)
{
	size_t soap_flag_saml1__Subject = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml1__SubjectStatementAbstractType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__SubjectStatementAbstractType, sizeof(struct saml1__SubjectStatementAbstractType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__SubjectStatementAbstractType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__Subject && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml1__SubjectType(soap, "saml1:Subject", &a->saml1__Subject, "saml1:SubjectType"))
				{	soap_flag_saml1__Subject--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_saml1__Subject > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml1__SubjectStatementAbstractType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__SubjectStatementAbstractType, SOAP_TYPE_saml1__SubjectStatementAbstractType, sizeof(struct saml1__SubjectStatementAbstractType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__SubjectStatementAbstractType * SOAP_FMAC4 soap_new_saml1__SubjectStatementAbstractType(struct soap *soap, int n)
{
	struct saml1__SubjectStatementAbstractType *p;
	struct saml1__SubjectStatementAbstractType *a = (struct saml1__SubjectStatementAbstractType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__SubjectStatementAbstractType));
	for (p = a; p && n--; p++)
		soap_default_saml1__SubjectStatementAbstractType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__SubjectStatementAbstractType(struct soap *soap, const struct saml1__SubjectStatementAbstractType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__SubjectStatementAbstractType(soap, tag ? tag : "saml1:SubjectStatementAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__SubjectStatementAbstractType * SOAP_FMAC4 soap_get_saml1__SubjectStatementAbstractType(struct soap *soap, struct saml1__SubjectStatementAbstractType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__SubjectStatementAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__StatementAbstractType(struct soap *soap, struct saml1__StatementAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__StatementAbstractType(struct soap *soap, const struct saml1__StatementAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__StatementAbstractType(struct soap *soap, const char *tag, int id, const struct saml1__StatementAbstractType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__StatementAbstractType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__StatementAbstractType * SOAP_FMAC4 soap_in_saml1__StatementAbstractType(struct soap *soap, const char *tag, struct saml1__StatementAbstractType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml1__StatementAbstractType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__StatementAbstractType, sizeof(struct saml1__StatementAbstractType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__StatementAbstractType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__StatementAbstractType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__StatementAbstractType, SOAP_TYPE_saml1__StatementAbstractType, sizeof(struct saml1__StatementAbstractType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__StatementAbstractType * SOAP_FMAC4 soap_new_saml1__StatementAbstractType(struct soap *soap, int n)
{
	struct saml1__StatementAbstractType *p;
	struct saml1__StatementAbstractType *a = (struct saml1__StatementAbstractType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__StatementAbstractType));
	for (p = a; p && n--; p++)
		soap_default_saml1__StatementAbstractType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__StatementAbstractType(struct soap *soap, const struct saml1__StatementAbstractType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__StatementAbstractType(soap, tag ? tag : "saml1:StatementAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__StatementAbstractType * SOAP_FMAC4 soap_get_saml1__StatementAbstractType(struct soap *soap, struct saml1__StatementAbstractType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__StatementAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AdviceType(struct soap *soap, struct saml1__AdviceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_AdviceType = 0;
	a->__union_AdviceType = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AdviceType(struct soap *soap, const struct saml1__AdviceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_AdviceType)
	{	int i;
		for (i = 0; i < (int)a->__size_AdviceType; i++)
		{
			soap_serialize___saml1__union_AdviceType(soap, a->__union_AdviceType + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AdviceType(struct soap *soap, const char *tag, int id, const struct saml1__AdviceType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AdviceType), type))
		return soap->error;
	if (a->__union_AdviceType)
	{	int i;
		for (i = 0; i < (int)a->__size_AdviceType; i++)
			if (soap_out___saml1__union_AdviceType(soap, "-union-AdviceType", -1, a->__union_AdviceType + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AdviceType * SOAP_FMAC4 soap_in_saml1__AdviceType(struct soap *soap, const char *tag, struct saml1__AdviceType *a, const char *type)
{
	struct soap_blist *soap_blist___union_AdviceType = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml1__AdviceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AdviceType, sizeof(struct saml1__AdviceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AdviceType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_AdviceType == NULL)
				{	if (soap_blist___union_AdviceType == NULL)
						soap_blist___union_AdviceType = soap_alloc_block(soap);
					a->__union_AdviceType = (struct __saml1__union_AdviceType *)soap_push_block_max(soap, soap_blist___union_AdviceType, sizeof(struct __saml1__union_AdviceType));
					if (a->__union_AdviceType == NULL)
						return NULL;
					soap_default___saml1__union_AdviceType(soap, a->__union_AdviceType);
				}
				if (soap_in___saml1__union_AdviceType(soap, "-union-AdviceType", a->__union_AdviceType, "-saml1:union-AdviceType"))
				{	a->__size_AdviceType++;
					a->__union_AdviceType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_AdviceType)
			soap_pop_block(soap, soap_blist___union_AdviceType);
		if (a->__size_AdviceType)
		{	a->__union_AdviceType = (struct __saml1__union_AdviceType *)soap_save_block(soap, soap_blist___union_AdviceType, NULL, 1);
		}
		else
		{	a->__union_AdviceType = NULL;
			if (soap_blist___union_AdviceType)
				soap_end_block(soap, soap_blist___union_AdviceType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__AdviceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AdviceType, SOAP_TYPE_saml1__AdviceType, sizeof(struct saml1__AdviceType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__AdviceType * SOAP_FMAC4 soap_new_saml1__AdviceType(struct soap *soap, int n)
{
	struct saml1__AdviceType *p;
	struct saml1__AdviceType *a = (struct saml1__AdviceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__AdviceType));
	for (p = a; p && n--; p++)
		soap_default_saml1__AdviceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AdviceType(struct soap *soap, const struct saml1__AdviceType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AdviceType(soap, tag ? tag : "saml1:AdviceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AdviceType * SOAP_FMAC4 soap_get_saml1__AdviceType(struct soap *soap, struct saml1__AdviceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AdviceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__DoNotCacheConditionType(struct soap *soap, struct saml1__DoNotCacheConditionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__DoNotCacheConditionType(struct soap *soap, const struct saml1__DoNotCacheConditionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__DoNotCacheConditionType(struct soap *soap, const char *tag, int id, const struct saml1__DoNotCacheConditionType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__DoNotCacheConditionType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__DoNotCacheConditionType * SOAP_FMAC4 soap_in_saml1__DoNotCacheConditionType(struct soap *soap, const char *tag, struct saml1__DoNotCacheConditionType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml1__DoNotCacheConditionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__DoNotCacheConditionType, sizeof(struct saml1__DoNotCacheConditionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__DoNotCacheConditionType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__DoNotCacheConditionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__DoNotCacheConditionType, SOAP_TYPE_saml1__DoNotCacheConditionType, sizeof(struct saml1__DoNotCacheConditionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__DoNotCacheConditionType * SOAP_FMAC4 soap_new_saml1__DoNotCacheConditionType(struct soap *soap, int n)
{
	struct saml1__DoNotCacheConditionType *p;
	struct saml1__DoNotCacheConditionType *a = (struct saml1__DoNotCacheConditionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__DoNotCacheConditionType));
	for (p = a; p && n--; p++)
		soap_default_saml1__DoNotCacheConditionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__DoNotCacheConditionType(struct soap *soap, const struct saml1__DoNotCacheConditionType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__DoNotCacheConditionType(soap, tag ? tag : "saml1:DoNotCacheConditionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__DoNotCacheConditionType * SOAP_FMAC4 soap_get_saml1__DoNotCacheConditionType(struct soap *soap, struct saml1__DoNotCacheConditionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__DoNotCacheConditionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AudienceRestrictionConditionType(struct soap *soap, struct saml1__AudienceRestrictionConditionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAudience = 0;
	a->saml1__Audience = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AudienceRestrictionConditionType(struct soap *soap, const struct saml1__AudienceRestrictionConditionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->saml1__Audience)
	{	int i;
		for (i = 0; i < (int)a->__sizeAudience; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->saml1__Audience + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AudienceRestrictionConditionType(struct soap *soap, const char *tag, int id, const struct saml1__AudienceRestrictionConditionType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AudienceRestrictionConditionType), type))
		return soap->error;
	if (a->saml1__Audience)
	{	int i;
		for (i = 0; i < (int)a->__sizeAudience; i++)
			soap_out_string(soap, "saml1:Audience", -1, (char*const*)(a->saml1__Audience + i), "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AudienceRestrictionConditionType * SOAP_FMAC4 soap_in_saml1__AudienceRestrictionConditionType(struct soap *soap, const char *tag, struct saml1__AudienceRestrictionConditionType *a, const char *type)
{
	struct soap_blist *soap_blist_saml1__Audience = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml1__AudienceRestrictionConditionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AudienceRestrictionConditionType, sizeof(struct saml1__AudienceRestrictionConditionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AudienceRestrictionConditionType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "saml1:Audience", 1, NULL))
			{	if (a->saml1__Audience == NULL)
				{	if (soap_blist_saml1__Audience == NULL)
						soap_blist_saml1__Audience = soap_alloc_block(soap);
					a->saml1__Audience = (char **)soap_push_block_max(soap, soap_blist_saml1__Audience, sizeof(char *));
					if (a->saml1__Audience == NULL)
						return NULL;
					*a->saml1__Audience = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "saml1:Audience", (char**)a->saml1__Audience, "xsd:string"))
				{	a->__sizeAudience++;
					a->saml1__Audience = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->saml1__Audience)
			soap_pop_block(soap, soap_blist_saml1__Audience);
		if (a->__sizeAudience)
		{	a->saml1__Audience = (char **)soap_save_block(soap, soap_blist_saml1__Audience, NULL, 1);
		}
		else
		{	a->saml1__Audience = NULL;
			if (soap_blist_saml1__Audience)
				soap_end_block(soap, soap_blist_saml1__Audience);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeAudience < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct saml1__AudienceRestrictionConditionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AudienceRestrictionConditionType, SOAP_TYPE_saml1__AudienceRestrictionConditionType, sizeof(struct saml1__AudienceRestrictionConditionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__AudienceRestrictionConditionType * SOAP_FMAC4 soap_new_saml1__AudienceRestrictionConditionType(struct soap *soap, int n)
{
	struct saml1__AudienceRestrictionConditionType *p;
	struct saml1__AudienceRestrictionConditionType *a = (struct saml1__AudienceRestrictionConditionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__AudienceRestrictionConditionType));
	for (p = a; p && n--; p++)
		soap_default_saml1__AudienceRestrictionConditionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AudienceRestrictionConditionType(struct soap *soap, const struct saml1__AudienceRestrictionConditionType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AudienceRestrictionConditionType(soap, tag ? tag : "saml1:AudienceRestrictionConditionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AudienceRestrictionConditionType * SOAP_FMAC4 soap_get_saml1__AudienceRestrictionConditionType(struct soap *soap, struct saml1__AudienceRestrictionConditionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AudienceRestrictionConditionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__ConditionAbstractType(struct soap *soap, struct saml1__ConditionAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__ConditionAbstractType(struct soap *soap, const struct saml1__ConditionAbstractType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__ConditionAbstractType(struct soap *soap, const char *tag, int id, const struct saml1__ConditionAbstractType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__ConditionAbstractType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__ConditionAbstractType * SOAP_FMAC4 soap_in_saml1__ConditionAbstractType(struct soap *soap, const char *tag, struct saml1__ConditionAbstractType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml1__ConditionAbstractType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__ConditionAbstractType, sizeof(struct saml1__ConditionAbstractType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__ConditionAbstractType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__ConditionAbstractType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__ConditionAbstractType, SOAP_TYPE_saml1__ConditionAbstractType, sizeof(struct saml1__ConditionAbstractType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__ConditionAbstractType * SOAP_FMAC4 soap_new_saml1__ConditionAbstractType(struct soap *soap, int n)
{
	struct saml1__ConditionAbstractType *p;
	struct saml1__ConditionAbstractType *a = (struct saml1__ConditionAbstractType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__ConditionAbstractType));
	for (p = a; p && n--; p++)
		soap_default_saml1__ConditionAbstractType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__ConditionAbstractType(struct soap *soap, const struct saml1__ConditionAbstractType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__ConditionAbstractType(soap, tag ? tag : "saml1:ConditionAbstractType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__ConditionAbstractType * SOAP_FMAC4 soap_get_saml1__ConditionAbstractType(struct soap *soap, struct saml1__ConditionAbstractType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__ConditionAbstractType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__ConditionsType(struct soap *soap, struct saml1__ConditionsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_ConditionsType = 0;
	a->__union_ConditionsType = NULL;
	a->NotBefore = NULL;
	a->NotOnOrAfter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__ConditionsType(struct soap *soap, const struct saml1__ConditionsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_ConditionsType)
	{	int i;
		for (i = 0; i < (int)a->__size_ConditionsType; i++)
		{
			soap_serialize___saml1__union_ConditionsType(soap, a->__union_ConditionsType + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__ConditionsType(struct soap *soap, const char *tag, int id, const struct saml1__ConditionsType *a, const char *type)
{
	if (a->NotBefore)
		soap_set_attr(soap, "NotBefore", soap_dateTime2s(soap, *a->NotBefore), 1);
	if (a->NotOnOrAfter)
		soap_set_attr(soap, "NotOnOrAfter", soap_dateTime2s(soap, *a->NotOnOrAfter), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__ConditionsType), type))
		return soap->error;
	if (a->__union_ConditionsType)
	{	int i;
		for (i = 0; i < (int)a->__size_ConditionsType; i++)
			if (soap_out___saml1__union_ConditionsType(soap, "-union-ConditionsType", -1, a->__union_ConditionsType + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__ConditionsType * SOAP_FMAC4 soap_in_saml1__ConditionsType(struct soap *soap, const char *tag, struct saml1__ConditionsType *a, const char *type)
{
	struct soap_blist *soap_blist___union_ConditionsType = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml1__ConditionsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__ConditionsType, sizeof(struct saml1__ConditionsType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__ConditionsType(soap, a);
	{	const char *t = soap_attr_value(soap, "NotBefore", 0);
		if (t)
		{
			if (!(a->NotBefore = (time_t *)soap_malloc(soap, sizeof(time_t))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2dateTime(soap, t, a->NotBefore))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "NotOnOrAfter", 0);
		if (t)
		{
			if (!(a->NotOnOrAfter = (time_t *)soap_malloc(soap, sizeof(time_t))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2dateTime(soap, t, a->NotOnOrAfter))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_ConditionsType == NULL)
				{	if (soap_blist___union_ConditionsType == NULL)
						soap_blist___union_ConditionsType = soap_alloc_block(soap);
					a->__union_ConditionsType = (struct __saml1__union_ConditionsType *)soap_push_block_max(soap, soap_blist___union_ConditionsType, sizeof(struct __saml1__union_ConditionsType));
					if (a->__union_ConditionsType == NULL)
						return NULL;
					soap_default___saml1__union_ConditionsType(soap, a->__union_ConditionsType);
				}
				if (soap_in___saml1__union_ConditionsType(soap, "-union-ConditionsType", a->__union_ConditionsType, "-saml1:union-ConditionsType"))
				{	a->__size_ConditionsType++;
					a->__union_ConditionsType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_ConditionsType)
			soap_pop_block(soap, soap_blist___union_ConditionsType);
		if (a->__size_ConditionsType)
		{	a->__union_ConditionsType = (struct __saml1__union_ConditionsType *)soap_save_block(soap, soap_blist___union_ConditionsType, NULL, 1);
		}
		else
		{	a->__union_ConditionsType = NULL;
			if (soap_blist___union_ConditionsType)
				soap_end_block(soap, soap_blist___union_ConditionsType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__ConditionsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__ConditionsType, SOAP_TYPE_saml1__ConditionsType, sizeof(struct saml1__ConditionsType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__ConditionsType * SOAP_FMAC4 soap_new_saml1__ConditionsType(struct soap *soap, int n)
{
	struct saml1__ConditionsType *p;
	struct saml1__ConditionsType *a = (struct saml1__ConditionsType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__ConditionsType));
	for (p = a; p && n--; p++)
		soap_default_saml1__ConditionsType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__ConditionsType(struct soap *soap, const struct saml1__ConditionsType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__ConditionsType(soap, tag ? tag : "saml1:ConditionsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__ConditionsType * SOAP_FMAC4 soap_get_saml1__ConditionsType(struct soap *soap, struct saml1__ConditionsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__ConditionsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_saml1__AssertionType(struct soap *soap, struct saml1__AssertionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->saml1__Conditions = NULL;
	a->saml1__Advice = NULL;
	a->__size_AssertionType = 0;
	a->__union_AssertionType = NULL;
	a->ds__Signature = NULL;
	soap_default_string(soap, &a->MajorVersion);
	soap_default_string(soap, &a->MinorVersion);
	soap_default_string(soap, &a->AssertionID);
	soap_default_string(soap, &a->Issuer);
	soap_default_dateTime(soap, &a->IssueInstant);
	soap_default_string(soap, &a->wsu__Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_saml1__AssertionType(struct soap *soap, const struct saml1__AssertionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTosaml1__ConditionsType(soap, &a->saml1__Conditions);
	soap_serialize_PointerTosaml1__AdviceType(soap, &a->saml1__Advice);
	if (a->__union_AssertionType)
	{	int i;
		for (i = 0; i < (int)a->__size_AssertionType; i++)
		{
			soap_serialize___saml1__union_AssertionType(soap, a->__union_AssertionType + i);
		}
	}
	soap_serialize_PointerTo_ds__Signature(soap, &a->ds__Signature);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_saml1__AssertionType(struct soap *soap, const char *tag, int id, const struct saml1__AssertionType *a, const char *type)
{
	if (a->MajorVersion)
		soap_set_attr(soap, "MajorVersion", soap_string2s(soap, a->MajorVersion), 1);
	if (a->MinorVersion)
		soap_set_attr(soap, "MinorVersion", soap_string2s(soap, a->MinorVersion), 1);
	if (a->AssertionID)
		soap_set_attr(soap, "AssertionID", soap_string2s(soap, a->AssertionID), 1);
	if (a->Issuer)
		soap_set_attr(soap, "Issuer", soap_string2s(soap, a->Issuer), 1);
	soap_set_attr(soap, "IssueInstant", soap_dateTime2s(soap, a->IssueInstant), 1);
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_saml1__AssertionType), type))
		return soap->error;
	if (soap_out_PointerTosaml1__ConditionsType(soap, "saml1:Conditions", -1, &a->saml1__Conditions, ""))
		return soap->error;
	if (soap_out_PointerTosaml1__AdviceType(soap, "saml1:Advice", -1, &a->saml1__Advice, ""))
		return soap->error;
	if (a->__union_AssertionType)
	{	int i;
		for (i = 0; i < (int)a->__size_AssertionType; i++)
			if (soap_out___saml1__union_AssertionType(soap, "-union-AssertionType", -1, a->__union_AssertionType + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_ds__Signature(soap, "ds:Signature", -1, &a->ds__Signature, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct saml1__AssertionType * SOAP_FMAC4 soap_in_saml1__AssertionType(struct soap *soap, const char *tag, struct saml1__AssertionType *a, const char *type)
{
	size_t soap_flag_saml1__Conditions = 1;
	size_t soap_flag_saml1__Advice = 1;
	struct soap_blist *soap_blist___union_AssertionType = NULL;
	size_t soap_flag_ds__Signature = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct saml1__AssertionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_saml1__AssertionType, sizeof(struct saml1__AssertionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_saml1__AssertionType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "MajorVersion", 1), &a->MajorVersion))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "MinorVersion", 1), &a->MinorVersion))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "AssertionID", 1), &a->AssertionID))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Issuer", 1), &a->Issuer))
		return NULL;
	if (soap_s2dateTime(soap, soap_attr_value(soap, "IssueInstant", 1), &a->IssueInstant))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 1), &a->wsu__Id))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_saml1__Conditions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml1__ConditionsType(soap, "saml1:Conditions", &a->saml1__Conditions, "saml1:ConditionsType"))
				{	soap_flag_saml1__Conditions--;
					continue;
				}
			if (soap_flag_saml1__Advice && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTosaml1__AdviceType(soap, "saml1:Advice", &a->saml1__Advice, "saml1:AdviceType"))
				{	soap_flag_saml1__Advice--;
					continue;
				}
			if (soap_flag_ds__Signature && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ds__Signature(soap, "ds:Signature", &a->ds__Signature, ""))
				{	soap_flag_ds__Signature--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_AssertionType == NULL)
				{	if (soap_blist___union_AssertionType == NULL)
						soap_blist___union_AssertionType = soap_alloc_block(soap);
					a->__union_AssertionType = (struct __saml1__union_AssertionType *)soap_push_block_max(soap, soap_blist___union_AssertionType, sizeof(struct __saml1__union_AssertionType));
					if (a->__union_AssertionType == NULL)
						return NULL;
					soap_default___saml1__union_AssertionType(soap, a->__union_AssertionType);
				}
				if (soap_in___saml1__union_AssertionType(soap, "-union-AssertionType", a->__union_AssertionType, "-saml1:union-AssertionType"))
				{	a->__size_AssertionType++;
					a->__union_AssertionType = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_AssertionType)
			soap_pop_block(soap, soap_blist___union_AssertionType);
		if (a->__size_AssertionType)
		{	a->__union_AssertionType = (struct __saml1__union_AssertionType *)soap_save_block(soap, soap_blist___union_AssertionType, NULL, 1);
		}
		else
		{	a->__union_AssertionType = NULL;
			if (soap_blist___union_AssertionType)
				soap_end_block(soap, soap_blist___union_AssertionType);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct saml1__AssertionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_saml1__AssertionType, SOAP_TYPE_saml1__AssertionType, sizeof(struct saml1__AssertionType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct saml1__AssertionType * SOAP_FMAC4 soap_new_saml1__AssertionType(struct soap *soap, int n)
{
	struct saml1__AssertionType *p;
	struct saml1__AssertionType *a = (struct saml1__AssertionType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct saml1__AssertionType));
	for (p = a; p && n--; p++)
		soap_default_saml1__AssertionType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_saml1__AssertionType(struct soap *soap, const struct saml1__AssertionType *a, const char *tag, const char *type)
{
	if (soap_out_saml1__AssertionType(soap, tag ? tag : "saml1:AssertionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct saml1__AssertionType * SOAP_FMAC4 soap_get_saml1__AssertionType(struct soap *soap, struct saml1__AssertionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_saml1__AssertionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsc__DerivedKeyTokenType_sequence(struct soap *soap, struct __wsc__DerivedKeyTokenType_sequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__union_DerivedKeyTokenType = -1;
	a->Length = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsc__DerivedKeyTokenType_sequence(struct soap *soap, const struct __wsc__DerivedKeyTokenType_sequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsc__union_DerivedKeyTokenType(soap, a->__union_DerivedKeyTokenType, &a->union_DerivedKeyTokenType);
	soap_serialize_PointerToULONG64(soap, &a->Length);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsc__DerivedKeyTokenType_sequence(struct soap *soap, const char *tag, int id, const struct __wsc__DerivedKeyTokenType_sequence *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out__wsc__union_DerivedKeyTokenType(soap, a->__union_DerivedKeyTokenType, &a->union_DerivedKeyTokenType))
		return soap->error;
	if (soap_out_PointerToULONG64(soap, "wsc:Length", -1, &a->Length, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsc__DerivedKeyTokenType_sequence * SOAP_FMAC4 soap_in___wsc__DerivedKeyTokenType_sequence(struct soap *soap, const char *tag, struct __wsc__DerivedKeyTokenType_sequence *a, const char *type)
{
	size_t soap_flag_union_DerivedKeyTokenType = 1;
	size_t soap_flag_Length = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsc__DerivedKeyTokenType_sequence *)soap_id_enter(soap, "", a, SOAP_TYPE___wsc__DerivedKeyTokenType_sequence, sizeof(struct __wsc__DerivedKeyTokenType_sequence), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsc__DerivedKeyTokenType_sequence(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_union_DerivedKeyTokenType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__wsc__union_DerivedKeyTokenType(soap, &a->__union_DerivedKeyTokenType, &a->union_DerivedKeyTokenType))
				{	soap_flag_union_DerivedKeyTokenType = 0;
					continue;
				}
			if (soap_flag_Length && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToULONG64(soap, "wsc:Length", &a->Length, "xsd:unsignedLong"))
				{	soap_flag_Length--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_DerivedKeyTokenType))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __wsc__DerivedKeyTokenType_sequence * SOAP_FMAC4 soap_new___wsc__DerivedKeyTokenType_sequence(struct soap *soap, int n)
{
	struct __wsc__DerivedKeyTokenType_sequence *p;
	struct __wsc__DerivedKeyTokenType_sequence *a = (struct __wsc__DerivedKeyTokenType_sequence*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __wsc__DerivedKeyTokenType_sequence));
	for (p = a; p && n--; p++)
		soap_default___wsc__DerivedKeyTokenType_sequence(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsc__DerivedKeyTokenType_sequence(struct soap *soap, const struct __wsc__DerivedKeyTokenType_sequence *a, const char *tag, const char *type)
{
	if (soap_out___wsc__DerivedKeyTokenType_sequence(soap, tag ? tag : "-wsc:DerivedKeyTokenType-sequence", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsc__DerivedKeyTokenType_sequence * SOAP_FMAC4 soap_get___wsc__DerivedKeyTokenType_sequence(struct soap *soap, struct __wsc__DerivedKeyTokenType_sequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsc__DerivedKeyTokenType_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsc__PropertiesType(struct soap *soap, struct wsc__PropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsc__PropertiesType(struct soap *soap, const struct wsc__PropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsc__PropertiesType(struct soap *soap, const char *tag, int id, const struct wsc__PropertiesType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsc__PropertiesType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsc__PropertiesType * SOAP_FMAC4 soap_in_wsc__PropertiesType(struct soap *soap, const char *tag, struct wsc__PropertiesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsc__PropertiesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsc__PropertiesType, sizeof(struct wsc__PropertiesType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsc__PropertiesType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsc__PropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsc__PropertiesType, SOAP_TYPE_wsc__PropertiesType, sizeof(struct wsc__PropertiesType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsc__PropertiesType * SOAP_FMAC4 soap_new_wsc__PropertiesType(struct soap *soap, int n)
{
	struct wsc__PropertiesType *p;
	struct wsc__PropertiesType *a = (struct wsc__PropertiesType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsc__PropertiesType));
	for (p = a; p && n--; p++)
		soap_default_wsc__PropertiesType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsc__PropertiesType(struct soap *soap, const struct wsc__PropertiesType *a, const char *tag, const char *type)
{
	if (soap_out_wsc__PropertiesType(soap, tag ? tag : "wsc:PropertiesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsc__PropertiesType * SOAP_FMAC4 soap_get_wsc__PropertiesType(struct soap *soap, struct wsc__PropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsc__PropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsc__DerivedKeyTokenType(struct soap *soap, struct wsc__DerivedKeyTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsse__SecurityTokenReference = NULL;
	a->Properties = NULL;
	a->__DerivedKeyTokenType_sequence = NULL;
	soap_default_string(soap, &a->Label);
	soap_default_string(soap, &a->Nonce);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsc__DerivedKeyTokenType(struct soap *soap, const struct wsc__DerivedKeyTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, &a->wsse__SecurityTokenReference);
	soap_serialize_PointerTowsc__PropertiesType(soap, &a->Properties);
	soap_serialize_PointerTo__wsc__DerivedKeyTokenType_sequence(soap, &a->__DerivedKeyTokenType_sequence);
	soap_serialize_string(soap, (char*const*)&a->Label);
	soap_serialize_string(soap, (char*const*)&a->Nonce);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsc__DerivedKeyTokenType(struct soap *soap, const char *tag, int id, const struct wsc__DerivedKeyTokenType *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", soap_string2s(soap, a->Algorithm), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsc__DerivedKeyTokenType), type))
		return soap->error;
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", -1, &a->wsse__SecurityTokenReference, ""))
		return soap->error;
	if (soap_out_PointerTowsc__PropertiesType(soap, "wsc:Properties", -1, &a->Properties, ""))
		return soap->error;
	if (soap_out_PointerTo__wsc__DerivedKeyTokenType_sequence(soap, "-DerivedKeyTokenType-sequence", -1, &a->__DerivedKeyTokenType_sequence, ""))
		return soap->error;
	if (soap_out_string(soap, "wsc:Label", -1, (char*const*)&a->Label, ""))
		return soap->error;
	if (soap_out_string(soap, "wsc:Nonce", -1, (char*const*)&a->Nonce, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsc__DerivedKeyTokenType * SOAP_FMAC4 soap_in_wsc__DerivedKeyTokenType(struct soap *soap, const char *tag, struct wsc__DerivedKeyTokenType *a, const char *type)
{
	size_t soap_flag_wsse__SecurityTokenReference = 1;
	size_t soap_flag_Properties = 1;
	size_t soap_flag___DerivedKeyTokenType_sequence = 1;
	size_t soap_flag_Label = 1;
	size_t soap_flag_Nonce = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsc__DerivedKeyTokenType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsc__DerivedKeyTokenType, sizeof(struct wsc__DerivedKeyTokenType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsc__DerivedKeyTokenType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 0), &a->Algorithm))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsse__SecurityTokenReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", &a->wsse__SecurityTokenReference, ""))
				{	soap_flag_wsse__SecurityTokenReference--;
					continue;
				}
			if (soap_flag_Properties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsc__PropertiesType(soap, "wsc:Properties", &a->Properties, "wsc:PropertiesType"))
				{	soap_flag_Properties--;
					continue;
				}
			if (soap_flag_Label && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsc:Label", (char**)&a->Label, "xsd:string"))
				{	soap_flag_Label--;
					continue;
				}
			if (soap_flag_Nonce && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsc:Nonce", (char**)&a->Nonce, "xsd:string"))
				{	soap_flag_Nonce--;
					continue;
				}
			if (soap_flag___DerivedKeyTokenType_sequence && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo__wsc__DerivedKeyTokenType_sequence(soap, "-DerivedKeyTokenType-sequence", &a->__DerivedKeyTokenType_sequence, "-wsc:DerivedKeyTokenType-sequence"))
				{	soap_flag___DerivedKeyTokenType_sequence--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsc__DerivedKeyTokenType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsc__DerivedKeyTokenType, SOAP_TYPE_wsc__DerivedKeyTokenType, sizeof(struct wsc__DerivedKeyTokenType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsc__DerivedKeyTokenType * SOAP_FMAC4 soap_new_wsc__DerivedKeyTokenType(struct soap *soap, int n)
{
	struct wsc__DerivedKeyTokenType *p;
	struct wsc__DerivedKeyTokenType *a = (struct wsc__DerivedKeyTokenType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsc__DerivedKeyTokenType));
	for (p = a; p && n--; p++)
		soap_default_wsc__DerivedKeyTokenType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsc__DerivedKeyTokenType(struct soap *soap, const struct wsc__DerivedKeyTokenType *a, const char *tag, const char *type)
{
	if (soap_out_wsc__DerivedKeyTokenType(soap, tag ? tag : "wsc:DerivedKeyTokenType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsc__DerivedKeyTokenType * SOAP_FMAC4 soap_get_wsc__DerivedKeyTokenType(struct soap *soap, struct wsc__DerivedKeyTokenType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsc__DerivedKeyTokenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsc__SecurityContextTokenType(struct soap *soap, struct wsc__SecurityContextTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Identifier);
	soap_default_string(soap, &a->Instance);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsc__SecurityContextTokenType(struct soap *soap, const struct wsc__SecurityContextTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Identifier);
	soap_serialize_string(soap, (char*const*)&a->Instance);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsc__SecurityContextTokenType(struct soap *soap, const char *tag, int id, const struct wsc__SecurityContextTokenType *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", soap_string2s(soap, a->wsu__Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsc__SecurityContextTokenType), type))
		return soap->error;
	if (soap_out_string(soap, "wsc:Identifier", -1, (char*const*)&a->Identifier, ""))
		return soap->error;
	if (soap_out_string(soap, "wsc:Instance", -1, (char*const*)&a->Instance, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsc__SecurityContextTokenType * SOAP_FMAC4 soap_in_wsc__SecurityContextTokenType(struct soap *soap, const char *tag, struct wsc__SecurityContextTokenType *a, const char *type)
{
	size_t soap_flag_Identifier = 1;
	size_t soap_flag_Instance = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsc__SecurityContextTokenType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsc__SecurityContextTokenType, sizeof(struct wsc__SecurityContextTokenType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsc__SecurityContextTokenType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Identifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsc:Identifier", (char**)&a->Identifier, "xsd:string"))
				{	soap_flag_Identifier--;
					continue;
				}
			if (soap_flag_Instance && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsc:Instance", (char**)&a->Instance, "xsd:string"))
				{	soap_flag_Instance--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsc__SecurityContextTokenType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsc__SecurityContextTokenType, SOAP_TYPE_wsc__SecurityContextTokenType, sizeof(struct wsc__SecurityContextTokenType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsc__SecurityContextTokenType * SOAP_FMAC4 soap_new_wsc__SecurityContextTokenType(struct soap *soap, int n)
{
	struct wsc__SecurityContextTokenType *p;
	struct wsc__SecurityContextTokenType *a = (struct wsc__SecurityContextTokenType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsc__SecurityContextTokenType));
	for (p = a; p && n--; p++)
		soap_default_wsc__SecurityContextTokenType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsc__SecurityContextTokenType(struct soap *soap, const struct wsc__SecurityContextTokenType *a, const char *tag, const char *type)
{
	if (soap_out_wsc__SecurityContextTokenType(soap, tag ? tag : "wsc:SecurityContextTokenType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsc__SecurityContextTokenType * SOAP_FMAC4 soap_get_wsc__SecurityContextTokenType(struct soap *soap, struct wsc__SecurityContextTokenType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsc__SecurityContextTokenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DataReference = NULL;
	a->KeyReference = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___xenc__union_ReferenceList(struct soap *soap, const struct __xenc__union_ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxenc__ReferenceType(soap, &a->DataReference);
	soap_serialize_PointerToxenc__ReferenceType(soap, &a->KeyReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___xenc__union_ReferenceList(struct soap *soap, const char *tag, int id, const struct __xenc__union_ReferenceList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerToxenc__ReferenceType(soap, "xenc:DataReference", -1, &a->DataReference, ""))
		return soap->error;
	if (soap_out_PointerToxenc__ReferenceType(soap, "xenc:KeyReference", -1, &a->KeyReference, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __xenc__union_ReferenceList * SOAP_FMAC4 soap_in___xenc__union_ReferenceList(struct soap *soap, const char *tag, struct __xenc__union_ReferenceList *a, const char *type)
{
	size_t soap_flag_DataReference = 1;
	size_t soap_flag_KeyReference = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __xenc__union_ReferenceList *)soap_id_enter(soap, "", a, SOAP_TYPE___xenc__union_ReferenceList, sizeof(struct __xenc__union_ReferenceList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___xenc__union_ReferenceList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DataReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__ReferenceType(soap, "xenc:DataReference", &a->DataReference, "xenc:ReferenceType"))
				{	soap_flag_DataReference--;
					continue;
				}
			if (soap_flag_KeyReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__ReferenceType(soap, "xenc:KeyReference", &a->KeyReference, "xenc:ReferenceType"))
				{	soap_flag_KeyReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __xenc__union_ReferenceList * SOAP_FMAC4 soap_new___xenc__union_ReferenceList(struct soap *soap, int n)
{
	struct __xenc__union_ReferenceList *p;
	struct __xenc__union_ReferenceList *a = (struct __xenc__union_ReferenceList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __xenc__union_ReferenceList));
	for (p = a; p && n--; p++)
		soap_default___xenc__union_ReferenceList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___xenc__union_ReferenceList(struct soap *soap, const struct __xenc__union_ReferenceList *a, const char *tag, const char *type)
{
	if (soap_out___xenc__union_ReferenceList(soap, tag ? tag : "-xenc:union-ReferenceList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __xenc__union_ReferenceList * SOAP_FMAC4 soap_get___xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *p, const char *tag, const char *type)
{
	if ((p = soap_in___xenc__union_ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_ReferenceList = 0;
	a->__union_ReferenceList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__xenc__ReferenceList(struct soap *soap, const struct _xenc__ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_ReferenceList)
	{	int i;
		for (i = 0; i < (int)a->__size_ReferenceList; i++)
		{
			soap_serialize___xenc__union_ReferenceList(soap, a->__union_ReferenceList + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__xenc__ReferenceList(struct soap *soap, const char *tag, int id, const struct _xenc__ReferenceList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__xenc__ReferenceList), type))
		return soap->error;
	if (a->__union_ReferenceList)
	{	int i;
		for (i = 0; i < (int)a->__size_ReferenceList; i++)
			if (soap_out___xenc__union_ReferenceList(soap, "-union-ReferenceList", -1, a->__union_ReferenceList + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _xenc__ReferenceList * SOAP_FMAC4 soap_in__xenc__ReferenceList(struct soap *soap, const char *tag, struct _xenc__ReferenceList *a, const char *type)
{
	struct soap_blist *soap_blist___union_ReferenceList = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _xenc__ReferenceList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__xenc__ReferenceList, sizeof(struct _xenc__ReferenceList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__xenc__ReferenceList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_ReferenceList == NULL)
				{	if (soap_blist___union_ReferenceList == NULL)
						soap_blist___union_ReferenceList = soap_alloc_block(soap);
					a->__union_ReferenceList = (struct __xenc__union_ReferenceList *)soap_push_block_max(soap, soap_blist___union_ReferenceList, sizeof(struct __xenc__union_ReferenceList));
					if (a->__union_ReferenceList == NULL)
						return NULL;
					soap_default___xenc__union_ReferenceList(soap, a->__union_ReferenceList);
				}
				if (soap_in___xenc__union_ReferenceList(soap, "-union-ReferenceList", a->__union_ReferenceList, "-xenc:union-ReferenceList"))
				{	a->__size_ReferenceList++;
					a->__union_ReferenceList = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_ReferenceList)
			soap_pop_block(soap, soap_blist___union_ReferenceList);
		if (a->__size_ReferenceList)
		{	a->__union_ReferenceList = (struct __xenc__union_ReferenceList *)soap_save_block(soap, soap_blist___union_ReferenceList, NULL, 1);
		}
		else
		{	a->__union_ReferenceList = NULL;
			if (soap_blist___union_ReferenceList)
				soap_end_block(soap, soap_blist___union_ReferenceList);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__size_ReferenceList < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _xenc__ReferenceList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__xenc__ReferenceList, SOAP_TYPE__xenc__ReferenceList, sizeof(struct _xenc__ReferenceList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _xenc__ReferenceList * SOAP_FMAC4 soap_new__xenc__ReferenceList(struct soap *soap, int n)
{
	struct _xenc__ReferenceList *p;
	struct _xenc__ReferenceList *a = (struct _xenc__ReferenceList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _xenc__ReferenceList));
	for (p = a; p && n--; p++)
		soap_default__xenc__ReferenceList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xenc__ReferenceList(struct soap *soap, const struct _xenc__ReferenceList *a, const char *tag, const char *type)
{
	if (soap_out__xenc__ReferenceList(soap, tag ? tag : "xenc:ReferenceList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _xenc__ReferenceList * SOAP_FMAC4 soap_get__xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *p, const char *tag, const char *type)
{
	if ((p = soap_in__xenc__ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Target);
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptionPropertyType(struct soap *soap, const struct xenc__EncryptionPropertyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptionPropertyType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptionPropertyType *a, const char *type)
{
	if (a->Target)
		soap_set_attr(soap, "Target", soap_string2s(soap, a->Target), 1);
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptionPropertyType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType * SOAP_FMAC4 soap_in_xenc__EncryptionPropertyType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertyType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptionPropertyType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionPropertyType, sizeof(struct xenc__EncryptionPropertyType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptionPropertyType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Target", 0), &a->Target))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionPropertyType, SOAP_TYPE_xenc__EncryptionPropertyType, sizeof(struct xenc__EncryptionPropertyType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType * SOAP_FMAC4 soap_new_xenc__EncryptionPropertyType(struct soap *soap, int n)
{
	struct xenc__EncryptionPropertyType *p;
	struct xenc__EncryptionPropertyType *a = (struct xenc__EncryptionPropertyType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct xenc__EncryptionPropertyType));
	for (p = a; p && n--; p++)
		soap_default_xenc__EncryptionPropertyType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptionPropertyType(struct soap *soap, const struct xenc__EncryptionPropertyType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__EncryptionPropertyType(soap, tag ? tag : "xenc:EncryptionPropertyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType * SOAP_FMAC4 soap_get_xenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptionPropertyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeEncryptionProperty = 0;
	a->EncryptionProperty = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptionPropertiesType(struct soap *soap, const struct xenc__EncryptionPropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->EncryptionProperty)
	{	int i;
		for (i = 0; i < (int)a->__sizeEncryptionProperty; i++)
		{
			soap_embedded(soap, a->EncryptionProperty + i, SOAP_TYPE_xenc__EncryptionPropertyType);
			soap_serialize_xenc__EncryptionPropertyType(soap, a->EncryptionProperty + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptionPropertiesType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptionPropertiesType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptionPropertiesType), type))
		return soap->error;
	if (a->EncryptionProperty)
	{	int i;
		for (i = 0; i < (int)a->__sizeEncryptionProperty; i++)
			if (soap_out_xenc__EncryptionPropertyType(soap, "xenc:EncryptionProperty", -1, a->EncryptionProperty + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType * SOAP_FMAC4 soap_in_xenc__EncryptionPropertiesType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertiesType *a, const char *type)
{
	struct soap_blist *soap_blist_EncryptionProperty = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptionPropertiesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionPropertiesType, sizeof(struct xenc__EncryptionPropertiesType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptionPropertiesType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "xenc:EncryptionProperty", 1, NULL))
			{	if (a->EncryptionProperty == NULL)
				{	if (soap_blist_EncryptionProperty == NULL)
						soap_blist_EncryptionProperty = soap_alloc_block(soap);
					a->EncryptionProperty = (struct xenc__EncryptionPropertyType *)soap_push_block_max(soap, soap_blist_EncryptionProperty, sizeof(struct xenc__EncryptionPropertyType));
					if (a->EncryptionProperty == NULL)
						return NULL;
					soap_default_xenc__EncryptionPropertyType(soap, a->EncryptionProperty);
				}
				soap_revert(soap);
				if (soap_in_xenc__EncryptionPropertyType(soap, "xenc:EncryptionProperty", a->EncryptionProperty, "xenc:EncryptionPropertyType"))
				{	a->__sizeEncryptionProperty++;
					a->EncryptionProperty = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->EncryptionProperty)
			soap_pop_block(soap, soap_blist_EncryptionProperty);
		if (a->__sizeEncryptionProperty)
		{	a->EncryptionProperty = (struct xenc__EncryptionPropertyType *)soap_save_block(soap, soap_blist_EncryptionProperty, NULL, 1);
		}
		else
		{	a->EncryptionProperty = NULL;
			if (soap_blist_EncryptionProperty)
				soap_end_block(soap, soap_blist_EncryptionProperty);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeEncryptionProperty < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionPropertiesType, SOAP_TYPE_xenc__EncryptionPropertiesType, sizeof(struct xenc__EncryptionPropertiesType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType * SOAP_FMAC4 soap_new_xenc__EncryptionPropertiesType(struct soap *soap, int n)
{
	struct xenc__EncryptionPropertiesType *p;
	struct xenc__EncryptionPropertiesType *a = (struct xenc__EncryptionPropertiesType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct xenc__EncryptionPropertiesType));
	for (p = a; p && n--; p++)
		soap_default_xenc__EncryptionPropertiesType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptionPropertiesType(struct soap *soap, const struct xenc__EncryptionPropertiesType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__EncryptionPropertiesType(soap, tag ? tag : "xenc:EncryptionPropertiesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType * SOAP_FMAC4 soap_get_xenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptionPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->URI);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__ReferenceType(struct soap *soap, const struct xenc__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__ReferenceType(struct soap *soap, const char *tag, int id, const struct xenc__ReferenceType *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", soap_string2s(soap, a->URI), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__ReferenceType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__ReferenceType * SOAP_FMAC4 soap_in_xenc__ReferenceType(struct soap *soap, const char *tag, struct xenc__ReferenceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__ReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__ReferenceType, sizeof(struct xenc__ReferenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__ReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 1), &a->URI))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__ReferenceType, SOAP_TYPE_xenc__ReferenceType, sizeof(struct xenc__ReferenceType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct xenc__ReferenceType * SOAP_FMAC4 soap_new_xenc__ReferenceType(struct soap *soap, int n)
{
	struct xenc__ReferenceType *p;
	struct xenc__ReferenceType *a = (struct xenc__ReferenceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct xenc__ReferenceType));
	for (p = a; p && n--; p++)
		soap_default_xenc__ReferenceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__ReferenceType(struct soap *soap, const struct xenc__ReferenceType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__ReferenceType(soap, tag ? tag : "xenc:ReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__ReferenceType * SOAP_FMAC4 soap_get_xenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__AgreementMethodType(struct soap *soap, struct xenc__AgreementMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->KA_Nonce);
	a->OriginatorKeyInfo = NULL;
	a->RecipientKeyInfo = NULL;
	soap_default_string(soap, &a->Algorithm);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__AgreementMethodType(struct soap *soap, const struct xenc__AgreementMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->KA_Nonce);
	soap_serialize_PointerTods__KeyInfoType(soap, &a->OriginatorKeyInfo);
	soap_serialize_PointerTods__KeyInfoType(soap, &a->RecipientKeyInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__AgreementMethodType(struct soap *soap, const char *tag, int id, const struct xenc__AgreementMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", soap_string2s(soap, a->Algorithm), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__AgreementMethodType), type))
		return soap->error;
	if (soap_out_string(soap, "xenc:KA-Nonce", -1, (char*const*)&a->KA_Nonce, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyInfoType(soap, "xenc:OriginatorKeyInfo", -1, &a->OriginatorKeyInfo, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyInfoType(soap, "xenc:RecipientKeyInfo", -1, &a->RecipientKeyInfo, ""))
		return soap->error;
	soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__AgreementMethodType * SOAP_FMAC4 soap_in_xenc__AgreementMethodType(struct soap *soap, const char *tag, struct xenc__AgreementMethodType *a, const char *type)
{
	size_t soap_flag_KA_Nonce = 1;
	size_t soap_flag_OriginatorKeyInfo = 1;
	size_t soap_flag_RecipientKeyInfo = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__AgreementMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__AgreementMethodType, sizeof(struct xenc__AgreementMethodType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__AgreementMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_KA_Nonce && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "xenc:KA-Nonce", (char**)&a->KA_Nonce, "xsd:string"))
				{	soap_flag_KA_Nonce--;
					continue;
				}
			if (soap_flag_OriginatorKeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__KeyInfoType(soap, "xenc:OriginatorKeyInfo", &a->OriginatorKeyInfo, "ds:KeyInfoType"))
				{	soap_flag_OriginatorKeyInfo--;
					continue;
				}
			if (soap_flag_RecipientKeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__KeyInfoType(soap, "xenc:RecipientKeyInfo", &a->RecipientKeyInfo, "ds:KeyInfoType"))
				{	soap_flag_RecipientKeyInfo--;
					continue;
				}
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__AgreementMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__AgreementMethodType, SOAP_TYPE_xenc__AgreementMethodType, sizeof(struct xenc__AgreementMethodType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct xenc__AgreementMethodType * SOAP_FMAC4 soap_new_xenc__AgreementMethodType(struct soap *soap, int n)
{
	struct xenc__AgreementMethodType *p;
	struct xenc__AgreementMethodType *a = (struct xenc__AgreementMethodType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct xenc__AgreementMethodType));
	for (p = a; p && n--; p++)
		soap_default_xenc__AgreementMethodType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__AgreementMethodType(struct soap *soap, const struct xenc__AgreementMethodType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__AgreementMethodType(soap, tag ? tag : "xenc:AgreementMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__AgreementMethodType * SOAP_FMAC4 soap_get_xenc__AgreementMethodType(struct soap *soap, struct xenc__AgreementMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__AgreementMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EncryptionMethod = NULL;
	a->ds__KeyInfo = NULL;
	a->CipherData = NULL;
	a->EncryptionProperties = NULL;
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->Type);
	soap_default_string(soap, &a->MimeType);
	soap_default_string(soap, &a->Encoding);
	a->ReferenceList = NULL;
	soap_default_string(soap, &a->CarriedKeyName);
	soap_default_string(soap, &a->Recipient);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptedKeyType(struct soap *soap, const struct xenc__EncryptedKeyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxenc__EncryptionMethodType(soap, &a->EncryptionMethod);
	soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
	soap_serialize_PointerToxenc__CipherDataType(soap, &a->CipherData);
	soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, &a->EncryptionProperties);
	soap_serialize_PointerTo_xenc__ReferenceList(soap, &a->ReferenceList);
	soap_serialize_string(soap, (char*const*)&a->CarriedKeyName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptedKeyType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptedKeyType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap_string2s(soap, a->Type), 1);
	if (a->MimeType)
		soap_set_attr(soap, "MimeType", soap_string2s(soap, a->MimeType), 1);
	if (a->Encoding)
		soap_set_attr(soap, "Encoding", soap_string2s(soap, a->Encoding), 1);
	if (a->Recipient)
		soap_set_attr(soap, "Recipient", soap_string2s(soap, a->Recipient), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptedKeyType), type))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", -1, &a->EncryptionMethod, ""))
		return soap->error;
	if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
		return soap->error;
	if (!a->CipherData)
	{	if (soap_element_nil(soap, "xenc:CipherData"))
			return soap->error;
	}
	else
	if (soap_out_PointerToxenc__CipherDataType(soap, "xenc:CipherData", -1, &a->CipherData, ""))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", -1, &a->EncryptionProperties, ""))
		return soap->error;
	if (soap_out_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", -1, &a->ReferenceList, ""))
		return soap->error;
	if (soap_out_string(soap, "xenc:CarriedKeyName", -1, (char*const*)&a->CarriedKeyName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType * SOAP_FMAC4 soap_in_xenc__EncryptedKeyType(struct soap *soap, const char *tag, struct xenc__EncryptedKeyType *a, const char *type)
{
	size_t soap_flag_EncryptionMethod = 1;
	size_t soap_flag_ds__KeyInfo = 1;
	size_t soap_flag_CipherData = 1;
	size_t soap_flag_EncryptionProperties = 1;
	size_t soap_flag_ReferenceList = 1;
	size_t soap_flag_CarriedKeyName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptedKeyType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptedKeyType, sizeof(struct xenc__EncryptedKeyType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptedKeyType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "MimeType", 0), &a->MimeType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Encoding", 0), &a->Encoding))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Recipient", 0), &a->Recipient))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EncryptionMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", &a->EncryptionMethod, "xenc:EncryptionMethodType"))
				{	soap_flag_EncryptionMethod--;
					continue;
				}
			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, ""))
				{	soap_flag_ds__KeyInfo--;
					continue;
				}
			if (soap_flag_CipherData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__CipherDataType(soap, "xenc:CipherData", &a->CipherData, "xenc:CipherDataType"))
				{	soap_flag_CipherData--;
					continue;
				}
			if (soap_flag_EncryptionProperties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", &a->EncryptionProperties, "xenc:EncryptionPropertiesType"))
				{	soap_flag_EncryptionProperties--;
					continue;
				}
			if (soap_flag_ReferenceList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", &a->ReferenceList, ""))
				{	soap_flag_ReferenceList--;
					continue;
				}
			if (soap_flag_CarriedKeyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "xenc:CarriedKeyName", (char**)&a->CarriedKeyName, "xsd:string"))
				{	soap_flag_CarriedKeyName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CipherData > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct xenc__EncryptedKeyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptedKeyType, SOAP_TYPE_xenc__EncryptedKeyType, sizeof(struct xenc__EncryptedKeyType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct xenc__EncryptedKeyType * SOAP_FMAC4 soap_new_xenc__EncryptedKeyType(struct soap *soap, int n)
{
	struct xenc__EncryptedKeyType *p;
	struct xenc__EncryptedKeyType *a = (struct xenc__EncryptedKeyType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct xenc__EncryptedKeyType));
	for (p = a; p && n--; p++)
		soap_default_xenc__EncryptedKeyType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptedKeyType(struct soap *soap, const struct xenc__EncryptedKeyType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__EncryptedKeyType(soap, tag ? tag : "xenc:EncryptedKeyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType * SOAP_FMAC4 soap_get_xenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptedKeyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptedDataType(struct soap *soap, struct xenc__EncryptedDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EncryptionMethod = NULL;
	a->ds__KeyInfo = NULL;
	a->CipherData = NULL;
	a->EncryptionProperties = NULL;
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->Type);
	soap_default_string(soap, &a->MimeType);
	soap_default_string(soap, &a->Encoding);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptedDataType(struct soap *soap, const struct xenc__EncryptedDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxenc__EncryptionMethodType(soap, &a->EncryptionMethod);
	soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
	soap_serialize_PointerToxenc__CipherDataType(soap, &a->CipherData);
	soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, &a->EncryptionProperties);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptedDataType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptedDataType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap_string2s(soap, a->Type), 1);
	if (a->MimeType)
		soap_set_attr(soap, "MimeType", soap_string2s(soap, a->MimeType), 1);
	if (a->Encoding)
		soap_set_attr(soap, "Encoding", soap_string2s(soap, a->Encoding), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptedDataType), type))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", -1, &a->EncryptionMethod, ""))
		return soap->error;
	if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
		return soap->error;
	if (!a->CipherData)
	{	if (soap_element_nil(soap, "xenc:CipherData"))
			return soap->error;
	}
	else
	if (soap_out_PointerToxenc__CipherDataType(soap, "xenc:CipherData", -1, &a->CipherData, ""))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", -1, &a->EncryptionProperties, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptedDataType * SOAP_FMAC4 soap_in_xenc__EncryptedDataType(struct soap *soap, const char *tag, struct xenc__EncryptedDataType *a, const char *type)
{
	size_t soap_flag_EncryptionMethod = 1;
	size_t soap_flag_ds__KeyInfo = 1;
	size_t soap_flag_CipherData = 1;
	size_t soap_flag_EncryptionProperties = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptedDataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptedDataType, sizeof(struct xenc__EncryptedDataType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptedDataType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "MimeType", 0), &a->MimeType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Encoding", 0), &a->Encoding))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EncryptionMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", &a->EncryptionMethod, "xenc:EncryptionMethodType"))
				{	soap_flag_EncryptionMethod--;
					continue;
				}
			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, ""))
				{	soap_flag_ds__KeyInfo--;
					continue;
				}
			if (soap_flag_CipherData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__CipherDataType(soap, "xenc:CipherData", &a->CipherData, "xenc:CipherDataType"))
				{	soap_flag_CipherData--;
					continue;
				}
			if (soap_flag_EncryptionProperties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", &a->EncryptionProperties, "xenc:EncryptionPropertiesType"))
				{	soap_flag_EncryptionProperties--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CipherData > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct xenc__EncryptedDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptedDataType, SOAP_TYPE_xenc__EncryptedDataType, sizeof(struct xenc__EncryptedDataType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct xenc__EncryptedDataType * SOAP_FMAC4 soap_new_xenc__EncryptedDataType(struct soap *soap, int n)
{
	struct xenc__EncryptedDataType *p;
	struct xenc__EncryptedDataType *a = (struct xenc__EncryptedDataType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct xenc__EncryptedDataType));
	for (p = a; p && n--; p++)
		soap_default_xenc__EncryptedDataType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptedDataType(struct soap *soap, const struct xenc__EncryptedDataType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__EncryptedDataType(soap, tag ? tag : "xenc:EncryptedDataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedDataType * SOAP_FMAC4 soap_get_xenc__EncryptedDataType(struct soap *soap, struct xenc__EncryptedDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptedDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__TransformsType(struct soap *soap, struct xenc__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__ds__Transform(soap, &a->ds__Transform);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__TransformsType(struct soap *soap, const struct xenc__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__ds__Transform(soap, &a->ds__Transform);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__TransformsType(struct soap *soap, const char *tag, int id, const struct xenc__TransformsType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__TransformsType), type))
		return soap->error;
	if (soap_out__ds__Transform(soap, "ds:Transform", -1, &a->ds__Transform, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__TransformsType * SOAP_FMAC4 soap_in_xenc__TransformsType(struct soap *soap, const char *tag, struct xenc__TransformsType *a, const char *type)
{
	size_t soap_flag_ds__Transform = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__TransformsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__TransformsType, sizeof(struct xenc__TransformsType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__TransformsType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ds__Transform && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ds__Transform(soap, "ds:Transform", &a->ds__Transform, ""))
				{	soap_flag_ds__Transform--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ds__Transform > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct xenc__TransformsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__TransformsType, SOAP_TYPE_xenc__TransformsType, sizeof(struct xenc__TransformsType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct xenc__TransformsType * SOAP_FMAC4 soap_new_xenc__TransformsType(struct soap *soap, int n)
{
	struct xenc__TransformsType *p;
	struct xenc__TransformsType *a = (struct xenc__TransformsType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct xenc__TransformsType));
	for (p = a; p && n--; p++)
		soap_default_xenc__TransformsType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__TransformsType(struct soap *soap, const struct xenc__TransformsType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__TransformsType(soap, tag ? tag : "xenc:TransformsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__TransformsType * SOAP_FMAC4 soap_get_xenc__TransformsType(struct soap *soap, struct xenc__TransformsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	soap_default_string(soap, &a->URI);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__CipherReferenceType(struct soap *soap, const struct xenc__CipherReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxenc__TransformsType(soap, &a->Transforms);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__CipherReferenceType(struct soap *soap, const char *tag, int id, const struct xenc__CipherReferenceType *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", soap_string2s(soap, a->URI), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__CipherReferenceType), type))
		return soap->error;
	if (soap_out_PointerToxenc__TransformsType(soap, "xenc:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__CipherReferenceType * SOAP_FMAC4 soap_in_xenc__CipherReferenceType(struct soap *soap, const char *tag, struct xenc__CipherReferenceType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__CipherReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__CipherReferenceType, sizeof(struct xenc__CipherReferenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__CipherReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 1), &a->URI))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__TransformsType(soap, "xenc:Transforms", &a->Transforms, "xenc:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__CipherReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__CipherReferenceType, SOAP_TYPE_xenc__CipherReferenceType, sizeof(struct xenc__CipherReferenceType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct xenc__CipherReferenceType * SOAP_FMAC4 soap_new_xenc__CipherReferenceType(struct soap *soap, int n)
{
	struct xenc__CipherReferenceType *p;
	struct xenc__CipherReferenceType *a = (struct xenc__CipherReferenceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct xenc__CipherReferenceType));
	for (p = a; p && n--; p++)
		soap_default_xenc__CipherReferenceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__CipherReferenceType(struct soap *soap, const struct xenc__CipherReferenceType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__CipherReferenceType(soap, tag ? tag : "xenc:CipherReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherReferenceType * SOAP_FMAC4 soap_get_xenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__CipherReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->CipherValue);
	a->CipherReference = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__CipherDataType(struct soap *soap, const struct xenc__CipherDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->CipherValue);
	soap_serialize_PointerToxenc__CipherReferenceType(soap, &a->CipherReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__CipherDataType(struct soap *soap, const char *tag, int id, const struct xenc__CipherDataType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__CipherDataType), type))
		return soap->error;
	if (soap_out_string(soap, "xenc:CipherValue", -1, (char*const*)&a->CipherValue, ""))
		return soap->error;
	if (soap_out_PointerToxenc__CipherReferenceType(soap, "xenc:CipherReference", -1, &a->CipherReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__CipherDataType * SOAP_FMAC4 soap_in_xenc__CipherDataType(struct soap *soap, const char *tag, struct xenc__CipherDataType *a, const char *type)
{
	size_t soap_flag_CipherValue = 1;
	size_t soap_flag_CipherReference = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__CipherDataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__CipherDataType, sizeof(struct xenc__CipherDataType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__CipherDataType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CipherValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "xenc:CipherValue", (char**)&a->CipherValue, "xsd:string"))
				{	soap_flag_CipherValue--;
					continue;
				}
			if (soap_flag_CipherReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__CipherReferenceType(soap, "xenc:CipherReference", &a->CipherReference, "xenc:CipherReferenceType"))
				{	soap_flag_CipherReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__CipherDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__CipherDataType, SOAP_TYPE_xenc__CipherDataType, sizeof(struct xenc__CipherDataType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct xenc__CipherDataType * SOAP_FMAC4 soap_new_xenc__CipherDataType(struct soap *soap, int n)
{
	struct xenc__CipherDataType *p;
	struct xenc__CipherDataType *a = (struct xenc__CipherDataType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct xenc__CipherDataType));
	for (p = a; p && n--; p++)
		soap_default_xenc__CipherDataType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__CipherDataType(struct soap *soap, const struct xenc__CipherDataType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__CipherDataType(soap, tag ? tag : "xenc:CipherDataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherDataType * SOAP_FMAC4 soap_get_xenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__CipherDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->KeySize = NULL;
	soap_default_string(soap, &a->OAEPparams);
	soap_default_string(soap, &a->Algorithm);
	a->ds__DigestMethod = NULL;
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptionMethodType(struct soap *soap, const struct xenc__EncryptionMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->KeySize);
	soap_serialize_string(soap, (char*const*)&a->OAEPparams);
	soap_serialize_PointerTods__DigestMethodType(soap, &a->ds__DigestMethod);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptionMethodType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptionMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", soap_string2s(soap, a->Algorithm), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptionMethodType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "xenc:KeySize", -1, &a->KeySize, ""))
		return soap->error;
	if (soap_out_string(soap, "xenc:OAEPparams", -1, (char*const*)&a->OAEPparams, ""))
		return soap->error;
	if (soap_out_PointerTods__DigestMethodType(soap, "ds:DigestMethod", -1, &a->ds__DigestMethod, ""))
		return soap->error;
	soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType * SOAP_FMAC4 soap_in_xenc__EncryptionMethodType(struct soap *soap, const char *tag, struct xenc__EncryptionMethodType *a, const char *type)
{
	size_t soap_flag_KeySize = 1;
	size_t soap_flag_OAEPparams = 1;
	size_t soap_flag_ds__DigestMethod = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptionMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionMethodType, sizeof(struct xenc__EncryptionMethodType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptionMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_KeySize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "xenc:KeySize", &a->KeySize, "xsd:int"))
				{	soap_flag_KeySize--;
					continue;
				}
			if (soap_flag_OAEPparams && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "xenc:OAEPparams", (char**)&a->OAEPparams, "xsd:string"))
				{	soap_flag_OAEPparams--;
					continue;
				}
			if (soap_flag_ds__DigestMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__DigestMethodType(soap, "ds:DigestMethod", &a->ds__DigestMethod, "ds:DigestMethodType"))
				{	soap_flag_ds__DigestMethod--;
					continue;
				}
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionMethodType, SOAP_TYPE_xenc__EncryptionMethodType, sizeof(struct xenc__EncryptionMethodType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct xenc__EncryptionMethodType * SOAP_FMAC4 soap_new_xenc__EncryptionMethodType(struct soap *soap, int n)
{
	struct xenc__EncryptionMethodType *p;
	struct xenc__EncryptionMethodType *a = (struct xenc__EncryptionMethodType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct xenc__EncryptionMethodType));
	for (p = a; p && n--; p++)
		soap_default_xenc__EncryptionMethodType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptionMethodType(struct soap *soap, const struct xenc__EncryptionMethodType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__EncryptionMethodType(soap, tag ? tag : "xenc:EncryptionMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType * SOAP_FMAC4 soap_get_xenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptionMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptedType(struct soap *soap, struct xenc__EncryptedType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EncryptionMethod = NULL;
	a->ds__KeyInfo = NULL;
	a->CipherData = NULL;
	a->EncryptionProperties = NULL;
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->Type);
	soap_default_string(soap, &a->MimeType);
	soap_default_string(soap, &a->Encoding);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptedType(struct soap *soap, const struct xenc__EncryptedType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxenc__EncryptionMethodType(soap, &a->EncryptionMethod);
	soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
	soap_serialize_PointerToxenc__CipherDataType(soap, &a->CipherData);
	soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, &a->EncryptionProperties);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptedType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptedType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap_string2s(soap, a->Type), 1);
	if (a->MimeType)
		soap_set_attr(soap, "MimeType", soap_string2s(soap, a->MimeType), 1);
	if (a->Encoding)
		soap_set_attr(soap, "Encoding", soap_string2s(soap, a->Encoding), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptedType), type))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", -1, &a->EncryptionMethod, ""))
		return soap->error;
	if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
		return soap->error;
	if (!a->CipherData)
	{	if (soap_element_nil(soap, "xenc:CipherData"))
			return soap->error;
	}
	else
	if (soap_out_PointerToxenc__CipherDataType(soap, "xenc:CipherData", -1, &a->CipherData, ""))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", -1, &a->EncryptionProperties, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptedType * SOAP_FMAC4 soap_in_xenc__EncryptedType(struct soap *soap, const char *tag, struct xenc__EncryptedType *a, const char *type)
{
	size_t soap_flag_EncryptionMethod = 1;
	size_t soap_flag_ds__KeyInfo = 1;
	size_t soap_flag_CipherData = 1;
	size_t soap_flag_EncryptionProperties = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptedType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptedType, sizeof(struct xenc__EncryptedType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptedType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "MimeType", 0), &a->MimeType))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Encoding", 0), &a->Encoding))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EncryptionMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", &a->EncryptionMethod, "xenc:EncryptionMethodType"))
				{	soap_flag_EncryptionMethod--;
					continue;
				}
			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, ""))
				{	soap_flag_ds__KeyInfo--;
					continue;
				}
			if (soap_flag_CipherData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__CipherDataType(soap, "xenc:CipherData", &a->CipherData, "xenc:CipherDataType"))
				{	soap_flag_CipherData--;
					continue;
				}
			if (soap_flag_EncryptionProperties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", &a->EncryptionProperties, "xenc:EncryptionPropertiesType"))
				{	soap_flag_EncryptionProperties--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CipherData > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct xenc__EncryptedType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptedType, SOAP_TYPE_xenc__EncryptedType, sizeof(struct xenc__EncryptedType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct xenc__EncryptedType * SOAP_FMAC4 soap_new_xenc__EncryptedType(struct soap *soap, int n)
{
	struct xenc__EncryptedType *p;
	struct xenc__EncryptedType *a = (struct xenc__EncryptedType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct xenc__EncryptedType));
	for (p = a; p && n--; p++)
		soap_default_xenc__EncryptedType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptedType(struct soap *soap, const struct xenc__EncryptedType *a, const char *tag, const char *type)
{
	if (soap_out_xenc__EncryptedType(soap, tag ? tag : "xenc:EncryptedType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedType * SOAP_FMAC4 soap_get_xenc__EncryptedType(struct soap *soap, struct xenc__EncryptedType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptedType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Modulus);
	soap_default_string(soap, &a->Exponent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__RSAKeyValueType(struct soap *soap, const struct ds__RSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Modulus);
	soap_serialize_string(soap, (char*const*)&a->Exponent);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__RSAKeyValueType(struct soap *soap, const char *tag, int id, const struct ds__RSAKeyValueType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__RSAKeyValueType), type))
		return soap->error;
	if (!a->Modulus)
	{	if (soap_element_nil(soap, "ds:Modulus"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ds:Modulus", -1, (char*const*)&a->Modulus, ""))
		return soap->error;
	if (!a->Exponent)
	{	if (soap_element_nil(soap, "ds:Exponent"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ds:Exponent", -1, (char*const*)&a->Exponent, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_in_ds__RSAKeyValueType(struct soap *soap, const char *tag, struct ds__RSAKeyValueType *a, const char *type)
{
	size_t soap_flag_Modulus = 1;
	size_t soap_flag_Exponent = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__RSAKeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__RSAKeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Modulus && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Modulus", (char**)&a->Modulus, "xsd:string"))
				{	soap_flag_Modulus--;
					continue;
				}
			if (soap_flag_Exponent && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Exponent", (char**)&a->Exponent, "xsd:string"))
				{	soap_flag_Exponent--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Modulus > 0 || soap_flag_Exponent > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ds__RSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RSAKeyValueType, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_new_ds__RSAKeyValueType(struct soap *soap, int n)
{
	struct ds__RSAKeyValueType *p;
	struct ds__RSAKeyValueType *a = (struct ds__RSAKeyValueType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ds__RSAKeyValueType));
	for (p = a; p && n--; p++)
		soap_default_ds__RSAKeyValueType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__RSAKeyValueType(struct soap *soap, const struct ds__RSAKeyValueType *a, const char *tag, const char *type)
{
	if (soap_out_ds__RSAKeyValueType(soap, tag ? tag : "ds:RSAKeyValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_get_ds__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__RSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->G);
	soap_default_string(soap, &a->Y);
	soap_default_string(soap, &a->J);
	soap_default_string(soap, &a->P);
	soap_default_string(soap, &a->Q);
	soap_default_string(soap, &a->Seed);
	soap_default_string(soap, &a->PgenCounter);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__DSAKeyValueType(struct soap *soap, const struct ds__DSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->G);
	soap_serialize_string(soap, (char*const*)&a->Y);
	soap_serialize_string(soap, (char*const*)&a->J);
	soap_serialize_string(soap, (char*const*)&a->P);
	soap_serialize_string(soap, (char*const*)&a->Q);
	soap_serialize_string(soap, (char*const*)&a->Seed);
	soap_serialize_string(soap, (char*const*)&a->PgenCounter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__DSAKeyValueType(struct soap *soap, const char *tag, int id, const struct ds__DSAKeyValueType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__DSAKeyValueType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:G", -1, (char*const*)&a->G, ""))
		return soap->error;
	if (!a->Y)
	{	if (soap_element_nil(soap, "ds:Y"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ds:Y", -1, (char*const*)&a->Y, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:J", -1, (char*const*)&a->J, ""))
		return soap->error;
	if (!a->P)
	{	if (soap_element_nil(soap, "ds:P"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ds:P", -1, (char*const*)&a->P, ""))
		return soap->error;
	if (!a->Q)
	{	if (soap_element_nil(soap, "ds:Q"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ds:Q", -1, (char*const*)&a->Q, ""))
		return soap->error;
	if (!a->Seed)
	{	if (soap_element_nil(soap, "ds:Seed"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ds:Seed", -1, (char*const*)&a->Seed, ""))
		return soap->error;
	if (!a->PgenCounter)
	{	if (soap_element_nil(soap, "ds:PgenCounter"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ds:PgenCounter", -1, (char*const*)&a->PgenCounter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_in_ds__DSAKeyValueType(struct soap *soap, const char *tag, struct ds__DSAKeyValueType *a, const char *type)
{
	size_t soap_flag_G = 1;
	size_t soap_flag_Y = 1;
	size_t soap_flag_J = 1;
	size_t soap_flag_P = 1;
	size_t soap_flag_Q = 1;
	size_t soap_flag_Seed = 1;
	size_t soap_flag_PgenCounter = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__DSAKeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__DSAKeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_G && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:G", (char**)&a->G, "xsd:string"))
				{	soap_flag_G--;
					continue;
				}
			if (soap_flag_Y && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Y", (char**)&a->Y, "xsd:string"))
				{	soap_flag_Y--;
					continue;
				}
			if (soap_flag_J && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:J", (char**)&a->J, "xsd:string"))
				{	soap_flag_J--;
					continue;
				}
			if (soap_flag_P && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:P", (char**)&a->P, "xsd:string"))
				{	soap_flag_P--;
					continue;
				}
			if (soap_flag_Q && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Q", (char**)&a->Q, "xsd:string"))
				{	soap_flag_Q--;
					continue;
				}
			if (soap_flag_Seed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Seed", (char**)&a->Seed, "xsd:string"))
				{	soap_flag_Seed--;
					continue;
				}
			if (soap_flag_PgenCounter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:PgenCounter", (char**)&a->PgenCounter, "xsd:string"))
				{	soap_flag_PgenCounter--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Y > 0 || soap_flag_P > 0 || soap_flag_Q > 0 || soap_flag_Seed > 0 || soap_flag_PgenCounter > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ds__DSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DSAKeyValueType, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_new_ds__DSAKeyValueType(struct soap *soap, int n)
{
	struct ds__DSAKeyValueType *p;
	struct ds__DSAKeyValueType *a = (struct ds__DSAKeyValueType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ds__DSAKeyValueType));
	for (p = a; p && n--; p++)
		soap_default_ds__DSAKeyValueType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__DSAKeyValueType(struct soap *soap, const struct ds__DSAKeyValueType *a, const char *tag, const char *type)
{
	if (soap_out_ds__DSAKeyValueType(soap, tag ? tag : "ds:DSAKeyValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_get_ds__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__DSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->X509IssuerName);
	soap_default_string(soap, &a->X509SerialNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__X509IssuerSerialType(struct soap *soap, const struct ds__X509IssuerSerialType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->X509IssuerName);
	soap_serialize_string(soap, (char*const*)&a->X509SerialNumber);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__X509IssuerSerialType(struct soap *soap, const char *tag, int id, const struct ds__X509IssuerSerialType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__X509IssuerSerialType), type))
		return soap->error;
	if (!a->X509IssuerName)
	{	if (soap_element_nil(soap, "ds:X509IssuerName"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ds:X509IssuerName", -1, (char*const*)&a->X509IssuerName, ""))
		return soap->error;
	if (!a->X509SerialNumber)
	{	if (soap_element_nil(soap, "ds:X509SerialNumber"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ds:X509SerialNumber", -1, (char*const*)&a->X509SerialNumber, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_in_ds__X509IssuerSerialType(struct soap *soap, const char *tag, struct ds__X509IssuerSerialType *a, const char *type)
{
	size_t soap_flag_X509IssuerName = 1;
	size_t soap_flag_X509SerialNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__X509IssuerSerialType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__X509IssuerSerialType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_X509IssuerName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509IssuerName", (char**)&a->X509IssuerName, "xsd:string"))
				{	soap_flag_X509IssuerName--;
					continue;
				}
			if (soap_flag_X509SerialNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509SerialNumber", (char**)&a->X509SerialNumber, "xsd:string"))
				{	soap_flag_X509SerialNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_X509IssuerName > 0 || soap_flag_X509SerialNumber > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ds__X509IssuerSerialType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509IssuerSerialType, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_new_ds__X509IssuerSerialType(struct soap *soap, int n)
{
	struct ds__X509IssuerSerialType *p;
	struct ds__X509IssuerSerialType *a = (struct ds__X509IssuerSerialType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ds__X509IssuerSerialType));
	for (p = a; p && n--; p++)
		soap_default_ds__X509IssuerSerialType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__X509IssuerSerialType(struct soap *soap, const struct ds__X509IssuerSerialType *a, const char *tag, const char *type)
{
	if (soap_out_ds__X509IssuerSerialType(soap, tag ? tag : "ds:X509IssuerSerialType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_get_ds__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__X509IssuerSerialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__RetrievalMethodType(struct soap *soap, const struct ds__RetrievalMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTods__TransformsType(soap, &a->Transforms);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__RetrievalMethodType(struct soap *soap, const char *tag, int id, const struct ds__RetrievalMethodType *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", soap_string2s(soap, a->URI), 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap_string2s(soap, a->Type), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__RetrievalMethodType), type))
		return soap->error;
	if (soap_out_PointerTods__TransformsType(soap, "ds:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_in_ds__RetrievalMethodType(struct soap *soap, const char *tag, struct ds__RetrievalMethodType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__RetrievalMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__RetrievalMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__TransformsType(soap, "ds:Transforms", &a->Transforms, "ds:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__RetrievalMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RetrievalMethodType, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_new_ds__RetrievalMethodType(struct soap *soap, int n)
{
	struct ds__RetrievalMethodType *p;
	struct ds__RetrievalMethodType *a = (struct ds__RetrievalMethodType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ds__RetrievalMethodType));
	for (p = a; p && n--; p++)
		soap_default_ds__RetrievalMethodType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__RetrievalMethodType(struct soap *soap, const struct ds__RetrievalMethodType *a, const char *tag, const char *type)
{
	if (soap_out_ds__RetrievalMethodType(soap, tag ? tag : "ds:RetrievalMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_get_ds__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__RetrievalMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__KeyValueType(struct soap *soap, struct ds__KeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DSAKeyValue = NULL;
	a->RSAKeyValue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__KeyValueType(struct soap *soap, const struct ds__KeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTods__DSAKeyValueType(soap, &a->DSAKeyValue);
	soap_serialize_PointerTods__RSAKeyValueType(soap, &a->RSAKeyValue);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__KeyValueType(struct soap *soap, const char *tag, int id, const struct ds__KeyValueType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__KeyValueType), type))
		return soap->error;
	if (soap_out_PointerTods__DSAKeyValueType(soap, "ds:DSAKeyValue", -1, &a->DSAKeyValue, ""))
		return soap->error;
	if (soap_out_PointerTods__RSAKeyValueType(soap, "ds:RSAKeyValue", -1, &a->RSAKeyValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_in_ds__KeyValueType(struct soap *soap, const char *tag, struct ds__KeyValueType *a, const char *type)
{
	size_t soap_flag_DSAKeyValue = 1;
	size_t soap_flag_RSAKeyValue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__KeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__KeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__DSAKeyValueType(soap, "ds:DSAKeyValue", &a->DSAKeyValue, "ds:DSAKeyValueType"))
				{	soap_flag_DSAKeyValue--;
					continue;
				}
			if (soap_flag_RSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__RSAKeyValueType(soap, "ds:RSAKeyValue", &a->RSAKeyValue, "ds:RSAKeyValueType"))
				{	soap_flag_RSAKeyValue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__KeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyValueType, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_new_ds__KeyValueType(struct soap *soap, int n)
{
	struct ds__KeyValueType *p;
	struct ds__KeyValueType *a = (struct ds__KeyValueType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ds__KeyValueType));
	for (p = a; p && n--; p++)
		soap_default_ds__KeyValueType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__KeyValueType(struct soap *soap, const struct ds__KeyValueType *a, const char *tag, const char *type)
{
	if (soap_out_ds__KeyValueType(soap, tag ? tag : "ds:KeyValueType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_get_ds__KeyValueType(struct soap *soap, struct ds__KeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__KeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__DigestMethodType(struct soap *soap, const struct ds__DigestMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__DigestMethodType(struct soap *soap, const char *tag, int id, const struct ds__DigestMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", soap_string2s(soap, a->Algorithm), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__DigestMethodType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_in_ds__DigestMethodType(struct soap *soap, const char *tag, struct ds__DigestMethodType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__DigestMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__DigestMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__DigestMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DigestMethodType, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_new_ds__DigestMethodType(struct soap *soap, int n)
{
	struct ds__DigestMethodType *p;
	struct ds__DigestMethodType *a = (struct ds__DigestMethodType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ds__DigestMethodType));
	for (p = a; p && n--; p++)
		soap_default_ds__DigestMethodType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__DigestMethodType(struct soap *soap, const struct ds__DigestMethodType *a, const char *tag, const char *type)
{
	if (soap_out_ds__DigestMethodType(soap, tag ? tag : "ds:DigestMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_get_ds__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__DigestMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__TransformType(struct soap *soap, struct ds__TransformType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->c14n__InclusiveNamespaces = NULL;
	a->__any = NULL;
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__TransformType(struct soap *soap, const struct ds__TransformType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, &a->c14n__InclusiveNamespaces);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__TransformType(struct soap *soap, const char *tag, int id, const struct ds__TransformType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", soap_string2s(soap, a->Algorithm), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__TransformType), type))
		return soap->error;
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", -1, &a->c14n__InclusiveNamespaces, ""))
		return soap->error;
	soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_in_ds__TransformType(struct soap *soap, const char *tag, struct ds__TransformType *a, const char *type)
{
	size_t soap_flag_c14n__InclusiveNamespaces = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__TransformType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__TransformType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 0), &a->Algorithm))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", &a->c14n__InclusiveNamespaces, ""))
				{	soap_flag_c14n__InclusiveNamespaces--;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__TransformType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformType, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_new_ds__TransformType(struct soap *soap, int n)
{
	struct ds__TransformType *p;
	struct ds__TransformType *a = (struct ds__TransformType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ds__TransformType));
	for (p = a; p && n--; p++)
		soap_default_ds__TransformType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__TransformType(struct soap *soap, const struct ds__TransformType *a, const char *tag, const char *type)
{
	if (soap_out_ds__TransformType(soap, tag ? tag : "ds:TransformType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_get_ds__TransformType(struct soap *soap, struct ds__TransformType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__TransformType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->PrefixList);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__c14n__InclusiveNamespaces(struct soap *soap, const struct _c14n__InclusiveNamespaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__c14n__InclusiveNamespaces(struct soap *soap, const char *tag, int id, const struct _c14n__InclusiveNamespaces *a, const char *type)
{
	if (a->PrefixList)
		soap_set_attr(soap, "PrefixList", soap_string2s(soap, a->PrefixList), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__c14n__InclusiveNamespaces), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_in__c14n__InclusiveNamespaces(struct soap *soap, const char *tag, struct _c14n__InclusiveNamespaces *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _c14n__InclusiveNamespaces *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__c14n__InclusiveNamespaces(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "PrefixList", 0), &a->PrefixList))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _c14n__InclusiveNamespaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__c14n__InclusiveNamespaces, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_new__c14n__InclusiveNamespaces(struct soap *soap, int n)
{
	struct _c14n__InclusiveNamespaces *p;
	struct _c14n__InclusiveNamespaces *a = (struct _c14n__InclusiveNamespaces*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _c14n__InclusiveNamespaces));
	for (p = a; p && n--; p++)
		soap_default__c14n__InclusiveNamespaces(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__c14n__InclusiveNamespaces(struct soap *soap, const struct _c14n__InclusiveNamespaces *a, const char *tag, const char *type)
{
	if (soap_out__c14n__InclusiveNamespaces(soap, tag ? tag : "c14n:InclusiveNamespaces", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_get__c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *p, const char *tag, const char *type)
{
	if ((p = soap_in__c14n__InclusiveNamespaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__TransformsType(struct soap *soap, struct ds__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeTransform = 0;
	a->Transform = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__TransformsType(struct soap *soap, const struct ds__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Transform)
	{	int i;
		for (i = 0; i < (int)a->__sizeTransform; i++)
		{
			soap_embedded(soap, a->Transform + i, SOAP_TYPE_ds__TransformType);
			soap_serialize_ds__TransformType(soap, a->Transform + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__TransformsType(struct soap *soap, const char *tag, int id, const struct ds__TransformsType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__TransformsType), type))
		return soap->error;
	if (a->Transform)
	{	int i;
		for (i = 0; i < (int)a->__sizeTransform; i++)
			if (soap_out_ds__TransformType(soap, "ds:Transform", -1, a->Transform + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_in_ds__TransformsType(struct soap *soap, const char *tag, struct ds__TransformsType *a, const char *type)
{
	struct soap_blist *soap_blist_Transform = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__TransformsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__TransformsType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:Transform", 1, NULL))
			{	if (a->Transform == NULL)
				{	if (soap_blist_Transform == NULL)
						soap_blist_Transform = soap_alloc_block(soap);
					a->Transform = (struct ds__TransformType *)soap_push_block_max(soap, soap_blist_Transform, sizeof(struct ds__TransformType));
					if (a->Transform == NULL)
						return NULL;
					soap_default_ds__TransformType(soap, a->Transform);
				}
				soap_revert(soap);
				if (soap_in_ds__TransformType(soap, "ds:Transform", a->Transform, "ds:TransformType"))
				{	a->__sizeTransform++;
					a->Transform = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Transform)
			soap_pop_block(soap, soap_blist_Transform);
		if (a->__sizeTransform)
		{	a->Transform = (struct ds__TransformType *)soap_save_block(soap, soap_blist_Transform, NULL, 1);
		}
		else
		{	a->Transform = NULL;
			if (soap_blist_Transform)
				soap_end_block(soap, soap_blist_Transform);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__TransformsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformsType, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_new_ds__TransformsType(struct soap *soap, int n)
{
	struct ds__TransformsType *p;
	struct ds__TransformsType *a = (struct ds__TransformsType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ds__TransformsType));
	for (p = a; p && n--; p++)
		soap_default_ds__TransformsType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__TransformsType(struct soap *soap, const struct ds__TransformsType *a, const char *tag, const char *type)
{
	if (soap_out_ds__TransformsType(soap, tag ? tag : "ds:TransformsType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_get_ds__TransformsType(struct soap *soap, struct ds__TransformsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__ReferenceType(struct soap *soap, struct ds__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	a->DigestMethod = NULL;
	soap_default_string(soap, &a->DigestValue);
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__ReferenceType(struct soap *soap, const struct ds__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTods__TransformsType(soap, &a->Transforms);
	soap_serialize_PointerTods__DigestMethodType(soap, &a->DigestMethod);
	soap_serialize_string(soap, (char*const*)&a->DigestValue);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__ReferenceType(struct soap *soap, const char *tag, int id, const struct ds__ReferenceType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", soap_string2s(soap, a->Id), 1);
	if (a->URI)
		soap_set_attr(soap, "URI", soap_string2s(soap, a->URI), 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap_string2s(soap, a->Type), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__ReferenceType), type))
		return soap->error;
	if (soap_out_PointerTods__TransformsType(soap, "ds:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	if (!a->DigestMethod)
	{	if (soap_element_nil(soap, "ds:DigestMethod"))
			return soap->error;
	}
	else
	if (soap_out_PointerTods__DigestMethodType(soap, "ds:DigestMethod", -1, &a->DigestMethod, ""))
		return soap->error;
	if (!a->DigestValue)
	{	if (soap_element_nil(soap, "ds:DigestValue"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ds:DigestValue", -1, (char*const*)&a->DigestValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_in_ds__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	size_t soap_flag_DigestMethod = 1;
	size_t soap_flag_DigestValue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__ReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__ReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__TransformsType(soap, "ds:Transforms", &a->Transforms, "ds:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			if (soap_flag_DigestMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__DigestMethodType(soap, "ds:DigestMethod", &a->DigestMethod, "ds:DigestMethodType"))
				{	soap_flag_DigestMethod--;
					continue;
				}
			if (soap_flag_DigestValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:DigestValue", (char**)&a->DigestValue, "xsd:string"))
				{	soap_flag_DigestValue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DigestMethod > 0 || soap_flag_DigestValue > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ds__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__ReferenceType, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_new_ds__ReferenceType(struct soap *soap, int n)
{
	struct ds__ReferenceType *p;
	struct ds__ReferenceType *a = (struct ds__ReferenceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ds__ReferenceType));
	for (p = a; p && n--; p++)
		soap_default_ds__ReferenceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__ReferenceType(struct soap *soap, const struct ds__ReferenceType *a, const char *tag, const char *type)
{
	if (soap_out_ds__ReferenceType(soap, tag ? tag : "ds:ReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_get_ds__ReferenceType(struct soap *soap, struct ds__ReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->HMACOutputLength = NULL;
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignatureMethodType(struct soap *soap, const struct ds__SignatureMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->HMACOutputLength);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignatureMethodType(struct soap *soap, const char *tag, int id, const struct ds__SignatureMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", soap_string2s(soap, a->Algorithm), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignatureMethodType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ds:HMACOutputLength", -1, &a->HMACOutputLength, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_in_ds__SignatureMethodType(struct soap *soap, const char *tag, struct ds__SignatureMethodType *a, const char *type)
{
	size_t soap_flag_HMACOutputLength = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignatureMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignatureMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HMACOutputLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ds:HMACOutputLength", &a->HMACOutputLength, "xsd:int"))
				{	soap_flag_HMACOutputLength--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureMethodType, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_new_ds__SignatureMethodType(struct soap *soap, int n)
{
	struct ds__SignatureMethodType *p;
	struct ds__SignatureMethodType *a = (struct ds__SignatureMethodType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ds__SignatureMethodType));
	for (p = a; p && n--; p++)
		soap_default_ds__SignatureMethodType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignatureMethodType(struct soap *soap, const struct ds__SignatureMethodType *a, const char *tag, const char *type)
{
	if (soap_out_ds__SignatureMethodType(soap, tag ? tag : "ds:SignatureMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_get_ds__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignatureMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Algorithm);
	a->c14n__InclusiveNamespaces = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__CanonicalizationMethodType(struct soap *soap, const struct ds__CanonicalizationMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, &a->c14n__InclusiveNamespaces);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__CanonicalizationMethodType(struct soap *soap, const char *tag, int id, const struct ds__CanonicalizationMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", soap_string2s(soap, a->Algorithm), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__CanonicalizationMethodType), type))
		return soap->error;
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", -1, &a->c14n__InclusiveNamespaces, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_in_ds__CanonicalizationMethodType(struct soap *soap, const char *tag, struct ds__CanonicalizationMethodType *a, const char *type)
{
	size_t soap_flag_c14n__InclusiveNamespaces = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__CanonicalizationMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__CanonicalizationMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", &a->c14n__InclusiveNamespaces, ""))
				{	soap_flag_c14n__InclusiveNamespaces--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__CanonicalizationMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__CanonicalizationMethodType, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_new_ds__CanonicalizationMethodType(struct soap *soap, int n)
{
	struct ds__CanonicalizationMethodType *p;
	struct ds__CanonicalizationMethodType *a = (struct ds__CanonicalizationMethodType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ds__CanonicalizationMethodType));
	for (p = a; p && n--; p++)
		soap_default_ds__CanonicalizationMethodType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__CanonicalizationMethodType(struct soap *soap, const struct ds__CanonicalizationMethodType *a, const char *tag, const char *type)
{
	if (soap_out_ds__CanonicalizationMethodType(soap, tag ? tag : "ds:CanonicalizationMethodType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_get_ds__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__CanonicalizationMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
