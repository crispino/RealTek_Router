/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:59 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__CertificateWithPrivateKey(struct soap *soap, struct tt__CertificateWithPrivateKey *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->CertificateID);
	a->Certificate = NULL;
	a->PrivateKey = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__CertificateWithPrivateKey(struct soap *soap, const struct tt__CertificateWithPrivateKey *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__token(soap, (char*const*)&a->CertificateID);
	soap_serialize_PointerTott__BinaryData(soap, &a->Certificate);
	soap_serialize_PointerTott__BinaryData(soap, &a->PrivateKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateWithPrivateKey(struct soap *soap, const char *tag, int id, const struct tt__CertificateWithPrivateKey *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CertificateWithPrivateKey), type))
		return soap->error;
	if (soap_out_xsd__token(soap, "tt:CertificateID", -1, (char*const*)&a->CertificateID, ""))
		return soap->error;
	if (!a->Certificate)
	{	if (soap_element_nil(soap, "tt:Certificate"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__BinaryData(soap, "tt:Certificate", -1, &a->Certificate, ""))
		return soap->error;
	if (!a->PrivateKey)
	{	if (soap_element_nil(soap, "tt:PrivateKey"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__BinaryData(soap, "tt:PrivateKey", -1, &a->PrivateKey, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__CertificateWithPrivateKey * SOAP_FMAC4 soap_in_tt__CertificateWithPrivateKey(struct soap *soap, const char *tag, struct tt__CertificateWithPrivateKey *a, const char *type)
{
	size_t soap_flag_CertificateID = 1;
	size_t soap_flag_Certificate = 1;
	size_t soap_flag_PrivateKey = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__CertificateWithPrivateKey *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateWithPrivateKey, sizeof(struct tt__CertificateWithPrivateKey), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__CertificateWithPrivateKey(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tt:CertificateID", (char**)&a->CertificateID, "xsd:token"))
				{	soap_flag_CertificateID--;
					continue;
				}
			if (soap_flag_Certificate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__BinaryData(soap, "tt:Certificate", &a->Certificate, "tt:BinaryData"))
				{	soap_flag_Certificate--;
					continue;
				}
			if (soap_flag_PrivateKey && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__BinaryData(soap, "tt:PrivateKey", &a->PrivateKey, "tt:BinaryData"))
				{	soap_flag_PrivateKey--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Certificate > 0 || soap_flag_PrivateKey > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__CertificateWithPrivateKey *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateWithPrivateKey, SOAP_TYPE_tt__CertificateWithPrivateKey, sizeof(struct tt__CertificateWithPrivateKey), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__CertificateWithPrivateKey * SOAP_FMAC4 soap_new_tt__CertificateWithPrivateKey(struct soap *soap, int n)
{
	struct tt__CertificateWithPrivateKey *p;
	struct tt__CertificateWithPrivateKey *a = (struct tt__CertificateWithPrivateKey*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__CertificateWithPrivateKey));
	for (p = a; p && n--; p++)
		soap_default_tt__CertificateWithPrivateKey(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CertificateWithPrivateKey(struct soap *soap, const struct tt__CertificateWithPrivateKey *a, const char *tag, const char *type)
{
	if (soap_out_tt__CertificateWithPrivateKey(soap, tag ? tag : "tt:CertificateWithPrivateKey", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateWithPrivateKey * SOAP_FMAC4 soap_get_tt__CertificateWithPrivateKey(struct soap *soap, struct tt__CertificateWithPrivateKey *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateWithPrivateKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__CertificateStatus(struct soap *soap, struct tt__CertificateStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->CertificateID);
	soap_default_xsd__boolean(soap, &a->Status);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__CertificateStatus(struct soap *soap, const struct tt__CertificateStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__token(soap, (char*const*)&a->CertificateID);
	soap_embedded(soap, &a->Status, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateStatus(struct soap *soap, const char *tag, int id, const struct tt__CertificateStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CertificateStatus), type))
		return soap->error;
	if (!a->CertificateID)
	{	if (soap_element_nil(soap, "tt:CertificateID"))
			return soap->error;
	}
	else
	if (soap_out_xsd__token(soap, "tt:CertificateID", -1, (char*const*)&a->CertificateID, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:Status", -1, &a->Status, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__CertificateStatus * SOAP_FMAC4 soap_in_tt__CertificateStatus(struct soap *soap, const char *tag, struct tt__CertificateStatus *a, const char *type)
{
	size_t soap_flag_CertificateID = 1;
	size_t soap_flag_Status = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__CertificateStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateStatus, sizeof(struct tt__CertificateStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__CertificateStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tt:CertificateID", (char**)&a->CertificateID, "xsd:token"))
				{	soap_flag_CertificateID--;
					continue;
				}
			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:Status", &a->Status, "xsd:boolean"))
				{	soap_flag_Status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CertificateID > 0 || soap_flag_Status > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__CertificateStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateStatus, SOAP_TYPE_tt__CertificateStatus, sizeof(struct tt__CertificateStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__CertificateStatus * SOAP_FMAC4 soap_new_tt__CertificateStatus(struct soap *soap, int n)
{
	struct tt__CertificateStatus *p;
	struct tt__CertificateStatus *a = (struct tt__CertificateStatus*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__CertificateStatus));
	for (p = a; p && n--; p++)
		soap_default_tt__CertificateStatus(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CertificateStatus(struct soap *soap, const struct tt__CertificateStatus *a, const char *tag, const char *type)
{
	if (soap_out_tt__CertificateStatus(soap, tag ? tag : "tt:CertificateStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateStatus * SOAP_FMAC4 soap_get_tt__CertificateStatus(struct soap *soap, struct tt__CertificateStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Certificate(struct soap *soap, struct tt__Certificate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->CertificateID);
	a->Certificate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Certificate(struct soap *soap, const struct tt__Certificate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__token(soap, (char*const*)&a->CertificateID);
	soap_serialize_PointerTott__BinaryData(soap, &a->Certificate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Certificate(struct soap *soap, const char *tag, int id, const struct tt__Certificate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Certificate), type))
		return soap->error;
	if (!a->CertificateID)
	{	if (soap_element_nil(soap, "tt:CertificateID"))
			return soap->error;
	}
	else
	if (soap_out_xsd__token(soap, "tt:CertificateID", -1, (char*const*)&a->CertificateID, ""))
		return soap->error;
	if (!a->Certificate)
	{	if (soap_element_nil(soap, "tt:Certificate"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__BinaryData(soap, "tt:Certificate", -1, &a->Certificate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Certificate * SOAP_FMAC4 soap_in_tt__Certificate(struct soap *soap, const char *tag, struct tt__Certificate *a, const char *type)
{
	size_t soap_flag_CertificateID = 1;
	size_t soap_flag_Certificate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Certificate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Certificate, sizeof(struct tt__Certificate), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Certificate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tt:CertificateID", (char**)&a->CertificateID, "xsd:token"))
				{	soap_flag_CertificateID--;
					continue;
				}
			if (soap_flag_Certificate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__BinaryData(soap, "tt:Certificate", &a->Certificate, "tt:BinaryData"))
				{	soap_flag_Certificate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CertificateID > 0 || soap_flag_Certificate > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Certificate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Certificate, SOAP_TYPE_tt__Certificate, sizeof(struct tt__Certificate), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Certificate * SOAP_FMAC4 soap_new_tt__Certificate(struct soap *soap, int n)
{
	struct tt__Certificate *p;
	struct tt__Certificate *a = (struct tt__Certificate*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Certificate));
	for (p = a; p && n--; p++)
		soap_default_tt__Certificate(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Certificate(struct soap *soap, const struct tt__Certificate *a, const char *tag, const char *type)
{
	if (soap_out_tt__Certificate(soap, tag ? tag : "tt:Certificate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Certificate * SOAP_FMAC4 soap_get_tt__Certificate(struct soap *soap, struct tt__Certificate *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Certificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__CertificateGenerationParametersExtension(struct soap *soap, struct tt__CertificateGenerationParametersExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__CertificateGenerationParametersExtension(struct soap *soap, const struct tt__CertificateGenerationParametersExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateGenerationParametersExtension(struct soap *soap, const char *tag, int id, const struct tt__CertificateGenerationParametersExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CertificateGenerationParametersExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__CertificateGenerationParametersExtension * SOAP_FMAC4 soap_in_tt__CertificateGenerationParametersExtension(struct soap *soap, const char *tag, struct tt__CertificateGenerationParametersExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__CertificateGenerationParametersExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateGenerationParametersExtension, sizeof(struct tt__CertificateGenerationParametersExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__CertificateGenerationParametersExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__CertificateGenerationParametersExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateGenerationParametersExtension, SOAP_TYPE_tt__CertificateGenerationParametersExtension, sizeof(struct tt__CertificateGenerationParametersExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__CertificateGenerationParametersExtension * SOAP_FMAC4 soap_new_tt__CertificateGenerationParametersExtension(struct soap *soap, int n)
{
	struct tt__CertificateGenerationParametersExtension *p;
	struct tt__CertificateGenerationParametersExtension *a = (struct tt__CertificateGenerationParametersExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__CertificateGenerationParametersExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__CertificateGenerationParametersExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CertificateGenerationParametersExtension(struct soap *soap, const struct tt__CertificateGenerationParametersExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__CertificateGenerationParametersExtension(soap, tag ? tag : "tt:CertificateGenerationParametersExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateGenerationParametersExtension * SOAP_FMAC4 soap_get_tt__CertificateGenerationParametersExtension(struct soap *soap, struct tt__CertificateGenerationParametersExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateGenerationParametersExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__CertificateGenerationParameters(struct soap *soap, struct tt__CertificateGenerationParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->CertificateID);
	soap_default_string(soap, &a->Subject);
	soap_default_xsd__token(soap, &a->ValidNotBefore);
	soap_default_xsd__token(soap, &a->ValidNotAfter);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__CertificateGenerationParameters(struct soap *soap, const struct tt__CertificateGenerationParameters *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__token(soap, (char*const*)&a->CertificateID);
	soap_serialize_string(soap, (char*const*)&a->Subject);
	soap_serialize_xsd__token(soap, (char*const*)&a->ValidNotBefore);
	soap_serialize_xsd__token(soap, (char*const*)&a->ValidNotAfter);
	soap_serialize_PointerTott__CertificateGenerationParametersExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateGenerationParameters(struct soap *soap, const char *tag, int id, const struct tt__CertificateGenerationParameters *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CertificateGenerationParameters), type))
		return soap->error;
	if (soap_out_xsd__token(soap, "tt:CertificateID", -1, (char*const*)&a->CertificateID, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:Subject", -1, (char*const*)&a->Subject, ""))
		return soap->error;
	if (soap_out_xsd__token(soap, "tt:ValidNotBefore", -1, (char*const*)&a->ValidNotBefore, ""))
		return soap->error;
	if (soap_out_xsd__token(soap, "tt:ValidNotAfter", -1, (char*const*)&a->ValidNotAfter, ""))
		return soap->error;
	if (soap_out_PointerTott__CertificateGenerationParametersExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__CertificateGenerationParameters * SOAP_FMAC4 soap_in_tt__CertificateGenerationParameters(struct soap *soap, const char *tag, struct tt__CertificateGenerationParameters *a, const char *type)
{
	size_t soap_flag_CertificateID = 1;
	size_t soap_flag_Subject = 1;
	size_t soap_flag_ValidNotBefore = 1;
	size_t soap_flag_ValidNotAfter = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__CertificateGenerationParameters *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateGenerationParameters, sizeof(struct tt__CertificateGenerationParameters), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__CertificateGenerationParameters(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tt:CertificateID", (char**)&a->CertificateID, "xsd:token"))
				{	soap_flag_CertificateID--;
					continue;
				}
			if (soap_flag_Subject && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Subject", (char**)&a->Subject, "xsd:string"))
				{	soap_flag_Subject--;
					continue;
				}
			if (soap_flag_ValidNotBefore && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tt:ValidNotBefore", (char**)&a->ValidNotBefore, "xsd:token"))
				{	soap_flag_ValidNotBefore--;
					continue;
				}
			if (soap_flag_ValidNotAfter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tt:ValidNotAfter", (char**)&a->ValidNotAfter, "xsd:token"))
				{	soap_flag_ValidNotAfter--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__CertificateGenerationParametersExtension(soap, "tt:Extension", &a->Extension, "tt:CertificateGenerationParametersExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__CertificateGenerationParameters *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateGenerationParameters, SOAP_TYPE_tt__CertificateGenerationParameters, sizeof(struct tt__CertificateGenerationParameters), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__CertificateGenerationParameters * SOAP_FMAC4 soap_new_tt__CertificateGenerationParameters(struct soap *soap, int n)
{
	struct tt__CertificateGenerationParameters *p;
	struct tt__CertificateGenerationParameters *a = (struct tt__CertificateGenerationParameters*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__CertificateGenerationParameters));
	for (p = a; p && n--; p++)
		soap_default_tt__CertificateGenerationParameters(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CertificateGenerationParameters(struct soap *soap, const struct tt__CertificateGenerationParameters *a, const char *tag, const char *type)
{
	if (soap_out_tt__CertificateGenerationParameters(soap, tag ? tag : "tt:CertificateGenerationParameters", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateGenerationParameters * SOAP_FMAC4 soap_get_tt__CertificateGenerationParameters(struct soap *soap, struct tt__CertificateGenerationParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateGenerationParameters(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__UserExtension(struct soap *soap, struct tt__UserExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__UserExtension(struct soap *soap, const struct tt__UserExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__UserExtension(struct soap *soap, const char *tag, int id, const struct tt__UserExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__UserExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__UserExtension * SOAP_FMAC4 soap_in_tt__UserExtension(struct soap *soap, const char *tag, struct tt__UserExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__UserExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__UserExtension, sizeof(struct tt__UserExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__UserExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__UserExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__UserExtension, SOAP_TYPE_tt__UserExtension, sizeof(struct tt__UserExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__UserExtension * SOAP_FMAC4 soap_new_tt__UserExtension(struct soap *soap, int n)
{
	struct tt__UserExtension *p;
	struct tt__UserExtension *a = (struct tt__UserExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__UserExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__UserExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__UserExtension(struct soap *soap, const struct tt__UserExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__UserExtension(soap, tag ? tag : "tt:UserExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__UserExtension * SOAP_FMAC4 soap_get_tt__UserExtension(struct soap *soap, struct tt__UserExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__UserExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__User(struct soap *soap, struct tt__User *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Username);
	soap_default_string(soap, &a->Password);
	soap_default_tt__UserLevel(soap, &a->UserLevel);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__User(struct soap *soap, const struct tt__User *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Username);
	soap_serialize_string(soap, (char*const*)&a->Password);
	soap_serialize_PointerTott__UserExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__User(struct soap *soap, const char *tag, int id, const struct tt__User *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__User), type))
		return soap->error;
	if (!a->Username)
	{	if (soap_element_nil(soap, "tt:Username"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "tt:Username", -1, (char*const*)&a->Username, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:Password", -1, (char*const*)&a->Password, ""))
		return soap->error;
	if (soap_out_tt__UserLevel(soap, "tt:UserLevel", -1, &a->UserLevel, ""))
		return soap->error;
	if (soap_out_PointerTott__UserExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__User * SOAP_FMAC4 soap_in_tt__User(struct soap *soap, const char *tag, struct tt__User *a, const char *type)
{
	size_t soap_flag_Username = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_UserLevel = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__User *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__User, sizeof(struct tt__User), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__User(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Username", (char**)&a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Password", (char**)&a->Password, "xsd:string"))
				{	soap_flag_Password--;
					continue;
				}
			if (soap_flag_UserLevel && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__UserLevel(soap, "tt:UserLevel", &a->UserLevel, "tt:UserLevel"))
				{	soap_flag_UserLevel--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__UserExtension(soap, "tt:Extension", &a->Extension, "tt:UserExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Username > 0 || soap_flag_UserLevel > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__User *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__User, SOAP_TYPE_tt__User, sizeof(struct tt__User), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__User * SOAP_FMAC4 soap_new_tt__User(struct soap *soap, int n)
{
	struct tt__User *p;
	struct tt__User *a = (struct tt__User*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__User));
	for (p = a; p && n--; p++)
		soap_default_tt__User(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__User(struct soap *soap, const struct tt__User *a, const char *tag, const char *type)
{
	if (soap_out_tt__User(soap, tag ? tag : "tt:User", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__User * SOAP_FMAC4 soap_get_tt__User(struct soap *soap, struct tt__User *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__User(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RemoteUser(struct soap *soap, struct tt__RemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Username);
	soap_default_string(soap, &a->Password);
	soap_default_xsd__boolean(soap, &a->UseDerivedPassword);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RemoteUser(struct soap *soap, const struct tt__RemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Username);
	soap_serialize_string(soap, (char*const*)&a->Password);
	soap_embedded(soap, &a->UseDerivedPassword, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RemoteUser(struct soap *soap, const char *tag, int id, const struct tt__RemoteUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RemoteUser), type))
		return soap->error;
	if (!a->Username)
	{	if (soap_element_nil(soap, "tt:Username"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "tt:Username", -1, (char*const*)&a->Username, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:Password", -1, (char*const*)&a->Password, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:UseDerivedPassword", -1, &a->UseDerivedPassword, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RemoteUser * SOAP_FMAC4 soap_in_tt__RemoteUser(struct soap *soap, const char *tag, struct tt__RemoteUser *a, const char *type)
{
	size_t soap_flag_Username = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_UseDerivedPassword = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RemoteUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RemoteUser, sizeof(struct tt__RemoteUser), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RemoteUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Username", (char**)&a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Password", (char**)&a->Password, "xsd:string"))
				{	soap_flag_Password--;
					continue;
				}
			if (soap_flag_UseDerivedPassword && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:UseDerivedPassword", &a->UseDerivedPassword, "xsd:boolean"))
				{	soap_flag_UseDerivedPassword--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Username > 0 || soap_flag_UseDerivedPassword > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__RemoteUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RemoteUser, SOAP_TYPE_tt__RemoteUser, sizeof(struct tt__RemoteUser), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RemoteUser * SOAP_FMAC4 soap_new_tt__RemoteUser(struct soap *soap, int n)
{
	struct tt__RemoteUser *p;
	struct tt__RemoteUser *a = (struct tt__RemoteUser*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RemoteUser));
	for (p = a; p && n--; p++)
		soap_default_tt__RemoteUser(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RemoteUser(struct soap *soap, const struct tt__RemoteUser *a, const char *tag, const char *type)
{
	if (soap_out_tt__RemoteUser(soap, tag ? tag : "tt:RemoteUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RemoteUser * SOAP_FMAC4 soap_get_tt__RemoteUser(struct soap *soap, struct tt__RemoteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Date(struct soap *soap, struct tt__Date *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Year);
	soap_default_int(soap, &a->Month);
	soap_default_int(soap, &a->Day);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Date(struct soap *soap, const struct tt__Date *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Year, SOAP_TYPE_int);
	soap_embedded(soap, &a->Month, SOAP_TYPE_int);
	soap_embedded(soap, &a->Day, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Date(struct soap *soap, const char *tag, int id, const struct tt__Date *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Date), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Year", -1, &a->Year, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Month", -1, &a->Month, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Day", -1, &a->Day, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Date * SOAP_FMAC4 soap_in_tt__Date(struct soap *soap, const char *tag, struct tt__Date *a, const char *type)
{
	size_t soap_flag_Year = 1;
	size_t soap_flag_Month = 1;
	size_t soap_flag_Day = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Date *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Date, sizeof(struct tt__Date), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Date(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Year && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Year", &a->Year, "xsd:int"))
				{	soap_flag_Year--;
					continue;
				}
			if (soap_flag_Month && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Month", &a->Month, "xsd:int"))
				{	soap_flag_Month--;
					continue;
				}
			if (soap_flag_Day && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Day", &a->Day, "xsd:int"))
				{	soap_flag_Day--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Year > 0 || soap_flag_Month > 0 || soap_flag_Day > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Date *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Date, SOAP_TYPE_tt__Date, sizeof(struct tt__Date), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Date * SOAP_FMAC4 soap_new_tt__Date(struct soap *soap, int n)
{
	struct tt__Date *p;
	struct tt__Date *a = (struct tt__Date*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Date));
	for (p = a; p && n--; p++)
		soap_default_tt__Date(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Date(struct soap *soap, const struct tt__Date *a, const char *tag, const char *type)
{
	if (soap_out_tt__Date(soap, tag ? tag : "tt:Date", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Date * SOAP_FMAC4 soap_get_tt__Date(struct soap *soap, struct tt__Date *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Time(struct soap *soap, struct tt__Time *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Hour);
	soap_default_int(soap, &a->Minute);
	soap_default_int(soap, &a->Second);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Time(struct soap *soap, const struct tt__Time *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Hour, SOAP_TYPE_int);
	soap_embedded(soap, &a->Minute, SOAP_TYPE_int);
	soap_embedded(soap, &a->Second, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Time(struct soap *soap, const char *tag, int id, const struct tt__Time *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Time), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Hour", -1, &a->Hour, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Minute", -1, &a->Minute, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Second", -1, &a->Second, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Time * SOAP_FMAC4 soap_in_tt__Time(struct soap *soap, const char *tag, struct tt__Time *a, const char *type)
{
	size_t soap_flag_Hour = 1;
	size_t soap_flag_Minute = 1;
	size_t soap_flag_Second = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Time *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Time, sizeof(struct tt__Time), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Time(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Hour && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Hour", &a->Hour, "xsd:int"))
				{	soap_flag_Hour--;
					continue;
				}
			if (soap_flag_Minute && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Minute", &a->Minute, "xsd:int"))
				{	soap_flag_Minute--;
					continue;
				}
			if (soap_flag_Second && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Second", &a->Second, "xsd:int"))
				{	soap_flag_Second--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Hour > 0 || soap_flag_Minute > 0 || soap_flag_Second > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Time *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Time, SOAP_TYPE_tt__Time, sizeof(struct tt__Time), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Time * SOAP_FMAC4 soap_new_tt__Time(struct soap *soap, int n)
{
	struct tt__Time *p;
	struct tt__Time *a = (struct tt__Time*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Time));
	for (p = a; p && n--; p++)
		soap_default_tt__Time(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Time(struct soap *soap, const struct tt__Time *a, const char *tag, const char *type)
{
	if (soap_out_tt__Time(soap, tag ? tag : "tt:Time", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Time * SOAP_FMAC4 soap_get_tt__Time(struct soap *soap, struct tt__Time *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SystemDateTimeExtension(struct soap *soap, struct tt__SystemDateTimeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SystemDateTimeExtension(struct soap *soap, const struct tt__SystemDateTimeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemDateTimeExtension(struct soap *soap, const char *tag, int id, const struct tt__SystemDateTimeExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemDateTimeExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SystemDateTimeExtension * SOAP_FMAC4 soap_in_tt__SystemDateTimeExtension(struct soap *soap, const char *tag, struct tt__SystemDateTimeExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SystemDateTimeExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemDateTimeExtension, sizeof(struct tt__SystemDateTimeExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SystemDateTimeExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SystemDateTimeExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemDateTimeExtension, SOAP_TYPE_tt__SystemDateTimeExtension, sizeof(struct tt__SystemDateTimeExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SystemDateTimeExtension * SOAP_FMAC4 soap_new_tt__SystemDateTimeExtension(struct soap *soap, int n)
{
	struct tt__SystemDateTimeExtension *p;
	struct tt__SystemDateTimeExtension *a = (struct tt__SystemDateTimeExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SystemDateTimeExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__SystemDateTimeExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SystemDateTimeExtension(struct soap *soap, const struct tt__SystemDateTimeExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__SystemDateTimeExtension(soap, tag ? tag : "tt:SystemDateTimeExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemDateTimeExtension * SOAP_FMAC4 soap_get_tt__SystemDateTimeExtension(struct soap *soap, struct tt__SystemDateTimeExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemDateTimeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DateTime(struct soap *soap, struct tt__DateTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Time = NULL;
	a->Date = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DateTime(struct soap *soap, const struct tt__DateTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Time(soap, &a->Time);
	soap_serialize_PointerTott__Date(soap, &a->Date);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DateTime(struct soap *soap, const char *tag, int id, const struct tt__DateTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DateTime), type))
		return soap->error;
	if (!a->Time)
	{	if (soap_element_nil(soap, "tt:Time"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__Time(soap, "tt:Time", -1, &a->Time, ""))
		return soap->error;
	if (!a->Date)
	{	if (soap_element_nil(soap, "tt:Date"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__Date(soap, "tt:Date", -1, &a->Date, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DateTime * SOAP_FMAC4 soap_in_tt__DateTime(struct soap *soap, const char *tag, struct tt__DateTime *a, const char *type)
{
	size_t soap_flag_Time = 1;
	size_t soap_flag_Date = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DateTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DateTime, sizeof(struct tt__DateTime), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DateTime(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Time && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Time(soap, "tt:Time", &a->Time, "tt:Time"))
				{	soap_flag_Time--;
					continue;
				}
			if (soap_flag_Date && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Date(soap, "tt:Date", &a->Date, "tt:Date"))
				{	soap_flag_Date--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Time > 0 || soap_flag_Date > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__DateTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DateTime, SOAP_TYPE_tt__DateTime, sizeof(struct tt__DateTime), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__DateTime * SOAP_FMAC4 soap_new_tt__DateTime(struct soap *soap, int n)
{
	struct tt__DateTime *p;
	struct tt__DateTime *a = (struct tt__DateTime*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__DateTime));
	for (p = a; p && n--; p++)
		soap_default_tt__DateTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DateTime(struct soap *soap, const struct tt__DateTime *a, const char *tag, const char *type)
{
	if (soap_out_tt__DateTime(soap, tag ? tag : "tt:DateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DateTime * SOAP_FMAC4 soap_get_tt__DateTime(struct soap *soap, struct tt__DateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__TimeZone(struct soap *soap, struct tt__TimeZone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->TZ);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__TimeZone(struct soap *soap, const struct tt__TimeZone *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__token(soap, (char*const*)&a->TZ);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TimeZone(struct soap *soap, const char *tag, int id, const struct tt__TimeZone *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TimeZone), type))
		return soap->error;
	if (!a->TZ)
	{	if (soap_element_nil(soap, "tt:TZ"))
			return soap->error;
	}
	else
	if (soap_out_xsd__token(soap, "tt:TZ", -1, (char*const*)&a->TZ, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__TimeZone * SOAP_FMAC4 soap_in_tt__TimeZone(struct soap *soap, const char *tag, struct tt__TimeZone *a, const char *type)
{
	size_t soap_flag_TZ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__TimeZone *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TimeZone, sizeof(struct tt__TimeZone), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__TimeZone(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TZ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tt:TZ", (char**)&a->TZ, "xsd:token"))
				{	soap_flag_TZ--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TZ > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__TimeZone *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TimeZone, SOAP_TYPE_tt__TimeZone, sizeof(struct tt__TimeZone), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__TimeZone * SOAP_FMAC4 soap_new_tt__TimeZone(struct soap *soap, int n)
{
	struct tt__TimeZone *p;
	struct tt__TimeZone *a = (struct tt__TimeZone*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__TimeZone));
	for (p = a; p && n--; p++)
		soap_default_tt__TimeZone(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__TimeZone(struct soap *soap, const struct tt__TimeZone *a, const char *tag, const char *type)
{
	if (soap_out_tt__TimeZone(soap, tag ? tag : "tt:TimeZone", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TimeZone * SOAP_FMAC4 soap_get_tt__TimeZone(struct soap *soap, struct tt__TimeZone *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TimeZone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SystemDateTime(struct soap *soap, struct tt__SystemDateTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__SetDateTimeType(soap, &a->DateTimeType);
	soap_default_xsd__boolean(soap, &a->DaylightSavings);
	a->TimeZone = NULL;
	a->UTCDateTime = NULL;
	a->LocalDateTime = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SystemDateTime(struct soap *soap, const struct tt__SystemDateTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->DaylightSavings, SOAP_TYPE_xsd__boolean);
	soap_serialize_PointerTott__TimeZone(soap, &a->TimeZone);
	soap_serialize_PointerTott__DateTime(soap, &a->UTCDateTime);
	soap_serialize_PointerTott__DateTime(soap, &a->LocalDateTime);
	soap_serialize_PointerTott__SystemDateTimeExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemDateTime(struct soap *soap, const char *tag, int id, const struct tt__SystemDateTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemDateTime), type))
		return soap->error;
	if (soap_out_tt__SetDateTimeType(soap, "tt:DateTimeType", -1, &a->DateTimeType, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:DaylightSavings", -1, &a->DaylightSavings, ""))
		return soap->error;
	if (soap_out_PointerTott__TimeZone(soap, "tt:TimeZone", -1, &a->TimeZone, ""))
		return soap->error;
	if (soap_out_PointerTott__DateTime(soap, "tt:UTCDateTime", -1, &a->UTCDateTime, ""))
		return soap->error;
	if (soap_out_PointerTott__DateTime(soap, "tt:LocalDateTime", -1, &a->LocalDateTime, ""))
		return soap->error;
	if (soap_out_PointerTott__SystemDateTimeExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SystemDateTime * SOAP_FMAC4 soap_in_tt__SystemDateTime(struct soap *soap, const char *tag, struct tt__SystemDateTime *a, const char *type)
{
	size_t soap_flag_DateTimeType = 1;
	size_t soap_flag_DaylightSavings = 1;
	size_t soap_flag_TimeZone = 1;
	size_t soap_flag_UTCDateTime = 1;
	size_t soap_flag_LocalDateTime = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SystemDateTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemDateTime, sizeof(struct tt__SystemDateTime), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SystemDateTime(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DateTimeType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__SetDateTimeType(soap, "tt:DateTimeType", &a->DateTimeType, "tt:SetDateTimeType"))
				{	soap_flag_DateTimeType--;
					continue;
				}
			if (soap_flag_DaylightSavings && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:DaylightSavings", &a->DaylightSavings, "xsd:boolean"))
				{	soap_flag_DaylightSavings--;
					continue;
				}
			if (soap_flag_TimeZone && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__TimeZone(soap, "tt:TimeZone", &a->TimeZone, "tt:TimeZone"))
				{	soap_flag_TimeZone--;
					continue;
				}
			if (soap_flag_UTCDateTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DateTime(soap, "tt:UTCDateTime", &a->UTCDateTime, "tt:DateTime"))
				{	soap_flag_UTCDateTime--;
					continue;
				}
			if (soap_flag_LocalDateTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DateTime(soap, "tt:LocalDateTime", &a->LocalDateTime, "tt:DateTime"))
				{	soap_flag_LocalDateTime--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SystemDateTimeExtension(soap, "tt:Extension", &a->Extension, "tt:SystemDateTimeExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DateTimeType > 0 || soap_flag_DaylightSavings > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__SystemDateTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemDateTime, SOAP_TYPE_tt__SystemDateTime, sizeof(struct tt__SystemDateTime), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SystemDateTime * SOAP_FMAC4 soap_new_tt__SystemDateTime(struct soap *soap, int n)
{
	struct tt__SystemDateTime *p;
	struct tt__SystemDateTime *a = (struct tt__SystemDateTime*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SystemDateTime));
	for (p = a; p && n--; p++)
		soap_default_tt__SystemDateTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SystemDateTime(struct soap *soap, const struct tt__SystemDateTime *a, const char *tag, const char *type)
{
	if (soap_out_tt__SystemDateTime(soap, tag ? tag : "tt:SystemDateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemDateTime * SOAP_FMAC4 soap_get_tt__SystemDateTime(struct soap *soap, struct tt__SystemDateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemDateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SystemLogUri(struct soap *soap, struct tt__SystemLogUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__SystemLogType(soap, &a->Type);
	soap_default_xsd__anyURI(soap, &a->Uri);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SystemLogUri(struct soap *soap, const struct tt__SystemLogUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->Uri);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemLogUri(struct soap *soap, const char *tag, int id, const struct tt__SystemLogUri *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemLogUri), type))
		return soap->error;
	if (soap_out_tt__SystemLogType(soap, "tt:Type", -1, &a->Type, ""))
		return soap->error;
	if (!a->Uri)
	{	if (soap_element_nil(soap, "tt:Uri"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "tt:Uri", -1, (char*const*)&a->Uri, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SystemLogUri * SOAP_FMAC4 soap_in_tt__SystemLogUri(struct soap *soap, const char *tag, struct tt__SystemLogUri *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_Uri = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SystemLogUri *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemLogUri, sizeof(struct tt__SystemLogUri), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SystemLogUri(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__SystemLogType(soap, "tt:Type", &a->Type, "tt:SystemLogType"))
				{	soap_flag_Type--;
					continue;
				}
			if (soap_flag_Uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:Uri", (char**)&a->Uri, "xsd:anyURI"))
				{	soap_flag_Uri--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0 || soap_flag_Uri > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__SystemLogUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemLogUri, SOAP_TYPE_tt__SystemLogUri, sizeof(struct tt__SystemLogUri), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SystemLogUri * SOAP_FMAC4 soap_new_tt__SystemLogUri(struct soap *soap, int n)
{
	struct tt__SystemLogUri *p;
	struct tt__SystemLogUri *a = (struct tt__SystemLogUri*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SystemLogUri));
	for (p = a; p && n--; p++)
		soap_default_tt__SystemLogUri(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SystemLogUri(struct soap *soap, const struct tt__SystemLogUri *a, const char *tag, const char *type)
{
	if (soap_out_tt__SystemLogUri(soap, tag ? tag : "tt:SystemLogUri", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemLogUri * SOAP_FMAC4 soap_get_tt__SystemLogUri(struct soap *soap, struct tt__SystemLogUri *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemLogUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SystemLogUriList(struct soap *soap, struct tt__SystemLogUriList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeSystemLog = 0;
	a->SystemLog = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SystemLogUriList(struct soap *soap, const struct tt__SystemLogUriList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->SystemLog)
	{	int i;
		for (i = 0; i < (int)a->__sizeSystemLog; i++)
		{
			soap_embedded(soap, a->SystemLog + i, SOAP_TYPE_tt__SystemLogUri);
			soap_serialize_tt__SystemLogUri(soap, a->SystemLog + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemLogUriList(struct soap *soap, const char *tag, int id, const struct tt__SystemLogUriList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemLogUriList), type))
		return soap->error;
	if (a->SystemLog)
	{	int i;
		for (i = 0; i < (int)a->__sizeSystemLog; i++)
			if (soap_out_tt__SystemLogUri(soap, "tt:SystemLog", -1, a->SystemLog + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SystemLogUriList * SOAP_FMAC4 soap_in_tt__SystemLogUriList(struct soap *soap, const char *tag, struct tt__SystemLogUriList *a, const char *type)
{
	struct soap_blist *soap_blist_SystemLog = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SystemLogUriList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemLogUriList, sizeof(struct tt__SystemLogUriList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SystemLogUriList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SystemLog", 1, NULL))
			{	if (a->SystemLog == NULL)
				{	if (soap_blist_SystemLog == NULL)
						soap_blist_SystemLog = soap_alloc_block(soap);
					a->SystemLog = (struct tt__SystemLogUri *)soap_push_block_max(soap, soap_blist_SystemLog, sizeof(struct tt__SystemLogUri));
					if (a->SystemLog == NULL)
						return NULL;
					soap_default_tt__SystemLogUri(soap, a->SystemLog);
				}
				soap_revert(soap);
				if (soap_in_tt__SystemLogUri(soap, "tt:SystemLog", a->SystemLog, "tt:SystemLogUri"))
				{	a->__sizeSystemLog++;
					a->SystemLog = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SystemLog)
			soap_pop_block(soap, soap_blist_SystemLog);
		if (a->__sizeSystemLog)
		{	a->SystemLog = (struct tt__SystemLogUri *)soap_save_block(soap, soap_blist_SystemLog, NULL, 1);
		}
		else
		{	a->SystemLog = NULL;
			if (soap_blist_SystemLog)
				soap_end_block(soap, soap_blist_SystemLog);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SystemLogUriList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemLogUriList, SOAP_TYPE_tt__SystemLogUriList, sizeof(struct tt__SystemLogUriList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SystemLogUriList * SOAP_FMAC4 soap_new_tt__SystemLogUriList(struct soap *soap, int n)
{
	struct tt__SystemLogUriList *p;
	struct tt__SystemLogUriList *a = (struct tt__SystemLogUriList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SystemLogUriList));
	for (p = a; p && n--; p++)
		soap_default_tt__SystemLogUriList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SystemLogUriList(struct soap *soap, const struct tt__SystemLogUriList *a, const char *tag, const char *type)
{
	if (soap_out_tt__SystemLogUriList(soap, tag ? tag : "tt:SystemLogUriList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemLogUriList * SOAP_FMAC4 soap_get_tt__SystemLogUriList(struct soap *soap, struct tt__SystemLogUriList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemLogUriList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__BackupFile(struct soap *soap, struct tt__BackupFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Name);
	a->Data = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__BackupFile(struct soap *soap, const struct tt__BackupFile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Name);
	soap_serialize_PointerTott__AttachmentData(soap, &a->Data);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BackupFile(struct soap *soap, const char *tag, int id, const struct tt__BackupFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BackupFile), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "tt:Name"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (!a->Data)
	{	if (soap_element_nil(soap, "tt:Data"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__AttachmentData(soap, "tt:Data", -1, &a->Data, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__BackupFile * SOAP_FMAC4 soap_in_tt__BackupFile(struct soap *soap, const char *tag, struct tt__BackupFile *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_Data = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__BackupFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BackupFile, sizeof(struct tt__BackupFile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__BackupFile(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Name", (char**)&a->Name, "xsd:string"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_Data && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AttachmentData(soap, "tt:Data", &a->Data, "tt:AttachmentData"))
				{	soap_flag_Data--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_Data > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__BackupFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BackupFile, SOAP_TYPE_tt__BackupFile, sizeof(struct tt__BackupFile), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__BackupFile * SOAP_FMAC4 soap_new_tt__BackupFile(struct soap *soap, int n)
{
	struct tt__BackupFile *p;
	struct tt__BackupFile *a = (struct tt__BackupFile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__BackupFile));
	for (p = a; p && n--; p++)
		soap_default_tt__BackupFile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__BackupFile(struct soap *soap, const struct tt__BackupFile *a, const char *tag, const char *type)
{
	if (soap_out_tt__BackupFile(soap, tag ? tag : "tt:BackupFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BackupFile * SOAP_FMAC4 soap_get_tt__BackupFile(struct soap *soap, struct tt__BackupFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BackupFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__BinaryData(struct soap *soap, struct tt__BinaryData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__base64Binary(soap, &a->Data);
	soap_default_string(soap, &a->xmime__contentType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__BinaryData(struct soap *soap, const struct tt__BinaryData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__base64Binary(soap, &a->Data);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BinaryData(struct soap *soap, const char *tag, int id, const struct tt__BinaryData *a, const char *type)
{
	if (a->xmime__contentType)
		soap_set_attr(soap, "xmime:contentType", soap_string2s(soap, a->xmime__contentType), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BinaryData), type))
		return soap->error;
	if (soap_out_xsd__base64Binary(soap, "tt:Data", -1, &a->Data, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__BinaryData * SOAP_FMAC4 soap_in_tt__BinaryData(struct soap *soap, const char *tag, struct tt__BinaryData *a, const char *type)
{
	size_t soap_flag_Data = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__BinaryData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BinaryData, sizeof(struct tt__BinaryData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__BinaryData(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "xmime:contentType", 0), &a->xmime__contentType))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Data && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__base64Binary(soap, "tt:Data", &a->Data, "xsd:base64Binary"))
				{	soap_flag_Data--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Data > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__BinaryData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BinaryData, SOAP_TYPE_tt__BinaryData, sizeof(struct tt__BinaryData), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__BinaryData * SOAP_FMAC4 soap_new_tt__BinaryData(struct soap *soap, int n)
{
	struct tt__BinaryData *p;
	struct tt__BinaryData *a = (struct tt__BinaryData*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__BinaryData));
	for (p = a; p && n--; p++)
		soap_default_tt__BinaryData(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__BinaryData(struct soap *soap, const struct tt__BinaryData *a, const char *tag, const char *type)
{
	if (soap_out_tt__BinaryData(soap, tag ? tag : "tt:BinaryData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BinaryData * SOAP_FMAC4 soap_get_tt__BinaryData(struct soap *soap, struct tt__BinaryData *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BinaryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SupportInformation(struct soap *soap, struct tt__SupportInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Binary = NULL;
	soap_default_string(soap, &a->String);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SupportInformation(struct soap *soap, const struct tt__SupportInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AttachmentData(soap, &a->Binary);
	soap_serialize_string(soap, (char*const*)&a->String);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SupportInformation(struct soap *soap, const char *tag, int id, const struct tt__SupportInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SupportInformation), type))
		return soap->error;
	if (soap_out_PointerTott__AttachmentData(soap, "tt:Binary", -1, &a->Binary, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:String", -1, (char*const*)&a->String, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SupportInformation * SOAP_FMAC4 soap_in_tt__SupportInformation(struct soap *soap, const char *tag, struct tt__SupportInformation *a, const char *type)
{
	size_t soap_flag_Binary = 1;
	size_t soap_flag_String = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SupportInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SupportInformation, sizeof(struct tt__SupportInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SupportInformation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Binary && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AttachmentData(soap, "tt:Binary", &a->Binary, "tt:AttachmentData"))
				{	soap_flag_Binary--;
					continue;
				}
			if (soap_flag_String && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:String", (char**)&a->String, "xsd:string"))
				{	soap_flag_String--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SupportInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SupportInformation, SOAP_TYPE_tt__SupportInformation, sizeof(struct tt__SupportInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SupportInformation * SOAP_FMAC4 soap_new_tt__SupportInformation(struct soap *soap, int n)
{
	struct tt__SupportInformation *p;
	struct tt__SupportInformation *a = (struct tt__SupportInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SupportInformation));
	for (p = a; p && n--; p++)
		soap_default_tt__SupportInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SupportInformation(struct soap *soap, const struct tt__SupportInformation *a, const char *tag, const char *type)
{
	if (soap_out_tt__SupportInformation(soap, tag ? tag : "tt:SupportInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SupportInformation * SOAP_FMAC4 soap_get_tt__SupportInformation(struct soap *soap, struct tt__SupportInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SupportInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AttachmentData(struct soap *soap, struct tt__AttachmentData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__xop__Include(soap, &a->xop__Include);
	soap_default_string(soap, &a->xmime__contentType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AttachmentData(struct soap *soap, const struct tt__AttachmentData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__xop__Include(soap, &a->xop__Include);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AttachmentData(struct soap *soap, const char *tag, int id, const struct tt__AttachmentData *a, const char *type)
{
	if (a->xmime__contentType)
		soap_set_attr(soap, "xmime:contentType", soap_string2s(soap, a->xmime__contentType), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AttachmentData), type))
		return soap->error;
	if (soap_out__xop__Include(soap, "xop:Include", -1, &a->xop__Include, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AttachmentData * SOAP_FMAC4 soap_in_tt__AttachmentData(struct soap *soap, const char *tag, struct tt__AttachmentData *a, const char *type)
{
	size_t soap_flag_xop__Include = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AttachmentData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AttachmentData, sizeof(struct tt__AttachmentData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AttachmentData(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "xmime:contentType", 0), &a->xmime__contentType))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xop__Include && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__xop__Include(soap, "xop:Include", &a->xop__Include, ""))
				{	soap_flag_xop__Include--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_xop__Include > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AttachmentData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AttachmentData, SOAP_TYPE_tt__AttachmentData, sizeof(struct tt__AttachmentData), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AttachmentData * SOAP_FMAC4 soap_new_tt__AttachmentData(struct soap *soap, int n)
{
	struct tt__AttachmentData *p;
	struct tt__AttachmentData *a = (struct tt__AttachmentData*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AttachmentData));
	for (p = a; p && n--; p++)
		soap_default_tt__AttachmentData(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AttachmentData(struct soap *soap, const struct tt__AttachmentData *a, const char *tag, const char *type)
{
	if (soap_out_tt__AttachmentData(soap, tag ? tag : "tt:AttachmentData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AttachmentData * SOAP_FMAC4 soap_get_tt__AttachmentData(struct soap *soap, struct tt__AttachmentData *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AttachmentData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SystemLog(struct soap *soap, struct tt__SystemLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Binary = NULL;
	soap_default_string(soap, &a->String);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SystemLog(struct soap *soap, const struct tt__SystemLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AttachmentData(soap, &a->Binary);
	soap_serialize_string(soap, (char*const*)&a->String);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemLog(struct soap *soap, const char *tag, int id, const struct tt__SystemLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemLog), type))
		return soap->error;
	if (soap_out_PointerTott__AttachmentData(soap, "tt:Binary", -1, &a->Binary, ""))
		return soap->error;
	if (soap_out_string(soap, "tt:String", -1, (char*const*)&a->String, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SystemLog * SOAP_FMAC4 soap_in_tt__SystemLog(struct soap *soap, const char *tag, struct tt__SystemLog *a, const char *type)
{
	size_t soap_flag_Binary = 1;
	size_t soap_flag_String = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SystemLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemLog, sizeof(struct tt__SystemLog), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SystemLog(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Binary && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AttachmentData(soap, "tt:Binary", &a->Binary, "tt:AttachmentData"))
				{	soap_flag_Binary--;
					continue;
				}
			if (soap_flag_String && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:String", (char**)&a->String, "xsd:string"))
				{	soap_flag_String--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SystemLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemLog, SOAP_TYPE_tt__SystemLog, sizeof(struct tt__SystemLog), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SystemLog * SOAP_FMAC4 soap_new_tt__SystemLog(struct soap *soap, int n)
{
	struct tt__SystemLog *p;
	struct tt__SystemLog *a = (struct tt__SystemLog*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SystemLog));
	for (p = a; p && n--; p++)
		soap_default_tt__SystemLog(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SystemLog(struct soap *soap, const struct tt__SystemLog *a, const char *tag, const char *type)
{
	if (soap_out_tt__SystemLog(soap, tag ? tag : "tt:SystemLog", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemLog * SOAP_FMAC4 soap_get_tt__SystemLog(struct soap *soap, struct tt__SystemLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsDeviceExtension(struct soap *soap, struct tt__AnalyticsDeviceExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsDeviceExtension(struct soap *soap, const struct tt__AnalyticsDeviceExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsDeviceExtension(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsDeviceExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsDeviceExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceExtension * SOAP_FMAC4 soap_in_tt__AnalyticsDeviceExtension(struct soap *soap, const char *tag, struct tt__AnalyticsDeviceExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AnalyticsDeviceExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsDeviceExtension, sizeof(struct tt__AnalyticsDeviceExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsDeviceExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsDeviceExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsDeviceExtension, SOAP_TYPE_tt__AnalyticsDeviceExtension, sizeof(struct tt__AnalyticsDeviceExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnalyticsDeviceExtension * SOAP_FMAC4 soap_new_tt__AnalyticsDeviceExtension(struct soap *soap, int n)
{
	struct tt__AnalyticsDeviceExtension *p;
	struct tt__AnalyticsDeviceExtension *a = (struct tt__AnalyticsDeviceExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnalyticsDeviceExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__AnalyticsDeviceExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsDeviceExtension(struct soap *soap, const struct tt__AnalyticsDeviceExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnalyticsDeviceExtension(soap, tag ? tag : "tt:AnalyticsDeviceExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceExtension * SOAP_FMAC4 soap_get_tt__AnalyticsDeviceExtension(struct soap *soap, struct tt__AnalyticsDeviceExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsDeviceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SystemCapabilitiesExtension2(struct soap *soap, struct tt__SystemCapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SystemCapabilitiesExtension2(struct soap *soap, const struct tt__SystemCapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemCapabilitiesExtension2(struct soap *soap, const char *tag, int id, const struct tt__SystemCapabilitiesExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemCapabilitiesExtension2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SystemCapabilitiesExtension2 * SOAP_FMAC4 soap_in_tt__SystemCapabilitiesExtension2(struct soap *soap, const char *tag, struct tt__SystemCapabilitiesExtension2 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SystemCapabilitiesExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemCapabilitiesExtension2, sizeof(struct tt__SystemCapabilitiesExtension2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SystemCapabilitiesExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SystemCapabilitiesExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemCapabilitiesExtension2, SOAP_TYPE_tt__SystemCapabilitiesExtension2, sizeof(struct tt__SystemCapabilitiesExtension2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SystemCapabilitiesExtension2 * SOAP_FMAC4 soap_new_tt__SystemCapabilitiesExtension2(struct soap *soap, int n)
{
	struct tt__SystemCapabilitiesExtension2 *p;
	struct tt__SystemCapabilitiesExtension2 *a = (struct tt__SystemCapabilitiesExtension2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SystemCapabilitiesExtension2));
	for (p = a; p && n--; p++)
		soap_default_tt__SystemCapabilitiesExtension2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SystemCapabilitiesExtension2(struct soap *soap, const struct tt__SystemCapabilitiesExtension2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__SystemCapabilitiesExtension2(soap, tag ? tag : "tt:SystemCapabilitiesExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemCapabilitiesExtension2 * SOAP_FMAC4 soap_get_tt__SystemCapabilitiesExtension2(struct soap *soap, struct tt__SystemCapabilitiesExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SystemCapabilitiesExtension(struct soap *soap, struct tt__SystemCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->HttpFirmwareUpgrade = NULL;
	a->HttpSystemBackup = NULL;
	a->HttpSystemLogging = NULL;
	a->HttpSupportInformation = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SystemCapabilitiesExtension(struct soap *soap, const struct tt__SystemCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__boolean(soap, &a->HttpFirmwareUpgrade);
	soap_serialize_PointerToxsd__boolean(soap, &a->HttpSystemBackup);
	soap_serialize_PointerToxsd__boolean(soap, &a->HttpSystemLogging);
	soap_serialize_PointerToxsd__boolean(soap, &a->HttpSupportInformation);
	soap_serialize_PointerTott__SystemCapabilitiesExtension2(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemCapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct tt__SystemCapabilitiesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemCapabilitiesExtension), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tt:HttpFirmwareUpgrade", -1, &a->HttpFirmwareUpgrade, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tt:HttpSystemBackup", -1, &a->HttpSystemBackup, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tt:HttpSystemLogging", -1, &a->HttpSystemLogging, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tt:HttpSupportInformation", -1, &a->HttpSupportInformation, ""))
		return soap->error;
	if (soap_out_PointerTott__SystemCapabilitiesExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SystemCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__SystemCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__SystemCapabilitiesExtension *a, const char *type)
{
	size_t soap_flag_HttpFirmwareUpgrade = 1;
	size_t soap_flag_HttpSystemBackup = 1;
	size_t soap_flag_HttpSystemLogging = 1;
	size_t soap_flag_HttpSupportInformation = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SystemCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemCapabilitiesExtension, sizeof(struct tt__SystemCapabilitiesExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SystemCapabilitiesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HttpFirmwareUpgrade && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "tt:HttpFirmwareUpgrade", &a->HttpFirmwareUpgrade, "xsd:boolean"))
				{	soap_flag_HttpFirmwareUpgrade--;
					continue;
				}
			if (soap_flag_HttpSystemBackup && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "tt:HttpSystemBackup", &a->HttpSystemBackup, "xsd:boolean"))
				{	soap_flag_HttpSystemBackup--;
					continue;
				}
			if (soap_flag_HttpSystemLogging && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "tt:HttpSystemLogging", &a->HttpSystemLogging, "xsd:boolean"))
				{	soap_flag_HttpSystemLogging--;
					continue;
				}
			if (soap_flag_HttpSupportInformation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "tt:HttpSupportInformation", &a->HttpSupportInformation, "xsd:boolean"))
				{	soap_flag_HttpSupportInformation--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SystemCapabilitiesExtension2(soap, "tt:Extension", &a->Extension, "tt:SystemCapabilitiesExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SystemCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemCapabilitiesExtension, SOAP_TYPE_tt__SystemCapabilitiesExtension, sizeof(struct tt__SystemCapabilitiesExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SystemCapabilitiesExtension * SOAP_FMAC4 soap_new_tt__SystemCapabilitiesExtension(struct soap *soap, int n)
{
	struct tt__SystemCapabilitiesExtension *p;
	struct tt__SystemCapabilitiesExtension *a = (struct tt__SystemCapabilitiesExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SystemCapabilitiesExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__SystemCapabilitiesExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SystemCapabilitiesExtension(struct soap *soap, const struct tt__SystemCapabilitiesExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__SystemCapabilitiesExtension(soap, tag ? tag : "tt:SystemCapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__SystemCapabilitiesExtension(struct soap *soap, struct tt__SystemCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OnvifVersion(struct soap *soap, struct tt__OnvifVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->Major);
	soap_default_int(soap, &a->Minor);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OnvifVersion(struct soap *soap, const struct tt__OnvifVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Major, SOAP_TYPE_int);
	soap_embedded(soap, &a->Minor, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OnvifVersion(struct soap *soap, const char *tag, int id, const struct tt__OnvifVersion *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OnvifVersion), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Major", -1, &a->Major, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Minor", -1, &a->Minor, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OnvifVersion * SOAP_FMAC4 soap_in_tt__OnvifVersion(struct soap *soap, const char *tag, struct tt__OnvifVersion *a, const char *type)
{
	size_t soap_flag_Major = 1;
	size_t soap_flag_Minor = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__OnvifVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OnvifVersion, sizeof(struct tt__OnvifVersion), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OnvifVersion(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Major && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Major", &a->Major, "xsd:int"))
				{	soap_flag_Major--;
					continue;
				}
			if (soap_flag_Minor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Minor", &a->Minor, "xsd:int"))
				{	soap_flag_Minor--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Major > 0 || soap_flag_Minor > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__OnvifVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OnvifVersion, SOAP_TYPE_tt__OnvifVersion, sizeof(struct tt__OnvifVersion), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OnvifVersion * SOAP_FMAC4 soap_new_tt__OnvifVersion(struct soap *soap, int n)
{
	struct tt__OnvifVersion *p;
	struct tt__OnvifVersion *a = (struct tt__OnvifVersion*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OnvifVersion));
	for (p = a; p && n--; p++)
		soap_default_tt__OnvifVersion(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OnvifVersion(struct soap *soap, const struct tt__OnvifVersion *a, const char *tag, const char *type)
{
	if (soap_out_tt__OnvifVersion(soap, tag ? tag : "tt:OnvifVersion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OnvifVersion * SOAP_FMAC4 soap_get_tt__OnvifVersion(struct soap *soap, struct tt__OnvifVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OnvifVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SecurityCapabilitiesExtension2(struct soap *soap, struct tt__SecurityCapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->Dot1X);
	a->__sizeSupportedEAPMethod = 0;
	a->SupportedEAPMethod = NULL;
	soap_default_xsd__boolean(soap, &a->RemoteUserHandling);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SecurityCapabilitiesExtension2(struct soap *soap, const struct tt__SecurityCapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Dot1X, SOAP_TYPE_xsd__boolean);
	if (a->SupportedEAPMethod)
	{	int i;
		for (i = 0; i < (int)a->__sizeSupportedEAPMethod; i++)
		{
			soap_embedded(soap, a->SupportedEAPMethod + i, SOAP_TYPE_int);
		}
	}
	soap_embedded(soap, &a->RemoteUserHandling, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SecurityCapabilitiesExtension2(struct soap *soap, const char *tag, int id, const struct tt__SecurityCapabilitiesExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SecurityCapabilitiesExtension2), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:Dot1X", -1, &a->Dot1X, ""))
		return soap->error;
	if (a->SupportedEAPMethod)
	{	int i;
		for (i = 0; i < (int)a->__sizeSupportedEAPMethod; i++)
			if (soap_out_int(soap, "tt:SupportedEAPMethod", -1, a->SupportedEAPMethod + i, ""))
				return soap->error;
	}
	if (soap_out_xsd__boolean(soap, "tt:RemoteUserHandling", -1, &a->RemoteUserHandling, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SecurityCapabilitiesExtension2 * SOAP_FMAC4 soap_in_tt__SecurityCapabilitiesExtension2(struct soap *soap, const char *tag, struct tt__SecurityCapabilitiesExtension2 *a, const char *type)
{
	size_t soap_flag_Dot1X = 1;
	struct soap_blist *soap_blist_SupportedEAPMethod = NULL;
	size_t soap_flag_RemoteUserHandling = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SecurityCapabilitiesExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, sizeof(struct tt__SecurityCapabilitiesExtension2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SecurityCapabilitiesExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1X && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:Dot1X", &a->Dot1X, "xsd:boolean"))
				{	soap_flag_Dot1X--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SupportedEAPMethod", 1, NULL))
			{	if (a->SupportedEAPMethod == NULL)
				{	if (soap_blist_SupportedEAPMethod == NULL)
						soap_blist_SupportedEAPMethod = soap_alloc_block(soap);
					a->SupportedEAPMethod = (int *)soap_push_block_max(soap, soap_blist_SupportedEAPMethod, sizeof(int));
					if (a->SupportedEAPMethod == NULL)
						return NULL;
					soap_default_int(soap, a->SupportedEAPMethod);
				}
				soap_revert(soap);
				if (soap_in_int(soap, "tt:SupportedEAPMethod", a->SupportedEAPMethod, "xsd:int"))
				{	a->__sizeSupportedEAPMethod++;
					a->SupportedEAPMethod = NULL;
					continue;
				}
			}
			if (soap_flag_RemoteUserHandling && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:RemoteUserHandling", &a->RemoteUserHandling, "xsd:boolean"))
				{	soap_flag_RemoteUserHandling--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SupportedEAPMethod)
			soap_pop_block(soap, soap_blist_SupportedEAPMethod);
		if (a->__sizeSupportedEAPMethod)
		{	a->SupportedEAPMethod = (int *)soap_save_block(soap, soap_blist_SupportedEAPMethod, NULL, 1);
		}
		else
		{	a->SupportedEAPMethod = NULL;
			if (soap_blist_SupportedEAPMethod)
				soap_end_block(soap, soap_blist_SupportedEAPMethod);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Dot1X > 0 || soap_flag_RemoteUserHandling > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__SecurityCapabilitiesExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, sizeof(struct tt__SecurityCapabilitiesExtension2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SecurityCapabilitiesExtension2 * SOAP_FMAC4 soap_new_tt__SecurityCapabilitiesExtension2(struct soap *soap, int n)
{
	struct tt__SecurityCapabilitiesExtension2 *p;
	struct tt__SecurityCapabilitiesExtension2 *a = (struct tt__SecurityCapabilitiesExtension2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SecurityCapabilitiesExtension2));
	for (p = a; p && n--; p++)
		soap_default_tt__SecurityCapabilitiesExtension2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SecurityCapabilitiesExtension2(struct soap *soap, const struct tt__SecurityCapabilitiesExtension2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__SecurityCapabilitiesExtension2(soap, tag ? tag : "tt:SecurityCapabilitiesExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SecurityCapabilitiesExtension2 * SOAP_FMAC4 soap_get_tt__SecurityCapabilitiesExtension2(struct soap *soap, struct tt__SecurityCapabilitiesExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SecurityCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SecurityCapabilitiesExtension(struct soap *soap, struct tt__SecurityCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->TLS1_x002e0);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SecurityCapabilitiesExtension(struct soap *soap, const struct tt__SecurityCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->TLS1_x002e0, SOAP_TYPE_xsd__boolean);
	soap_serialize_PointerTott__SecurityCapabilitiesExtension2(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SecurityCapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct tt__SecurityCapabilitiesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SecurityCapabilitiesExtension), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:TLS1.0", -1, &a->TLS1_x002e0, ""))
		return soap->error;
	if (soap_out_PointerTott__SecurityCapabilitiesExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SecurityCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__SecurityCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__SecurityCapabilitiesExtension *a, const char *type)
{
	size_t soap_flag_TLS1_x002e0 = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SecurityCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SecurityCapabilitiesExtension, sizeof(struct tt__SecurityCapabilitiesExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SecurityCapabilitiesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TLS1_x002e0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:TLS1.0", &a->TLS1_x002e0, "xsd:boolean"))
				{	soap_flag_TLS1_x002e0--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SecurityCapabilitiesExtension2(soap, "tt:Extension", &a->Extension, "tt:SecurityCapabilitiesExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TLS1_x002e0 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__SecurityCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SecurityCapabilitiesExtension, SOAP_TYPE_tt__SecurityCapabilitiesExtension, sizeof(struct tt__SecurityCapabilitiesExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SecurityCapabilitiesExtension * SOAP_FMAC4 soap_new_tt__SecurityCapabilitiesExtension(struct soap *soap, int n)
{
	struct tt__SecurityCapabilitiesExtension *p;
	struct tt__SecurityCapabilitiesExtension *a = (struct tt__SecurityCapabilitiesExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SecurityCapabilitiesExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__SecurityCapabilitiesExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SecurityCapabilitiesExtension(struct soap *soap, const struct tt__SecurityCapabilitiesExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__SecurityCapabilitiesExtension(soap, tag ? tag : "tt:SecurityCapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SecurityCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__SecurityCapabilitiesExtension(struct soap *soap, struct tt__SecurityCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SecurityCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkCapabilitiesExtension2(struct soap *soap, struct tt__NetworkCapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkCapabilitiesExtension2(struct soap *soap, const struct tt__NetworkCapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkCapabilitiesExtension2(struct soap *soap, const char *tag, int id, const struct tt__NetworkCapabilitiesExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkCapabilitiesExtension2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkCapabilitiesExtension2 * SOAP_FMAC4 soap_in_tt__NetworkCapabilitiesExtension2(struct soap *soap, const char *tag, struct tt__NetworkCapabilitiesExtension2 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkCapabilitiesExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkCapabilitiesExtension2, sizeof(struct tt__NetworkCapabilitiesExtension2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkCapabilitiesExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkCapabilitiesExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkCapabilitiesExtension2, SOAP_TYPE_tt__NetworkCapabilitiesExtension2, sizeof(struct tt__NetworkCapabilitiesExtension2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__NetworkCapabilitiesExtension2 * SOAP_FMAC4 soap_new_tt__NetworkCapabilitiesExtension2(struct soap *soap, int n)
{
	struct tt__NetworkCapabilitiesExtension2 *p;
	struct tt__NetworkCapabilitiesExtension2 *a = (struct tt__NetworkCapabilitiesExtension2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__NetworkCapabilitiesExtension2));
	for (p = a; p && n--; p++)
		soap_default_tt__NetworkCapabilitiesExtension2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkCapabilitiesExtension2(struct soap *soap, const struct tt__NetworkCapabilitiesExtension2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__NetworkCapabilitiesExtension2(soap, tag ? tag : "tt:NetworkCapabilitiesExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkCapabilitiesExtension2 * SOAP_FMAC4 soap_get_tt__NetworkCapabilitiesExtension2(struct soap *soap, struct tt__NetworkCapabilitiesExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkCapabilitiesExtension(struct soap *soap, struct tt__NetworkCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Dot11Configuration = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkCapabilitiesExtension(struct soap *soap, const struct tt__NetworkCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__boolean(soap, &a->Dot11Configuration);
	soap_serialize_PointerTott__NetworkCapabilitiesExtension2(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkCapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct tt__NetworkCapabilitiesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkCapabilitiesExtension), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tt:Dot11Configuration", -1, &a->Dot11Configuration, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkCapabilitiesExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__NetworkCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__NetworkCapabilitiesExtension *a, const char *type)
{
	size_t soap_flag_Dot11Configuration = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkCapabilitiesExtension, sizeof(struct tt__NetworkCapabilitiesExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkCapabilitiesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot11Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "tt:Dot11Configuration", &a->Dot11Configuration, "xsd:boolean"))
				{	soap_flag_Dot11Configuration--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkCapabilitiesExtension2(soap, "tt:Extension", &a->Extension, "tt:NetworkCapabilitiesExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkCapabilitiesExtension, SOAP_TYPE_tt__NetworkCapabilitiesExtension, sizeof(struct tt__NetworkCapabilitiesExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__NetworkCapabilitiesExtension * SOAP_FMAC4 soap_new_tt__NetworkCapabilitiesExtension(struct soap *soap, int n)
{
	struct tt__NetworkCapabilitiesExtension *p;
	struct tt__NetworkCapabilitiesExtension *a = (struct tt__NetworkCapabilitiesExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__NetworkCapabilitiesExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__NetworkCapabilitiesExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkCapabilitiesExtension(struct soap *soap, const struct tt__NetworkCapabilitiesExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__NetworkCapabilitiesExtension(soap, tag ? tag : "tt:NetworkCapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__NetworkCapabilitiesExtension(struct soap *soap, struct tt__NetworkCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, struct tt__RealTimeStreamingCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const struct tt__RealTimeStreamingCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct tt__RealTimeStreamingCapabilitiesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RealTimeStreamingCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__RealTimeStreamingCapabilitiesExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RealTimeStreamingCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension, sizeof(struct tt__RealTimeStreamingCapabilitiesExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RealTimeStreamingCapabilitiesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RealTimeStreamingCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension, sizeof(struct tt__RealTimeStreamingCapabilitiesExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RealTimeStreamingCapabilitiesExtension * SOAP_FMAC4 soap_new_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, int n)
{
	struct tt__RealTimeStreamingCapabilitiesExtension *p;
	struct tt__RealTimeStreamingCapabilitiesExtension *a = (struct tt__RealTimeStreamingCapabilitiesExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RealTimeStreamingCapabilitiesExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__RealTimeStreamingCapabilitiesExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const struct tt__RealTimeStreamingCapabilitiesExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__RealTimeStreamingCapabilitiesExtension(soap, tag ? tag : "tt:RealTimeStreamingCapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RealTimeStreamingCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, struct tt__RealTimeStreamingCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RealTimeStreamingCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ProfileCapabilities(struct soap *soap, struct tt__ProfileCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->MaximumNumberOfProfiles);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ProfileCapabilities(struct soap *soap, const struct tt__ProfileCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->MaximumNumberOfProfiles, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ProfileCapabilities(struct soap *soap, const char *tag, int id, const struct tt__ProfileCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ProfileCapabilities), type))
		return soap->error;
	if (soap_out_int(soap, "tt:MaximumNumberOfProfiles", -1, &a->MaximumNumberOfProfiles, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ProfileCapabilities * SOAP_FMAC4 soap_in_tt__ProfileCapabilities(struct soap *soap, const char *tag, struct tt__ProfileCapabilities *a, const char *type)
{
	size_t soap_flag_MaximumNumberOfProfiles = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ProfileCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ProfileCapabilities, sizeof(struct tt__ProfileCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ProfileCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaximumNumberOfProfiles && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:MaximumNumberOfProfiles", &a->MaximumNumberOfProfiles, "xsd:int"))
				{	soap_flag_MaximumNumberOfProfiles--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MaximumNumberOfProfiles > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ProfileCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ProfileCapabilities, SOAP_TYPE_tt__ProfileCapabilities, sizeof(struct tt__ProfileCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ProfileCapabilities * SOAP_FMAC4 soap_new_tt__ProfileCapabilities(struct soap *soap, int n)
{
	struct tt__ProfileCapabilities *p;
	struct tt__ProfileCapabilities *a = (struct tt__ProfileCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ProfileCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tt__ProfileCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ProfileCapabilities(struct soap *soap, const struct tt__ProfileCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tt__ProfileCapabilities(soap, tag ? tag : "tt:ProfileCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ProfileCapabilities * SOAP_FMAC4 soap_get_tt__ProfileCapabilities(struct soap *soap, struct tt__ProfileCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ProfileCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MediaCapabilitiesExtension(struct soap *soap, struct tt__MediaCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ProfileCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MediaCapabilitiesExtension(struct soap *soap, const struct tt__MediaCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ProfileCapabilities(soap, &a->ProfileCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MediaCapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct tt__MediaCapabilitiesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MediaCapabilitiesExtension), type))
		return soap->error;
	if (!a->ProfileCapabilities)
	{	if (soap_element_nil(soap, "tt:ProfileCapabilities"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__ProfileCapabilities(soap, "tt:ProfileCapabilities", -1, &a->ProfileCapabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MediaCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__MediaCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__MediaCapabilitiesExtension *a, const char *type)
{
	size_t soap_flag_ProfileCapabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MediaCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MediaCapabilitiesExtension, sizeof(struct tt__MediaCapabilitiesExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MediaCapabilitiesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileCapabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ProfileCapabilities(soap, "tt:ProfileCapabilities", &a->ProfileCapabilities, "tt:ProfileCapabilities"))
				{	soap_flag_ProfileCapabilities--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileCapabilities > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__MediaCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MediaCapabilitiesExtension, SOAP_TYPE_tt__MediaCapabilitiesExtension, sizeof(struct tt__MediaCapabilitiesExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MediaCapabilitiesExtension * SOAP_FMAC4 soap_new_tt__MediaCapabilitiesExtension(struct soap *soap, int n)
{
	struct tt__MediaCapabilitiesExtension *p;
	struct tt__MediaCapabilitiesExtension *a = (struct tt__MediaCapabilitiesExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MediaCapabilitiesExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__MediaCapabilitiesExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MediaCapabilitiesExtension(struct soap *soap, const struct tt__MediaCapabilitiesExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__MediaCapabilitiesExtension(soap, tag ? tag : "tt:MediaCapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MediaCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__MediaCapabilitiesExtension(struct soap *soap, struct tt__MediaCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MediaCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RealTimeStreamingCapabilities(struct soap *soap, struct tt__RealTimeStreamingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RTPMulticast = NULL;
	a->RTP_USCORETCP = NULL;
	a->RTP_USCORERTSP_USCORETCP = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RealTimeStreamingCapabilities(struct soap *soap, const struct tt__RealTimeStreamingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__boolean(soap, &a->RTPMulticast);
	soap_serialize_PointerToxsd__boolean(soap, &a->RTP_USCORETCP);
	soap_serialize_PointerToxsd__boolean(soap, &a->RTP_USCORERTSP_USCORETCP);
	soap_serialize_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RealTimeStreamingCapabilities(struct soap *soap, const char *tag, int id, const struct tt__RealTimeStreamingCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RealTimeStreamingCapabilities), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tt:RTPMulticast", -1, &a->RTPMulticast, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tt:RTP_TCP", -1, &a->RTP_USCORETCP, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tt:RTP_RTSP_TCP", -1, &a->RTP_USCORERTSP_USCORETCP, ""))
		return soap->error;
	if (soap_out_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RealTimeStreamingCapabilities * SOAP_FMAC4 soap_in_tt__RealTimeStreamingCapabilities(struct soap *soap, const char *tag, struct tt__RealTimeStreamingCapabilities *a, const char *type)
{
	size_t soap_flag_RTPMulticast = 1;
	size_t soap_flag_RTP_USCORETCP = 1;
	size_t soap_flag_RTP_USCORERTSP_USCORETCP = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RealTimeStreamingCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RealTimeStreamingCapabilities, sizeof(struct tt__RealTimeStreamingCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RealTimeStreamingCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RTPMulticast && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "tt:RTPMulticast", &a->RTPMulticast, "xsd:boolean"))
				{	soap_flag_RTPMulticast--;
					continue;
				}
			if (soap_flag_RTP_USCORETCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "tt:RTP_TCP", &a->RTP_USCORETCP, "xsd:boolean"))
				{	soap_flag_RTP_USCORETCP--;
					continue;
				}
			if (soap_flag_RTP_USCORERTSP_USCORETCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "tt:RTP_RTSP_TCP", &a->RTP_USCORERTSP_USCORETCP, "xsd:boolean"))
				{	soap_flag_RTP_USCORERTSP_USCORETCP--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, "tt:Extension", &a->Extension, "tt:RealTimeStreamingCapabilitiesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RealTimeStreamingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RealTimeStreamingCapabilities, SOAP_TYPE_tt__RealTimeStreamingCapabilities, sizeof(struct tt__RealTimeStreamingCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RealTimeStreamingCapabilities * SOAP_FMAC4 soap_new_tt__RealTimeStreamingCapabilities(struct soap *soap, int n)
{
	struct tt__RealTimeStreamingCapabilities *p;
	struct tt__RealTimeStreamingCapabilities *a = (struct tt__RealTimeStreamingCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RealTimeStreamingCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tt__RealTimeStreamingCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RealTimeStreamingCapabilities(struct soap *soap, const struct tt__RealTimeStreamingCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tt__RealTimeStreamingCapabilities(soap, tag ? tag : "tt:RealTimeStreamingCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RealTimeStreamingCapabilities * SOAP_FMAC4 soap_get_tt__RealTimeStreamingCapabilities(struct soap *soap, struct tt__RealTimeStreamingCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RealTimeStreamingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IOCapabilitiesExtension2(struct soap *soap, struct tt__IOCapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IOCapabilitiesExtension2(struct soap *soap, const struct tt__IOCapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IOCapabilitiesExtension2(struct soap *soap, const char *tag, int id, const struct tt__IOCapabilitiesExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IOCapabilitiesExtension2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IOCapabilitiesExtension2 * SOAP_FMAC4 soap_in_tt__IOCapabilitiesExtension2(struct soap *soap, const char *tag, struct tt__IOCapabilitiesExtension2 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IOCapabilitiesExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IOCapabilitiesExtension2, sizeof(struct tt__IOCapabilitiesExtension2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IOCapabilitiesExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__IOCapabilitiesExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IOCapabilitiesExtension2, SOAP_TYPE_tt__IOCapabilitiesExtension2, sizeof(struct tt__IOCapabilitiesExtension2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__IOCapabilitiesExtension2 * SOAP_FMAC4 soap_new_tt__IOCapabilitiesExtension2(struct soap *soap, int n)
{
	struct tt__IOCapabilitiesExtension2 *p;
	struct tt__IOCapabilitiesExtension2 *a = (struct tt__IOCapabilitiesExtension2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__IOCapabilitiesExtension2));
	for (p = a; p && n--; p++)
		soap_default_tt__IOCapabilitiesExtension2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IOCapabilitiesExtension2(struct soap *soap, const struct tt__IOCapabilitiesExtension2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__IOCapabilitiesExtension2(soap, tag ? tag : "tt:IOCapabilitiesExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IOCapabilitiesExtension2 * SOAP_FMAC4 soap_get_tt__IOCapabilitiesExtension2(struct soap *soap, struct tt__IOCapabilitiesExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IOCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IOCapabilitiesExtension(struct soap *soap, struct tt__IOCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Auxiliary = NULL;
	a->__sizeAuxiliaryCommands = 0;
	a->AuxiliaryCommands = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IOCapabilitiesExtension(struct soap *soap, const struct tt__IOCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__boolean(soap, &a->Auxiliary);
	if (a->AuxiliaryCommands)
	{	int i;
		for (i = 0; i < (int)a->__sizeAuxiliaryCommands; i++)
		{
			soap_serialize_tt__AuxiliaryData(soap, (char*const*)(a->AuxiliaryCommands + i));
		}
	}
	soap_serialize_PointerTott__IOCapabilitiesExtension2(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IOCapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct tt__IOCapabilitiesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IOCapabilitiesExtension), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tt:Auxiliary", -1, &a->Auxiliary, ""))
		return soap->error;
	if (a->AuxiliaryCommands)
	{	int i;
		for (i = 0; i < (int)a->__sizeAuxiliaryCommands; i++)
			soap_out_string(soap, "tt:AuxiliaryCommands", -1, (char*const*)(a->AuxiliaryCommands + i), "");
	}
	if (!a->Extension)
	{	if (soap_element_nil(soap, "tt:Extension"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__IOCapabilitiesExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IOCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__IOCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__IOCapabilitiesExtension *a, const char *type)
{
	size_t soap_flag_Auxiliary = 1;
	struct soap_blist *soap_blist_AuxiliaryCommands = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IOCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IOCapabilitiesExtension, sizeof(struct tt__IOCapabilitiesExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IOCapabilitiesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auxiliary && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "tt:Auxiliary", &a->Auxiliary, "xsd:boolean"))
				{	soap_flag_Auxiliary--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AuxiliaryCommands", 1, NULL))
			{	if (a->AuxiliaryCommands == NULL)
				{	if (soap_blist_AuxiliaryCommands == NULL)
						soap_blist_AuxiliaryCommands = soap_alloc_block(soap);
					a->AuxiliaryCommands = (char **)soap_push_block_max(soap, soap_blist_AuxiliaryCommands, sizeof(char *));
					if (a->AuxiliaryCommands == NULL)
						return NULL;
					*a->AuxiliaryCommands = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__AuxiliaryData(soap, "tt:AuxiliaryCommands", (char**)a->AuxiliaryCommands, "tt:AuxiliaryData"))
				{	a->__sizeAuxiliaryCommands++;
					a->AuxiliaryCommands = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IOCapabilitiesExtension2(soap, "tt:Extension", &a->Extension, "tt:IOCapabilitiesExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AuxiliaryCommands)
			soap_pop_block(soap, soap_blist_AuxiliaryCommands);
		if (a->__sizeAuxiliaryCommands)
		{	a->AuxiliaryCommands = (char **)soap_save_block(soap, soap_blist_AuxiliaryCommands, NULL, 1);
		}
		else
		{	a->AuxiliaryCommands = NULL;
			if (soap_blist_AuxiliaryCommands)
				soap_end_block(soap, soap_blist_AuxiliaryCommands);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Extension > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__IOCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IOCapabilitiesExtension, SOAP_TYPE_tt__IOCapabilitiesExtension, sizeof(struct tt__IOCapabilitiesExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__IOCapabilitiesExtension * SOAP_FMAC4 soap_new_tt__IOCapabilitiesExtension(struct soap *soap, int n)
{
	struct tt__IOCapabilitiesExtension *p;
	struct tt__IOCapabilitiesExtension *a = (struct tt__IOCapabilitiesExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__IOCapabilitiesExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__IOCapabilitiesExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IOCapabilitiesExtension(struct soap *soap, const struct tt__IOCapabilitiesExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__IOCapabilitiesExtension(soap, tag ? tag : "tt:IOCapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IOCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__IOCapabilitiesExtension(struct soap *soap, struct tt__IOCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IOCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DeviceCapabilitiesExtension(struct soap *soap, struct tt__DeviceCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DeviceCapabilitiesExtension(struct soap *soap, const struct tt__DeviceCapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DeviceCapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct tt__DeviceCapabilitiesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DeviceCapabilitiesExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DeviceCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__DeviceCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__DeviceCapabilitiesExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DeviceCapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceCapabilitiesExtension, sizeof(struct tt__DeviceCapabilitiesExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DeviceCapabilitiesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__DeviceCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DeviceCapabilitiesExtension, SOAP_TYPE_tt__DeviceCapabilitiesExtension, sizeof(struct tt__DeviceCapabilitiesExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__DeviceCapabilitiesExtension * SOAP_FMAC4 soap_new_tt__DeviceCapabilitiesExtension(struct soap *soap, int n)
{
	struct tt__DeviceCapabilitiesExtension *p;
	struct tt__DeviceCapabilitiesExtension *a = (struct tt__DeviceCapabilitiesExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__DeviceCapabilitiesExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__DeviceCapabilitiesExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DeviceCapabilitiesExtension(struct soap *soap, const struct tt__DeviceCapabilitiesExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__DeviceCapabilitiesExtension(soap, tag ? tag : "tt:DeviceCapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DeviceCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__DeviceCapabilitiesExtension(struct soap *soap, struct tt__DeviceCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DeviceCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SecurityCapabilities(struct soap *soap, struct tt__SecurityCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->TLS1_x002e1);
	soap_default_xsd__boolean(soap, &a->TLS1_x002e2);
	soap_default_xsd__boolean(soap, &a->OnboardKeyGeneration);
	soap_default_xsd__boolean(soap, &a->AccessPolicyConfig);
	soap_default_xsd__boolean(soap, &a->X_x002e509Token);
	soap_default_xsd__boolean(soap, &a->SAMLToken);
	soap_default_xsd__boolean(soap, &a->KerberosToken);
	soap_default_xsd__boolean(soap, &a->RELToken);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SecurityCapabilities(struct soap *soap, const struct tt__SecurityCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->TLS1_x002e1, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->TLS1_x002e2, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->OnboardKeyGeneration, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->AccessPolicyConfig, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->X_x002e509Token, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->SAMLToken, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->KerberosToken, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->RELToken, SOAP_TYPE_xsd__boolean);
	soap_serialize_PointerTott__SecurityCapabilitiesExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SecurityCapabilities(struct soap *soap, const char *tag, int id, const struct tt__SecurityCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SecurityCapabilities), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:TLS1.1", -1, &a->TLS1_x002e1, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:TLS1.2", -1, &a->TLS1_x002e2, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:OnboardKeyGeneration", -1, &a->OnboardKeyGeneration, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:AccessPolicyConfig", -1, &a->AccessPolicyConfig, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:X.509Token", -1, &a->X_x002e509Token, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:SAMLToken", -1, &a->SAMLToken, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:KerberosToken", -1, &a->KerberosToken, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:RELToken", -1, &a->RELToken, ""))
		return soap->error;
	if (soap_out_PointerTott__SecurityCapabilitiesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SecurityCapabilities * SOAP_FMAC4 soap_in_tt__SecurityCapabilities(struct soap *soap, const char *tag, struct tt__SecurityCapabilities *a, const char *type)
{
	size_t soap_flag_TLS1_x002e1 = 1;
	size_t soap_flag_TLS1_x002e2 = 1;
	size_t soap_flag_OnboardKeyGeneration = 1;
	size_t soap_flag_AccessPolicyConfig = 1;
	size_t soap_flag_X_x002e509Token = 1;
	size_t soap_flag_SAMLToken = 1;
	size_t soap_flag_KerberosToken = 1;
	size_t soap_flag_RELToken = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SecurityCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SecurityCapabilities, sizeof(struct tt__SecurityCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SecurityCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TLS1_x002e1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:TLS1.1", &a->TLS1_x002e1, "xsd:boolean"))
				{	soap_flag_TLS1_x002e1--;
					continue;
				}
			if (soap_flag_TLS1_x002e2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:TLS1.2", &a->TLS1_x002e2, "xsd:boolean"))
				{	soap_flag_TLS1_x002e2--;
					continue;
				}
			if (soap_flag_OnboardKeyGeneration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:OnboardKeyGeneration", &a->OnboardKeyGeneration, "xsd:boolean"))
				{	soap_flag_OnboardKeyGeneration--;
					continue;
				}
			if (soap_flag_AccessPolicyConfig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:AccessPolicyConfig", &a->AccessPolicyConfig, "xsd:boolean"))
				{	soap_flag_AccessPolicyConfig--;
					continue;
				}
			if (soap_flag_X_x002e509Token && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:X.509Token", &a->X_x002e509Token, "xsd:boolean"))
				{	soap_flag_X_x002e509Token--;
					continue;
				}
			if (soap_flag_SAMLToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:SAMLToken", &a->SAMLToken, "xsd:boolean"))
				{	soap_flag_SAMLToken--;
					continue;
				}
			if (soap_flag_KerberosToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:KerberosToken", &a->KerberosToken, "xsd:boolean"))
				{	soap_flag_KerberosToken--;
					continue;
				}
			if (soap_flag_RELToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:RELToken", &a->RELToken, "xsd:boolean"))
				{	soap_flag_RELToken--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SecurityCapabilitiesExtension(soap, "tt:Extension", &a->Extension, "tt:SecurityCapabilitiesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TLS1_x002e1 > 0 || soap_flag_TLS1_x002e2 > 0 || soap_flag_OnboardKeyGeneration > 0 || soap_flag_AccessPolicyConfig > 0 || soap_flag_X_x002e509Token > 0 || soap_flag_SAMLToken > 0 || soap_flag_KerberosToken > 0 || soap_flag_RELToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__SecurityCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SecurityCapabilities, SOAP_TYPE_tt__SecurityCapabilities, sizeof(struct tt__SecurityCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SecurityCapabilities * SOAP_FMAC4 soap_new_tt__SecurityCapabilities(struct soap *soap, int n)
{
	struct tt__SecurityCapabilities *p;
	struct tt__SecurityCapabilities *a = (struct tt__SecurityCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SecurityCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tt__SecurityCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SecurityCapabilities(struct soap *soap, const struct tt__SecurityCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tt__SecurityCapabilities(soap, tag ? tag : "tt:SecurityCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SecurityCapabilities * SOAP_FMAC4 soap_get_tt__SecurityCapabilities(struct soap *soap, struct tt__SecurityCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SecurityCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__IOCapabilities(struct soap *soap, struct tt__IOCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->InputConnectors = NULL;
	a->RelayOutputs = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IOCapabilities(struct soap *soap, const struct tt__IOCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->InputConnectors);
	soap_serialize_PointerToint(soap, &a->RelayOutputs);
	soap_serialize_PointerTott__IOCapabilitiesExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IOCapabilities(struct soap *soap, const char *tag, int id, const struct tt__IOCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IOCapabilities), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:InputConnectors", -1, &a->InputConnectors, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:RelayOutputs", -1, &a->RelayOutputs, ""))
		return soap->error;
	if (soap_out_PointerTott__IOCapabilitiesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__IOCapabilities * SOAP_FMAC4 soap_in_tt__IOCapabilities(struct soap *soap, const char *tag, struct tt__IOCapabilities *a, const char *type)
{
	size_t soap_flag_InputConnectors = 1;
	size_t soap_flag_RelayOutputs = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__IOCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IOCapabilities, sizeof(struct tt__IOCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__IOCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InputConnectors && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tt:InputConnectors", &a->InputConnectors, "xsd:int"))
				{	soap_flag_InputConnectors--;
					continue;
				}
			if (soap_flag_RelayOutputs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tt:RelayOutputs", &a->RelayOutputs, "xsd:int"))
				{	soap_flag_RelayOutputs--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IOCapabilitiesExtension(soap, "tt:Extension", &a->Extension, "tt:IOCapabilitiesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__IOCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IOCapabilities, SOAP_TYPE_tt__IOCapabilities, sizeof(struct tt__IOCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__IOCapabilities * SOAP_FMAC4 soap_new_tt__IOCapabilities(struct soap *soap, int n)
{
	struct tt__IOCapabilities *p;
	struct tt__IOCapabilities *a = (struct tt__IOCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__IOCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tt__IOCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IOCapabilities(struct soap *soap, const struct tt__IOCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tt__IOCapabilities(soap, tag ? tag : "tt:IOCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IOCapabilities * SOAP_FMAC4 soap_get_tt__IOCapabilities(struct soap *soap, struct tt__IOCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IOCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SystemCapabilities(struct soap *soap, struct tt__SystemCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->DiscoveryResolve);
	soap_default_xsd__boolean(soap, &a->DiscoveryBye);
	soap_default_xsd__boolean(soap, &a->RemoteDiscovery);
	soap_default_xsd__boolean(soap, &a->SystemBackup);
	soap_default_xsd__boolean(soap, &a->SystemLogging);
	soap_default_xsd__boolean(soap, &a->FirmwareUpgrade);
	a->__sizeSupportedVersions = 0;
	a->SupportedVersions = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SystemCapabilities(struct soap *soap, const struct tt__SystemCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->DiscoveryResolve, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->DiscoveryBye, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->RemoteDiscovery, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->SystemBackup, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->SystemLogging, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->FirmwareUpgrade, SOAP_TYPE_xsd__boolean);
	if (a->SupportedVersions)
	{	int i;
		for (i = 0; i < (int)a->__sizeSupportedVersions; i++)
		{
			soap_embedded(soap, a->SupportedVersions + i, SOAP_TYPE_tt__OnvifVersion);
			soap_serialize_tt__OnvifVersion(soap, a->SupportedVersions + i);
		}
	}
	soap_serialize_PointerTott__SystemCapabilitiesExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemCapabilities(struct soap *soap, const char *tag, int id, const struct tt__SystemCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemCapabilities), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:DiscoveryResolve", -1, &a->DiscoveryResolve, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:DiscoveryBye", -1, &a->DiscoveryBye, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:RemoteDiscovery", -1, &a->RemoteDiscovery, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:SystemBackup", -1, &a->SystemBackup, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:SystemLogging", -1, &a->SystemLogging, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:FirmwareUpgrade", -1, &a->FirmwareUpgrade, ""))
		return soap->error;
	if (a->SupportedVersions)
	{	int i;
		for (i = 0; i < (int)a->__sizeSupportedVersions; i++)
			if (soap_out_tt__OnvifVersion(soap, "tt:SupportedVersions", -1, a->SupportedVersions + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__SystemCapabilitiesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SystemCapabilities * SOAP_FMAC4 soap_in_tt__SystemCapabilities(struct soap *soap, const char *tag, struct tt__SystemCapabilities *a, const char *type)
{
	size_t soap_flag_DiscoveryResolve = 1;
	size_t soap_flag_DiscoveryBye = 1;
	size_t soap_flag_RemoteDiscovery = 1;
	size_t soap_flag_SystemBackup = 1;
	size_t soap_flag_SystemLogging = 1;
	size_t soap_flag_FirmwareUpgrade = 1;
	struct soap_blist *soap_blist_SupportedVersions = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SystemCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemCapabilities, sizeof(struct tt__SystemCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SystemCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DiscoveryResolve && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:DiscoveryResolve", &a->DiscoveryResolve, "xsd:boolean"))
				{	soap_flag_DiscoveryResolve--;
					continue;
				}
			if (soap_flag_DiscoveryBye && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:DiscoveryBye", &a->DiscoveryBye, "xsd:boolean"))
				{	soap_flag_DiscoveryBye--;
					continue;
				}
			if (soap_flag_RemoteDiscovery && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:RemoteDiscovery", &a->RemoteDiscovery, "xsd:boolean"))
				{	soap_flag_RemoteDiscovery--;
					continue;
				}
			if (soap_flag_SystemBackup && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:SystemBackup", &a->SystemBackup, "xsd:boolean"))
				{	soap_flag_SystemBackup--;
					continue;
				}
			if (soap_flag_SystemLogging && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:SystemLogging", &a->SystemLogging, "xsd:boolean"))
				{	soap_flag_SystemLogging--;
					continue;
				}
			if (soap_flag_FirmwareUpgrade && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:FirmwareUpgrade", &a->FirmwareUpgrade, "xsd:boolean"))
				{	soap_flag_FirmwareUpgrade--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:SupportedVersions", 1, NULL))
			{	if (a->SupportedVersions == NULL)
				{	if (soap_blist_SupportedVersions == NULL)
						soap_blist_SupportedVersions = soap_alloc_block(soap);
					a->SupportedVersions = (struct tt__OnvifVersion *)soap_push_block_max(soap, soap_blist_SupportedVersions, sizeof(struct tt__OnvifVersion));
					if (a->SupportedVersions == NULL)
						return NULL;
					soap_default_tt__OnvifVersion(soap, a->SupportedVersions);
				}
				soap_revert(soap);
				if (soap_in_tt__OnvifVersion(soap, "tt:SupportedVersions", a->SupportedVersions, "tt:OnvifVersion"))
				{	a->__sizeSupportedVersions++;
					a->SupportedVersions = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SystemCapabilitiesExtension(soap, "tt:Extension", &a->Extension, "tt:SystemCapabilitiesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SupportedVersions)
			soap_pop_block(soap, soap_blist_SupportedVersions);
		if (a->__sizeSupportedVersions)
		{	a->SupportedVersions = (struct tt__OnvifVersion *)soap_save_block(soap, soap_blist_SupportedVersions, NULL, 1);
		}
		else
		{	a->SupportedVersions = NULL;
			if (soap_blist_SupportedVersions)
				soap_end_block(soap, soap_blist_SupportedVersions);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DiscoveryResolve > 0 || soap_flag_DiscoveryBye > 0 || soap_flag_RemoteDiscovery > 0 || soap_flag_SystemBackup > 0 || soap_flag_SystemLogging > 0 || soap_flag_FirmwareUpgrade > 0 || a->__sizeSupportedVersions < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__SystemCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemCapabilities, SOAP_TYPE_tt__SystemCapabilities, sizeof(struct tt__SystemCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SystemCapabilities * SOAP_FMAC4 soap_new_tt__SystemCapabilities(struct soap *soap, int n)
{
	struct tt__SystemCapabilities *p;
	struct tt__SystemCapabilities *a = (struct tt__SystemCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SystemCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tt__SystemCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SystemCapabilities(struct soap *soap, const struct tt__SystemCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tt__SystemCapabilities(soap, tag ? tag : "tt:SystemCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemCapabilities * SOAP_FMAC4 soap_get_tt__SystemCapabilities(struct soap *soap, struct tt__SystemCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkCapabilities(struct soap *soap, struct tt__NetworkCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->IPFilter = NULL;
	a->ZeroConfiguration = NULL;
	a->IPVersion6 = NULL;
	a->DynDNS = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkCapabilities(struct soap *soap, const struct tt__NetworkCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__boolean(soap, &a->IPFilter);
	soap_serialize_PointerToxsd__boolean(soap, &a->ZeroConfiguration);
	soap_serialize_PointerToxsd__boolean(soap, &a->IPVersion6);
	soap_serialize_PointerToxsd__boolean(soap, &a->DynDNS);
	soap_serialize_PointerTott__NetworkCapabilitiesExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkCapabilities(struct soap *soap, const char *tag, int id, const struct tt__NetworkCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkCapabilities), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tt:IPFilter", -1, &a->IPFilter, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tt:ZeroConfiguration", -1, &a->ZeroConfiguration, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tt:IPVersion6", -1, &a->IPVersion6, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tt:DynDNS", -1, &a->DynDNS, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkCapabilitiesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkCapabilities * SOAP_FMAC4 soap_in_tt__NetworkCapabilities(struct soap *soap, const char *tag, struct tt__NetworkCapabilities *a, const char *type)
{
	size_t soap_flag_IPFilter = 1;
	size_t soap_flag_ZeroConfiguration = 1;
	size_t soap_flag_IPVersion6 = 1;
	size_t soap_flag_DynDNS = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkCapabilities, sizeof(struct tt__NetworkCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPFilter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "tt:IPFilter", &a->IPFilter, "xsd:boolean"))
				{	soap_flag_IPFilter--;
					continue;
				}
			if (soap_flag_ZeroConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "tt:ZeroConfiguration", &a->ZeroConfiguration, "xsd:boolean"))
				{	soap_flag_ZeroConfiguration--;
					continue;
				}
			if (soap_flag_IPVersion6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "tt:IPVersion6", &a->IPVersion6, "xsd:boolean"))
				{	soap_flag_IPVersion6--;
					continue;
				}
			if (soap_flag_DynDNS && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "tt:DynDNS", &a->DynDNS, "xsd:boolean"))
				{	soap_flag_DynDNS--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkCapabilitiesExtension(soap, "tt:Extension", &a->Extension, "tt:NetworkCapabilitiesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkCapabilities, SOAP_TYPE_tt__NetworkCapabilities, sizeof(struct tt__NetworkCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__NetworkCapabilities * SOAP_FMAC4 soap_new_tt__NetworkCapabilities(struct soap *soap, int n)
{
	struct tt__NetworkCapabilities *p;
	struct tt__NetworkCapabilities *a = (struct tt__NetworkCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__NetworkCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tt__NetworkCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkCapabilities(struct soap *soap, const struct tt__NetworkCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tt__NetworkCapabilities(soap, tag ? tag : "tt:NetworkCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkCapabilities * SOAP_FMAC4 soap_get_tt__NetworkCapabilities(struct soap *soap, struct tt__NetworkCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__CapabilitiesExtension2(struct soap *soap, struct tt__CapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__CapabilitiesExtension2(struct soap *soap, const struct tt__CapabilitiesExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CapabilitiesExtension2(struct soap *soap, const char *tag, int id, const struct tt__CapabilitiesExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CapabilitiesExtension2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__CapabilitiesExtension2 * SOAP_FMAC4 soap_in_tt__CapabilitiesExtension2(struct soap *soap, const char *tag, struct tt__CapabilitiesExtension2 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__CapabilitiesExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CapabilitiesExtension2, sizeof(struct tt__CapabilitiesExtension2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__CapabilitiesExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__CapabilitiesExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CapabilitiesExtension2, SOAP_TYPE_tt__CapabilitiesExtension2, sizeof(struct tt__CapabilitiesExtension2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__CapabilitiesExtension2 * SOAP_FMAC4 soap_new_tt__CapabilitiesExtension2(struct soap *soap, int n)
{
	struct tt__CapabilitiesExtension2 *p;
	struct tt__CapabilitiesExtension2 *a = (struct tt__CapabilitiesExtension2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__CapabilitiesExtension2));
	for (p = a; p && n--; p++)
		soap_default_tt__CapabilitiesExtension2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CapabilitiesExtension2(struct soap *soap, const struct tt__CapabilitiesExtension2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__CapabilitiesExtension2(soap, tag ? tag : "tt:CapabilitiesExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CapabilitiesExtension2 * SOAP_FMAC4 soap_get_tt__CapabilitiesExtension2(struct soap *soap, struct tt__CapabilitiesExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsDeviceCapabilities(struct soap *soap, struct tt__AnalyticsDeviceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->XAddr);
	a->RuleSupport = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsDeviceCapabilities(struct soap *soap, const struct tt__AnalyticsDeviceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->XAddr);
	soap_serialize_PointerToxsd__boolean(soap, &a->RuleSupport);
	soap_serialize_PointerTott__AnalyticsDeviceExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsDeviceCapabilities(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsDeviceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsDeviceCapabilities), type))
		return soap->error;
	if (!a->XAddr)
	{	if (soap_element_nil(soap, "tt:XAddr"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, (char*const*)&a->XAddr, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tt:RuleSupport", -1, &a->RuleSupport, ""))
		return soap->error;
	if (soap_out_PointerTott__AnalyticsDeviceExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceCapabilities * SOAP_FMAC4 soap_in_tt__AnalyticsDeviceCapabilities(struct soap *soap, const char *tag, struct tt__AnalyticsDeviceCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_RuleSupport = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AnalyticsDeviceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsDeviceCapabilities, sizeof(struct tt__AnalyticsDeviceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsDeviceCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:XAddr", (char**)&a->XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap_flag_RuleSupport && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "tt:RuleSupport", &a->RuleSupport, "xsd:boolean"))
				{	soap_flag_RuleSupport--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AnalyticsDeviceExtension(soap, "tt:Extension", &a->Extension, "tt:AnalyticsDeviceExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__AnalyticsDeviceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsDeviceCapabilities, SOAP_TYPE_tt__AnalyticsDeviceCapabilities, sizeof(struct tt__AnalyticsDeviceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnalyticsDeviceCapabilities * SOAP_FMAC4 soap_new_tt__AnalyticsDeviceCapabilities(struct soap *soap, int n)
{
	struct tt__AnalyticsDeviceCapabilities *p;
	struct tt__AnalyticsDeviceCapabilities *a = (struct tt__AnalyticsDeviceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnalyticsDeviceCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tt__AnalyticsDeviceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsDeviceCapabilities(struct soap *soap, const struct tt__AnalyticsDeviceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnalyticsDeviceCapabilities(soap, tag ? tag : "tt:AnalyticsDeviceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceCapabilities * SOAP_FMAC4 soap_get_tt__AnalyticsDeviceCapabilities(struct soap *soap, struct tt__AnalyticsDeviceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsDeviceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ReceiverCapabilities(struct soap *soap, struct tt__ReceiverCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->XAddr);
	soap_default_xsd__boolean(soap, &a->RTP_USCOREMulticast);
	soap_default_xsd__boolean(soap, &a->RTP_USCORETCP);
	soap_default_xsd__boolean(soap, &a->RTP_USCORERTSP_USCORETCP);
	soap_default_int(soap, &a->SupportedReceivers);
	soap_default_int(soap, &a->MaximumRTSPURILength);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ReceiverCapabilities(struct soap *soap, const struct tt__ReceiverCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->XAddr);
	soap_embedded(soap, &a->RTP_USCOREMulticast, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->RTP_USCORETCP, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->RTP_USCORERTSP_USCORETCP, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->SupportedReceivers, SOAP_TYPE_int);
	soap_embedded(soap, &a->MaximumRTSPURILength, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReceiverCapabilities(struct soap *soap, const char *tag, int id, const struct tt__ReceiverCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReceiverCapabilities), type))
		return soap->error;
	if (!a->XAddr)
	{	if (soap_element_nil(soap, "tt:XAddr"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, (char*const*)&a->XAddr, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:RTP_Multicast", -1, &a->RTP_USCOREMulticast, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:RTP_TCP", -1, &a->RTP_USCORETCP, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:RTP_RTSP_TCP", -1, &a->RTP_USCORERTSP_USCORETCP, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:SupportedReceivers", -1, &a->SupportedReceivers, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:MaximumRTSPURILength", -1, &a->MaximumRTSPURILength, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ReceiverCapabilities * SOAP_FMAC4 soap_in_tt__ReceiverCapabilities(struct soap *soap, const char *tag, struct tt__ReceiverCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_RTP_USCOREMulticast = 1;
	size_t soap_flag_RTP_USCORETCP = 1;
	size_t soap_flag_RTP_USCORERTSP_USCORETCP = 1;
	size_t soap_flag_SupportedReceivers = 1;
	size_t soap_flag_MaximumRTSPURILength = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ReceiverCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReceiverCapabilities, sizeof(struct tt__ReceiverCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ReceiverCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:XAddr", (char**)&a->XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap_flag_RTP_USCOREMulticast && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:RTP_Multicast", &a->RTP_USCOREMulticast, "xsd:boolean"))
				{	soap_flag_RTP_USCOREMulticast--;
					continue;
				}
			if (soap_flag_RTP_USCORETCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:RTP_TCP", &a->RTP_USCORETCP, "xsd:boolean"))
				{	soap_flag_RTP_USCORETCP--;
					continue;
				}
			if (soap_flag_RTP_USCORERTSP_USCORETCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:RTP_RTSP_TCP", &a->RTP_USCORERTSP_USCORETCP, "xsd:boolean"))
				{	soap_flag_RTP_USCORERTSP_USCORETCP--;
					continue;
				}
			if (soap_flag_SupportedReceivers && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:SupportedReceivers", &a->SupportedReceivers, "xsd:int"))
				{	soap_flag_SupportedReceivers--;
					continue;
				}
			if (soap_flag_MaximumRTSPURILength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:MaximumRTSPURILength", &a->MaximumRTSPURILength, "xsd:int"))
				{	soap_flag_MaximumRTSPURILength--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0 || soap_flag_RTP_USCOREMulticast > 0 || soap_flag_RTP_USCORETCP > 0 || soap_flag_RTP_USCORERTSP_USCORETCP > 0 || soap_flag_SupportedReceivers > 0 || soap_flag_MaximumRTSPURILength > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ReceiverCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReceiverCapabilities, SOAP_TYPE_tt__ReceiverCapabilities, sizeof(struct tt__ReceiverCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ReceiverCapabilities * SOAP_FMAC4 soap_new_tt__ReceiverCapabilities(struct soap *soap, int n)
{
	struct tt__ReceiverCapabilities *p;
	struct tt__ReceiverCapabilities *a = (struct tt__ReceiverCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ReceiverCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tt__ReceiverCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReceiverCapabilities(struct soap *soap, const struct tt__ReceiverCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tt__ReceiverCapabilities(soap, tag ? tag : "tt:ReceiverCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReceiverCapabilities * SOAP_FMAC4 soap_get_tt__ReceiverCapabilities(struct soap *soap, struct tt__ReceiverCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReceiverCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ReplayCapabilities(struct soap *soap, struct tt__ReplayCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->XAddr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ReplayCapabilities(struct soap *soap, const struct tt__ReplayCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->XAddr);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReplayCapabilities(struct soap *soap, const char *tag, int id, const struct tt__ReplayCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReplayCapabilities), type))
		return soap->error;
	if (!a->XAddr)
	{	if (soap_element_nil(soap, "tt:XAddr"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, (char*const*)&a->XAddr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ReplayCapabilities * SOAP_FMAC4 soap_in_tt__ReplayCapabilities(struct soap *soap, const char *tag, struct tt__ReplayCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ReplayCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReplayCapabilities, sizeof(struct tt__ReplayCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ReplayCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:XAddr", (char**)&a->XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ReplayCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReplayCapabilities, SOAP_TYPE_tt__ReplayCapabilities, sizeof(struct tt__ReplayCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ReplayCapabilities * SOAP_FMAC4 soap_new_tt__ReplayCapabilities(struct soap *soap, int n)
{
	struct tt__ReplayCapabilities *p;
	struct tt__ReplayCapabilities *a = (struct tt__ReplayCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ReplayCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tt__ReplayCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReplayCapabilities(struct soap *soap, const struct tt__ReplayCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tt__ReplayCapabilities(soap, tag ? tag : "tt:ReplayCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReplayCapabilities * SOAP_FMAC4 soap_get_tt__ReplayCapabilities(struct soap *soap, struct tt__ReplayCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReplayCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SearchCapabilities(struct soap *soap, struct tt__SearchCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->XAddr);
	soap_default_xsd__boolean(soap, &a->MetadataSearch);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SearchCapabilities(struct soap *soap, const struct tt__SearchCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->XAddr);
	soap_embedded(soap, &a->MetadataSearch, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SearchCapabilities(struct soap *soap, const char *tag, int id, const struct tt__SearchCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SearchCapabilities), type))
		return soap->error;
	if (!a->XAddr)
	{	if (soap_element_nil(soap, "tt:XAddr"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, (char*const*)&a->XAddr, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:MetadataSearch", -1, &a->MetadataSearch, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SearchCapabilities * SOAP_FMAC4 soap_in_tt__SearchCapabilities(struct soap *soap, const char *tag, struct tt__SearchCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_MetadataSearch = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SearchCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SearchCapabilities, sizeof(struct tt__SearchCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SearchCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:XAddr", (char**)&a->XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap_flag_MetadataSearch && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:MetadataSearch", &a->MetadataSearch, "xsd:boolean"))
				{	soap_flag_MetadataSearch--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0 || soap_flag_MetadataSearch > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__SearchCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SearchCapabilities, SOAP_TYPE_tt__SearchCapabilities, sizeof(struct tt__SearchCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SearchCapabilities * SOAP_FMAC4 soap_new_tt__SearchCapabilities(struct soap *soap, int n)
{
	struct tt__SearchCapabilities *p;
	struct tt__SearchCapabilities *a = (struct tt__SearchCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SearchCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tt__SearchCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SearchCapabilities(struct soap *soap, const struct tt__SearchCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tt__SearchCapabilities(soap, tag ? tag : "tt:SearchCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SearchCapabilities * SOAP_FMAC4 soap_get_tt__SearchCapabilities(struct soap *soap, struct tt__SearchCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SearchCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RecordingCapabilities(struct soap *soap, struct tt__RecordingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->XAddr);
	soap_default_xsd__boolean(soap, &a->ReceiverSource);
	soap_default_xsd__boolean(soap, &a->MediaProfileSource);
	soap_default_xsd__boolean(soap, &a->DynamicRecordings);
	soap_default_xsd__boolean(soap, &a->DynamicTracks);
	soap_default_int(soap, &a->MaxStringLength);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingCapabilities(struct soap *soap, const struct tt__RecordingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->XAddr);
	soap_embedded(soap, &a->ReceiverSource, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->MediaProfileSource, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->DynamicRecordings, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->DynamicTracks, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &a->MaxStringLength, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingCapabilities(struct soap *soap, const char *tag, int id, const struct tt__RecordingCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingCapabilities), type))
		return soap->error;
	if (!a->XAddr)
	{	if (soap_element_nil(soap, "tt:XAddr"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, (char*const*)&a->XAddr, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:ReceiverSource", -1, &a->ReceiverSource, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:MediaProfileSource", -1, &a->MediaProfileSource, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:DynamicRecordings", -1, &a->DynamicRecordings, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:DynamicTracks", -1, &a->DynamicTracks, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:MaxStringLength", -1, &a->MaxStringLength, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RecordingCapabilities * SOAP_FMAC4 soap_in_tt__RecordingCapabilities(struct soap *soap, const char *tag, struct tt__RecordingCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_ReceiverSource = 1;
	size_t soap_flag_MediaProfileSource = 1;
	size_t soap_flag_DynamicRecordings = 1;
	size_t soap_flag_DynamicTracks = 1;
	size_t soap_flag_MaxStringLength = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RecordingCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingCapabilities, sizeof(struct tt__RecordingCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RecordingCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:XAddr", (char**)&a->XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap_flag_ReceiverSource && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:ReceiverSource", &a->ReceiverSource, "xsd:boolean"))
				{	soap_flag_ReceiverSource--;
					continue;
				}
			if (soap_flag_MediaProfileSource && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:MediaProfileSource", &a->MediaProfileSource, "xsd:boolean"))
				{	soap_flag_MediaProfileSource--;
					continue;
				}
			if (soap_flag_DynamicRecordings && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:DynamicRecordings", &a->DynamicRecordings, "xsd:boolean"))
				{	soap_flag_DynamicRecordings--;
					continue;
				}
			if (soap_flag_DynamicTracks && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:DynamicTracks", &a->DynamicTracks, "xsd:boolean"))
				{	soap_flag_DynamicTracks--;
					continue;
				}
			if (soap_flag_MaxStringLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:MaxStringLength", &a->MaxStringLength, "xsd:int"))
				{	soap_flag_MaxStringLength--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0 || soap_flag_ReceiverSource > 0 || soap_flag_MediaProfileSource > 0 || soap_flag_DynamicRecordings > 0 || soap_flag_DynamicTracks > 0 || soap_flag_MaxStringLength > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__RecordingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingCapabilities, SOAP_TYPE_tt__RecordingCapabilities, sizeof(struct tt__RecordingCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RecordingCapabilities * SOAP_FMAC4 soap_new_tt__RecordingCapabilities(struct soap *soap, int n)
{
	struct tt__RecordingCapabilities *p;
	struct tt__RecordingCapabilities *a = (struct tt__RecordingCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RecordingCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tt__RecordingCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingCapabilities(struct soap *soap, const struct tt__RecordingCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tt__RecordingCapabilities(soap, tag ? tag : "tt:RecordingCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingCapabilities * SOAP_FMAC4 soap_get_tt__RecordingCapabilities(struct soap *soap, struct tt__RecordingCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DisplayCapabilities(struct soap *soap, struct tt__DisplayCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->XAddr);
	soap_default_xsd__boolean(soap, &a->FixedLayout);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DisplayCapabilities(struct soap *soap, const struct tt__DisplayCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->XAddr);
	soap_embedded(soap, &a->FixedLayout, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DisplayCapabilities(struct soap *soap, const char *tag, int id, const struct tt__DisplayCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DisplayCapabilities), type))
		return soap->error;
	if (!a->XAddr)
	{	if (soap_element_nil(soap, "tt:XAddr"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, (char*const*)&a->XAddr, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:FixedLayout", -1, &a->FixedLayout, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DisplayCapabilities * SOAP_FMAC4 soap_in_tt__DisplayCapabilities(struct soap *soap, const char *tag, struct tt__DisplayCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_FixedLayout = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DisplayCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DisplayCapabilities, sizeof(struct tt__DisplayCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DisplayCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:XAddr", (char**)&a->XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap_flag_FixedLayout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:FixedLayout", &a->FixedLayout, "xsd:boolean"))
				{	soap_flag_FixedLayout--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0 || soap_flag_FixedLayout > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__DisplayCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DisplayCapabilities, SOAP_TYPE_tt__DisplayCapabilities, sizeof(struct tt__DisplayCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__DisplayCapabilities * SOAP_FMAC4 soap_new_tt__DisplayCapabilities(struct soap *soap, int n)
{
	struct tt__DisplayCapabilities *p;
	struct tt__DisplayCapabilities *a = (struct tt__DisplayCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__DisplayCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tt__DisplayCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DisplayCapabilities(struct soap *soap, const struct tt__DisplayCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tt__DisplayCapabilities(soap, tag ? tag : "tt:DisplayCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DisplayCapabilities * SOAP_FMAC4 soap_get_tt__DisplayCapabilities(struct soap *soap, struct tt__DisplayCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DisplayCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DeviceIOCapabilities(struct soap *soap, struct tt__DeviceIOCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->XAddr);
	soap_default_int(soap, &a->VideoSources);
	soap_default_int(soap, &a->VideoOutputs);
	soap_default_int(soap, &a->AudioSources);
	soap_default_int(soap, &a->AudioOutputs);
	soap_default_int(soap, &a->RelayOutputs);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DeviceIOCapabilities(struct soap *soap, const struct tt__DeviceIOCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->XAddr);
	soap_embedded(soap, &a->VideoSources, SOAP_TYPE_int);
	soap_embedded(soap, &a->VideoOutputs, SOAP_TYPE_int);
	soap_embedded(soap, &a->AudioSources, SOAP_TYPE_int);
	soap_embedded(soap, &a->AudioOutputs, SOAP_TYPE_int);
	soap_embedded(soap, &a->RelayOutputs, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DeviceIOCapabilities(struct soap *soap, const char *tag, int id, const struct tt__DeviceIOCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DeviceIOCapabilities), type))
		return soap->error;
	if (!a->XAddr)
	{	if (soap_element_nil(soap, "tt:XAddr"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, (char*const*)&a->XAddr, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:VideoSources", -1, &a->VideoSources, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:VideoOutputs", -1, &a->VideoOutputs, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:AudioSources", -1, &a->AudioSources, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:AudioOutputs", -1, &a->AudioOutputs, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:RelayOutputs", -1, &a->RelayOutputs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DeviceIOCapabilities * SOAP_FMAC4 soap_in_tt__DeviceIOCapabilities(struct soap *soap, const char *tag, struct tt__DeviceIOCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	size_t soap_flag_VideoSources = 1;
	size_t soap_flag_VideoOutputs = 1;
	size_t soap_flag_AudioSources = 1;
	size_t soap_flag_AudioOutputs = 1;
	size_t soap_flag_RelayOutputs = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DeviceIOCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceIOCapabilities, sizeof(struct tt__DeviceIOCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DeviceIOCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:XAddr", (char**)&a->XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap_flag_VideoSources && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:VideoSources", &a->VideoSources, "xsd:int"))
				{	soap_flag_VideoSources--;
					continue;
				}
			if (soap_flag_VideoOutputs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:VideoOutputs", &a->VideoOutputs, "xsd:int"))
				{	soap_flag_VideoOutputs--;
					continue;
				}
			if (soap_flag_AudioSources && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:AudioSources", &a->AudioSources, "xsd:int"))
				{	soap_flag_AudioSources--;
					continue;
				}
			if (soap_flag_AudioOutputs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:AudioOutputs", &a->AudioOutputs, "xsd:int"))
				{	soap_flag_AudioOutputs--;
					continue;
				}
			if (soap_flag_RelayOutputs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:RelayOutputs", &a->RelayOutputs, "xsd:int"))
				{	soap_flag_RelayOutputs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0 || soap_flag_VideoSources > 0 || soap_flag_VideoOutputs > 0 || soap_flag_AudioSources > 0 || soap_flag_AudioOutputs > 0 || soap_flag_RelayOutputs > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__DeviceIOCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DeviceIOCapabilities, SOAP_TYPE_tt__DeviceIOCapabilities, sizeof(struct tt__DeviceIOCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__DeviceIOCapabilities * SOAP_FMAC4 soap_new_tt__DeviceIOCapabilities(struct soap *soap, int n)
{
	struct tt__DeviceIOCapabilities *p;
	struct tt__DeviceIOCapabilities *a = (struct tt__DeviceIOCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__DeviceIOCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tt__DeviceIOCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DeviceIOCapabilities(struct soap *soap, const struct tt__DeviceIOCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tt__DeviceIOCapabilities(soap, tag ? tag : "tt:DeviceIOCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DeviceIOCapabilities * SOAP_FMAC4 soap_get_tt__DeviceIOCapabilities(struct soap *soap, struct tt__DeviceIOCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DeviceIOCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__CapabilitiesExtension(struct soap *soap, struct tt__CapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DeviceIO = NULL;
	a->Display = NULL;
	a->Recording = NULL;
	a->Search = NULL;
	a->Replay = NULL;
	a->Receiver = NULL;
	a->AnalyticsDevice = NULL;
	a->Extensions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__CapabilitiesExtension(struct soap *soap, const struct tt__CapabilitiesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__DeviceIOCapabilities(soap, &a->DeviceIO);
	soap_serialize_PointerTott__DisplayCapabilities(soap, &a->Display);
	soap_serialize_PointerTott__RecordingCapabilities(soap, &a->Recording);
	soap_serialize_PointerTott__SearchCapabilities(soap, &a->Search);
	soap_serialize_PointerTott__ReplayCapabilities(soap, &a->Replay);
	soap_serialize_PointerTott__ReceiverCapabilities(soap, &a->Receiver);
	soap_serialize_PointerTott__AnalyticsDeviceCapabilities(soap, &a->AnalyticsDevice);
	soap_serialize_PointerTott__CapabilitiesExtension2(soap, &a->Extensions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CapabilitiesExtension(struct soap *soap, const char *tag, int id, const struct tt__CapabilitiesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CapabilitiesExtension), type))
		return soap->error;
	if (soap_out_PointerTott__DeviceIOCapabilities(soap, "tt:DeviceIO", -1, &a->DeviceIO, ""))
		return soap->error;
	if (soap_out_PointerTott__DisplayCapabilities(soap, "tt:Display", -1, &a->Display, ""))
		return soap->error;
	if (soap_out_PointerTott__RecordingCapabilities(soap, "tt:Recording", -1, &a->Recording, ""))
		return soap->error;
	if (soap_out_PointerTott__SearchCapabilities(soap, "tt:Search", -1, &a->Search, ""))
		return soap->error;
	if (soap_out_PointerTott__ReplayCapabilities(soap, "tt:Replay", -1, &a->Replay, ""))
		return soap->error;
	if (soap_out_PointerTott__ReceiverCapabilities(soap, "tt:Receiver", -1, &a->Receiver, ""))
		return soap->error;
	if (soap_out_PointerTott__AnalyticsDeviceCapabilities(soap, "tt:AnalyticsDevice", -1, &a->AnalyticsDevice, ""))
		return soap->error;
	if (soap_out_PointerTott__CapabilitiesExtension2(soap, "tt:Extensions", -1, &a->Extensions, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__CapabilitiesExtension * SOAP_FMAC4 soap_in_tt__CapabilitiesExtension(struct soap *soap, const char *tag, struct tt__CapabilitiesExtension *a, const char *type)
{
	size_t soap_flag_DeviceIO = 1;
	size_t soap_flag_Display = 1;
	size_t soap_flag_Recording = 1;
	size_t soap_flag_Search = 1;
	size_t soap_flag_Replay = 1;
	size_t soap_flag_Receiver = 1;
	size_t soap_flag_AnalyticsDevice = 1;
	size_t soap_flag_Extensions = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__CapabilitiesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CapabilitiesExtension, sizeof(struct tt__CapabilitiesExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__CapabilitiesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DeviceIO && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DeviceIOCapabilities(soap, "tt:DeviceIO", &a->DeviceIO, "tt:DeviceIOCapabilities"))
				{	soap_flag_DeviceIO--;
					continue;
				}
			if (soap_flag_Display && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DisplayCapabilities(soap, "tt:Display", &a->Display, "tt:DisplayCapabilities"))
				{	soap_flag_Display--;
					continue;
				}
			if (soap_flag_Recording && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingCapabilities(soap, "tt:Recording", &a->Recording, "tt:RecordingCapabilities"))
				{	soap_flag_Recording--;
					continue;
				}
			if (soap_flag_Search && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SearchCapabilities(soap, "tt:Search", &a->Search, "tt:SearchCapabilities"))
				{	soap_flag_Search--;
					continue;
				}
			if (soap_flag_Replay && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ReplayCapabilities(soap, "tt:Replay", &a->Replay, "tt:ReplayCapabilities"))
				{	soap_flag_Replay--;
					continue;
				}
			if (soap_flag_Receiver && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ReceiverCapabilities(soap, "tt:Receiver", &a->Receiver, "tt:ReceiverCapabilities"))
				{	soap_flag_Receiver--;
					continue;
				}
			if (soap_flag_AnalyticsDevice && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AnalyticsDeviceCapabilities(soap, "tt:AnalyticsDevice", &a->AnalyticsDevice, "tt:AnalyticsDeviceCapabilities"))
				{	soap_flag_AnalyticsDevice--;
					continue;
				}
			if (soap_flag_Extensions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__CapabilitiesExtension2(soap, "tt:Extensions", &a->Extensions, "tt:CapabilitiesExtension2"))
				{	soap_flag_Extensions--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__CapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CapabilitiesExtension, SOAP_TYPE_tt__CapabilitiesExtension, sizeof(struct tt__CapabilitiesExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__CapabilitiesExtension * SOAP_FMAC4 soap_new_tt__CapabilitiesExtension(struct soap *soap, int n)
{
	struct tt__CapabilitiesExtension *p;
	struct tt__CapabilitiesExtension *a = (struct tt__CapabilitiesExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__CapabilitiesExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__CapabilitiesExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CapabilitiesExtension(struct soap *soap, const struct tt__CapabilitiesExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__CapabilitiesExtension(soap, tag ? tag : "tt:CapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CapabilitiesExtension * SOAP_FMAC4 soap_get_tt__CapabilitiesExtension(struct soap *soap, struct tt__CapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZCapabilities(struct soap *soap, struct tt__PTZCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->XAddr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZCapabilities(struct soap *soap, const struct tt__PTZCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->XAddr);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZCapabilities(struct soap *soap, const char *tag, int id, const struct tt__PTZCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZCapabilities), type))
		return soap->error;
	if (!a->XAddr)
	{	if (soap_element_nil(soap, "tt:XAddr"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, (char*const*)&a->XAddr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZCapabilities * SOAP_FMAC4 soap_in_tt__PTZCapabilities(struct soap *soap, const char *tag, struct tt__PTZCapabilities *a, const char *type)
{
	size_t soap_flag_XAddr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZCapabilities, sizeof(struct tt__PTZCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tt:XAddr", (char**)&a->XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XAddr > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PTZCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZCapabilities, SOAP_TYPE_tt__PTZCapabilities, sizeof(struct tt__PTZCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZCapabilities * SOAP_FMAC4 soap_new_tt__PTZCapabilities(struct soap *soap, int n)
{
	struct tt__PTZCapabilities *p;
	struct tt__PTZCapabilities *a = (struct tt__PTZCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZCapabilities(struct soap *soap, const struct tt__PTZCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZCapabilities(soap, tag ? tag : "tt:PTZCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZCapabilities * SOAP_FMAC4 soap_get_tt__PTZCapabilities(struct soap *soap, struct tt__PTZCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
