/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:59 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__SetAudioSourceConfiguration(struct soap *soap, struct _ns6__SetAudioSourceConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__SetAudioSourceConfiguration))
		soap_serialize__ns6__SetAudioSourceConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__SetAudioSourceConfiguration(struct soap *soap, const char *tag, int id, struct _ns6__SetAudioSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__SetAudioSourceConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns6__SetAudioSourceConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns6__SetAudioSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_ns6__SetAudioSourceConfiguration(struct soap *soap, const char *tag, struct _ns6__SetAudioSourceConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns6__SetAudioSourceConfiguration **)soap_malloc(soap, sizeof(struct _ns6__SetAudioSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns6__SetAudioSourceConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns6__SetAudioSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__SetAudioSourceConfiguration, sizeof(struct _ns6__SetAudioSourceConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__SetAudioSourceConfiguration(struct soap *soap, struct _ns6__SetAudioSourceConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns6__SetAudioSourceConfiguration(soap, tag ? tag : "ns6:SetAudioSourceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__SetAudioSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_ns6__SetAudioSourceConfiguration(struct soap *soap, struct _ns6__SetAudioSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__SetAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__SetVideoEncoderConfiguration(struct soap *soap, struct _ns6__SetVideoEncoderConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__SetVideoEncoderConfiguration))
		soap_serialize__ns6__SetVideoEncoderConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__SetVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, struct _ns6__SetVideoEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__SetVideoEncoderConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns6__SetVideoEncoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns6__SetVideoEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_ns6__SetVideoEncoderConfiguration(struct soap *soap, const char *tag, struct _ns6__SetVideoEncoderConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns6__SetVideoEncoderConfiguration **)soap_malloc(soap, sizeof(struct _ns6__SetVideoEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns6__SetVideoEncoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns6__SetVideoEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__SetVideoEncoderConfiguration, sizeof(struct _ns6__SetVideoEncoderConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__SetVideoEncoderConfiguration(struct soap *soap, struct _ns6__SetVideoEncoderConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns6__SetVideoEncoderConfiguration(soap, tag ? tag : "ns6:SetVideoEncoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__SetVideoEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_ns6__SetVideoEncoderConfiguration(struct soap *soap, struct _ns6__SetVideoEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__SetVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__SetConfigurationResponse(struct soap *soap, struct _ns6__SetConfigurationResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__SetConfigurationResponse))
		soap_serialize__ns6__SetConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__SetConfigurationResponse(struct soap *soap, const char *tag, int id, struct _ns6__SetConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__SetConfigurationResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns6__SetConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns6__SetConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns6__SetConfigurationResponse(struct soap *soap, const char *tag, struct _ns6__SetConfigurationResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns6__SetConfigurationResponse **)soap_malloc(soap, sizeof(struct _ns6__SetConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns6__SetConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns6__SetConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__SetConfigurationResponse, sizeof(struct _ns6__SetConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__SetConfigurationResponse(struct soap *soap, struct _ns6__SetConfigurationResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns6__SetConfigurationResponse(soap, tag ? tag : "ns6:SetConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__SetConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns6__SetConfigurationResponse(struct soap *soap, struct _ns6__SetConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__SetConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__SetVideoSourceConfiguration(struct soap *soap, struct _ns6__SetVideoSourceConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__SetVideoSourceConfiguration))
		soap_serialize__ns6__SetVideoSourceConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__SetVideoSourceConfiguration(struct soap *soap, const char *tag, int id, struct _ns6__SetVideoSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__SetVideoSourceConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns6__SetVideoSourceConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns6__SetVideoSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_ns6__SetVideoSourceConfiguration(struct soap *soap, const char *tag, struct _ns6__SetVideoSourceConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns6__SetVideoSourceConfiguration **)soap_malloc(soap, sizeof(struct _ns6__SetVideoSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns6__SetVideoSourceConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns6__SetVideoSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__SetVideoSourceConfiguration, sizeof(struct _ns6__SetVideoSourceConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__SetVideoSourceConfiguration(struct soap *soap, struct _ns6__SetVideoSourceConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns6__SetVideoSourceConfiguration(soap, tag ? tag : "ns6:SetVideoSourceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__SetVideoSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_ns6__SetVideoSourceConfiguration(struct soap *soap, struct _ns6__SetVideoSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__SetVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__GetAudioDecoderConfigurationsResponse(struct soap *soap, struct _ns6__GetAudioDecoderConfigurationsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__GetAudioDecoderConfigurationsResponse))
		soap_serialize__ns6__GetAudioDecoderConfigurationsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__GetAudioDecoderConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _ns6__GetAudioDecoderConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__GetAudioDecoderConfigurationsResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns6__GetAudioDecoderConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns6__GetAudioDecoderConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns6__GetAudioDecoderConfigurationsResponse(struct soap *soap, const char *tag, struct _ns6__GetAudioDecoderConfigurationsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns6__GetAudioDecoderConfigurationsResponse **)soap_malloc(soap, sizeof(struct _ns6__GetAudioDecoderConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns6__GetAudioDecoderConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns6__GetAudioDecoderConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__GetAudioDecoderConfigurationsResponse, sizeof(struct _ns6__GetAudioDecoderConfigurationsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__GetAudioDecoderConfigurationsResponse(struct soap *soap, struct _ns6__GetAudioDecoderConfigurationsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns6__GetAudioDecoderConfigurationsResponse(soap, tag ? tag : "ns6:GetAudioDecoderConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetAudioDecoderConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns6__GetAudioDecoderConfigurationsResponse(struct soap *soap, struct _ns6__GetAudioDecoderConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__GetAudioDecoderConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__GetAudioOutputConfigurationsResponse(struct soap *soap, struct _ns6__GetAudioOutputConfigurationsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__GetAudioOutputConfigurationsResponse))
		soap_serialize__ns6__GetAudioOutputConfigurationsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__GetAudioOutputConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _ns6__GetAudioOutputConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__GetAudioOutputConfigurationsResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns6__GetAudioOutputConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns6__GetAudioOutputConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns6__GetAudioOutputConfigurationsResponse(struct soap *soap, const char *tag, struct _ns6__GetAudioOutputConfigurationsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns6__GetAudioOutputConfigurationsResponse **)soap_malloc(soap, sizeof(struct _ns6__GetAudioOutputConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns6__GetAudioOutputConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns6__GetAudioOutputConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__GetAudioOutputConfigurationsResponse, sizeof(struct _ns6__GetAudioOutputConfigurationsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__GetAudioOutputConfigurationsResponse(struct soap *soap, struct _ns6__GetAudioOutputConfigurationsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns6__GetAudioOutputConfigurationsResponse(soap, tag ? tag : "ns6:GetAudioOutputConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetAudioOutputConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns6__GetAudioOutputConfigurationsResponse(struct soap *soap, struct _ns6__GetAudioOutputConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__GetAudioOutputConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__GetMetadataConfigurationsResponse(struct soap *soap, struct _ns6__GetMetadataConfigurationsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__GetMetadataConfigurationsResponse))
		soap_serialize__ns6__GetMetadataConfigurationsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__GetMetadataConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _ns6__GetMetadataConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__GetMetadataConfigurationsResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns6__GetMetadataConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns6__GetMetadataConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns6__GetMetadataConfigurationsResponse(struct soap *soap, const char *tag, struct _ns6__GetMetadataConfigurationsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns6__GetMetadataConfigurationsResponse **)soap_malloc(soap, sizeof(struct _ns6__GetMetadataConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns6__GetMetadataConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns6__GetMetadataConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__GetMetadataConfigurationsResponse, sizeof(struct _ns6__GetMetadataConfigurationsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__GetMetadataConfigurationsResponse(struct soap *soap, struct _ns6__GetMetadataConfigurationsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns6__GetMetadataConfigurationsResponse(soap, tag ? tag : "ns6:GetMetadataConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetMetadataConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns6__GetMetadataConfigurationsResponse(struct soap *soap, struct _ns6__GetMetadataConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__GetMetadataConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__GetAnalyticsConfigurationsResponse(struct soap *soap, struct _ns6__GetAnalyticsConfigurationsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__GetAnalyticsConfigurationsResponse))
		soap_serialize__ns6__GetAnalyticsConfigurationsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__GetAnalyticsConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _ns6__GetAnalyticsConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__GetAnalyticsConfigurationsResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns6__GetAnalyticsConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns6__GetAnalyticsConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns6__GetAnalyticsConfigurationsResponse(struct soap *soap, const char *tag, struct _ns6__GetAnalyticsConfigurationsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns6__GetAnalyticsConfigurationsResponse **)soap_malloc(soap, sizeof(struct _ns6__GetAnalyticsConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns6__GetAnalyticsConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns6__GetAnalyticsConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__GetAnalyticsConfigurationsResponse, sizeof(struct _ns6__GetAnalyticsConfigurationsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__GetAnalyticsConfigurationsResponse(struct soap *soap, struct _ns6__GetAnalyticsConfigurationsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns6__GetAnalyticsConfigurationsResponse(soap, tag ? tag : "ns6:GetAnalyticsConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetAnalyticsConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns6__GetAnalyticsConfigurationsResponse(struct soap *soap, struct _ns6__GetAnalyticsConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__GetAnalyticsConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__GetAudioEncoderConfigurationsResponse(struct soap *soap, struct _ns6__GetAudioEncoderConfigurationsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__GetAudioEncoderConfigurationsResponse))
		soap_serialize__ns6__GetAudioEncoderConfigurationsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__GetAudioEncoderConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _ns6__GetAudioEncoderConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__GetAudioEncoderConfigurationsResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns6__GetAudioEncoderConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns6__GetAudioEncoderConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns6__GetAudioEncoderConfigurationsResponse(struct soap *soap, const char *tag, struct _ns6__GetAudioEncoderConfigurationsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns6__GetAudioEncoderConfigurationsResponse **)soap_malloc(soap, sizeof(struct _ns6__GetAudioEncoderConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns6__GetAudioEncoderConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns6__GetAudioEncoderConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__GetAudioEncoderConfigurationsResponse, sizeof(struct _ns6__GetAudioEncoderConfigurationsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__GetAudioEncoderConfigurationsResponse(struct soap *soap, struct _ns6__GetAudioEncoderConfigurationsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns6__GetAudioEncoderConfigurationsResponse(soap, tag ? tag : "ns6:GetAudioEncoderConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetAudioEncoderConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns6__GetAudioEncoderConfigurationsResponse(struct soap *soap, struct _ns6__GetAudioEncoderConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__GetAudioEncoderConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__GetAudioSourceConfigurationsResponse(struct soap *soap, struct _ns6__GetAudioSourceConfigurationsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__GetAudioSourceConfigurationsResponse))
		soap_serialize__ns6__GetAudioSourceConfigurationsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__GetAudioSourceConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _ns6__GetAudioSourceConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__GetAudioSourceConfigurationsResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns6__GetAudioSourceConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns6__GetAudioSourceConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns6__GetAudioSourceConfigurationsResponse(struct soap *soap, const char *tag, struct _ns6__GetAudioSourceConfigurationsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns6__GetAudioSourceConfigurationsResponse **)soap_malloc(soap, sizeof(struct _ns6__GetAudioSourceConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns6__GetAudioSourceConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns6__GetAudioSourceConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__GetAudioSourceConfigurationsResponse, sizeof(struct _ns6__GetAudioSourceConfigurationsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__GetAudioSourceConfigurationsResponse(struct soap *soap, struct _ns6__GetAudioSourceConfigurationsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns6__GetAudioSourceConfigurationsResponse(soap, tag ? tag : "ns6:GetAudioSourceConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetAudioSourceConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns6__GetAudioSourceConfigurationsResponse(struct soap *soap, struct _ns6__GetAudioSourceConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__GetAudioSourceConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__GetVideoEncoderConfigurationsResponse(struct soap *soap, struct _ns6__GetVideoEncoderConfigurationsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__GetVideoEncoderConfigurationsResponse))
		soap_serialize__ns6__GetVideoEncoderConfigurationsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__GetVideoEncoderConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _ns6__GetVideoEncoderConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__GetVideoEncoderConfigurationsResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns6__GetVideoEncoderConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns6__GetVideoEncoderConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns6__GetVideoEncoderConfigurationsResponse(struct soap *soap, const char *tag, struct _ns6__GetVideoEncoderConfigurationsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns6__GetVideoEncoderConfigurationsResponse **)soap_malloc(soap, sizeof(struct _ns6__GetVideoEncoderConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns6__GetVideoEncoderConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns6__GetVideoEncoderConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__GetVideoEncoderConfigurationsResponse, sizeof(struct _ns6__GetVideoEncoderConfigurationsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__GetVideoEncoderConfigurationsResponse(struct soap *soap, struct _ns6__GetVideoEncoderConfigurationsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns6__GetVideoEncoderConfigurationsResponse(soap, tag ? tag : "ns6:GetVideoEncoderConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetVideoEncoderConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns6__GetVideoEncoderConfigurationsResponse(struct soap *soap, struct _ns6__GetVideoEncoderConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__GetVideoEncoderConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__GetVideoSourceConfigurationsResponse(struct soap *soap, struct _ns6__GetVideoSourceConfigurationsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__GetVideoSourceConfigurationsResponse))
		soap_serialize__ns6__GetVideoSourceConfigurationsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__GetVideoSourceConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _ns6__GetVideoSourceConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__GetVideoSourceConfigurationsResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns6__GetVideoSourceConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns6__GetVideoSourceConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns6__GetVideoSourceConfigurationsResponse(struct soap *soap, const char *tag, struct _ns6__GetVideoSourceConfigurationsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns6__GetVideoSourceConfigurationsResponse **)soap_malloc(soap, sizeof(struct _ns6__GetVideoSourceConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns6__GetVideoSourceConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns6__GetVideoSourceConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__GetVideoSourceConfigurationsResponse, sizeof(struct _ns6__GetVideoSourceConfigurationsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__GetVideoSourceConfigurationsResponse(struct soap *soap, struct _ns6__GetVideoSourceConfigurationsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns6__GetVideoSourceConfigurationsResponse(soap, tag ? tag : "ns6:GetVideoSourceConfigurationsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetVideoSourceConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns6__GetVideoSourceConfigurationsResponse(struct soap *soap, struct _ns6__GetVideoSourceConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__GetVideoSourceConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons6__GetConfiguration(struct soap *soap, struct ns6__GetConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns6__GetConfiguration))
		soap_serialize_ns6__GetConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons6__GetConfiguration(struct soap *soap, const char *tag, int id, struct ns6__GetConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns6__GetConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns6__GetConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns6__GetConfiguration ** SOAP_FMAC4 soap_in_PointerTons6__GetConfiguration(struct soap *soap, const char *tag, struct ns6__GetConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns6__GetConfiguration **)soap_malloc(soap, sizeof(struct ns6__GetConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns6__GetConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns6__GetConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns6__GetConfiguration, sizeof(struct ns6__GetConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons6__GetConfiguration(struct soap *soap, struct ns6__GetConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons6__GetConfiguration(soap, tag ? tag : "ns6:GetConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns6__GetConfiguration ** SOAP_FMAC4 soap_get_PointerTons6__GetConfiguration(struct soap *soap, struct ns6__GetConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons6__GetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__DeleteProfileResponse(struct soap *soap, struct _ns6__DeleteProfileResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__DeleteProfileResponse))
		soap_serialize__ns6__DeleteProfileResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__DeleteProfileResponse(struct soap *soap, const char *tag, int id, struct _ns6__DeleteProfileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__DeleteProfileResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns6__DeleteProfileResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns6__DeleteProfileResponse ** SOAP_FMAC4 soap_in_PointerTo_ns6__DeleteProfileResponse(struct soap *soap, const char *tag, struct _ns6__DeleteProfileResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns6__DeleteProfileResponse **)soap_malloc(soap, sizeof(struct _ns6__DeleteProfileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns6__DeleteProfileResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns6__DeleteProfileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__DeleteProfileResponse, sizeof(struct _ns6__DeleteProfileResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__DeleteProfileResponse(struct soap *soap, struct _ns6__DeleteProfileResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns6__DeleteProfileResponse(soap, tag ? tag : "ns6:DeleteProfileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__DeleteProfileResponse ** SOAP_FMAC4 soap_get_PointerTo_ns6__DeleteProfileResponse(struct soap *soap, struct _ns6__DeleteProfileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__DeleteProfileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__DeleteProfile(struct soap *soap, struct _ns6__DeleteProfile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__DeleteProfile))
		soap_serialize__ns6__DeleteProfile(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__DeleteProfile(struct soap *soap, const char *tag, int id, struct _ns6__DeleteProfile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__DeleteProfile, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns6__DeleteProfile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns6__DeleteProfile ** SOAP_FMAC4 soap_in_PointerTo_ns6__DeleteProfile(struct soap *soap, const char *tag, struct _ns6__DeleteProfile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns6__DeleteProfile **)soap_malloc(soap, sizeof(struct _ns6__DeleteProfile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns6__DeleteProfile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns6__DeleteProfile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__DeleteProfile, sizeof(struct _ns6__DeleteProfile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__DeleteProfile(struct soap *soap, struct _ns6__DeleteProfile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns6__DeleteProfile(soap, tag ? tag : "ns6:DeleteProfile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__DeleteProfile ** SOAP_FMAC4 soap_get_PointerTo_ns6__DeleteProfile(struct soap *soap, struct _ns6__DeleteProfile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__DeleteProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__RemoveConfigurationResponse(struct soap *soap, struct _ns6__RemoveConfigurationResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__RemoveConfigurationResponse))
		soap_serialize__ns6__RemoveConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__RemoveConfigurationResponse(struct soap *soap, const char *tag, int id, struct _ns6__RemoveConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__RemoveConfigurationResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns6__RemoveConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns6__RemoveConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns6__RemoveConfigurationResponse(struct soap *soap, const char *tag, struct _ns6__RemoveConfigurationResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns6__RemoveConfigurationResponse **)soap_malloc(soap, sizeof(struct _ns6__RemoveConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns6__RemoveConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns6__RemoveConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__RemoveConfigurationResponse, sizeof(struct _ns6__RemoveConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__RemoveConfigurationResponse(struct soap *soap, struct _ns6__RemoveConfigurationResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns6__RemoveConfigurationResponse(soap, tag ? tag : "ns6:RemoveConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__RemoveConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns6__RemoveConfigurationResponse(struct soap *soap, struct _ns6__RemoveConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__RemoveConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__RemoveConfiguration(struct soap *soap, struct _ns6__RemoveConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__RemoveConfiguration))
		soap_serialize__ns6__RemoveConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__RemoveConfiguration(struct soap *soap, const char *tag, int id, struct _ns6__RemoveConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__RemoveConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns6__RemoveConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns6__RemoveConfiguration ** SOAP_FMAC4 soap_in_PointerTo_ns6__RemoveConfiguration(struct soap *soap, const char *tag, struct _ns6__RemoveConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns6__RemoveConfiguration **)soap_malloc(soap, sizeof(struct _ns6__RemoveConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns6__RemoveConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns6__RemoveConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__RemoveConfiguration, sizeof(struct _ns6__RemoveConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__RemoveConfiguration(struct soap *soap, struct _ns6__RemoveConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns6__RemoveConfiguration(soap, tag ? tag : "ns6:RemoveConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__RemoveConfiguration ** SOAP_FMAC4 soap_get_PointerTo_ns6__RemoveConfiguration(struct soap *soap, struct _ns6__RemoveConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__RemoveConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__AddConfigurationResponse(struct soap *soap, struct _ns6__AddConfigurationResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__AddConfigurationResponse))
		soap_serialize__ns6__AddConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__AddConfigurationResponse(struct soap *soap, const char *tag, int id, struct _ns6__AddConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__AddConfigurationResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns6__AddConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns6__AddConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_ns6__AddConfigurationResponse(struct soap *soap, const char *tag, struct _ns6__AddConfigurationResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns6__AddConfigurationResponse **)soap_malloc(soap, sizeof(struct _ns6__AddConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns6__AddConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns6__AddConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__AddConfigurationResponse, sizeof(struct _ns6__AddConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__AddConfigurationResponse(struct soap *soap, struct _ns6__AddConfigurationResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns6__AddConfigurationResponse(soap, tag ? tag : "ns6:AddConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__AddConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_ns6__AddConfigurationResponse(struct soap *soap, struct _ns6__AddConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__AddConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__AddConfiguration(struct soap *soap, struct _ns6__AddConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__AddConfiguration))
		soap_serialize__ns6__AddConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__AddConfiguration(struct soap *soap, const char *tag, int id, struct _ns6__AddConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__AddConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns6__AddConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns6__AddConfiguration ** SOAP_FMAC4 soap_in_PointerTo_ns6__AddConfiguration(struct soap *soap, const char *tag, struct _ns6__AddConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns6__AddConfiguration **)soap_malloc(soap, sizeof(struct _ns6__AddConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns6__AddConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns6__AddConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__AddConfiguration, sizeof(struct _ns6__AddConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__AddConfiguration(struct soap *soap, struct _ns6__AddConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns6__AddConfiguration(soap, tag ? tag : "ns6:AddConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__AddConfiguration ** SOAP_FMAC4 soap_get_PointerTo_ns6__AddConfiguration(struct soap *soap, struct _ns6__AddConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__AddConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__GetProfilesResponse(struct soap *soap, struct _ns6__GetProfilesResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__GetProfilesResponse))
		soap_serialize__ns6__GetProfilesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__GetProfilesResponse(struct soap *soap, const char *tag, int id, struct _ns6__GetProfilesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__GetProfilesResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns6__GetProfilesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns6__GetProfilesResponse ** SOAP_FMAC4 soap_in_PointerTo_ns6__GetProfilesResponse(struct soap *soap, const char *tag, struct _ns6__GetProfilesResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns6__GetProfilesResponse **)soap_malloc(soap, sizeof(struct _ns6__GetProfilesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns6__GetProfilesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns6__GetProfilesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__GetProfilesResponse, sizeof(struct _ns6__GetProfilesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__GetProfilesResponse(struct soap *soap, struct _ns6__GetProfilesResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns6__GetProfilesResponse(soap, tag ? tag : "ns6:GetProfilesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetProfilesResponse ** SOAP_FMAC4 soap_get_PointerTo_ns6__GetProfilesResponse(struct soap *soap, struct _ns6__GetProfilesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__GetProfilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__GetProfiles(struct soap *soap, struct _ns6__GetProfiles *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__GetProfiles))
		soap_serialize__ns6__GetProfiles(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__GetProfiles(struct soap *soap, const char *tag, int id, struct _ns6__GetProfiles *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__GetProfiles, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns6__GetProfiles(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns6__GetProfiles ** SOAP_FMAC4 soap_in_PointerTo_ns6__GetProfiles(struct soap *soap, const char *tag, struct _ns6__GetProfiles **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns6__GetProfiles **)soap_malloc(soap, sizeof(struct _ns6__GetProfiles *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns6__GetProfiles(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns6__GetProfiles **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__GetProfiles, sizeof(struct _ns6__GetProfiles), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__GetProfiles(struct soap *soap, struct _ns6__GetProfiles *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns6__GetProfiles(soap, tag ? tag : "ns6:GetProfiles", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetProfiles ** SOAP_FMAC4 soap_get_PointerTo_ns6__GetProfiles(struct soap *soap, struct _ns6__GetProfiles **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__GetProfiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__CreateProfileResponse(struct soap *soap, struct _ns6__CreateProfileResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__CreateProfileResponse))
		soap_serialize__ns6__CreateProfileResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__CreateProfileResponse(struct soap *soap, const char *tag, int id, struct _ns6__CreateProfileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__CreateProfileResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns6__CreateProfileResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns6__CreateProfileResponse ** SOAP_FMAC4 soap_in_PointerTo_ns6__CreateProfileResponse(struct soap *soap, const char *tag, struct _ns6__CreateProfileResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns6__CreateProfileResponse **)soap_malloc(soap, sizeof(struct _ns6__CreateProfileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns6__CreateProfileResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns6__CreateProfileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__CreateProfileResponse, sizeof(struct _ns6__CreateProfileResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__CreateProfileResponse(struct soap *soap, struct _ns6__CreateProfileResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns6__CreateProfileResponse(soap, tag ? tag : "ns6:CreateProfileResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__CreateProfileResponse ** SOAP_FMAC4 soap_get_PointerTo_ns6__CreateProfileResponse(struct soap *soap, struct _ns6__CreateProfileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__CreateProfileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__CreateProfile(struct soap *soap, struct _ns6__CreateProfile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__CreateProfile))
		soap_serialize__ns6__CreateProfile(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__CreateProfile(struct soap *soap, const char *tag, int id, struct _ns6__CreateProfile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__CreateProfile, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns6__CreateProfile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns6__CreateProfile ** SOAP_FMAC4 soap_in_PointerTo_ns6__CreateProfile(struct soap *soap, const char *tag, struct _ns6__CreateProfile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns6__CreateProfile **)soap_malloc(soap, sizeof(struct _ns6__CreateProfile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns6__CreateProfile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns6__CreateProfile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__CreateProfile, sizeof(struct _ns6__CreateProfile), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__CreateProfile(struct soap *soap, struct _ns6__CreateProfile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns6__CreateProfile(soap, tag ? tag : "ns6:CreateProfile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__CreateProfile ** SOAP_FMAC4 soap_get_PointerTo_ns6__CreateProfile(struct soap *soap, struct _ns6__CreateProfile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__CreateProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__GetServiceCapabilitiesResponse2(struct soap *soap, struct _ns6__GetServiceCapabilitiesResponse2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__GetServiceCapabilitiesResponse2))
		soap_serialize__ns6__GetServiceCapabilitiesResponse2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__GetServiceCapabilitiesResponse2(struct soap *soap, const char *tag, int id, struct _ns6__GetServiceCapabilitiesResponse2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__GetServiceCapabilitiesResponse2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns6__GetServiceCapabilitiesResponse2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns6__GetServiceCapabilitiesResponse2 ** SOAP_FMAC4 soap_in_PointerTo_ns6__GetServiceCapabilitiesResponse2(struct soap *soap, const char *tag, struct _ns6__GetServiceCapabilitiesResponse2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns6__GetServiceCapabilitiesResponse2 **)soap_malloc(soap, sizeof(struct _ns6__GetServiceCapabilitiesResponse2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns6__GetServiceCapabilitiesResponse2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns6__GetServiceCapabilitiesResponse2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__GetServiceCapabilitiesResponse2, sizeof(struct _ns6__GetServiceCapabilitiesResponse2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__GetServiceCapabilitiesResponse2(struct soap *soap, struct _ns6__GetServiceCapabilitiesResponse2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns6__GetServiceCapabilitiesResponse2(soap, tag ? tag : "ns6:GetServiceCapabilitiesResponse2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetServiceCapabilitiesResponse2 ** SOAP_FMAC4 soap_get_PointerTo_ns6__GetServiceCapabilitiesResponse2(struct soap *soap, struct _ns6__GetServiceCapabilitiesResponse2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__GetServiceCapabilitiesResponse2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns6__GetServiceCapabilities(struct soap *soap, struct _ns6__GetServiceCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns6__GetServiceCapabilities))
		soap_serialize__ns6__GetServiceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns6__GetServiceCapabilities(struct soap *soap, const char *tag, int id, struct _ns6__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns6__GetServiceCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns6__GetServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns6__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_ns6__GetServiceCapabilities(struct soap *soap, const char *tag, struct _ns6__GetServiceCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns6__GetServiceCapabilities **)soap_malloc(soap, sizeof(struct _ns6__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns6__GetServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns6__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns6__GetServiceCapabilities, sizeof(struct _ns6__GetServiceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns6__GetServiceCapabilities(struct soap *soap, struct _ns6__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns6__GetServiceCapabilities(soap, tag ? tag : "ns6:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns6__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_ns6__GetServiceCapabilities(struct soap *soap, struct _ns6__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns6__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__DoubleLockDoorResponse(struct soap *soap, struct _ns5__DoubleLockDoorResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__DoubleLockDoorResponse))
		soap_serialize__ns5__DoubleLockDoorResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__DoubleLockDoorResponse(struct soap *soap, const char *tag, int id, struct _ns5__DoubleLockDoorResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__DoubleLockDoorResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns5__DoubleLockDoorResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns5__DoubleLockDoorResponse ** SOAP_FMAC4 soap_in_PointerTo_ns5__DoubleLockDoorResponse(struct soap *soap, const char *tag, struct _ns5__DoubleLockDoorResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns5__DoubleLockDoorResponse **)soap_malloc(soap, sizeof(struct _ns5__DoubleLockDoorResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns5__DoubleLockDoorResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns5__DoubleLockDoorResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__DoubleLockDoorResponse, sizeof(struct _ns5__DoubleLockDoorResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__DoubleLockDoorResponse(struct soap *soap, struct _ns5__DoubleLockDoorResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__DoubleLockDoorResponse(soap, tag ? tag : "ns5:DoubleLockDoorResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__DoubleLockDoorResponse ** SOAP_FMAC4 soap_get_PointerTo_ns5__DoubleLockDoorResponse(struct soap *soap, struct _ns5__DoubleLockDoorResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__DoubleLockDoorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__DoubleLockDoor(struct soap *soap, struct _ns5__DoubleLockDoor *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__DoubleLockDoor))
		soap_serialize__ns5__DoubleLockDoor(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__DoubleLockDoor(struct soap *soap, const char *tag, int id, struct _ns5__DoubleLockDoor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__DoubleLockDoor, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns5__DoubleLockDoor(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns5__DoubleLockDoor ** SOAP_FMAC4 soap_in_PointerTo_ns5__DoubleLockDoor(struct soap *soap, const char *tag, struct _ns5__DoubleLockDoor **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns5__DoubleLockDoor **)soap_malloc(soap, sizeof(struct _ns5__DoubleLockDoor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns5__DoubleLockDoor(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns5__DoubleLockDoor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__DoubleLockDoor, sizeof(struct _ns5__DoubleLockDoor), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__DoubleLockDoor(struct soap *soap, struct _ns5__DoubleLockDoor *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__DoubleLockDoor(soap, tag ? tag : "ns5:DoubleLockDoor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__DoubleLockDoor ** SOAP_FMAC4 soap_get_PointerTo_ns5__DoubleLockDoor(struct soap *soap, struct _ns5__DoubleLockDoor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__DoubleLockDoor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__LockOpenReleaseDoorResponse(struct soap *soap, struct _ns5__LockOpenReleaseDoorResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__LockOpenReleaseDoorResponse))
		soap_serialize__ns5__LockOpenReleaseDoorResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__LockOpenReleaseDoorResponse(struct soap *soap, const char *tag, int id, struct _ns5__LockOpenReleaseDoorResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__LockOpenReleaseDoorResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns5__LockOpenReleaseDoorResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns5__LockOpenReleaseDoorResponse ** SOAP_FMAC4 soap_in_PointerTo_ns5__LockOpenReleaseDoorResponse(struct soap *soap, const char *tag, struct _ns5__LockOpenReleaseDoorResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns5__LockOpenReleaseDoorResponse **)soap_malloc(soap, sizeof(struct _ns5__LockOpenReleaseDoorResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns5__LockOpenReleaseDoorResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns5__LockOpenReleaseDoorResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__LockOpenReleaseDoorResponse, sizeof(struct _ns5__LockOpenReleaseDoorResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__LockOpenReleaseDoorResponse(struct soap *soap, struct _ns5__LockOpenReleaseDoorResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__LockOpenReleaseDoorResponse(soap, tag ? tag : "ns5:LockOpenReleaseDoorResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__LockOpenReleaseDoorResponse ** SOAP_FMAC4 soap_get_PointerTo_ns5__LockOpenReleaseDoorResponse(struct soap *soap, struct _ns5__LockOpenReleaseDoorResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__LockOpenReleaseDoorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__LockOpenReleaseDoor(struct soap *soap, struct _ns5__LockOpenReleaseDoor *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__LockOpenReleaseDoor))
		soap_serialize__ns5__LockOpenReleaseDoor(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__LockOpenReleaseDoor(struct soap *soap, const char *tag, int id, struct _ns5__LockOpenReleaseDoor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__LockOpenReleaseDoor, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns5__LockOpenReleaseDoor(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns5__LockOpenReleaseDoor ** SOAP_FMAC4 soap_in_PointerTo_ns5__LockOpenReleaseDoor(struct soap *soap, const char *tag, struct _ns5__LockOpenReleaseDoor **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns5__LockOpenReleaseDoor **)soap_malloc(soap, sizeof(struct _ns5__LockOpenReleaseDoor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns5__LockOpenReleaseDoor(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns5__LockOpenReleaseDoor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__LockOpenReleaseDoor, sizeof(struct _ns5__LockOpenReleaseDoor), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__LockOpenReleaseDoor(struct soap *soap, struct _ns5__LockOpenReleaseDoor *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__LockOpenReleaseDoor(soap, tag ? tag : "ns5:LockOpenReleaseDoor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__LockOpenReleaseDoor ** SOAP_FMAC4 soap_get_PointerTo_ns5__LockOpenReleaseDoor(struct soap *soap, struct _ns5__LockOpenReleaseDoor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__LockOpenReleaseDoor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__LockOpenDoorResponse(struct soap *soap, struct _ns5__LockOpenDoorResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__LockOpenDoorResponse))
		soap_serialize__ns5__LockOpenDoorResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__LockOpenDoorResponse(struct soap *soap, const char *tag, int id, struct _ns5__LockOpenDoorResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__LockOpenDoorResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns5__LockOpenDoorResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns5__LockOpenDoorResponse ** SOAP_FMAC4 soap_in_PointerTo_ns5__LockOpenDoorResponse(struct soap *soap, const char *tag, struct _ns5__LockOpenDoorResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns5__LockOpenDoorResponse **)soap_malloc(soap, sizeof(struct _ns5__LockOpenDoorResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns5__LockOpenDoorResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns5__LockOpenDoorResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__LockOpenDoorResponse, sizeof(struct _ns5__LockOpenDoorResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__LockOpenDoorResponse(struct soap *soap, struct _ns5__LockOpenDoorResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__LockOpenDoorResponse(soap, tag ? tag : "ns5:LockOpenDoorResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__LockOpenDoorResponse ** SOAP_FMAC4 soap_get_PointerTo_ns5__LockOpenDoorResponse(struct soap *soap, struct _ns5__LockOpenDoorResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__LockOpenDoorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__LockOpenDoor(struct soap *soap, struct _ns5__LockOpenDoor *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__LockOpenDoor))
		soap_serialize__ns5__LockOpenDoor(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__LockOpenDoor(struct soap *soap, const char *tag, int id, struct _ns5__LockOpenDoor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__LockOpenDoor, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns5__LockOpenDoor(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns5__LockOpenDoor ** SOAP_FMAC4 soap_in_PointerTo_ns5__LockOpenDoor(struct soap *soap, const char *tag, struct _ns5__LockOpenDoor **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns5__LockOpenDoor **)soap_malloc(soap, sizeof(struct _ns5__LockOpenDoor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns5__LockOpenDoor(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns5__LockOpenDoor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__LockOpenDoor, sizeof(struct _ns5__LockOpenDoor), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__LockOpenDoor(struct soap *soap, struct _ns5__LockOpenDoor *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__LockOpenDoor(soap, tag ? tag : "ns5:LockOpenDoor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__LockOpenDoor ** SOAP_FMAC4 soap_get_PointerTo_ns5__LockOpenDoor(struct soap *soap, struct _ns5__LockOpenDoor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__LockOpenDoor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__LockDownReleaseDoorResponse(struct soap *soap, struct _ns5__LockDownReleaseDoorResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__LockDownReleaseDoorResponse))
		soap_serialize__ns5__LockDownReleaseDoorResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__LockDownReleaseDoorResponse(struct soap *soap, const char *tag, int id, struct _ns5__LockDownReleaseDoorResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__LockDownReleaseDoorResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns5__LockDownReleaseDoorResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns5__LockDownReleaseDoorResponse ** SOAP_FMAC4 soap_in_PointerTo_ns5__LockDownReleaseDoorResponse(struct soap *soap, const char *tag, struct _ns5__LockDownReleaseDoorResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns5__LockDownReleaseDoorResponse **)soap_malloc(soap, sizeof(struct _ns5__LockDownReleaseDoorResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns5__LockDownReleaseDoorResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns5__LockDownReleaseDoorResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__LockDownReleaseDoorResponse, sizeof(struct _ns5__LockDownReleaseDoorResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__LockDownReleaseDoorResponse(struct soap *soap, struct _ns5__LockDownReleaseDoorResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__LockDownReleaseDoorResponse(soap, tag ? tag : "ns5:LockDownReleaseDoorResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__LockDownReleaseDoorResponse ** SOAP_FMAC4 soap_get_PointerTo_ns5__LockDownReleaseDoorResponse(struct soap *soap, struct _ns5__LockDownReleaseDoorResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__LockDownReleaseDoorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__LockDownReleaseDoor(struct soap *soap, struct _ns5__LockDownReleaseDoor *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__LockDownReleaseDoor))
		soap_serialize__ns5__LockDownReleaseDoor(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__LockDownReleaseDoor(struct soap *soap, const char *tag, int id, struct _ns5__LockDownReleaseDoor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__LockDownReleaseDoor, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns5__LockDownReleaseDoor(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns5__LockDownReleaseDoor ** SOAP_FMAC4 soap_in_PointerTo_ns5__LockDownReleaseDoor(struct soap *soap, const char *tag, struct _ns5__LockDownReleaseDoor **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns5__LockDownReleaseDoor **)soap_malloc(soap, sizeof(struct _ns5__LockDownReleaseDoor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns5__LockDownReleaseDoor(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns5__LockDownReleaseDoor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__LockDownReleaseDoor, sizeof(struct _ns5__LockDownReleaseDoor), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__LockDownReleaseDoor(struct soap *soap, struct _ns5__LockDownReleaseDoor *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__LockDownReleaseDoor(soap, tag ? tag : "ns5:LockDownReleaseDoor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__LockDownReleaseDoor ** SOAP_FMAC4 soap_get_PointerTo_ns5__LockDownReleaseDoor(struct soap *soap, struct _ns5__LockDownReleaseDoor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__LockDownReleaseDoor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__LockDownDoorResponse(struct soap *soap, struct _ns5__LockDownDoorResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__LockDownDoorResponse))
		soap_serialize__ns5__LockDownDoorResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__LockDownDoorResponse(struct soap *soap, const char *tag, int id, struct _ns5__LockDownDoorResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__LockDownDoorResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns5__LockDownDoorResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns5__LockDownDoorResponse ** SOAP_FMAC4 soap_in_PointerTo_ns5__LockDownDoorResponse(struct soap *soap, const char *tag, struct _ns5__LockDownDoorResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns5__LockDownDoorResponse **)soap_malloc(soap, sizeof(struct _ns5__LockDownDoorResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns5__LockDownDoorResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns5__LockDownDoorResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__LockDownDoorResponse, sizeof(struct _ns5__LockDownDoorResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__LockDownDoorResponse(struct soap *soap, struct _ns5__LockDownDoorResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__LockDownDoorResponse(soap, tag ? tag : "ns5:LockDownDoorResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__LockDownDoorResponse ** SOAP_FMAC4 soap_get_PointerTo_ns5__LockDownDoorResponse(struct soap *soap, struct _ns5__LockDownDoorResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__LockDownDoorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__LockDownDoor(struct soap *soap, struct _ns5__LockDownDoor *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__LockDownDoor))
		soap_serialize__ns5__LockDownDoor(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__LockDownDoor(struct soap *soap, const char *tag, int id, struct _ns5__LockDownDoor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__LockDownDoor, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns5__LockDownDoor(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns5__LockDownDoor ** SOAP_FMAC4 soap_in_PointerTo_ns5__LockDownDoor(struct soap *soap, const char *tag, struct _ns5__LockDownDoor **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns5__LockDownDoor **)soap_malloc(soap, sizeof(struct _ns5__LockDownDoor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns5__LockDownDoor(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns5__LockDownDoor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__LockDownDoor, sizeof(struct _ns5__LockDownDoor), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__LockDownDoor(struct soap *soap, struct _ns5__LockDownDoor *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__LockDownDoor(soap, tag ? tag : "ns5:LockDownDoor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__LockDownDoor ** SOAP_FMAC4 soap_get_PointerTo_ns5__LockDownDoor(struct soap *soap, struct _ns5__LockDownDoor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__LockDownDoor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__BlockDoorResponse(struct soap *soap, struct _ns5__BlockDoorResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__BlockDoorResponse))
		soap_serialize__ns5__BlockDoorResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__BlockDoorResponse(struct soap *soap, const char *tag, int id, struct _ns5__BlockDoorResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__BlockDoorResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns5__BlockDoorResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns5__BlockDoorResponse ** SOAP_FMAC4 soap_in_PointerTo_ns5__BlockDoorResponse(struct soap *soap, const char *tag, struct _ns5__BlockDoorResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns5__BlockDoorResponse **)soap_malloc(soap, sizeof(struct _ns5__BlockDoorResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns5__BlockDoorResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns5__BlockDoorResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__BlockDoorResponse, sizeof(struct _ns5__BlockDoorResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__BlockDoorResponse(struct soap *soap, struct _ns5__BlockDoorResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__BlockDoorResponse(soap, tag ? tag : "ns5:BlockDoorResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__BlockDoorResponse ** SOAP_FMAC4 soap_get_PointerTo_ns5__BlockDoorResponse(struct soap *soap, struct _ns5__BlockDoorResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__BlockDoorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__BlockDoor(struct soap *soap, struct _ns5__BlockDoor *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__BlockDoor))
		soap_serialize__ns5__BlockDoor(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__BlockDoor(struct soap *soap, const char *tag, int id, struct _ns5__BlockDoor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__BlockDoor, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns5__BlockDoor(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns5__BlockDoor ** SOAP_FMAC4 soap_in_PointerTo_ns5__BlockDoor(struct soap *soap, const char *tag, struct _ns5__BlockDoor **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns5__BlockDoor **)soap_malloc(soap, sizeof(struct _ns5__BlockDoor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns5__BlockDoor(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns5__BlockDoor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__BlockDoor, sizeof(struct _ns5__BlockDoor), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__BlockDoor(struct soap *soap, struct _ns5__BlockDoor *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__BlockDoor(soap, tag ? tag : "ns5:BlockDoor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__BlockDoor ** SOAP_FMAC4 soap_get_PointerTo_ns5__BlockDoor(struct soap *soap, struct _ns5__BlockDoor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__BlockDoor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__UnlockDoorResponse(struct soap *soap, struct _ns5__UnlockDoorResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__UnlockDoorResponse))
		soap_serialize__ns5__UnlockDoorResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__UnlockDoorResponse(struct soap *soap, const char *tag, int id, struct _ns5__UnlockDoorResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__UnlockDoorResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns5__UnlockDoorResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns5__UnlockDoorResponse ** SOAP_FMAC4 soap_in_PointerTo_ns5__UnlockDoorResponse(struct soap *soap, const char *tag, struct _ns5__UnlockDoorResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns5__UnlockDoorResponse **)soap_malloc(soap, sizeof(struct _ns5__UnlockDoorResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns5__UnlockDoorResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns5__UnlockDoorResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__UnlockDoorResponse, sizeof(struct _ns5__UnlockDoorResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__UnlockDoorResponse(struct soap *soap, struct _ns5__UnlockDoorResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__UnlockDoorResponse(soap, tag ? tag : "ns5:UnlockDoorResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__UnlockDoorResponse ** SOAP_FMAC4 soap_get_PointerTo_ns5__UnlockDoorResponse(struct soap *soap, struct _ns5__UnlockDoorResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__UnlockDoorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__UnlockDoor(struct soap *soap, struct _ns5__UnlockDoor *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__UnlockDoor))
		soap_serialize__ns5__UnlockDoor(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__UnlockDoor(struct soap *soap, const char *tag, int id, struct _ns5__UnlockDoor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__UnlockDoor, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns5__UnlockDoor(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns5__UnlockDoor ** SOAP_FMAC4 soap_in_PointerTo_ns5__UnlockDoor(struct soap *soap, const char *tag, struct _ns5__UnlockDoor **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns5__UnlockDoor **)soap_malloc(soap, sizeof(struct _ns5__UnlockDoor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns5__UnlockDoor(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns5__UnlockDoor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__UnlockDoor, sizeof(struct _ns5__UnlockDoor), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__UnlockDoor(struct soap *soap, struct _ns5__UnlockDoor *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__UnlockDoor(soap, tag ? tag : "ns5:UnlockDoor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__UnlockDoor ** SOAP_FMAC4 soap_get_PointerTo_ns5__UnlockDoor(struct soap *soap, struct _ns5__UnlockDoor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__UnlockDoor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__LockDoorResponse(struct soap *soap, struct _ns5__LockDoorResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__LockDoorResponse))
		soap_serialize__ns5__LockDoorResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__LockDoorResponse(struct soap *soap, const char *tag, int id, struct _ns5__LockDoorResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__LockDoorResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns5__LockDoorResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns5__LockDoorResponse ** SOAP_FMAC4 soap_in_PointerTo_ns5__LockDoorResponse(struct soap *soap, const char *tag, struct _ns5__LockDoorResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns5__LockDoorResponse **)soap_malloc(soap, sizeof(struct _ns5__LockDoorResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns5__LockDoorResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns5__LockDoorResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__LockDoorResponse, sizeof(struct _ns5__LockDoorResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__LockDoorResponse(struct soap *soap, struct _ns5__LockDoorResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__LockDoorResponse(soap, tag ? tag : "ns5:LockDoorResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__LockDoorResponse ** SOAP_FMAC4 soap_get_PointerTo_ns5__LockDoorResponse(struct soap *soap, struct _ns5__LockDoorResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__LockDoorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__LockDoor(struct soap *soap, struct _ns5__LockDoor *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__LockDoor))
		soap_serialize__ns5__LockDoor(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__LockDoor(struct soap *soap, const char *tag, int id, struct _ns5__LockDoor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__LockDoor, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns5__LockDoor(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns5__LockDoor ** SOAP_FMAC4 soap_in_PointerTo_ns5__LockDoor(struct soap *soap, const char *tag, struct _ns5__LockDoor **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns5__LockDoor **)soap_malloc(soap, sizeof(struct _ns5__LockDoor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns5__LockDoor(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns5__LockDoor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__LockDoor, sizeof(struct _ns5__LockDoor), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__LockDoor(struct soap *soap, struct _ns5__LockDoor *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__LockDoor(soap, tag ? tag : "ns5:LockDoor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__LockDoor ** SOAP_FMAC4 soap_get_PointerTo_ns5__LockDoor(struct soap *soap, struct _ns5__LockDoor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__LockDoor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__AccessDoorResponse(struct soap *soap, struct _ns5__AccessDoorResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__AccessDoorResponse))
		soap_serialize__ns5__AccessDoorResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__AccessDoorResponse(struct soap *soap, const char *tag, int id, struct _ns5__AccessDoorResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__AccessDoorResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns5__AccessDoorResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns5__AccessDoorResponse ** SOAP_FMAC4 soap_in_PointerTo_ns5__AccessDoorResponse(struct soap *soap, const char *tag, struct _ns5__AccessDoorResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns5__AccessDoorResponse **)soap_malloc(soap, sizeof(struct _ns5__AccessDoorResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns5__AccessDoorResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns5__AccessDoorResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__AccessDoorResponse, sizeof(struct _ns5__AccessDoorResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__AccessDoorResponse(struct soap *soap, struct _ns5__AccessDoorResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__AccessDoorResponse(soap, tag ? tag : "ns5:AccessDoorResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__AccessDoorResponse ** SOAP_FMAC4 soap_get_PointerTo_ns5__AccessDoorResponse(struct soap *soap, struct _ns5__AccessDoorResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__AccessDoorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__AccessDoor(struct soap *soap, struct _ns5__AccessDoor *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__AccessDoor))
		soap_serialize__ns5__AccessDoor(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__AccessDoor(struct soap *soap, const char *tag, int id, struct _ns5__AccessDoor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__AccessDoor, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns5__AccessDoor(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns5__AccessDoor ** SOAP_FMAC4 soap_in_PointerTo_ns5__AccessDoor(struct soap *soap, const char *tag, struct _ns5__AccessDoor **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns5__AccessDoor **)soap_malloc(soap, sizeof(struct _ns5__AccessDoor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns5__AccessDoor(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns5__AccessDoor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__AccessDoor, sizeof(struct _ns5__AccessDoor), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__AccessDoor(struct soap *soap, struct _ns5__AccessDoor *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__AccessDoor(soap, tag ? tag : "ns5:AccessDoor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__AccessDoor ** SOAP_FMAC4 soap_get_PointerTo_ns5__AccessDoor(struct soap *soap, struct _ns5__AccessDoor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__AccessDoor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__GetDoorStateResponse(struct soap *soap, struct _ns5__GetDoorStateResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__GetDoorStateResponse))
		soap_serialize__ns5__GetDoorStateResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__GetDoorStateResponse(struct soap *soap, const char *tag, int id, struct _ns5__GetDoorStateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__GetDoorStateResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns5__GetDoorStateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns5__GetDoorStateResponse ** SOAP_FMAC4 soap_in_PointerTo_ns5__GetDoorStateResponse(struct soap *soap, const char *tag, struct _ns5__GetDoorStateResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns5__GetDoorStateResponse **)soap_malloc(soap, sizeof(struct _ns5__GetDoorStateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns5__GetDoorStateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns5__GetDoorStateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetDoorStateResponse, sizeof(struct _ns5__GetDoorStateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__GetDoorStateResponse(struct soap *soap, struct _ns5__GetDoorStateResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__GetDoorStateResponse(soap, tag ? tag : "ns5:GetDoorStateResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__GetDoorStateResponse ** SOAP_FMAC4 soap_get_PointerTo_ns5__GetDoorStateResponse(struct soap *soap, struct _ns5__GetDoorStateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__GetDoorStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__GetDoorState(struct soap *soap, struct _ns5__GetDoorState *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__GetDoorState))
		soap_serialize__ns5__GetDoorState(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__GetDoorState(struct soap *soap, const char *tag, int id, struct _ns5__GetDoorState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__GetDoorState, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns5__GetDoorState(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns5__GetDoorState ** SOAP_FMAC4 soap_in_PointerTo_ns5__GetDoorState(struct soap *soap, const char *tag, struct _ns5__GetDoorState **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns5__GetDoorState **)soap_malloc(soap, sizeof(struct _ns5__GetDoorState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns5__GetDoorState(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns5__GetDoorState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetDoorState, sizeof(struct _ns5__GetDoorState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__GetDoorState(struct soap *soap, struct _ns5__GetDoorState *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__GetDoorState(soap, tag ? tag : "ns5:GetDoorState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__GetDoorState ** SOAP_FMAC4 soap_get_PointerTo_ns5__GetDoorState(struct soap *soap, struct _ns5__GetDoorState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__GetDoorState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__GetDoorInfoResponse(struct soap *soap, struct _ns5__GetDoorInfoResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__GetDoorInfoResponse))
		soap_serialize__ns5__GetDoorInfoResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__GetDoorInfoResponse(struct soap *soap, const char *tag, int id, struct _ns5__GetDoorInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__GetDoorInfoResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns5__GetDoorInfoResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns5__GetDoorInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_ns5__GetDoorInfoResponse(struct soap *soap, const char *tag, struct _ns5__GetDoorInfoResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns5__GetDoorInfoResponse **)soap_malloc(soap, sizeof(struct _ns5__GetDoorInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns5__GetDoorInfoResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns5__GetDoorInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetDoorInfoResponse, sizeof(struct _ns5__GetDoorInfoResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__GetDoorInfoResponse(struct soap *soap, struct _ns5__GetDoorInfoResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__GetDoorInfoResponse(soap, tag ? tag : "ns5:GetDoorInfoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__GetDoorInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_ns5__GetDoorInfoResponse(struct soap *soap, struct _ns5__GetDoorInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__GetDoorInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__GetDoorInfo(struct soap *soap, struct _ns5__GetDoorInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__GetDoorInfo))
		soap_serialize__ns5__GetDoorInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__GetDoorInfo(struct soap *soap, const char *tag, int id, struct _ns5__GetDoorInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__GetDoorInfo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns5__GetDoorInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns5__GetDoorInfo ** SOAP_FMAC4 soap_in_PointerTo_ns5__GetDoorInfo(struct soap *soap, const char *tag, struct _ns5__GetDoorInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns5__GetDoorInfo **)soap_malloc(soap, sizeof(struct _ns5__GetDoorInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns5__GetDoorInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns5__GetDoorInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetDoorInfo, sizeof(struct _ns5__GetDoorInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__GetDoorInfo(struct soap *soap, struct _ns5__GetDoorInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__GetDoorInfo(soap, tag ? tag : "ns5:GetDoorInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__GetDoorInfo ** SOAP_FMAC4 soap_get_PointerTo_ns5__GetDoorInfo(struct soap *soap, struct _ns5__GetDoorInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__GetDoorInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__GetDoorInfoListResponse(struct soap *soap, struct _ns5__GetDoorInfoListResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__GetDoorInfoListResponse))
		soap_serialize__ns5__GetDoorInfoListResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__GetDoorInfoListResponse(struct soap *soap, const char *tag, int id, struct _ns5__GetDoorInfoListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__GetDoorInfoListResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns5__GetDoorInfoListResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns5__GetDoorInfoListResponse ** SOAP_FMAC4 soap_in_PointerTo_ns5__GetDoorInfoListResponse(struct soap *soap, const char *tag, struct _ns5__GetDoorInfoListResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns5__GetDoorInfoListResponse **)soap_malloc(soap, sizeof(struct _ns5__GetDoorInfoListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns5__GetDoorInfoListResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns5__GetDoorInfoListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetDoorInfoListResponse, sizeof(struct _ns5__GetDoorInfoListResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__GetDoorInfoListResponse(struct soap *soap, struct _ns5__GetDoorInfoListResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__GetDoorInfoListResponse(soap, tag ? tag : "ns5:GetDoorInfoListResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__GetDoorInfoListResponse ** SOAP_FMAC4 soap_get_PointerTo_ns5__GetDoorInfoListResponse(struct soap *soap, struct _ns5__GetDoorInfoListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__GetDoorInfoListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__GetDoorInfoList(struct soap *soap, struct _ns5__GetDoorInfoList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__GetDoorInfoList))
		soap_serialize__ns5__GetDoorInfoList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__GetDoorInfoList(struct soap *soap, const char *tag, int id, struct _ns5__GetDoorInfoList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__GetDoorInfoList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns5__GetDoorInfoList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns5__GetDoorInfoList ** SOAP_FMAC4 soap_in_PointerTo_ns5__GetDoorInfoList(struct soap *soap, const char *tag, struct _ns5__GetDoorInfoList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns5__GetDoorInfoList **)soap_malloc(soap, sizeof(struct _ns5__GetDoorInfoList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns5__GetDoorInfoList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns5__GetDoorInfoList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetDoorInfoList, sizeof(struct _ns5__GetDoorInfoList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__GetDoorInfoList(struct soap *soap, struct _ns5__GetDoorInfoList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__GetDoorInfoList(soap, tag ? tag : "ns5:GetDoorInfoList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__GetDoorInfoList ** SOAP_FMAC4 soap_get_PointerTo_ns5__GetDoorInfoList(struct soap *soap, struct _ns5__GetDoorInfoList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__GetDoorInfoList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns5__GetServiceCapabilitiesResponse(struct soap *soap, struct _ns5__GetServiceCapabilitiesResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns5__GetServiceCapabilitiesResponse))
		soap_serialize__ns5__GetServiceCapabilitiesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns5__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, struct _ns5__GetServiceCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns5__GetServiceCapabilitiesResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__ns5__GetServiceCapabilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns5__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_ns5__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _ns5__GetServiceCapabilitiesResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns5__GetServiceCapabilitiesResponse **)soap_malloc(soap, sizeof(struct _ns5__GetServiceCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns5__GetServiceCapabilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns5__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns5__GetServiceCapabilitiesResponse, sizeof(struct _ns5__GetServiceCapabilitiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns5__GetServiceCapabilitiesResponse(struct soap *soap, struct _ns5__GetServiceCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns5__GetServiceCapabilitiesResponse(soap, tag ? tag : "ns5:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_ns5__GetServiceCapabilitiesResponse(struct soap *soap, struct _ns5__GetServiceCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns5__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
