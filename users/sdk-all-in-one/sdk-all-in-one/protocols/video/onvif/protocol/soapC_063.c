/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:59 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause))
		soap_serialize__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_Description *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description))
		soap_serialize__wsnt__SubscribeCreationFailedFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__SubscribeCreationFailedFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__SubscribeCreationFailedFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_Description **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__SubscribeCreationFailedFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__SubscribeCreationFailedFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_Description), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_Description *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode))
		soap_serialize__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDConfigurationExtension(struct soap *soap, struct tt__OSDConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDConfigurationExtension))
		soap_serialize_tt__OSDConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__OSDConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__OSDConfigurationExtension(struct soap *soap, const char *tag, struct tt__OSDConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__OSDConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDConfigurationExtension, sizeof(struct tt__OSDConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDConfigurationExtension(struct soap *soap, struct tt__OSDConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDConfigurationExtension(soap, tag ? tag : "tt:OSDConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__OSDConfigurationExtension(struct soap *soap, struct tt__OSDConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDImgConfiguration(struct soap *soap, struct tt__OSDImgConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDImgConfiguration))
		soap_serialize_tt__OSDImgConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDImgConfiguration(struct soap *soap, const char *tag, int id, struct tt__OSDImgConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDImgConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDImgConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDImgConfiguration ** SOAP_FMAC4 soap_in_PointerTott__OSDImgConfiguration(struct soap *soap, const char *tag, struct tt__OSDImgConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDImgConfiguration **)soap_malloc(soap, sizeof(struct tt__OSDImgConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDImgConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDImgConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDImgConfiguration, sizeof(struct tt__OSDImgConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDImgConfiguration(struct soap *soap, struct tt__OSDImgConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDImgConfiguration(soap, tag ? tag : "tt:OSDImgConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDImgConfiguration ** SOAP_FMAC4 soap_get_PointerTott__OSDImgConfiguration(struct soap *soap, struct tt__OSDImgConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDImgConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDTextConfiguration(struct soap *soap, struct tt__OSDTextConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDTextConfiguration))
		soap_serialize_tt__OSDTextConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDTextConfiguration(struct soap *soap, const char *tag, int id, struct tt__OSDTextConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDTextConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDTextConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDTextConfiguration ** SOAP_FMAC4 soap_in_PointerTott__OSDTextConfiguration(struct soap *soap, const char *tag, struct tt__OSDTextConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDTextConfiguration **)soap_malloc(soap, sizeof(struct tt__OSDTextConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDTextConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDTextConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDTextConfiguration, sizeof(struct tt__OSDTextConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDTextConfiguration(struct soap *soap, struct tt__OSDTextConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDTextConfiguration(soap, tag ? tag : "tt:OSDTextConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDTextConfiguration ** SOAP_FMAC4 soap_get_PointerTott__OSDTextConfiguration(struct soap *soap, struct tt__OSDTextConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDTextConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDPosConfiguration(struct soap *soap, struct tt__OSDPosConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDPosConfiguration))
		soap_serialize_tt__OSDPosConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDPosConfiguration(struct soap *soap, const char *tag, int id, struct tt__OSDPosConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDPosConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDPosConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDPosConfiguration ** SOAP_FMAC4 soap_in_PointerTott__OSDPosConfiguration(struct soap *soap, const char *tag, struct tt__OSDPosConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDPosConfiguration **)soap_malloc(soap, sizeof(struct tt__OSDPosConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDPosConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDPosConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDPosConfiguration, sizeof(struct tt__OSDPosConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDPosConfiguration(struct soap *soap, struct tt__OSDPosConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDPosConfiguration(soap, tag ? tag : "tt:OSDPosConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDPosConfiguration ** SOAP_FMAC4 soap_get_PointerTott__OSDPosConfiguration(struct soap *soap, struct tt__OSDPosConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDPosConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDReference(struct soap *soap, struct tt__OSDReference *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDReference))
		soap_serialize_tt__OSDReference(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDReference(struct soap *soap, const char *tag, int id, struct tt__OSDReference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDReference, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OSDReference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OSDReference ** SOAP_FMAC4 soap_in_PointerTott__OSDReference(struct soap *soap, const char *tag, struct tt__OSDReference **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OSDReference **)soap_malloc(soap, sizeof(struct tt__OSDReference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OSDReference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OSDReference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDReference, sizeof(struct tt__OSDReference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDReference(struct soap *soap, struct tt__OSDReference *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDReference(soap, tag ? tag : "tt:OSDReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDReference ** SOAP_FMAC4 soap_get_PointerTott__OSDReference(struct soap *soap, struct tt__OSDReference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataInput(struct soap *soap, struct tt__MetadataInput *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataInput))
		soap_serialize_tt__MetadataInput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataInput(struct soap *soap, const char *tag, int id, struct tt__MetadataInput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataInput, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MetadataInput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MetadataInput ** SOAP_FMAC4 soap_in_PointerTott__MetadataInput(struct soap *soap, const char *tag, struct tt__MetadataInput **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MetadataInput **)soap_malloc(soap, sizeof(struct tt__MetadataInput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MetadataInput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataInput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataInput, sizeof(struct tt__MetadataInput), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataInput(struct soap *soap, struct tt__MetadataInput *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MetadataInput(soap, tag ? tag : "tt:MetadataInput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataInput ** SOAP_FMAC4 soap_get_PointerTott__MetadataInput(struct soap *soap, struct tt__MetadataInput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SourceIdentification(struct soap *soap, struct tt__SourceIdentification *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SourceIdentification))
		soap_serialize_tt__SourceIdentification(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SourceIdentification(struct soap *soap, const char *tag, int id, struct tt__SourceIdentification *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SourceIdentification, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SourceIdentification(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SourceIdentification ** SOAP_FMAC4 soap_in_PointerTott__SourceIdentification(struct soap *soap, const char *tag, struct tt__SourceIdentification **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SourceIdentification **)soap_malloc(soap, sizeof(struct tt__SourceIdentification *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SourceIdentification(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SourceIdentification **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SourceIdentification, sizeof(struct tt__SourceIdentification), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SourceIdentification(struct soap *soap, struct tt__SourceIdentification *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SourceIdentification(soap, tag ? tag : "tt:SourceIdentification", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SourceIdentification ** SOAP_FMAC4 soap_get_PointerTott__SourceIdentification(struct soap *soap, struct tt__SourceIdentification **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SourceIdentification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsDeviceEngineConfiguration(struct soap *soap, struct tt__AnalyticsDeviceEngineConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration))
		soap_serialize_tt__AnalyticsDeviceEngineConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsDeviceEngineConfiguration(struct soap *soap, const char *tag, int id, struct tt__AnalyticsDeviceEngineConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsDeviceEngineConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceEngineConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsDeviceEngineConfiguration(struct soap *soap, const char *tag, struct tt__AnalyticsDeviceEngineConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsDeviceEngineConfiguration **)soap_malloc(soap, sizeof(struct tt__AnalyticsDeviceEngineConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsDeviceEngineConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsDeviceEngineConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration, sizeof(struct tt__AnalyticsDeviceEngineConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsDeviceEngineConfiguration(struct soap *soap, struct tt__AnalyticsDeviceEngineConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsDeviceEngineConfiguration(soap, tag ? tag : "tt:AnalyticsDeviceEngineConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceEngineConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsDeviceEngineConfiguration(struct soap *soap, struct tt__AnalyticsDeviceEngineConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsDeviceEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ObjectExtension(struct soap *soap, struct tt__ObjectExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ObjectExtension))
		soap_serialize_tt__ObjectExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ObjectExtension(struct soap *soap, const char *tag, int id, struct tt__ObjectExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ObjectExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ObjectExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ObjectExtension ** SOAP_FMAC4 soap_in_PointerTott__ObjectExtension(struct soap *soap, const char *tag, struct tt__ObjectExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ObjectExtension **)soap_malloc(soap, sizeof(struct tt__ObjectExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ObjectExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ObjectExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ObjectExtension, sizeof(struct tt__ObjectExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ObjectExtension(struct soap *soap, struct tt__ObjectExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ObjectExtension(soap, tag ? tag : "tt:ObjectExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ObjectExtension ** SOAP_FMAC4 soap_get_PointerTott__ObjectExtension(struct soap *soap, struct tt__ObjectExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ObjectExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Behaviour(struct soap *soap, struct tt__Behaviour *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Behaviour))
		soap_serialize_tt__Behaviour(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Behaviour(struct soap *soap, const char *tag, int id, struct tt__Behaviour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Behaviour, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Behaviour(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Behaviour ** SOAP_FMAC4 soap_in_PointerTott__Behaviour(struct soap *soap, const char *tag, struct tt__Behaviour **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Behaviour **)soap_malloc(soap, sizeof(struct tt__Behaviour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Behaviour(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Behaviour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Behaviour, sizeof(struct tt__Behaviour), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Behaviour(struct soap *soap, struct tt__Behaviour *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Behaviour(soap, tag ? tag : "tt:Behaviour", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Behaviour ** SOAP_FMAC4 soap_get_PointerTott__Behaviour(struct soap *soap, struct tt__Behaviour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Behaviour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Appearance(struct soap *soap, struct tt__Appearance *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Appearance))
		soap_serialize_tt__Appearance(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Appearance(struct soap *soap, const char *tag, int id, struct tt__Appearance *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Appearance, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Appearance(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Appearance ** SOAP_FMAC4 soap_in_PointerTott__Appearance(struct soap *soap, const char *tag, struct tt__Appearance **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Appearance **)soap_malloc(soap, sizeof(struct tt__Appearance *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Appearance(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Appearance **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Appearance, sizeof(struct tt__Appearance), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Appearance(struct soap *soap, struct tt__Appearance *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Appearance(soap, tag ? tag : "tt:Appearance", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Appearance ** SOAP_FMAC4 soap_get_PointerTott__Appearance(struct soap *soap, struct tt__Appearance **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Appearance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZConfigurationExtension(struct soap *soap, struct tt__PTZConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZConfigurationExtension))
		soap_serialize_tt__PTZConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__PTZConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZConfigurationExtension(struct soap *soap, const char *tag, struct tt__PTZConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__PTZConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfigurationExtension, sizeof(struct tt__PTZConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZConfigurationExtension(struct soap *soap, struct tt__PTZConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZConfigurationExtension(soap, tag ? tag : "tt:PTZConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZConfigurationExtension(struct soap *soap, struct tt__PTZConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ZoomLimits(struct soap *soap, struct tt__ZoomLimits *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ZoomLimits))
		soap_serialize_tt__ZoomLimits(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ZoomLimits(struct soap *soap, const char *tag, int id, struct tt__ZoomLimits *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ZoomLimits, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ZoomLimits(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ZoomLimits ** SOAP_FMAC4 soap_in_PointerTott__ZoomLimits(struct soap *soap, const char *tag, struct tt__ZoomLimits **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ZoomLimits **)soap_malloc(soap, sizeof(struct tt__ZoomLimits *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ZoomLimits(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ZoomLimits **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ZoomLimits, sizeof(struct tt__ZoomLimits), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ZoomLimits(struct soap *soap, struct tt__ZoomLimits *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ZoomLimits(soap, tag ? tag : "tt:ZoomLimits", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ZoomLimits ** SOAP_FMAC4 soap_get_PointerTott__ZoomLimits(struct soap *soap, struct tt__ZoomLimits **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ZoomLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PanTiltLimits(struct soap *soap, struct tt__PanTiltLimits *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PanTiltLimits))
		soap_serialize_tt__PanTiltLimits(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PanTiltLimits(struct soap *soap, const char *tag, int id, struct tt__PanTiltLimits *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PanTiltLimits, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PanTiltLimits(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PanTiltLimits ** SOAP_FMAC4 soap_in_PointerTott__PanTiltLimits(struct soap *soap, const char *tag, struct tt__PanTiltLimits **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PanTiltLimits **)soap_malloc(soap, sizeof(struct tt__PanTiltLimits *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PanTiltLimits(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PanTiltLimits **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PanTiltLimits, sizeof(struct tt__PanTiltLimits), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PanTiltLimits(struct soap *soap, struct tt__PanTiltLimits *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PanTiltLimits(soap, tag ? tag : "tt:PanTiltLimits", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PanTiltLimits ** SOAP_FMAC4 soap_get_PointerTott__PanTiltLimits(struct soap *soap, struct tt__PanTiltLimits **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PanTiltLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZNodeExtension(struct soap *soap, struct tt__PTZNodeExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZNodeExtension))
		soap_serialize_tt__PTZNodeExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZNodeExtension(struct soap *soap, const char *tag, int id, struct tt__PTZNodeExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZNodeExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZNodeExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZNodeExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZNodeExtension(struct soap *soap, const char *tag, struct tt__PTZNodeExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZNodeExtension **)soap_malloc(soap, sizeof(struct tt__PTZNodeExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZNodeExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZNodeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZNodeExtension, sizeof(struct tt__PTZNodeExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZNodeExtension(struct soap *soap, struct tt__PTZNodeExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZNodeExtension(soap, tag ? tag : "tt:PTZNodeExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZNodeExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZNodeExtension(struct soap *soap, struct tt__PTZNodeExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZNodeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DigitalIdleState(struct soap *soap, enum tt__DigitalIdleState *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__DigitalIdleState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DigitalIdleState(struct soap *soap, const char *tag, int id, enum tt__DigitalIdleState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DigitalIdleState, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DigitalIdleState(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__DigitalIdleState ** SOAP_FMAC4 soap_in_PointerTott__DigitalIdleState(struct soap *soap, const char *tag, enum tt__DigitalIdleState **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__DigitalIdleState **)soap_malloc(soap, sizeof(enum tt__DigitalIdleState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DigitalIdleState(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__DigitalIdleState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DigitalIdleState, sizeof(enum tt__DigitalIdleState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DigitalIdleState(struct soap *soap, enum tt__DigitalIdleState *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DigitalIdleState(soap, tag ? tag : "tt:DigitalIdleState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__DigitalIdleState ** SOAP_FMAC4 soap_get_PointerTott__DigitalIdleState(struct soap *soap, enum tt__DigitalIdleState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DigitalIdleState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceExtension(struct soap *soap, struct tt__NetworkInterfaceExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceExtension))
		soap_serialize_tt__NetworkInterfaceExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceExtension(struct soap *soap, const char *tag, int id, struct tt__NetworkInterfaceExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkInterfaceExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkInterfaceExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceExtension(struct soap *soap, const char *tag, struct tt__NetworkInterfaceExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkInterfaceExtension **)soap_malloc(soap, sizeof(struct tt__NetworkInterfaceExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkInterfaceExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceExtension, sizeof(struct tt__NetworkInterfaceExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceExtension(struct soap *soap, struct tt__NetworkInterfaceExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterfaceExtension(soap, tag ? tag : "tt:NetworkInterfaceExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceExtension(struct soap *soap, struct tt__NetworkInterfaceExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6NetworkInterface(struct soap *soap, struct tt__IPv6NetworkInterface *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6NetworkInterface))
		soap_serialize_tt__IPv6NetworkInterface(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6NetworkInterface(struct soap *soap, const char *tag, int id, struct tt__IPv6NetworkInterface *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6NetworkInterface, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv6NetworkInterface(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPv6NetworkInterface ** SOAP_FMAC4 soap_in_PointerTott__IPv6NetworkInterface(struct soap *soap, const char *tag, struct tt__IPv6NetworkInterface **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IPv6NetworkInterface **)soap_malloc(soap, sizeof(struct tt__IPv6NetworkInterface *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv6NetworkInterface(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IPv6NetworkInterface **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6NetworkInterface, sizeof(struct tt__IPv6NetworkInterface), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6NetworkInterface(struct soap *soap, struct tt__IPv6NetworkInterface *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv6NetworkInterface(soap, tag ? tag : "tt:IPv6NetworkInterface", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv6NetworkInterface ** SOAP_FMAC4 soap_get_PointerTott__IPv6NetworkInterface(struct soap *soap, struct tt__IPv6NetworkInterface **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv4NetworkInterface(struct soap *soap, struct tt__IPv4NetworkInterface *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv4NetworkInterface))
		soap_serialize_tt__IPv4NetworkInterface(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv4NetworkInterface(struct soap *soap, const char *tag, int id, struct tt__IPv4NetworkInterface *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv4NetworkInterface, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv4NetworkInterface(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPv4NetworkInterface ** SOAP_FMAC4 soap_in_PointerTott__IPv4NetworkInterface(struct soap *soap, const char *tag, struct tt__IPv4NetworkInterface **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IPv4NetworkInterface **)soap_malloc(soap, sizeof(struct tt__IPv4NetworkInterface *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv4NetworkInterface(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IPv4NetworkInterface **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv4NetworkInterface, sizeof(struct tt__IPv4NetworkInterface), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv4NetworkInterface(struct soap *soap, struct tt__IPv4NetworkInterface *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv4NetworkInterface(soap, tag ? tag : "tt:IPv4NetworkInterface", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv4NetworkInterface ** SOAP_FMAC4 soap_get_PointerTott__IPv4NetworkInterface(struct soap *soap, struct tt__IPv4NetworkInterface **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv4NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceLink(struct soap *soap, struct tt__NetworkInterfaceLink *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceLink))
		soap_serialize_tt__NetworkInterfaceLink(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceLink(struct soap *soap, const char *tag, int id, struct tt__NetworkInterfaceLink *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceLink, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkInterfaceLink(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkInterfaceLink ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceLink(struct soap *soap, const char *tag, struct tt__NetworkInterfaceLink **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkInterfaceLink **)soap_malloc(soap, sizeof(struct tt__NetworkInterfaceLink *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkInterfaceLink(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceLink **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceLink, sizeof(struct tt__NetworkInterfaceLink), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceLink(struct soap *soap, struct tt__NetworkInterfaceLink *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterfaceLink(soap, tag ? tag : "tt:NetworkInterfaceLink", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceLink ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceLink(struct soap *soap, struct tt__NetworkInterfaceLink **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceInfo(struct soap *soap, struct tt__NetworkInterfaceInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceInfo))
		soap_serialize_tt__NetworkInterfaceInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceInfo(struct soap *soap, const char *tag, int id, struct tt__NetworkInterfaceInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceInfo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkInterfaceInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkInterfaceInfo ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceInfo(struct soap *soap, const char *tag, struct tt__NetworkInterfaceInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkInterfaceInfo **)soap_malloc(soap, sizeof(struct tt__NetworkInterfaceInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkInterfaceInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceInfo, sizeof(struct tt__NetworkInterfaceInfo), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceInfo(struct soap *soap, struct tt__NetworkInterfaceInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterfaceInfo(soap, tag ? tag : "tt:NetworkInterfaceInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceInfo ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceInfo(struct soap *soap, struct tt__NetworkInterfaceInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoOutputExtension(struct soap *soap, struct tt__VideoOutputExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoOutputExtension))
		soap_serialize_tt__VideoOutputExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoOutputExtension(struct soap *soap, const char *tag, int id, struct tt__VideoOutputExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoOutputExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoOutputExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoOutputExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoOutputExtension(struct soap *soap, const char *tag, struct tt__VideoOutputExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoOutputExtension **)soap_malloc(soap, sizeof(struct tt__VideoOutputExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoOutputExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoOutputExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoOutputExtension, sizeof(struct tt__VideoOutputExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoOutputExtension(struct soap *soap, struct tt__VideoOutputExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoOutputExtension(soap, tag ? tag : "tt:VideoOutputExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoOutputExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoOutputExtension(struct soap *soap, struct tt__VideoOutputExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoOutputExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataConfigurationExtension(struct soap *soap, struct tt__MetadataConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataConfigurationExtension))
		soap_serialize_tt__MetadataConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__MetadataConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MetadataConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MetadataConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__MetadataConfigurationExtension(struct soap *soap, const char *tag, struct tt__MetadataConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MetadataConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__MetadataConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MetadataConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataConfigurationExtension, sizeof(struct tt__MetadataConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataConfigurationExtension(struct soap *soap, struct tt__MetadataConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MetadataConfigurationExtension(soap, tag ? tag : "tt:MetadataConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__MetadataConfigurationExtension(struct soap *soap, struct tt__MetadataConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EventSubscription(struct soap *soap, struct tt__EventSubscription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EventSubscription))
		soap_serialize_tt__EventSubscription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EventSubscription(struct soap *soap, const char *tag, int id, struct tt__EventSubscription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EventSubscription, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__EventSubscription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__EventSubscription ** SOAP_FMAC4 soap_in_PointerTott__EventSubscription(struct soap *soap, const char *tag, struct tt__EventSubscription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__EventSubscription **)soap_malloc(soap, sizeof(struct tt__EventSubscription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__EventSubscription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__EventSubscription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EventSubscription, sizeof(struct tt__EventSubscription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EventSubscription(struct soap *soap, struct tt__EventSubscription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__EventSubscription(soap, tag ? tag : "tt:EventSubscription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EventSubscription ** SOAP_FMAC4 soap_get_PointerTott__EventSubscription(struct soap *soap, struct tt__EventSubscription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EventSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZFilter(struct soap *soap, struct tt__PTZFilter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZFilter))
		soap_serialize_tt__PTZFilter(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZFilter(struct soap *soap, const char *tag, int id, struct tt__PTZFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZFilter, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZFilter ** SOAP_FMAC4 soap_in_PointerTott__PTZFilter(struct soap *soap, const char *tag, struct tt__PTZFilter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZFilter **)soap_malloc(soap, sizeof(struct tt__PTZFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZFilter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZFilter, sizeof(struct tt__PTZFilter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZFilter(struct soap *soap, struct tt__PTZFilter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZFilter(soap, tag ? tag : "tt:PTZFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZFilter ** SOAP_FMAC4 soap_get_PointerTott__PTZFilter(struct soap *soap, struct tt__PTZFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RuleEngineConfiguration(struct soap *soap, struct tt__RuleEngineConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RuleEngineConfiguration))
		soap_serialize_tt__RuleEngineConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RuleEngineConfiguration(struct soap *soap, const char *tag, int id, struct tt__RuleEngineConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RuleEngineConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RuleEngineConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RuleEngineConfiguration ** SOAP_FMAC4 soap_in_PointerTott__RuleEngineConfiguration(struct soap *soap, const char *tag, struct tt__RuleEngineConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RuleEngineConfiguration **)soap_malloc(soap, sizeof(struct tt__RuleEngineConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RuleEngineConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RuleEngineConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RuleEngineConfiguration, sizeof(struct tt__RuleEngineConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RuleEngineConfiguration(struct soap *soap, struct tt__RuleEngineConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RuleEngineConfiguration(soap, tag ? tag : "tt:RuleEngineConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RuleEngineConfiguration ** SOAP_FMAC4 soap_get_PointerTott__RuleEngineConfiguration(struct soap *soap, struct tt__RuleEngineConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RuleEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, struct tt__AnalyticsEngineConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsEngineConfiguration))
		soap_serialize_tt__AnalyticsEngineConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, const char *tag, int id, struct tt__AnalyticsEngineConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsEngineConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsEngineConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsEngineConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, const char *tag, struct tt__AnalyticsEngineConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsEngineConfiguration **)soap_malloc(soap, sizeof(struct tt__AnalyticsEngineConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsEngineConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineConfiguration, sizeof(struct tt__AnalyticsEngineConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, struct tt__AnalyticsEngineConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsEngineConfiguration(soap, tag ? tag : "tt:AnalyticsEngineConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, struct tt__AnalyticsEngineConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoRateControl2(struct soap *soap, struct tt__VideoRateControl2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoRateControl2))
		soap_serialize_tt__VideoRateControl2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoRateControl2(struct soap *soap, const char *tag, int id, struct tt__VideoRateControl2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoRateControl2, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoRateControl2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoRateControl2 ** SOAP_FMAC4 soap_in_PointerTott__VideoRateControl2(struct soap *soap, const char *tag, struct tt__VideoRateControl2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoRateControl2 **)soap_malloc(soap, sizeof(struct tt__VideoRateControl2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoRateControl2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoRateControl2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoRateControl2, sizeof(struct tt__VideoRateControl2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoRateControl2(struct soap *soap, struct tt__VideoRateControl2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoRateControl2(soap, tag ? tag : "tt:VideoRateControl2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoRateControl2 ** SOAP_FMAC4 soap_get_PointerTott__VideoRateControl2(struct soap *soap, struct tt__VideoRateControl2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoRateControl2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MulticastConfiguration(struct soap *soap, struct tt__MulticastConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MulticastConfiguration))
		soap_serialize_tt__MulticastConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MulticastConfiguration(struct soap *soap, const char *tag, int id, struct tt__MulticastConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MulticastConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MulticastConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MulticastConfiguration ** SOAP_FMAC4 soap_in_PointerTott__MulticastConfiguration(struct soap *soap, const char *tag, struct tt__MulticastConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MulticastConfiguration **)soap_malloc(soap, sizeof(struct tt__MulticastConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MulticastConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MulticastConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MulticastConfiguration, sizeof(struct tt__MulticastConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MulticastConfiguration(struct soap *soap, struct tt__MulticastConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MulticastConfiguration(soap, tag ? tag : "tt:MulticastConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MulticastConfiguration ** SOAP_FMAC4 soap_get_PointerTott__MulticastConfiguration(struct soap *soap, struct tt__MulticastConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MulticastConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__H264Configuration(struct soap *soap, struct tt__H264Configuration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__H264Configuration))
		soap_serialize_tt__H264Configuration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__H264Configuration(struct soap *soap, const char *tag, int id, struct tt__H264Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__H264Configuration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__H264Configuration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__H264Configuration ** SOAP_FMAC4 soap_in_PointerTott__H264Configuration(struct soap *soap, const char *tag, struct tt__H264Configuration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__H264Configuration **)soap_malloc(soap, sizeof(struct tt__H264Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__H264Configuration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__H264Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__H264Configuration, sizeof(struct tt__H264Configuration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__H264Configuration(struct soap *soap, struct tt__H264Configuration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__H264Configuration(soap, tag ? tag : "tt:H264Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__H264Configuration ** SOAP_FMAC4 soap_get_PointerTott__H264Configuration(struct soap *soap, struct tt__H264Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__H264Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Mpeg4Configuration(struct soap *soap, struct tt__Mpeg4Configuration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Mpeg4Configuration))
		soap_serialize_tt__Mpeg4Configuration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Mpeg4Configuration(struct soap *soap, const char *tag, int id, struct tt__Mpeg4Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Mpeg4Configuration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Mpeg4Configuration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Mpeg4Configuration ** SOAP_FMAC4 soap_in_PointerTott__Mpeg4Configuration(struct soap *soap, const char *tag, struct tt__Mpeg4Configuration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Mpeg4Configuration **)soap_malloc(soap, sizeof(struct tt__Mpeg4Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Mpeg4Configuration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Mpeg4Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Mpeg4Configuration, sizeof(struct tt__Mpeg4Configuration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Mpeg4Configuration(struct soap *soap, struct tt__Mpeg4Configuration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Mpeg4Configuration(soap, tag ? tag : "tt:Mpeg4Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Mpeg4Configuration ** SOAP_FMAC4 soap_get_PointerTott__Mpeg4Configuration(struct soap *soap, struct tt__Mpeg4Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Mpeg4Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoRateControl(struct soap *soap, struct tt__VideoRateControl *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoRateControl))
		soap_serialize_tt__VideoRateControl(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoRateControl(struct soap *soap, const char *tag, int id, struct tt__VideoRateControl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoRateControl, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoRateControl(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoRateControl ** SOAP_FMAC4 soap_in_PointerTott__VideoRateControl(struct soap *soap, const char *tag, struct tt__VideoRateControl **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoRateControl **)soap_malloc(soap, sizeof(struct tt__VideoRateControl *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoRateControl(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoRateControl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoRateControl, sizeof(struct tt__VideoRateControl), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoRateControl(struct soap *soap, struct tt__VideoRateControl *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoRateControl(soap, tag ? tag : "tt:VideoRateControl", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoRateControl ** SOAP_FMAC4 soap_get_PointerTott__VideoRateControl(struct soap *soap, struct tt__VideoRateControl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoRateControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, struct tt__VideoSourceConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceConfigurationExtension))
		soap_serialize_tt__VideoSourceConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__VideoSourceConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoSourceConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, const char *tag, struct tt__VideoSourceConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoSourceConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__VideoSourceConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoSourceConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfigurationExtension, sizeof(struct tt__VideoSourceConfigurationExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, struct tt__VideoSourceConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoSourceConfigurationExtension(soap, tag ? tag : "tt:VideoSourceConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, struct tt__VideoSourceConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IntRectangle(struct soap *soap, struct tt__IntRectangle *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IntRectangle))
		soap_serialize_tt__IntRectangle(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IntRectangle(struct soap *soap, const char *tag, int id, struct tt__IntRectangle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IntRectangle, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IntRectangle(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IntRectangle ** SOAP_FMAC4 soap_in_PointerTott__IntRectangle(struct soap *soap, const char *tag, struct tt__IntRectangle **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IntRectangle **)soap_malloc(soap, sizeof(struct tt__IntRectangle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IntRectangle(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IntRectangle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntRectangle, sizeof(struct tt__IntRectangle), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IntRectangle(struct soap *soap, struct tt__IntRectangle *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IntRectangle(soap, tag ? tag : "tt:IntRectangle", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IntRectangle ** SOAP_FMAC4 soap_get_PointerTott__IntRectangle(struct soap *soap, struct tt__IntRectangle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IntRectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceExtension(struct soap *soap, struct tt__VideoSourceExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceExtension))
		soap_serialize_tt__VideoSourceExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceExtension(struct soap *soap, const char *tag, int id, struct tt__VideoSourceExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceExtension, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoSourceExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoSourceExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceExtension(struct soap *soap, const char *tag, struct tt__VideoSourceExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoSourceExtension **)soap_malloc(soap, sizeof(struct tt__VideoSourceExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoSourceExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceExtension, sizeof(struct tt__VideoSourceExtension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceExtension(struct soap *soap, struct tt__VideoSourceExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoSourceExtension(soap, tag ? tag : "tt:VideoSourceExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceExtension(struct soap *soap, struct tt__VideoSourceExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettings(struct soap *soap, struct tt__ImagingSettings *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingSettings))
		soap_serialize_tt__ImagingSettings(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettings(struct soap *soap, const char *tag, int id, struct tt__ImagingSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingSettings, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImagingSettings(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImagingSettings ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettings(struct soap *soap, const char *tag, struct tt__ImagingSettings **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImagingSettings **)soap_malloc(soap, sizeof(struct tt__ImagingSettings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImagingSettings(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettings, sizeof(struct tt__ImagingSettings), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettings(struct soap *soap, struct tt__ImagingSettings *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingSettings(soap, tag ? tag : "tt:ImagingSettings", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingSettings ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettings(struct soap *soap, struct tt__ImagingSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons8__Configuration(struct soap *soap, struct ns8__Configuration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns8__Configuration))
		soap_serialize_ns8__Configuration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons8__Configuration(struct soap *soap, const char *tag, int id, struct ns8__Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns8__Configuration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns8__Configuration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns8__Configuration ** SOAP_FMAC4 soap_in_PointerTons8__Configuration(struct soap *soap, const char *tag, struct ns8__Configuration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns8__Configuration **)soap_malloc(soap, sizeof(struct ns8__Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns8__Configuration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns8__Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns8__Configuration, sizeof(struct ns8__Configuration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons8__Configuration(struct soap *soap, struct ns8__Configuration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons8__Configuration(soap, tag ? tag : "ns8:Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__Configuration ** SOAP_FMAC4 soap_get_PointerTons8__Configuration(struct soap *soap, struct ns8__Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons8__Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons8__ConfigurationOptions(struct soap *soap, struct ns8__ConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns8__ConfigurationOptions))
		soap_serialize_ns8__ConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons8__ConfigurationOptions(struct soap *soap, const char *tag, int id, struct ns8__ConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns8__ConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns8__ConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns8__ConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTons8__ConfigurationOptions(struct soap *soap, const char *tag, struct ns8__ConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns8__ConfigurationOptions **)soap_malloc(soap, sizeof(struct ns8__ConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns8__ConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns8__ConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns8__ConfigurationOptions, sizeof(struct ns8__ConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons8__ConfigurationOptions(struct soap *soap, struct ns8__ConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons8__ConfigurationOptions(soap, tag ? tag : "ns8:ConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__ConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTons8__ConfigurationOptions(struct soap *soap, struct ns8__ConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons8__ConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons8__Capabilities(struct soap *soap, struct ns8__Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns8__Capabilities))
		soap_serialize_ns8__Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons8__Capabilities(struct soap *soap, const char *tag, int id, struct ns8__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns8__Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns8__Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns8__Capabilities ** SOAP_FMAC4 soap_in_PointerTons8__Capabilities(struct soap *soap, const char *tag, struct ns8__Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns8__Capabilities **)soap_malloc(soap, sizeof(struct ns8__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns8__Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns8__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns8__Capabilities, sizeof(struct ns8__Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons8__Capabilities(struct soap *soap, struct ns8__Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons8__Capabilities(soap, tag ? tag : "ns8:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__Capabilities ** SOAP_FMAC4 soap_get_PointerTons8__Capabilities(struct soap *soap, struct ns8__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons8__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons8__CoolerOptions(struct soap *soap, struct ns8__CoolerOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns8__CoolerOptions))
		soap_serialize_ns8__CoolerOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons8__CoolerOptions(struct soap *soap, const char *tag, int id, struct ns8__CoolerOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns8__CoolerOptions, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns8__CoolerOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns8__CoolerOptions ** SOAP_FMAC4 soap_in_PointerTons8__CoolerOptions(struct soap *soap, const char *tag, struct ns8__CoolerOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns8__CoolerOptions **)soap_malloc(soap, sizeof(struct ns8__CoolerOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns8__CoolerOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns8__CoolerOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns8__CoolerOptions, sizeof(struct ns8__CoolerOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons8__CoolerOptions(struct soap *soap, struct ns8__CoolerOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons8__CoolerOptions(soap, tag ? tag : "ns8:CoolerOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__CoolerOptions ** SOAP_FMAC4 soap_get_PointerTons8__CoolerOptions(struct soap *soap, struct ns8__CoolerOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons8__CoolerOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons8__Cooler(struct soap *soap, struct ns8__Cooler *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns8__Cooler))
		soap_serialize_ns8__Cooler(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons8__Cooler(struct soap *soap, const char *tag, int id, struct ns8__Cooler *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns8__Cooler, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns8__Cooler(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns8__Cooler ** SOAP_FMAC4 soap_in_PointerTons8__Cooler(struct soap *soap, const char *tag, struct ns8__Cooler **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns8__Cooler **)soap_malloc(soap, sizeof(struct ns8__Cooler *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns8__Cooler(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns8__Cooler **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns8__Cooler, sizeof(struct ns8__Cooler), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons8__Cooler(struct soap *soap, struct ns8__Cooler *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons8__Cooler(soap, tag ? tag : "ns8:Cooler", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__Cooler ** SOAP_FMAC4 soap_get_PointerTons8__Cooler(struct soap *soap, struct ns8__Cooler **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons8__Cooler(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons8__NUCTable(struct soap *soap, struct ns8__NUCTable *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns8__NUCTable))
		soap_serialize_ns8__NUCTable(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons8__NUCTable(struct soap *soap, const char *tag, int id, struct ns8__NUCTable *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns8__NUCTable, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns8__NUCTable(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns8__NUCTable ** SOAP_FMAC4 soap_in_PointerTons8__NUCTable(struct soap *soap, const char *tag, struct ns8__NUCTable **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns8__NUCTable **)soap_malloc(soap, sizeof(struct ns8__NUCTable *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns8__NUCTable(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns8__NUCTable **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns8__NUCTable, sizeof(struct ns8__NUCTable), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons8__NUCTable(struct soap *soap, struct ns8__NUCTable *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons8__NUCTable(soap, tag ? tag : "ns8:NUCTable", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__NUCTable ** SOAP_FMAC4 soap_get_PointerTons8__NUCTable(struct soap *soap, struct ns8__NUCTable **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons8__NUCTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons8__ColorPalette(struct soap *soap, struct ns8__ColorPalette *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns8__ColorPalette))
		soap_serialize_ns8__ColorPalette(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons8__ColorPalette(struct soap *soap, const char *tag, int id, struct ns8__ColorPalette *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns8__ColorPalette, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_ns8__ColorPalette(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns8__ColorPalette ** SOAP_FMAC4 soap_in_PointerTons8__ColorPalette(struct soap *soap, const char *tag, struct ns8__ColorPalette **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns8__ColorPalette **)soap_malloc(soap, sizeof(struct ns8__ColorPalette *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns8__ColorPalette(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns8__ColorPalette **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns8__ColorPalette, sizeof(struct ns8__ColorPalette), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons8__ColorPalette(struct soap *soap, struct ns8__ColorPalette *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons8__ColorPalette(soap, tag ? tag : "ns8:ColorPalette", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__ColorPalette ** SOAP_FMAC4 soap_get_PointerTons8__ColorPalette(struct soap *soap, struct ns8__ColorPalette **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons8__ColorPalette(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FindMetadataResultList(struct soap *soap, struct tt__FindMetadataResultList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FindMetadataResultList))
		soap_serialize_tt__FindMetadataResultList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FindMetadataResultList(struct soap *soap, const char *tag, int id, struct tt__FindMetadataResultList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FindMetadataResultList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FindMetadataResultList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FindMetadataResultList ** SOAP_FMAC4 soap_in_PointerTott__FindMetadataResultList(struct soap *soap, const char *tag, struct tt__FindMetadataResultList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FindMetadataResultList **)soap_malloc(soap, sizeof(struct tt__FindMetadataResultList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FindMetadataResultList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FindMetadataResultList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FindMetadataResultList, sizeof(struct tt__FindMetadataResultList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FindMetadataResultList(struct soap *soap, struct tt__FindMetadataResultList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FindMetadataResultList(soap, tag ? tag : "tt:FindMetadataResultList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindMetadataResultList ** SOAP_FMAC4 soap_get_PointerTott__FindMetadataResultList(struct soap *soap, struct tt__FindMetadataResultList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FindMetadataResultList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataFilter(struct soap *soap, struct tt__MetadataFilter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataFilter))
		soap_serialize_tt__MetadataFilter(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataFilter(struct soap *soap, const char *tag, int id, struct tt__MetadataFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataFilter, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MetadataFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MetadataFilter ** SOAP_FMAC4 soap_in_PointerTott__MetadataFilter(struct soap *soap, const char *tag, struct tt__MetadataFilter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MetadataFilter **)soap_malloc(soap, sizeof(struct tt__MetadataFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MetadataFilter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataFilter, sizeof(struct tt__MetadataFilter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataFilter(struct soap *soap, struct tt__MetadataFilter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MetadataFilter(soap, tag ? tag : "tt:MetadataFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataFilter ** SOAP_FMAC4 soap_get_PointerTott__MetadataFilter(struct soap *soap, struct tt__MetadataFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FindPTZPositionResultList(struct soap *soap, struct tt__FindPTZPositionResultList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FindPTZPositionResultList))
		soap_serialize_tt__FindPTZPositionResultList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FindPTZPositionResultList(struct soap *soap, const char *tag, int id, struct tt__FindPTZPositionResultList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FindPTZPositionResultList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FindPTZPositionResultList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FindPTZPositionResultList ** SOAP_FMAC4 soap_in_PointerTott__FindPTZPositionResultList(struct soap *soap, const char *tag, struct tt__FindPTZPositionResultList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FindPTZPositionResultList **)soap_malloc(soap, sizeof(struct tt__FindPTZPositionResultList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FindPTZPositionResultList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FindPTZPositionResultList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FindPTZPositionResultList, sizeof(struct tt__FindPTZPositionResultList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FindPTZPositionResultList(struct soap *soap, struct tt__FindPTZPositionResultList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FindPTZPositionResultList(soap, tag ? tag : "tt:FindPTZPositionResultList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindPTZPositionResultList ** SOAP_FMAC4 soap_get_PointerTott__FindPTZPositionResultList(struct soap *soap, struct tt__FindPTZPositionResultList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FindPTZPositionResultList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPositionFilter(struct soap *soap, struct tt__PTZPositionFilter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPositionFilter))
		soap_serialize_tt__PTZPositionFilter(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPositionFilter(struct soap *soap, const char *tag, int id, struct tt__PTZPositionFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPositionFilter, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPositionFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPositionFilter ** SOAP_FMAC4 soap_in_PointerTott__PTZPositionFilter(struct soap *soap, const char *tag, struct tt__PTZPositionFilter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPositionFilter **)soap_malloc(soap, sizeof(struct tt__PTZPositionFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPositionFilter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPositionFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPositionFilter, sizeof(struct tt__PTZPositionFilter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPositionFilter(struct soap *soap, struct tt__PTZPositionFilter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPositionFilter(soap, tag ? tag : "tt:PTZPositionFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPositionFilter ** SOAP_FMAC4 soap_get_PointerTott__PTZPositionFilter(struct soap *soap, struct tt__PTZPositionFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPositionFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
