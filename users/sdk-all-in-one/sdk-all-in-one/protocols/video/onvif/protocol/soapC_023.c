/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:59 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__Seek(struct soap *soap, struct _tev__Seek *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->UtcTime);
	a->Reverse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__Seek(struct soap *soap, const struct _tev__Seek *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->UtcTime, SOAP_TYPE_dateTime);
	soap_serialize_PointerToxsd__boolean(soap, &a->Reverse);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__Seek(struct soap *soap, const char *tag, int id, const struct _tev__Seek *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__Seek), type))
		return soap->error;
	if (soap_out_dateTime(soap, "tev:UtcTime", -1, &a->UtcTime, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tev:Reverse", -1, &a->Reverse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__Seek * SOAP_FMAC4 soap_in__tev__Seek(struct soap *soap, const char *tag, struct _tev__Seek *a, const char *type)
{
	size_t soap_flag_UtcTime = 1;
	size_t soap_flag_Reverse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tev__Seek *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__Seek, sizeof(struct _tev__Seek), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__Seek(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UtcTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "tev:UtcTime", &a->UtcTime, "xsd:dateTime"))
				{	soap_flag_UtcTime--;
					continue;
				}
			if (soap_flag_Reverse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "tev:Reverse", &a->Reverse, "xsd:boolean"))
				{	soap_flag_Reverse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_UtcTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tev__Seek *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__Seek, SOAP_TYPE__tev__Seek, sizeof(struct _tev__Seek), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__Seek * SOAP_FMAC4 soap_new__tev__Seek(struct soap *soap, int n)
{
	struct _tev__Seek *p;
	struct _tev__Seek *a = (struct _tev__Seek*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__Seek));
	for (p = a; p && n--; p++)
		soap_default__tev__Seek(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__Seek(struct soap *soap, const struct _tev__Seek *a, const char *tag, const char *type)
{
	if (soap_out__tev__Seek(soap, tag ? tag : "tev:Seek", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__Seek * SOAP_FMAC4 soap_get__tev__Seek(struct soap *soap, struct _tev__Seek *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__Seek(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__PullMessagesFaultResponse(struct soap *soap, struct _tev__PullMessagesFaultResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__duration(soap, &a->MaxTimeout);
	soap_default_int(soap, &a->MaxMessageLimit);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__PullMessagesFaultResponse(struct soap *soap, const struct _tev__PullMessagesFaultResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->MaxTimeout, SOAP_TYPE_xsd__duration);
	soap_embedded(soap, &a->MaxMessageLimit, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__PullMessagesFaultResponse(struct soap *soap, const char *tag, int id, const struct _tev__PullMessagesFaultResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__PullMessagesFaultResponse), type))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tev:MaxTimeout", -1, &a->MaxTimeout, ""))
		return soap->error;
	if (soap_out_int(soap, "tev:MaxMessageLimit", -1, &a->MaxMessageLimit, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__PullMessagesFaultResponse * SOAP_FMAC4 soap_in__tev__PullMessagesFaultResponse(struct soap *soap, const char *tag, struct _tev__PullMessagesFaultResponse *a, const char *type)
{
	size_t soap_flag_MaxTimeout = 1;
	size_t soap_flag_MaxMessageLimit = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tev__PullMessagesFaultResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__PullMessagesFaultResponse, sizeof(struct _tev__PullMessagesFaultResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__PullMessagesFaultResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaxTimeout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tev:MaxTimeout", &a->MaxTimeout, "xsd:duration"))
				{	soap_flag_MaxTimeout--;
					continue;
				}
			if (soap_flag_MaxMessageLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tev:MaxMessageLimit", &a->MaxMessageLimit, "xsd:int"))
				{	soap_flag_MaxMessageLimit--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MaxTimeout > 0 || soap_flag_MaxMessageLimit > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tev__PullMessagesFaultResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__PullMessagesFaultResponse, SOAP_TYPE__tev__PullMessagesFaultResponse, sizeof(struct _tev__PullMessagesFaultResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__PullMessagesFaultResponse * SOAP_FMAC4 soap_new__tev__PullMessagesFaultResponse(struct soap *soap, int n)
{
	struct _tev__PullMessagesFaultResponse *p;
	struct _tev__PullMessagesFaultResponse *a = (struct _tev__PullMessagesFaultResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__PullMessagesFaultResponse));
	for (p = a; p && n--; p++)
		soap_default__tev__PullMessagesFaultResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__PullMessagesFaultResponse(struct soap *soap, const struct _tev__PullMessagesFaultResponse *a, const char *tag, const char *type)
{
	if (soap_out__tev__PullMessagesFaultResponse(soap, tag ? tag : "tev:PullMessagesFaultResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__PullMessagesFaultResponse * SOAP_FMAC4 soap_get__tev__PullMessagesFaultResponse(struct soap *soap, struct _tev__PullMessagesFaultResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__PullMessagesFaultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__PullMessagesResponse(struct soap *soap, struct _tev__PullMessagesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->CurrentTime);
	soap_default_dateTime(soap, &a->TerminationTime);
	a->__sizeNotificationMessage = 0;
	a->wsnt__NotificationMessage = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__PullMessagesResponse(struct soap *soap, const struct _tev__PullMessagesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->CurrentTime, SOAP_TYPE_dateTime);
	soap_embedded(soap, &a->TerminationTime, SOAP_TYPE_dateTime);
	if (a->wsnt__NotificationMessage)
	{	int i;
		for (i = 0; i < (int)a->__sizeNotificationMessage; i++)
		{
			soap_embedded(soap, a->wsnt__NotificationMessage + i, SOAP_TYPE_wsnt__NotificationMessageHolderType);
			soap_serialize_wsnt__NotificationMessageHolderType(soap, a->wsnt__NotificationMessage + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__PullMessagesResponse(struct soap *soap, const char *tag, int id, const struct _tev__PullMessagesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__PullMessagesResponse), type))
		return soap->error;
	soap_element_result(soap, "tev:CurrentTime");
	if (soap_out_dateTime(soap, "tev:CurrentTime", -1, &a->CurrentTime, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "tev:TerminationTime", -1, &a->TerminationTime, ""))
		return soap->error;
	if (a->wsnt__NotificationMessage)
	{	int i;
		for (i = 0; i < (int)a->__sizeNotificationMessage; i++)
			if (soap_out_wsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", -1, a->wsnt__NotificationMessage + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__PullMessagesResponse * SOAP_FMAC4 soap_in__tev__PullMessagesResponse(struct soap *soap, const char *tag, struct _tev__PullMessagesResponse *a, const char *type)
{
	size_t soap_flag_CurrentTime = 1;
	size_t soap_flag_TerminationTime = 1;
	struct soap_blist *soap_blist_wsnt__NotificationMessage = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tev__PullMessagesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__PullMessagesResponse, sizeof(struct _tev__PullMessagesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__PullMessagesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CurrentTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "tev:CurrentTime", &a->CurrentTime, "xsd:dateTime"))
				{	soap_flag_CurrentTime--;
					continue;
				}
			if (soap_flag_TerminationTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "tev:TerminationTime", &a->TerminationTime, "xsd:dateTime"))
				{	soap_flag_TerminationTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:NotificationMessage", 1, NULL))
			{	if (a->wsnt__NotificationMessage == NULL)
				{	if (soap_blist_wsnt__NotificationMessage == NULL)
						soap_blist_wsnt__NotificationMessage = soap_alloc_block(soap);
					a->wsnt__NotificationMessage = (struct wsnt__NotificationMessageHolderType *)soap_push_block_max(soap, soap_blist_wsnt__NotificationMessage, sizeof(struct wsnt__NotificationMessageHolderType));
					if (a->wsnt__NotificationMessage == NULL)
						return NULL;
					soap_default_wsnt__NotificationMessageHolderType(soap, a->wsnt__NotificationMessage);
				}
				soap_revert(soap);
				if (soap_in_wsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", a->wsnt__NotificationMessage, "wsnt:NotificationMessageHolderType"))
				{	a->__sizeNotificationMessage++;
					a->wsnt__NotificationMessage = NULL;
					continue;
				}
			}
			soap_check_result(soap, "tev:CurrentTime");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsnt__NotificationMessage)
			soap_pop_block(soap, soap_blist_wsnt__NotificationMessage);
		if (a->__sizeNotificationMessage)
		{	a->wsnt__NotificationMessage = (struct wsnt__NotificationMessageHolderType *)soap_save_block(soap, soap_blist_wsnt__NotificationMessage, NULL, 1);
		}
		else
		{	a->wsnt__NotificationMessage = NULL;
			if (soap_blist_wsnt__NotificationMessage)
				soap_end_block(soap, soap_blist_wsnt__NotificationMessage);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CurrentTime > 0 || soap_flag_TerminationTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tev__PullMessagesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__PullMessagesResponse, SOAP_TYPE__tev__PullMessagesResponse, sizeof(struct _tev__PullMessagesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__PullMessagesResponse * SOAP_FMAC4 soap_new__tev__PullMessagesResponse(struct soap *soap, int n)
{
	struct _tev__PullMessagesResponse *p;
	struct _tev__PullMessagesResponse *a = (struct _tev__PullMessagesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__PullMessagesResponse));
	for (p = a; p && n--; p++)
		soap_default__tev__PullMessagesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__PullMessagesResponse(struct soap *soap, const struct _tev__PullMessagesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tev__PullMessagesResponse(soap, tag ? tag : "tev:PullMessagesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__PullMessagesResponse * SOAP_FMAC4 soap_get__tev__PullMessagesResponse(struct soap *soap, struct _tev__PullMessagesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__PullMessagesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__PullMessages(struct soap *soap, struct _tev__PullMessages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__duration(soap, &a->Timeout);
	soap_default_int(soap, &a->MessageLimit);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__PullMessages(struct soap *soap, const struct _tev__PullMessages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Timeout, SOAP_TYPE_xsd__duration);
	soap_embedded(soap, &a->MessageLimit, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__PullMessages(struct soap *soap, const char *tag, int id, const struct _tev__PullMessages *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__PullMessages), type))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tev:Timeout", -1, &a->Timeout, ""))
		return soap->error;
	if (soap_out_int(soap, "tev:MessageLimit", -1, &a->MessageLimit, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__PullMessages * SOAP_FMAC4 soap_in__tev__PullMessages(struct soap *soap, const char *tag, struct _tev__PullMessages *a, const char *type)
{
	size_t soap_flag_Timeout = 1;
	size_t soap_flag_MessageLimit = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tev__PullMessages *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__PullMessages, sizeof(struct _tev__PullMessages), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__PullMessages(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timeout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tev:Timeout", &a->Timeout, "xsd:duration"))
				{	soap_flag_Timeout--;
					continue;
				}
			if (soap_flag_MessageLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tev:MessageLimit", &a->MessageLimit, "xsd:int"))
				{	soap_flag_MessageLimit--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timeout > 0 || soap_flag_MessageLimit > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tev__PullMessages *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__PullMessages, SOAP_TYPE__tev__PullMessages, sizeof(struct _tev__PullMessages), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__PullMessages * SOAP_FMAC4 soap_new__tev__PullMessages(struct soap *soap, int n)
{
	struct _tev__PullMessages *p;
	struct _tev__PullMessages *a = (struct _tev__PullMessages*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__PullMessages));
	for (p = a; p && n--; p++)
		soap_default__tev__PullMessages(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__PullMessages(struct soap *soap, const struct _tev__PullMessages *a, const char *tag, const char *type)
{
	if (soap_out__tev__PullMessages(soap, tag ? tag : "tev:PullMessages", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__PullMessages * SOAP_FMAC4 soap_get__tev__PullMessages(struct soap *soap, struct _tev__PullMessages *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__PullMessages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__CreatePullPointSubscriptionResponse(struct soap *soap, struct _tev__CreatePullPointSubscriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
	soap_default_dateTime(soap, &a->wsnt__CurrentTime);
	soap_default_dateTime(soap, &a->wsnt__TerminationTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__CreatePullPointSubscriptionResponse(struct soap *soap, const struct _tev__CreatePullPointSubscriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->SubscriptionReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
	soap_embedded(soap, &a->wsnt__CurrentTime, SOAP_TYPE_dateTime);
	soap_embedded(soap, &a->wsnt__TerminationTime, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__CreatePullPointSubscriptionResponse(struct soap *soap, const char *tag, int id, const struct _tev__CreatePullPointSubscriptionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse), type))
		return soap->error;
	soap_element_result(soap, "tev:SubscriptionReference");
	if (soap_out_wsa5__EndpointReferenceType(soap, "tev:SubscriptionReference", -1, &a->SubscriptionReference, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsnt:CurrentTime", -1, &a->wsnt__CurrentTime, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsnt:TerminationTime", -1, &a->wsnt__TerminationTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscriptionResponse * SOAP_FMAC4 soap_in__tev__CreatePullPointSubscriptionResponse(struct soap *soap, const char *tag, struct _tev__CreatePullPointSubscriptionResponse *a, const char *type)
{
	size_t soap_flag_SubscriptionReference = 1;
	size_t soap_flag_wsnt__CurrentTime = 1;
	size_t soap_flag_wsnt__TerminationTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tev__CreatePullPointSubscriptionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse, sizeof(struct _tev__CreatePullPointSubscriptionResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__CreatePullPointSubscriptionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wsa5__EndpointReferenceType(soap, "tev:SubscriptionReference", &a->SubscriptionReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference--;
					continue;
				}
			if (soap_flag_wsnt__CurrentTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "wsnt:CurrentTime", &a->wsnt__CurrentTime, "xsd:dateTime"))
				{	soap_flag_wsnt__CurrentTime--;
					continue;
				}
			if (soap_flag_wsnt__TerminationTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "wsnt:TerminationTime", &a->wsnt__TerminationTime, "xsd:dateTime"))
				{	soap_flag_wsnt__TerminationTime--;
					continue;
				}
			soap_check_result(soap, "tev:SubscriptionReference");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SubscriptionReference > 0 || soap_flag_wsnt__CurrentTime > 0 || soap_flag_wsnt__TerminationTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tev__CreatePullPointSubscriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse, sizeof(struct _tev__CreatePullPointSubscriptionResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscriptionResponse * SOAP_FMAC4 soap_new__tev__CreatePullPointSubscriptionResponse(struct soap *soap, int n)
{
	struct _tev__CreatePullPointSubscriptionResponse *p;
	struct _tev__CreatePullPointSubscriptionResponse *a = (struct _tev__CreatePullPointSubscriptionResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__CreatePullPointSubscriptionResponse));
	for (p = a; p && n--; p++)
		soap_default__tev__CreatePullPointSubscriptionResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__CreatePullPointSubscriptionResponse(struct soap *soap, const struct _tev__CreatePullPointSubscriptionResponse *a, const char *tag, const char *type)
{
	if (soap_out__tev__CreatePullPointSubscriptionResponse(soap, tag ? tag : "tev:CreatePullPointSubscriptionResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscriptionResponse * SOAP_FMAC4 soap_get__tev__CreatePullPointSubscriptionResponse(struct soap *soap, struct _tev__CreatePullPointSubscriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__CreatePullPointSubscriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, struct _tev__CreatePullPointSubscription_SubscriptionPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, const struct _tev__CreatePullPointSubscription_SubscriptionPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, int id, const struct _tev__CreatePullPointSubscription_SubscriptionPolicy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscription_SubscriptionPolicy * SOAP_FMAC4 soap_in__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, struct _tev__CreatePullPointSubscription_SubscriptionPolicy *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tev__CreatePullPointSubscription_SubscriptionPolicy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy, sizeof(struct _tev__CreatePullPointSubscription_SubscriptionPolicy), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__CreatePullPointSubscription_SubscriptionPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy, sizeof(struct _tev__CreatePullPointSubscription_SubscriptionPolicy), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscription_SubscriptionPolicy * SOAP_FMAC4 soap_new__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, int n)
{
	struct _tev__CreatePullPointSubscription_SubscriptionPolicy *p;
	struct _tev__CreatePullPointSubscription_SubscriptionPolicy *a = (struct _tev__CreatePullPointSubscription_SubscriptionPolicy*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__CreatePullPointSubscription_SubscriptionPolicy));
	for (p = a; p && n--; p++)
		soap_default__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, const struct _tev__CreatePullPointSubscription_SubscriptionPolicy *a, const char *tag, const char *type)
{
	if (soap_out__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, tag ? tag : "tev:CreatePullPointSubscription-SubscriptionPolicy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscription_SubscriptionPolicy * SOAP_FMAC4 soap_get__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, struct _tev__CreatePullPointSubscription_SubscriptionPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__CreatePullPointSubscription(struct soap *soap, struct _tev__CreatePullPointSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Filter = NULL;
	soap_default_wsnt__AbsoluteOrRelativeTimeType(soap, &a->InitialTerminationTime);
	a->SubscriptionPolicy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__CreatePullPointSubscription(struct soap *soap, const struct _tev__CreatePullPointSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsnt__FilterType(soap, &a->Filter);
	soap_serialize_wsnt__AbsoluteOrRelativeTimeType(soap, (char*const*)&a->InitialTerminationTime);
	soap_serialize_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(soap, &a->SubscriptionPolicy);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__CreatePullPointSubscription(struct soap *soap, const char *tag, int id, const struct _tev__CreatePullPointSubscription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__CreatePullPointSubscription), type))
		return soap->error;
	if (soap_out_PointerTowsnt__FilterType(soap, "tev:Filter", -1, &a->Filter, ""))
		return soap->error;
	if (soap_out_wsnt__AbsoluteOrRelativeTimeType(soap, "tev:InitialTerminationTime", -1, (char*const*)&a->InitialTerminationTime, ""))
		return soap->error;
	if (soap_out_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(soap, "tev:SubscriptionPolicy", -1, &a->SubscriptionPolicy, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscription * SOAP_FMAC4 soap_in__tev__CreatePullPointSubscription(struct soap *soap, const char *tag, struct _tev__CreatePullPointSubscription *a, const char *type)
{
	size_t soap_flag_Filter = 1;
	size_t soap_flag_InitialTerminationTime = 1;
	size_t soap_flag_SubscriptionPolicy = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tev__CreatePullPointSubscription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__CreatePullPointSubscription, sizeof(struct _tev__CreatePullPointSubscription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__CreatePullPointSubscription(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Filter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnt__FilterType(soap, "tev:Filter", &a->Filter, "wsnt:FilterType"))
				{	soap_flag_Filter--;
					continue;
				}
			if (soap_flag_InitialTerminationTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wsnt__AbsoluteOrRelativeTimeType(soap, "tev:InitialTerminationTime", (char**)&a->InitialTerminationTime, "wsnt:AbsoluteOrRelativeTimeType"))
				{	soap_flag_InitialTerminationTime--;
					continue;
				}
			if (soap_flag_SubscriptionPolicy && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(soap, "tev:SubscriptionPolicy", &a->SubscriptionPolicy, ""))
				{	soap_flag_SubscriptionPolicy--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__CreatePullPointSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__CreatePullPointSubscription, SOAP_TYPE__tev__CreatePullPointSubscription, sizeof(struct _tev__CreatePullPointSubscription), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscription * SOAP_FMAC4 soap_new__tev__CreatePullPointSubscription(struct soap *soap, int n)
{
	struct _tev__CreatePullPointSubscription *p;
	struct _tev__CreatePullPointSubscription *a = (struct _tev__CreatePullPointSubscription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__CreatePullPointSubscription));
	for (p = a; p && n--; p++)
		soap_default__tev__CreatePullPointSubscription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__CreatePullPointSubscription(struct soap *soap, const struct _tev__CreatePullPointSubscription *a, const char *tag, const char *type)
{
	if (soap_out__tev__CreatePullPointSubscription(soap, tag ? tag : "tev:CreatePullPointSubscription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscription * SOAP_FMAC4 soap_get__tev__CreatePullPointSubscription(struct soap *soap, struct _tev__CreatePullPointSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__CreatePullPointSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__GetServiceCapabilitiesResponse(struct soap *soap, struct _tev__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tev__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotev__Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _tev__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tev:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_nil(soap, "tev:Capabilities"))
			return soap->error;
	}
	else
	if (soap_out_PointerTotev__Capabilities(soap, "tev:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__tev__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tev__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tev__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__GetServiceCapabilitiesResponse, sizeof(struct _tev__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotev__Capabilities(soap, "tev:Capabilities", &a->Capabilities, "tev:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			soap_check_result(soap, "tev:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tev__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__GetServiceCapabilitiesResponse, SOAP_TYPE__tev__GetServiceCapabilitiesResponse, sizeof(struct _tev__GetServiceCapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_new__tev__GetServiceCapabilitiesResponse(struct soap *soap, int n)
{
	struct _tev__GetServiceCapabilitiesResponse *p;
	struct _tev__GetServiceCapabilitiesResponse *a = (struct _tev__GetServiceCapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__GetServiceCapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__tev__GetServiceCapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tev__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tev__GetServiceCapabilitiesResponse(soap, tag ? tag : "tev:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__tev__GetServiceCapabilitiesResponse(struct soap *soap, struct _tev__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__GetServiceCapabilities(struct soap *soap, struct _tev__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__GetServiceCapabilities(struct soap *soap, const struct _tev__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _tev__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__GetServiceCapabilities * SOAP_FMAC4 soap_in__tev__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tev__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tev__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__GetServiceCapabilities, sizeof(struct _tev__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__GetServiceCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__GetServiceCapabilities, SOAP_TYPE__tev__GetServiceCapabilities, sizeof(struct _tev__GetServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tev__GetServiceCapabilities * SOAP_FMAC4 soap_new__tev__GetServiceCapabilities(struct soap *soap, int n)
{
	struct _tev__GetServiceCapabilities *p;
	struct _tev__GetServiceCapabilities *a = (struct _tev__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tev__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default__tev__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__GetServiceCapabilities(struct soap *soap, const struct _tev__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__tev__GetServiceCapabilities(soap, tag ? tag : "tev:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__GetServiceCapabilities * SOAP_FMAC4 soap_get__tev__GetServiceCapabilities(struct soap *soap, struct _tev__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tev__SubscriptionPolicy(struct soap *soap, struct tev__SubscriptionPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ChangedOnly = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tev__SubscriptionPolicy(struct soap *soap, const struct tev__SubscriptionPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tev__SubscriptionPolicy(struct soap *soap, const char *tag, int id, const struct tev__SubscriptionPolicy *a, const char *type)
{
	if (a->ChangedOnly)
		soap_set_attr(soap, "ChangedOnly", soap_xsd__boolean2s(soap, *a->ChangedOnly), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tev__SubscriptionPolicy), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tev__SubscriptionPolicy * SOAP_FMAC4 soap_in_tev__SubscriptionPolicy(struct soap *soap, const char *tag, struct tev__SubscriptionPolicy *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tev__SubscriptionPolicy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tev__SubscriptionPolicy, sizeof(struct tev__SubscriptionPolicy), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tev__SubscriptionPolicy(soap, a);
	{	const char *t = soap_attr_value(soap, "ChangedOnly", 0);
		if (t)
		{
			if (!(a->ChangedOnly = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->ChangedOnly))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tev__SubscriptionPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tev__SubscriptionPolicy, SOAP_TYPE_tev__SubscriptionPolicy, sizeof(struct tev__SubscriptionPolicy), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tev__SubscriptionPolicy * SOAP_FMAC4 soap_new_tev__SubscriptionPolicy(struct soap *soap, int n)
{
	struct tev__SubscriptionPolicy *p;
	struct tev__SubscriptionPolicy *a = (struct tev__SubscriptionPolicy*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tev__SubscriptionPolicy));
	for (p = a; p && n--; p++)
		soap_default_tev__SubscriptionPolicy(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tev__SubscriptionPolicy(struct soap *soap, const struct tev__SubscriptionPolicy *a, const char *tag, const char *type)
{
	if (soap_out_tev__SubscriptionPolicy(soap, tag ? tag : "tev:SubscriptionPolicy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tev__SubscriptionPolicy * SOAP_FMAC4 soap_get_tev__SubscriptionPolicy(struct soap *soap, struct tev__SubscriptionPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in_tev__SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tev__Capabilities(struct soap *soap, struct tev__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->WSSubscriptionPolicySupport = NULL;
	a->WSPullPointSupport = NULL;
	a->WSPausableSubscriptionManagerInterfaceSupport = NULL;
	a->MaxNotificationProducers = NULL;
	a->MaxPullPoints = NULL;
	a->PersistentNotificationStorage = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tev__Capabilities(struct soap *soap, const struct tev__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tev__Capabilities(struct soap *soap, const char *tag, int id, const struct tev__Capabilities *a, const char *type)
{
	if (a->WSSubscriptionPolicySupport)
		soap_set_attr(soap, "WSSubscriptionPolicySupport", soap_xsd__boolean2s(soap, *a->WSSubscriptionPolicySupport), 1);
	if (a->WSPullPointSupport)
		soap_set_attr(soap, "WSPullPointSupport", soap_xsd__boolean2s(soap, *a->WSPullPointSupport), 1);
	if (a->WSPausableSubscriptionManagerInterfaceSupport)
		soap_set_attr(soap, "WSPausableSubscriptionManagerInterfaceSupport", soap_xsd__boolean2s(soap, *a->WSPausableSubscriptionManagerInterfaceSupport), 1);
	if (a->MaxNotificationProducers)
		soap_set_attr(soap, "MaxNotificationProducers", soap_int2s(soap, *a->MaxNotificationProducers), 1);
	if (a->MaxPullPoints)
		soap_set_attr(soap, "MaxPullPoints", soap_int2s(soap, *a->MaxPullPoints), 1);
	if (a->PersistentNotificationStorage)
		soap_set_attr(soap, "PersistentNotificationStorage", soap_xsd__boolean2s(soap, *a->PersistentNotificationStorage), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tev__Capabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tev__Capabilities * SOAP_FMAC4 soap_in_tev__Capabilities(struct soap *soap, const char *tag, struct tev__Capabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tev__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tev__Capabilities, sizeof(struct tev__Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tev__Capabilities(soap, a);
	{	const char *t = soap_attr_value(soap, "WSSubscriptionPolicySupport", 0);
		if (t)
		{
			if (!(a->WSSubscriptionPolicySupport = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->WSSubscriptionPolicySupport))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "WSPullPointSupport", 0);
		if (t)
		{
			if (!(a->WSPullPointSupport = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->WSPullPointSupport))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "WSPausableSubscriptionManagerInterfaceSupport", 0);
		if (t)
		{
			if (!(a->WSPausableSubscriptionManagerInterfaceSupport = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->WSPausableSubscriptionManagerInterfaceSupport))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "MaxNotificationProducers", 0);
		if (t)
		{
			if (!(a->MaxNotificationProducers = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->MaxNotificationProducers))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "MaxPullPoints", 0);
		if (t)
		{
			if (!(a->MaxPullPoints = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->MaxPullPoints))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "PersistentNotificationStorage", 0);
		if (t)
		{
			if (!(a->PersistentNotificationStorage = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->PersistentNotificationStorage))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tev__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tev__Capabilities, SOAP_TYPE_tev__Capabilities, sizeof(struct tev__Capabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tev__Capabilities * SOAP_FMAC4 soap_new_tev__Capabilities(struct soap *soap, int n)
{
	struct tev__Capabilities *p;
	struct tev__Capabilities *a = (struct tev__Capabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tev__Capabilities));
	for (p = a; p && n--; p++)
		soap_default_tev__Capabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tev__Capabilities(struct soap *soap, const struct tev__Capabilities *a, const char *tag, const char *type)
{
	if (soap_out_tev__Capabilities(soap, tag ? tag : "tev:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tev__Capabilities * SOAP_FMAC4 soap_get_tev__Capabilities(struct soap *soap, struct tev__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tev__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns5__DoubleLockDoorResponse(struct soap *soap, struct _ns5__DoubleLockDoorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns5__DoubleLockDoorResponse(struct soap *soap, const struct _ns5__DoubleLockDoorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__DoubleLockDoorResponse(struct soap *soap, const char *tag, int id, const struct _ns5__DoubleLockDoorResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__DoubleLockDoorResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns5__DoubleLockDoorResponse * SOAP_FMAC4 soap_in__ns5__DoubleLockDoorResponse(struct soap *soap, const char *tag, struct _ns5__DoubleLockDoorResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns5__DoubleLockDoorResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__DoubleLockDoorResponse, sizeof(struct _ns5__DoubleLockDoorResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns5__DoubleLockDoorResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns5__DoubleLockDoorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__DoubleLockDoorResponse, SOAP_TYPE__ns5__DoubleLockDoorResponse, sizeof(struct _ns5__DoubleLockDoorResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns5__DoubleLockDoorResponse * SOAP_FMAC4 soap_new__ns5__DoubleLockDoorResponse(struct soap *soap, int n)
{
	struct _ns5__DoubleLockDoorResponse *p;
	struct _ns5__DoubleLockDoorResponse *a = (struct _ns5__DoubleLockDoorResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns5__DoubleLockDoorResponse));
	for (p = a; p && n--; p++)
		soap_default__ns5__DoubleLockDoorResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns5__DoubleLockDoorResponse(struct soap *soap, const struct _ns5__DoubleLockDoorResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns5__DoubleLockDoorResponse(soap, tag ? tag : "ns5:DoubleLockDoorResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__DoubleLockDoorResponse * SOAP_FMAC4 soap_get__ns5__DoubleLockDoorResponse(struct soap *soap, struct _ns5__DoubleLockDoorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__DoubleLockDoorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns5__DoubleLockDoor(struct soap *soap, struct _ns5__DoubleLockDoor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns5__DoubleLockDoor(struct soap *soap, const struct _ns5__DoubleLockDoor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__ReferenceToken(soap, (char*const*)&a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__DoubleLockDoor(struct soap *soap, const char *tag, int id, const struct _ns5__DoubleLockDoor *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__DoubleLockDoor), type))
		return soap->error;
	if (!a->Token)
	{	if (soap_element_nil(soap, "ns5:Token"))
			return soap->error;
	}
	else
	if (soap_out_ns2__ReferenceToken(soap, "ns5:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns5__DoubleLockDoor * SOAP_FMAC4 soap_in__ns5__DoubleLockDoor(struct soap *soap, const char *tag, struct _ns5__DoubleLockDoor *a, const char *type)
{
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns5__DoubleLockDoor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__DoubleLockDoor, sizeof(struct _ns5__DoubleLockDoor), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns5__DoubleLockDoor(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns5:Token", (char**)&a->Token, "ns2:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns5__DoubleLockDoor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__DoubleLockDoor, SOAP_TYPE__ns5__DoubleLockDoor, sizeof(struct _ns5__DoubleLockDoor), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns5__DoubleLockDoor * SOAP_FMAC4 soap_new__ns5__DoubleLockDoor(struct soap *soap, int n)
{
	struct _ns5__DoubleLockDoor *p;
	struct _ns5__DoubleLockDoor *a = (struct _ns5__DoubleLockDoor*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns5__DoubleLockDoor));
	for (p = a; p && n--; p++)
		soap_default__ns5__DoubleLockDoor(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns5__DoubleLockDoor(struct soap *soap, const struct _ns5__DoubleLockDoor *a, const char *tag, const char *type)
{
	if (soap_out__ns5__DoubleLockDoor(soap, tag ? tag : "ns5:DoubleLockDoor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__DoubleLockDoor * SOAP_FMAC4 soap_get__ns5__DoubleLockDoor(struct soap *soap, struct _ns5__DoubleLockDoor *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__DoubleLockDoor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns5__LockOpenReleaseDoorResponse(struct soap *soap, struct _ns5__LockOpenReleaseDoorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns5__LockOpenReleaseDoorResponse(struct soap *soap, const struct _ns5__LockOpenReleaseDoorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__LockOpenReleaseDoorResponse(struct soap *soap, const char *tag, int id, const struct _ns5__LockOpenReleaseDoorResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__LockOpenReleaseDoorResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns5__LockOpenReleaseDoorResponse * SOAP_FMAC4 soap_in__ns5__LockOpenReleaseDoorResponse(struct soap *soap, const char *tag, struct _ns5__LockOpenReleaseDoorResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns5__LockOpenReleaseDoorResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__LockOpenReleaseDoorResponse, sizeof(struct _ns5__LockOpenReleaseDoorResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns5__LockOpenReleaseDoorResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns5__LockOpenReleaseDoorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__LockOpenReleaseDoorResponse, SOAP_TYPE__ns5__LockOpenReleaseDoorResponse, sizeof(struct _ns5__LockOpenReleaseDoorResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns5__LockOpenReleaseDoorResponse * SOAP_FMAC4 soap_new__ns5__LockOpenReleaseDoorResponse(struct soap *soap, int n)
{
	struct _ns5__LockOpenReleaseDoorResponse *p;
	struct _ns5__LockOpenReleaseDoorResponse *a = (struct _ns5__LockOpenReleaseDoorResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns5__LockOpenReleaseDoorResponse));
	for (p = a; p && n--; p++)
		soap_default__ns5__LockOpenReleaseDoorResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns5__LockOpenReleaseDoorResponse(struct soap *soap, const struct _ns5__LockOpenReleaseDoorResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns5__LockOpenReleaseDoorResponse(soap, tag ? tag : "ns5:LockOpenReleaseDoorResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__LockOpenReleaseDoorResponse * SOAP_FMAC4 soap_get__ns5__LockOpenReleaseDoorResponse(struct soap *soap, struct _ns5__LockOpenReleaseDoorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__LockOpenReleaseDoorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns5__LockOpenReleaseDoor(struct soap *soap, struct _ns5__LockOpenReleaseDoor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns5__LockOpenReleaseDoor(struct soap *soap, const struct _ns5__LockOpenReleaseDoor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__ReferenceToken(soap, (char*const*)&a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__LockOpenReleaseDoor(struct soap *soap, const char *tag, int id, const struct _ns5__LockOpenReleaseDoor *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__LockOpenReleaseDoor), type))
		return soap->error;
	if (!a->Token)
	{	if (soap_element_nil(soap, "ns5:Token"))
			return soap->error;
	}
	else
	if (soap_out_ns2__ReferenceToken(soap, "ns5:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns5__LockOpenReleaseDoor * SOAP_FMAC4 soap_in__ns5__LockOpenReleaseDoor(struct soap *soap, const char *tag, struct _ns5__LockOpenReleaseDoor *a, const char *type)
{
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns5__LockOpenReleaseDoor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__LockOpenReleaseDoor, sizeof(struct _ns5__LockOpenReleaseDoor), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns5__LockOpenReleaseDoor(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns5:Token", (char**)&a->Token, "ns2:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns5__LockOpenReleaseDoor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__LockOpenReleaseDoor, SOAP_TYPE__ns5__LockOpenReleaseDoor, sizeof(struct _ns5__LockOpenReleaseDoor), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns5__LockOpenReleaseDoor * SOAP_FMAC4 soap_new__ns5__LockOpenReleaseDoor(struct soap *soap, int n)
{
	struct _ns5__LockOpenReleaseDoor *p;
	struct _ns5__LockOpenReleaseDoor *a = (struct _ns5__LockOpenReleaseDoor*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns5__LockOpenReleaseDoor));
	for (p = a; p && n--; p++)
		soap_default__ns5__LockOpenReleaseDoor(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns5__LockOpenReleaseDoor(struct soap *soap, const struct _ns5__LockOpenReleaseDoor *a, const char *tag, const char *type)
{
	if (soap_out__ns5__LockOpenReleaseDoor(soap, tag ? tag : "ns5:LockOpenReleaseDoor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__LockOpenReleaseDoor * SOAP_FMAC4 soap_get__ns5__LockOpenReleaseDoor(struct soap *soap, struct _ns5__LockOpenReleaseDoor *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__LockOpenReleaseDoor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns5__LockOpenDoorResponse(struct soap *soap, struct _ns5__LockOpenDoorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns5__LockOpenDoorResponse(struct soap *soap, const struct _ns5__LockOpenDoorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__LockOpenDoorResponse(struct soap *soap, const char *tag, int id, const struct _ns5__LockOpenDoorResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__LockOpenDoorResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns5__LockOpenDoorResponse * SOAP_FMAC4 soap_in__ns5__LockOpenDoorResponse(struct soap *soap, const char *tag, struct _ns5__LockOpenDoorResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns5__LockOpenDoorResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__LockOpenDoorResponse, sizeof(struct _ns5__LockOpenDoorResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns5__LockOpenDoorResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns5__LockOpenDoorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__LockOpenDoorResponse, SOAP_TYPE__ns5__LockOpenDoorResponse, sizeof(struct _ns5__LockOpenDoorResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns5__LockOpenDoorResponse * SOAP_FMAC4 soap_new__ns5__LockOpenDoorResponse(struct soap *soap, int n)
{
	struct _ns5__LockOpenDoorResponse *p;
	struct _ns5__LockOpenDoorResponse *a = (struct _ns5__LockOpenDoorResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns5__LockOpenDoorResponse));
	for (p = a; p && n--; p++)
		soap_default__ns5__LockOpenDoorResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns5__LockOpenDoorResponse(struct soap *soap, const struct _ns5__LockOpenDoorResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns5__LockOpenDoorResponse(soap, tag ? tag : "ns5:LockOpenDoorResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__LockOpenDoorResponse * SOAP_FMAC4 soap_get__ns5__LockOpenDoorResponse(struct soap *soap, struct _ns5__LockOpenDoorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__LockOpenDoorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns5__LockOpenDoor(struct soap *soap, struct _ns5__LockOpenDoor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns5__LockOpenDoor(struct soap *soap, const struct _ns5__LockOpenDoor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__ReferenceToken(soap, (char*const*)&a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__LockOpenDoor(struct soap *soap, const char *tag, int id, const struct _ns5__LockOpenDoor *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__LockOpenDoor), type))
		return soap->error;
	if (!a->Token)
	{	if (soap_element_nil(soap, "ns5:Token"))
			return soap->error;
	}
	else
	if (soap_out_ns2__ReferenceToken(soap, "ns5:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns5__LockOpenDoor * SOAP_FMAC4 soap_in__ns5__LockOpenDoor(struct soap *soap, const char *tag, struct _ns5__LockOpenDoor *a, const char *type)
{
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns5__LockOpenDoor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__LockOpenDoor, sizeof(struct _ns5__LockOpenDoor), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns5__LockOpenDoor(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns5:Token", (char**)&a->Token, "ns2:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns5__LockOpenDoor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__LockOpenDoor, SOAP_TYPE__ns5__LockOpenDoor, sizeof(struct _ns5__LockOpenDoor), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns5__LockOpenDoor * SOAP_FMAC4 soap_new__ns5__LockOpenDoor(struct soap *soap, int n)
{
	struct _ns5__LockOpenDoor *p;
	struct _ns5__LockOpenDoor *a = (struct _ns5__LockOpenDoor*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns5__LockOpenDoor));
	for (p = a; p && n--; p++)
		soap_default__ns5__LockOpenDoor(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns5__LockOpenDoor(struct soap *soap, const struct _ns5__LockOpenDoor *a, const char *tag, const char *type)
{
	if (soap_out__ns5__LockOpenDoor(soap, tag ? tag : "ns5:LockOpenDoor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__LockOpenDoor * SOAP_FMAC4 soap_get__ns5__LockOpenDoor(struct soap *soap, struct _ns5__LockOpenDoor *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__LockOpenDoor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns5__LockDownReleaseDoorResponse(struct soap *soap, struct _ns5__LockDownReleaseDoorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns5__LockDownReleaseDoorResponse(struct soap *soap, const struct _ns5__LockDownReleaseDoorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__LockDownReleaseDoorResponse(struct soap *soap, const char *tag, int id, const struct _ns5__LockDownReleaseDoorResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__LockDownReleaseDoorResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns5__LockDownReleaseDoorResponse * SOAP_FMAC4 soap_in__ns5__LockDownReleaseDoorResponse(struct soap *soap, const char *tag, struct _ns5__LockDownReleaseDoorResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns5__LockDownReleaseDoorResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__LockDownReleaseDoorResponse, sizeof(struct _ns5__LockDownReleaseDoorResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns5__LockDownReleaseDoorResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns5__LockDownReleaseDoorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__LockDownReleaseDoorResponse, SOAP_TYPE__ns5__LockDownReleaseDoorResponse, sizeof(struct _ns5__LockDownReleaseDoorResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns5__LockDownReleaseDoorResponse * SOAP_FMAC4 soap_new__ns5__LockDownReleaseDoorResponse(struct soap *soap, int n)
{
	struct _ns5__LockDownReleaseDoorResponse *p;
	struct _ns5__LockDownReleaseDoorResponse *a = (struct _ns5__LockDownReleaseDoorResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns5__LockDownReleaseDoorResponse));
	for (p = a; p && n--; p++)
		soap_default__ns5__LockDownReleaseDoorResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns5__LockDownReleaseDoorResponse(struct soap *soap, const struct _ns5__LockDownReleaseDoorResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns5__LockDownReleaseDoorResponse(soap, tag ? tag : "ns5:LockDownReleaseDoorResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__LockDownReleaseDoorResponse * SOAP_FMAC4 soap_get__ns5__LockDownReleaseDoorResponse(struct soap *soap, struct _ns5__LockDownReleaseDoorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__LockDownReleaseDoorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns5__LockDownReleaseDoor(struct soap *soap, struct _ns5__LockDownReleaseDoor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns5__LockDownReleaseDoor(struct soap *soap, const struct _ns5__LockDownReleaseDoor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__ReferenceToken(soap, (char*const*)&a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__LockDownReleaseDoor(struct soap *soap, const char *tag, int id, const struct _ns5__LockDownReleaseDoor *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__LockDownReleaseDoor), type))
		return soap->error;
	if (!a->Token)
	{	if (soap_element_nil(soap, "ns5:Token"))
			return soap->error;
	}
	else
	if (soap_out_ns2__ReferenceToken(soap, "ns5:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns5__LockDownReleaseDoor * SOAP_FMAC4 soap_in__ns5__LockDownReleaseDoor(struct soap *soap, const char *tag, struct _ns5__LockDownReleaseDoor *a, const char *type)
{
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns5__LockDownReleaseDoor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__LockDownReleaseDoor, sizeof(struct _ns5__LockDownReleaseDoor), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns5__LockDownReleaseDoor(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns5:Token", (char**)&a->Token, "ns2:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns5__LockDownReleaseDoor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__LockDownReleaseDoor, SOAP_TYPE__ns5__LockDownReleaseDoor, sizeof(struct _ns5__LockDownReleaseDoor), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns5__LockDownReleaseDoor * SOAP_FMAC4 soap_new__ns5__LockDownReleaseDoor(struct soap *soap, int n)
{
	struct _ns5__LockDownReleaseDoor *p;
	struct _ns5__LockDownReleaseDoor *a = (struct _ns5__LockDownReleaseDoor*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns5__LockDownReleaseDoor));
	for (p = a; p && n--; p++)
		soap_default__ns5__LockDownReleaseDoor(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns5__LockDownReleaseDoor(struct soap *soap, const struct _ns5__LockDownReleaseDoor *a, const char *tag, const char *type)
{
	if (soap_out__ns5__LockDownReleaseDoor(soap, tag ? tag : "ns5:LockDownReleaseDoor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__LockDownReleaseDoor * SOAP_FMAC4 soap_get__ns5__LockDownReleaseDoor(struct soap *soap, struct _ns5__LockDownReleaseDoor *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__LockDownReleaseDoor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns5__LockDownDoorResponse(struct soap *soap, struct _ns5__LockDownDoorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns5__LockDownDoorResponse(struct soap *soap, const struct _ns5__LockDownDoorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__LockDownDoorResponse(struct soap *soap, const char *tag, int id, const struct _ns5__LockDownDoorResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__LockDownDoorResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns5__LockDownDoorResponse * SOAP_FMAC4 soap_in__ns5__LockDownDoorResponse(struct soap *soap, const char *tag, struct _ns5__LockDownDoorResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns5__LockDownDoorResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__LockDownDoorResponse, sizeof(struct _ns5__LockDownDoorResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns5__LockDownDoorResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns5__LockDownDoorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__LockDownDoorResponse, SOAP_TYPE__ns5__LockDownDoorResponse, sizeof(struct _ns5__LockDownDoorResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns5__LockDownDoorResponse * SOAP_FMAC4 soap_new__ns5__LockDownDoorResponse(struct soap *soap, int n)
{
	struct _ns5__LockDownDoorResponse *p;
	struct _ns5__LockDownDoorResponse *a = (struct _ns5__LockDownDoorResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns5__LockDownDoorResponse));
	for (p = a; p && n--; p++)
		soap_default__ns5__LockDownDoorResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns5__LockDownDoorResponse(struct soap *soap, const struct _ns5__LockDownDoorResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns5__LockDownDoorResponse(soap, tag ? tag : "ns5:LockDownDoorResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__LockDownDoorResponse * SOAP_FMAC4 soap_get__ns5__LockDownDoorResponse(struct soap *soap, struct _ns5__LockDownDoorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__LockDownDoorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns5__LockDownDoor(struct soap *soap, struct _ns5__LockDownDoor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns5__LockDownDoor(struct soap *soap, const struct _ns5__LockDownDoor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__ReferenceToken(soap, (char*const*)&a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__LockDownDoor(struct soap *soap, const char *tag, int id, const struct _ns5__LockDownDoor *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__LockDownDoor), type))
		return soap->error;
	if (!a->Token)
	{	if (soap_element_nil(soap, "ns5:Token"))
			return soap->error;
	}
	else
	if (soap_out_ns2__ReferenceToken(soap, "ns5:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns5__LockDownDoor * SOAP_FMAC4 soap_in__ns5__LockDownDoor(struct soap *soap, const char *tag, struct _ns5__LockDownDoor *a, const char *type)
{
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns5__LockDownDoor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__LockDownDoor, sizeof(struct _ns5__LockDownDoor), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns5__LockDownDoor(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns5:Token", (char**)&a->Token, "ns2:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns5__LockDownDoor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__LockDownDoor, SOAP_TYPE__ns5__LockDownDoor, sizeof(struct _ns5__LockDownDoor), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns5__LockDownDoor * SOAP_FMAC4 soap_new__ns5__LockDownDoor(struct soap *soap, int n)
{
	struct _ns5__LockDownDoor *p;
	struct _ns5__LockDownDoor *a = (struct _ns5__LockDownDoor*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns5__LockDownDoor));
	for (p = a; p && n--; p++)
		soap_default__ns5__LockDownDoor(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns5__LockDownDoor(struct soap *soap, const struct _ns5__LockDownDoor *a, const char *tag, const char *type)
{
	if (soap_out__ns5__LockDownDoor(soap, tag ? tag : "ns5:LockDownDoor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__LockDownDoor * SOAP_FMAC4 soap_get__ns5__LockDownDoor(struct soap *soap, struct _ns5__LockDownDoor *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__LockDownDoor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns5__BlockDoorResponse(struct soap *soap, struct _ns5__BlockDoorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns5__BlockDoorResponse(struct soap *soap, const struct _ns5__BlockDoorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__BlockDoorResponse(struct soap *soap, const char *tag, int id, const struct _ns5__BlockDoorResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__BlockDoorResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns5__BlockDoorResponse * SOAP_FMAC4 soap_in__ns5__BlockDoorResponse(struct soap *soap, const char *tag, struct _ns5__BlockDoorResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns5__BlockDoorResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__BlockDoorResponse, sizeof(struct _ns5__BlockDoorResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns5__BlockDoorResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns5__BlockDoorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__BlockDoorResponse, SOAP_TYPE__ns5__BlockDoorResponse, sizeof(struct _ns5__BlockDoorResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns5__BlockDoorResponse * SOAP_FMAC4 soap_new__ns5__BlockDoorResponse(struct soap *soap, int n)
{
	struct _ns5__BlockDoorResponse *p;
	struct _ns5__BlockDoorResponse *a = (struct _ns5__BlockDoorResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns5__BlockDoorResponse));
	for (p = a; p && n--; p++)
		soap_default__ns5__BlockDoorResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns5__BlockDoorResponse(struct soap *soap, const struct _ns5__BlockDoorResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns5__BlockDoorResponse(soap, tag ? tag : "ns5:BlockDoorResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__BlockDoorResponse * SOAP_FMAC4 soap_get__ns5__BlockDoorResponse(struct soap *soap, struct _ns5__BlockDoorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__BlockDoorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns5__BlockDoor(struct soap *soap, struct _ns5__BlockDoor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns5__BlockDoor(struct soap *soap, const struct _ns5__BlockDoor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__ReferenceToken(soap, (char*const*)&a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__BlockDoor(struct soap *soap, const char *tag, int id, const struct _ns5__BlockDoor *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__BlockDoor), type))
		return soap->error;
	if (!a->Token)
	{	if (soap_element_nil(soap, "ns5:Token"))
			return soap->error;
	}
	else
	if (soap_out_ns2__ReferenceToken(soap, "ns5:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns5__BlockDoor * SOAP_FMAC4 soap_in__ns5__BlockDoor(struct soap *soap, const char *tag, struct _ns5__BlockDoor *a, const char *type)
{
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns5__BlockDoor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__BlockDoor, sizeof(struct _ns5__BlockDoor), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns5__BlockDoor(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns5:Token", (char**)&a->Token, "ns2:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns5__BlockDoor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__BlockDoor, SOAP_TYPE__ns5__BlockDoor, sizeof(struct _ns5__BlockDoor), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns5__BlockDoor * SOAP_FMAC4 soap_new__ns5__BlockDoor(struct soap *soap, int n)
{
	struct _ns5__BlockDoor *p;
	struct _ns5__BlockDoor *a = (struct _ns5__BlockDoor*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns5__BlockDoor));
	for (p = a; p && n--; p++)
		soap_default__ns5__BlockDoor(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns5__BlockDoor(struct soap *soap, const struct _ns5__BlockDoor *a, const char *tag, const char *type)
{
	if (soap_out__ns5__BlockDoor(soap, tag ? tag : "ns5:BlockDoor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__BlockDoor * SOAP_FMAC4 soap_get__ns5__BlockDoor(struct soap *soap, struct _ns5__BlockDoor *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__BlockDoor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns5__UnlockDoorResponse(struct soap *soap, struct _ns5__UnlockDoorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns5__UnlockDoorResponse(struct soap *soap, const struct _ns5__UnlockDoorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__UnlockDoorResponse(struct soap *soap, const char *tag, int id, const struct _ns5__UnlockDoorResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__UnlockDoorResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns5__UnlockDoorResponse * SOAP_FMAC4 soap_in__ns5__UnlockDoorResponse(struct soap *soap, const char *tag, struct _ns5__UnlockDoorResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns5__UnlockDoorResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__UnlockDoorResponse, sizeof(struct _ns5__UnlockDoorResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns5__UnlockDoorResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns5__UnlockDoorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__UnlockDoorResponse, SOAP_TYPE__ns5__UnlockDoorResponse, sizeof(struct _ns5__UnlockDoorResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns5__UnlockDoorResponse * SOAP_FMAC4 soap_new__ns5__UnlockDoorResponse(struct soap *soap, int n)
{
	struct _ns5__UnlockDoorResponse *p;
	struct _ns5__UnlockDoorResponse *a = (struct _ns5__UnlockDoorResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns5__UnlockDoorResponse));
	for (p = a; p && n--; p++)
		soap_default__ns5__UnlockDoorResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns5__UnlockDoorResponse(struct soap *soap, const struct _ns5__UnlockDoorResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns5__UnlockDoorResponse(soap, tag ? tag : "ns5:UnlockDoorResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__UnlockDoorResponse * SOAP_FMAC4 soap_get__ns5__UnlockDoorResponse(struct soap *soap, struct _ns5__UnlockDoorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__UnlockDoorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns5__UnlockDoor(struct soap *soap, struct _ns5__UnlockDoor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns5__UnlockDoor(struct soap *soap, const struct _ns5__UnlockDoor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__ReferenceToken(soap, (char*const*)&a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__UnlockDoor(struct soap *soap, const char *tag, int id, const struct _ns5__UnlockDoor *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__UnlockDoor), type))
		return soap->error;
	if (!a->Token)
	{	if (soap_element_nil(soap, "ns5:Token"))
			return soap->error;
	}
	else
	if (soap_out_ns2__ReferenceToken(soap, "ns5:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns5__UnlockDoor * SOAP_FMAC4 soap_in__ns5__UnlockDoor(struct soap *soap, const char *tag, struct _ns5__UnlockDoor *a, const char *type)
{
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns5__UnlockDoor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__UnlockDoor, sizeof(struct _ns5__UnlockDoor), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns5__UnlockDoor(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns5:Token", (char**)&a->Token, "ns2:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns5__UnlockDoor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__UnlockDoor, SOAP_TYPE__ns5__UnlockDoor, sizeof(struct _ns5__UnlockDoor), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns5__UnlockDoor * SOAP_FMAC4 soap_new__ns5__UnlockDoor(struct soap *soap, int n)
{
	struct _ns5__UnlockDoor *p;
	struct _ns5__UnlockDoor *a = (struct _ns5__UnlockDoor*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns5__UnlockDoor));
	for (p = a; p && n--; p++)
		soap_default__ns5__UnlockDoor(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns5__UnlockDoor(struct soap *soap, const struct _ns5__UnlockDoor *a, const char *tag, const char *type)
{
	if (soap_out__ns5__UnlockDoor(soap, tag ? tag : "ns5:UnlockDoor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__UnlockDoor * SOAP_FMAC4 soap_get__ns5__UnlockDoor(struct soap *soap, struct _ns5__UnlockDoor *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__UnlockDoor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns5__LockDoorResponse(struct soap *soap, struct _ns5__LockDoorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns5__LockDoorResponse(struct soap *soap, const struct _ns5__LockDoorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__LockDoorResponse(struct soap *soap, const char *tag, int id, const struct _ns5__LockDoorResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__LockDoorResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns5__LockDoorResponse * SOAP_FMAC4 soap_in__ns5__LockDoorResponse(struct soap *soap, const char *tag, struct _ns5__LockDoorResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns5__LockDoorResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__LockDoorResponse, sizeof(struct _ns5__LockDoorResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns5__LockDoorResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns5__LockDoorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__LockDoorResponse, SOAP_TYPE__ns5__LockDoorResponse, sizeof(struct _ns5__LockDoorResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns5__LockDoorResponse * SOAP_FMAC4 soap_new__ns5__LockDoorResponse(struct soap *soap, int n)
{
	struct _ns5__LockDoorResponse *p;
	struct _ns5__LockDoorResponse *a = (struct _ns5__LockDoorResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns5__LockDoorResponse));
	for (p = a; p && n--; p++)
		soap_default__ns5__LockDoorResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns5__LockDoorResponse(struct soap *soap, const struct _ns5__LockDoorResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns5__LockDoorResponse(soap, tag ? tag : "ns5:LockDoorResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__LockDoorResponse * SOAP_FMAC4 soap_get__ns5__LockDoorResponse(struct soap *soap, struct _ns5__LockDoorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__LockDoorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns5__LockDoor(struct soap *soap, struct _ns5__LockDoor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns5__LockDoor(struct soap *soap, const struct _ns5__LockDoor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__ReferenceToken(soap, (char*const*)&a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__LockDoor(struct soap *soap, const char *tag, int id, const struct _ns5__LockDoor *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__LockDoor), type))
		return soap->error;
	if (!a->Token)
	{	if (soap_element_nil(soap, "ns5:Token"))
			return soap->error;
	}
	else
	if (soap_out_ns2__ReferenceToken(soap, "ns5:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns5__LockDoor * SOAP_FMAC4 soap_in__ns5__LockDoor(struct soap *soap, const char *tag, struct _ns5__LockDoor *a, const char *type)
{
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns5__LockDoor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__LockDoor, sizeof(struct _ns5__LockDoor), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns5__LockDoor(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns5:Token", (char**)&a->Token, "ns2:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns5__LockDoor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__LockDoor, SOAP_TYPE__ns5__LockDoor, sizeof(struct _ns5__LockDoor), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns5__LockDoor * SOAP_FMAC4 soap_new__ns5__LockDoor(struct soap *soap, int n)
{
	struct _ns5__LockDoor *p;
	struct _ns5__LockDoor *a = (struct _ns5__LockDoor*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns5__LockDoor));
	for (p = a; p && n--; p++)
		soap_default__ns5__LockDoor(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns5__LockDoor(struct soap *soap, const struct _ns5__LockDoor *a, const char *tag, const char *type)
{
	if (soap_out__ns5__LockDoor(soap, tag ? tag : "ns5:LockDoor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__LockDoor * SOAP_FMAC4 soap_get__ns5__LockDoor(struct soap *soap, struct _ns5__LockDoor *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__LockDoor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns5__AccessDoorResponse(struct soap *soap, struct _ns5__AccessDoorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns5__AccessDoorResponse(struct soap *soap, const struct _ns5__AccessDoorResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__AccessDoorResponse(struct soap *soap, const char *tag, int id, const struct _ns5__AccessDoorResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__AccessDoorResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns5__AccessDoorResponse * SOAP_FMAC4 soap_in__ns5__AccessDoorResponse(struct soap *soap, const char *tag, struct _ns5__AccessDoorResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns5__AccessDoorResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__AccessDoorResponse, sizeof(struct _ns5__AccessDoorResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns5__AccessDoorResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns5__AccessDoorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__AccessDoorResponse, SOAP_TYPE__ns5__AccessDoorResponse, sizeof(struct _ns5__AccessDoorResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns5__AccessDoorResponse * SOAP_FMAC4 soap_new__ns5__AccessDoorResponse(struct soap *soap, int n)
{
	struct _ns5__AccessDoorResponse *p;
	struct _ns5__AccessDoorResponse *a = (struct _ns5__AccessDoorResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns5__AccessDoorResponse));
	for (p = a; p && n--; p++)
		soap_default__ns5__AccessDoorResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns5__AccessDoorResponse(struct soap *soap, const struct _ns5__AccessDoorResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns5__AccessDoorResponse(soap, tag ? tag : "ns5:AccessDoorResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__AccessDoorResponse * SOAP_FMAC4 soap_get__ns5__AccessDoorResponse(struct soap *soap, struct _ns5__AccessDoorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__AccessDoorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns5__AccessDoor(struct soap *soap, struct _ns5__AccessDoor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->Token);
	a->UseExtendedTime = NULL;
	a->AccessTime = NULL;
	a->OpenTooLongTime = NULL;
	a->PreAlarmTime = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns5__AccessDoor(struct soap *soap, const struct _ns5__AccessDoor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__ReferenceToken(soap, (char*const*)&a->Token);
	soap_serialize_PointerToxsd__boolean(soap, &a->UseExtendedTime);
	soap_serialize_PointerToxsd__duration(soap, &a->AccessTime);
	soap_serialize_PointerToxsd__duration(soap, &a->OpenTooLongTime);
	soap_serialize_PointerToxsd__duration(soap, &a->PreAlarmTime);
	soap_serialize_PointerTons5__AccessDoorExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__AccessDoor(struct soap *soap, const char *tag, int id, const struct _ns5__AccessDoor *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__AccessDoor), type))
		return soap->error;
	if (!a->Token)
	{	if (soap_element_nil(soap, "ns5:Token"))
			return soap->error;
	}
	else
	if (soap_out_ns2__ReferenceToken(soap, "ns5:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns5:UseExtendedTime", -1, &a->UseExtendedTime, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "ns5:AccessTime", -1, &a->AccessTime, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "ns5:OpenTooLongTime", -1, &a->OpenTooLongTime, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "ns5:PreAlarmTime", -1, &a->PreAlarmTime, ""))
		return soap->error;
	if (soap_out_PointerTons5__AccessDoorExtension(soap, "ns5:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns5__AccessDoor * SOAP_FMAC4 soap_in__ns5__AccessDoor(struct soap *soap, const char *tag, struct _ns5__AccessDoor *a, const char *type)
{
	size_t soap_flag_Token = 1;
	size_t soap_flag_UseExtendedTime = 1;
	size_t soap_flag_AccessTime = 1;
	size_t soap_flag_OpenTooLongTime = 1;
	size_t soap_flag_PreAlarmTime = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns5__AccessDoor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__AccessDoor, sizeof(struct _ns5__AccessDoor), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns5__AccessDoor(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns5:Token", (char**)&a->Token, "ns2:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap_flag_UseExtendedTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns5:UseExtendedTime", &a->UseExtendedTime, "xsd:boolean"))
				{	soap_flag_UseExtendedTime--;
					continue;
				}
			if (soap_flag_AccessTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__duration(soap, "ns5:AccessTime", &a->AccessTime, "xsd:duration"))
				{	soap_flag_AccessTime--;
					continue;
				}
			if (soap_flag_OpenTooLongTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__duration(soap, "ns5:OpenTooLongTime", &a->OpenTooLongTime, "xsd:duration"))
				{	soap_flag_OpenTooLongTime--;
					continue;
				}
			if (soap_flag_PreAlarmTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__duration(soap, "ns5:PreAlarmTime", &a->PreAlarmTime, "xsd:duration"))
				{	soap_flag_PreAlarmTime--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__AccessDoorExtension(soap, "ns5:Extension", &a->Extension, "ns5:AccessDoorExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns5__AccessDoor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__AccessDoor, SOAP_TYPE__ns5__AccessDoor, sizeof(struct _ns5__AccessDoor), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns5__AccessDoor * SOAP_FMAC4 soap_new__ns5__AccessDoor(struct soap *soap, int n)
{
	struct _ns5__AccessDoor *p;
	struct _ns5__AccessDoor *a = (struct _ns5__AccessDoor*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns5__AccessDoor));
	for (p = a; p && n--; p++)
		soap_default__ns5__AccessDoor(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns5__AccessDoor(struct soap *soap, const struct _ns5__AccessDoor *a, const char *tag, const char *type)
{
	if (soap_out__ns5__AccessDoor(soap, tag ? tag : "ns5:AccessDoor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__AccessDoor * SOAP_FMAC4 soap_get__ns5__AccessDoor(struct soap *soap, struct _ns5__AccessDoor *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__AccessDoor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns5__GetDoorStateResponse(struct soap *soap, struct _ns5__GetDoorStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DoorState = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns5__GetDoorStateResponse(struct soap *soap, const struct _ns5__GetDoorStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons5__DoorState(soap, &a->DoorState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__GetDoorStateResponse(struct soap *soap, const char *tag, int id, const struct _ns5__GetDoorStateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__GetDoorStateResponse), type))
		return soap->error;
	if (a->DoorState)
		soap_element_result(soap, "ns5:DoorState");
	if (!a->DoorState)
	{	if (soap_element_nil(soap, "ns5:DoorState"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons5__DoorState(soap, "ns5:DoorState", -1, &a->DoorState, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns5__GetDoorStateResponse * SOAP_FMAC4 soap_in__ns5__GetDoorStateResponse(struct soap *soap, const char *tag, struct _ns5__GetDoorStateResponse *a, const char *type)
{
	size_t soap_flag_DoorState = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns5__GetDoorStateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetDoorStateResponse, sizeof(struct _ns5__GetDoorStateResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns5__GetDoorStateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DoorState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__DoorState(soap, "ns5:DoorState", &a->DoorState, "ns5:DoorState"))
				{	soap_flag_DoorState--;
					continue;
				}
			soap_check_result(soap, "ns5:DoorState");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DoorState > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns5__GetDoorStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetDoorStateResponse, SOAP_TYPE__ns5__GetDoorStateResponse, sizeof(struct _ns5__GetDoorStateResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns5__GetDoorStateResponse * SOAP_FMAC4 soap_new__ns5__GetDoorStateResponse(struct soap *soap, int n)
{
	struct _ns5__GetDoorStateResponse *p;
	struct _ns5__GetDoorStateResponse *a = (struct _ns5__GetDoorStateResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns5__GetDoorStateResponse));
	for (p = a; p && n--; p++)
		soap_default__ns5__GetDoorStateResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns5__GetDoorStateResponse(struct soap *soap, const struct _ns5__GetDoorStateResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns5__GetDoorStateResponse(soap, tag ? tag : "ns5:GetDoorStateResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__GetDoorStateResponse * SOAP_FMAC4 soap_get__ns5__GetDoorStateResponse(struct soap *soap, struct _ns5__GetDoorStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__GetDoorStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns5__GetDoorState(struct soap *soap, struct _ns5__GetDoorState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns5__GetDoorState(struct soap *soap, const struct _ns5__GetDoorState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__ReferenceToken(soap, (char*const*)&a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__GetDoorState(struct soap *soap, const char *tag, int id, const struct _ns5__GetDoorState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__GetDoorState), type))
		return soap->error;
	if (!a->Token)
	{	if (soap_element_nil(soap, "ns5:Token"))
			return soap->error;
	}
	else
	if (soap_out_ns2__ReferenceToken(soap, "ns5:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns5__GetDoorState * SOAP_FMAC4 soap_in__ns5__GetDoorState(struct soap *soap, const char *tag, struct _ns5__GetDoorState *a, const char *type)
{
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns5__GetDoorState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetDoorState, sizeof(struct _ns5__GetDoorState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns5__GetDoorState(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns5:Token", (char**)&a->Token, "ns2:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns5__GetDoorState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetDoorState, SOAP_TYPE__ns5__GetDoorState, sizeof(struct _ns5__GetDoorState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns5__GetDoorState * SOAP_FMAC4 soap_new__ns5__GetDoorState(struct soap *soap, int n)
{
	struct _ns5__GetDoorState *p;
	struct _ns5__GetDoorState *a = (struct _ns5__GetDoorState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns5__GetDoorState));
	for (p = a; p && n--; p++)
		soap_default__ns5__GetDoorState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns5__GetDoorState(struct soap *soap, const struct _ns5__GetDoorState *a, const char *tag, const char *type)
{
	if (soap_out__ns5__GetDoorState(soap, tag ? tag : "ns5:GetDoorState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__GetDoorState * SOAP_FMAC4 soap_get__ns5__GetDoorState(struct soap *soap, struct _ns5__GetDoorState *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__GetDoorState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns5__GetDoorInfoResponse(struct soap *soap, struct _ns5__GetDoorInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeDoorInfo = 0;
	a->DoorInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns5__GetDoorInfoResponse(struct soap *soap, const struct _ns5__GetDoorInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->DoorInfo)
	{	int i;
		for (i = 0; i < (int)a->__sizeDoorInfo; i++)
		{
			soap_embedded(soap, a->DoorInfo + i, SOAP_TYPE_ns5__DoorInfo);
			soap_serialize_ns5__DoorInfo(soap, a->DoorInfo + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__GetDoorInfoResponse(struct soap *soap, const char *tag, int id, const struct _ns5__GetDoorInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__GetDoorInfoResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeDoorInfo");
	if (a->DoorInfo)
	{	int i;
		for (i = 0; i < (int)a->__sizeDoorInfo; i++)
			if (soap_out_ns5__DoorInfo(soap, "ns5:DoorInfo", -1, a->DoorInfo + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns5__GetDoorInfoResponse * SOAP_FMAC4 soap_in__ns5__GetDoorInfoResponse(struct soap *soap, const char *tag, struct _ns5__GetDoorInfoResponse *a, const char *type)
{
	struct soap_blist *soap_blist_DoorInfo = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns5__GetDoorInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetDoorInfoResponse, sizeof(struct _ns5__GetDoorInfoResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns5__GetDoorInfoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:DoorInfo", 1, NULL))
			{	if (a->DoorInfo == NULL)
				{	if (soap_blist_DoorInfo == NULL)
						soap_blist_DoorInfo = soap_alloc_block(soap);
					a->DoorInfo = (struct ns5__DoorInfo *)soap_push_block_max(soap, soap_blist_DoorInfo, sizeof(struct ns5__DoorInfo));
					if (a->DoorInfo == NULL)
						return NULL;
					soap_default_ns5__DoorInfo(soap, a->DoorInfo);
				}
				soap_revert(soap);
				if (soap_in_ns5__DoorInfo(soap, "ns5:DoorInfo", a->DoorInfo, "ns5:DoorInfo"))
				{	a->__sizeDoorInfo++;
					a->DoorInfo = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeDoorInfo");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->DoorInfo)
			soap_pop_block(soap, soap_blist_DoorInfo);
		if (a->__sizeDoorInfo)
		{	a->DoorInfo = (struct ns5__DoorInfo *)soap_save_block(soap, soap_blist_DoorInfo, NULL, 1);
		}
		else
		{	a->DoorInfo = NULL;
			if (soap_blist_DoorInfo)
				soap_end_block(soap, soap_blist_DoorInfo);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns5__GetDoorInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetDoorInfoResponse, SOAP_TYPE__ns5__GetDoorInfoResponse, sizeof(struct _ns5__GetDoorInfoResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns5__GetDoorInfoResponse * SOAP_FMAC4 soap_new__ns5__GetDoorInfoResponse(struct soap *soap, int n)
{
	struct _ns5__GetDoorInfoResponse *p;
	struct _ns5__GetDoorInfoResponse *a = (struct _ns5__GetDoorInfoResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns5__GetDoorInfoResponse));
	for (p = a; p && n--; p++)
		soap_default__ns5__GetDoorInfoResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns5__GetDoorInfoResponse(struct soap *soap, const struct _ns5__GetDoorInfoResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns5__GetDoorInfoResponse(soap, tag ? tag : "ns5:GetDoorInfoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__GetDoorInfoResponse * SOAP_FMAC4 soap_get__ns5__GetDoorInfoResponse(struct soap *soap, struct _ns5__GetDoorInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__GetDoorInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns5__GetDoorInfo(struct soap *soap, struct _ns5__GetDoorInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeToken = 0;
	a->Token = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns5__GetDoorInfo(struct soap *soap, const struct _ns5__GetDoorInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Token)
	{	int i;
		for (i = 0; i < (int)a->__sizeToken; i++)
		{
			soap_serialize_ns2__ReferenceToken(soap, (char*const*)(a->Token + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__GetDoorInfo(struct soap *soap, const char *tag, int id, const struct _ns5__GetDoorInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__GetDoorInfo), type))
		return soap->error;
	if (a->Token)
	{	int i;
		for (i = 0; i < (int)a->__sizeToken; i++)
			soap_out_string(soap, "ns5:Token", -1, (char*const*)(a->Token + i), "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns5__GetDoorInfo * SOAP_FMAC4 soap_in__ns5__GetDoorInfo(struct soap *soap, const char *tag, struct _ns5__GetDoorInfo *a, const char *type)
{
	struct soap_blist *soap_blist_Token = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns5__GetDoorInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetDoorInfo, sizeof(struct _ns5__GetDoorInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns5__GetDoorInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:Token", 1, NULL))
			{	if (a->Token == NULL)
				{	if (soap_blist_Token == NULL)
						soap_blist_Token = soap_alloc_block(soap);
					a->Token = (char **)soap_push_block_max(soap, soap_blist_Token, sizeof(char *));
					if (a->Token == NULL)
						return NULL;
					*a->Token = NULL;
				}
				soap_revert(soap);
				if (soap_in_ns2__ReferenceToken(soap, "ns5:Token", (char**)a->Token, "ns2:ReferenceToken"))
				{	a->__sizeToken++;
					a->Token = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Token)
			soap_pop_block(soap, soap_blist_Token);
		if (a->__sizeToken)
		{	a->Token = (char **)soap_save_block(soap, soap_blist_Token, NULL, 1);
		}
		else
		{	a->Token = NULL;
			if (soap_blist_Token)
				soap_end_block(soap, soap_blist_Token);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeToken < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns5__GetDoorInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetDoorInfo, SOAP_TYPE__ns5__GetDoorInfo, sizeof(struct _ns5__GetDoorInfo), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns5__GetDoorInfo * SOAP_FMAC4 soap_new__ns5__GetDoorInfo(struct soap *soap, int n)
{
	struct _ns5__GetDoorInfo *p;
	struct _ns5__GetDoorInfo *a = (struct _ns5__GetDoorInfo*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns5__GetDoorInfo));
	for (p = a; p && n--; p++)
		soap_default__ns5__GetDoorInfo(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns5__GetDoorInfo(struct soap *soap, const struct _ns5__GetDoorInfo *a, const char *tag, const char *type)
{
	if (soap_out__ns5__GetDoorInfo(soap, tag ? tag : "ns5:GetDoorInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__GetDoorInfo * SOAP_FMAC4 soap_get__ns5__GetDoorInfo(struct soap *soap, struct _ns5__GetDoorInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__GetDoorInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__DoorInfo(struct soap *soap, struct ns5__DoorInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->token);
	soap_default_ns2__Name(soap, &a->Name);
	soap_default_ns2__Description(soap, &a->Description);
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns5__DoorInfo(struct soap *soap, const struct ns5__DoorInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__Name(soap, (char*const*)&a->Name);
	soap_serialize_ns2__Description(soap, (char*const*)&a->Description);
	soap_serialize_PointerTons5__DoorCapabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__DoorInfo(struct soap *soap, const char *tag, int id, const struct ns5__DoorInfo *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_ns2__ReferenceToken2s(soap, a->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__DoorInfo), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "ns5:Name"))
			return soap->error;
	}
	else
	if (soap_out_ns2__Name(soap, "ns5:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_ns2__Description(soap, "ns5:Description", -1, (char*const*)&a->Description, ""))
		return soap->error;
	if (!a->Capabilities)
	{	if (soap_element_nil(soap, "ns5:Capabilities"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons5__DoorCapabilities(soap, "ns5:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns5__DoorInfo * SOAP_FMAC4 soap_in_ns5__DoorInfo(struct soap *soap, const char *tag, struct ns5__DoorInfo *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_Description = 1;
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns5__DoorInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__DoorInfo, sizeof(struct ns5__DoorInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns5__DoorInfo(soap, a);
	if (soap_s2ns2__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Name(soap, "ns5:Name", (char**)&a->Name, "ns2:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Description(soap, "ns5:Description", (char**)&a->Description, "ns2:Description"))
				{	soap_flag_Description--;
					continue;
				}
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__DoorCapabilities(soap, "ns5:Capabilities", &a->Capabilities, "ns5:DoorCapabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_Capabilities > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns5__DoorInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__DoorInfo, SOAP_TYPE_ns5__DoorInfo, sizeof(struct ns5__DoorInfo), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns5__DoorInfo * SOAP_FMAC4 soap_new_ns5__DoorInfo(struct soap *soap, int n)
{
	struct ns5__DoorInfo *p;
	struct ns5__DoorInfo *a = (struct ns5__DoorInfo*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns5__DoorInfo));
	for (p = a; p && n--; p++)
		soap_default_ns5__DoorInfo(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__DoorInfo(struct soap *soap, const struct ns5__DoorInfo *a, const char *tag, const char *type)
{
	if (soap_out_ns5__DoorInfo(soap, tag ? tag : "ns5:DoorInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__DoorInfo * SOAP_FMAC4 soap_get_ns5__DoorInfo(struct soap *soap, struct ns5__DoorInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__DoorInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns5__GetDoorInfoListResponse(struct soap *soap, struct _ns5__GetDoorInfoListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->NextStartReference);
	a->__sizeDoorInfo = 0;
	a->DoorInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns5__GetDoorInfoListResponse(struct soap *soap, const struct _ns5__GetDoorInfoListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->NextStartReference);
	if (a->DoorInfo)
	{	int i;
		for (i = 0; i < (int)a->__sizeDoorInfo; i++)
		{
			soap_embedded(soap, a->DoorInfo + i, SOAP_TYPE_ns5__DoorInfo);
			soap_serialize_ns5__DoorInfo(soap, a->DoorInfo + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__GetDoorInfoListResponse(struct soap *soap, const char *tag, int id, const struct _ns5__GetDoorInfoListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__GetDoorInfoListResponse), type))
		return soap->error;
	if (a->NextStartReference)
		soap_element_result(soap, "ns5:NextStartReference");
	if (soap_out_string(soap, "ns5:NextStartReference", -1, (char*const*)&a->NextStartReference, ""))
		return soap->error;
	if (a->DoorInfo)
	{	int i;
		for (i = 0; i < (int)a->__sizeDoorInfo; i++)
			if (soap_out_ns5__DoorInfo(soap, "ns5:DoorInfo", -1, a->DoorInfo + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns5__GetDoorInfoListResponse * SOAP_FMAC4 soap_in__ns5__GetDoorInfoListResponse(struct soap *soap, const char *tag, struct _ns5__GetDoorInfoListResponse *a, const char *type)
{
	size_t soap_flag_NextStartReference = 1;
	struct soap_blist *soap_blist_DoorInfo = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns5__GetDoorInfoListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetDoorInfoListResponse, sizeof(struct _ns5__GetDoorInfoListResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns5__GetDoorInfoListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NextStartReference && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns5:NextStartReference", (char**)&a->NextStartReference, "xsd:string"))
				{	soap_flag_NextStartReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns5:DoorInfo", 1, NULL))
			{	if (a->DoorInfo == NULL)
				{	if (soap_blist_DoorInfo == NULL)
						soap_blist_DoorInfo = soap_alloc_block(soap);
					a->DoorInfo = (struct ns5__DoorInfo *)soap_push_block_max(soap, soap_blist_DoorInfo, sizeof(struct ns5__DoorInfo));
					if (a->DoorInfo == NULL)
						return NULL;
					soap_default_ns5__DoorInfo(soap, a->DoorInfo);
				}
				soap_revert(soap);
				if (soap_in_ns5__DoorInfo(soap, "ns5:DoorInfo", a->DoorInfo, "ns5:DoorInfo"))
				{	a->__sizeDoorInfo++;
					a->DoorInfo = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns5:NextStartReference");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->DoorInfo)
			soap_pop_block(soap, soap_blist_DoorInfo);
		if (a->__sizeDoorInfo)
		{	a->DoorInfo = (struct ns5__DoorInfo *)soap_save_block(soap, soap_blist_DoorInfo, NULL, 1);
		}
		else
		{	a->DoorInfo = NULL;
			if (soap_blist_DoorInfo)
				soap_end_block(soap, soap_blist_DoorInfo);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns5__GetDoorInfoListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetDoorInfoListResponse, SOAP_TYPE__ns5__GetDoorInfoListResponse, sizeof(struct _ns5__GetDoorInfoListResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns5__GetDoorInfoListResponse * SOAP_FMAC4 soap_new__ns5__GetDoorInfoListResponse(struct soap *soap, int n)
{
	struct _ns5__GetDoorInfoListResponse *p;
	struct _ns5__GetDoorInfoListResponse *a = (struct _ns5__GetDoorInfoListResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns5__GetDoorInfoListResponse));
	for (p = a; p && n--; p++)
		soap_default__ns5__GetDoorInfoListResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns5__GetDoorInfoListResponse(struct soap *soap, const struct _ns5__GetDoorInfoListResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns5__GetDoorInfoListResponse(soap, tag ? tag : "ns5:GetDoorInfoListResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__GetDoorInfoListResponse * SOAP_FMAC4 soap_get__ns5__GetDoorInfoListResponse(struct soap *soap, struct _ns5__GetDoorInfoListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__GetDoorInfoListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns5__GetDoorInfoList(struct soap *soap, struct _ns5__GetDoorInfoList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Limit = NULL;
	soap_default_string(soap, &a->StartReference);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns5__GetDoorInfoList(struct soap *soap, const struct _ns5__GetDoorInfoList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->Limit);
	soap_serialize_string(soap, (char*const*)&a->StartReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__GetDoorInfoList(struct soap *soap, const char *tag, int id, const struct _ns5__GetDoorInfoList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__GetDoorInfoList), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns5:Limit", -1, &a->Limit, ""))
		return soap->error;
	if (soap_out_string(soap, "ns5:StartReference", -1, (char*const*)&a->StartReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns5__GetDoorInfoList * SOAP_FMAC4 soap_in__ns5__GetDoorInfoList(struct soap *soap, const char *tag, struct _ns5__GetDoorInfoList *a, const char *type)
{
	size_t soap_flag_Limit = 1;
	size_t soap_flag_StartReference = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns5__GetDoorInfoList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetDoorInfoList, sizeof(struct _ns5__GetDoorInfoList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns5__GetDoorInfoList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Limit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns5:Limit", &a->Limit, "xsd:int"))
				{	soap_flag_Limit--;
					continue;
				}
			if (soap_flag_StartReference && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns5:StartReference", (char**)&a->StartReference, "xsd:string"))
				{	soap_flag_StartReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns5__GetDoorInfoList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetDoorInfoList, SOAP_TYPE__ns5__GetDoorInfoList, sizeof(struct _ns5__GetDoorInfoList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns5__GetDoorInfoList * SOAP_FMAC4 soap_new__ns5__GetDoorInfoList(struct soap *soap, int n)
{
	struct _ns5__GetDoorInfoList *p;
	struct _ns5__GetDoorInfoList *a = (struct _ns5__GetDoorInfoList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns5__GetDoorInfoList));
	for (p = a; p && n--; p++)
		soap_default__ns5__GetDoorInfoList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns5__GetDoorInfoList(struct soap *soap, const struct _ns5__GetDoorInfoList *a, const char *tag, const char *type)
{
	if (soap_out__ns5__GetDoorInfoList(soap, tag ? tag : "ns5:GetDoorInfoList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__GetDoorInfoList * SOAP_FMAC4 soap_get__ns5__GetDoorInfoList(struct soap *soap, struct _ns5__GetDoorInfoList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__GetDoorInfoList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns5__GetServiceCapabilitiesResponse(struct soap *soap, struct _ns5__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns5__GetServiceCapabilitiesResponse(struct soap *soap, const struct _ns5__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons5__ServiceCapabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _ns5__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "ns5:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_nil(soap, "ns5:Capabilities"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons5__ServiceCapabilities(soap, "ns5:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns5__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__ns5__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _ns5__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns5__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetServiceCapabilitiesResponse, sizeof(struct _ns5__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns5__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__ServiceCapabilities(soap, "ns5:Capabilities", &a->Capabilities, "ns5:ServiceCapabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			soap_check_result(soap, "ns5:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns5__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetServiceCapabilitiesResponse, SOAP_TYPE__ns5__GetServiceCapabilitiesResponse, sizeof(struct _ns5__GetServiceCapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns5__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_new__ns5__GetServiceCapabilitiesResponse(struct soap *soap, int n)
{
	struct _ns5__GetServiceCapabilitiesResponse *p;
	struct _ns5__GetServiceCapabilitiesResponse *a = (struct _ns5__GetServiceCapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns5__GetServiceCapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__ns5__GetServiceCapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns5__GetServiceCapabilitiesResponse(struct soap *soap, const struct _ns5__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns5__GetServiceCapabilitiesResponse(soap, tag ? tag : "ns5:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__ns5__GetServiceCapabilitiesResponse(struct soap *soap, struct _ns5__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns5__GetServiceCapabilities(struct soap *soap, struct _ns5__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns5__GetServiceCapabilities(struct soap *soap, const struct _ns5__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns5__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _ns5__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns5__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns5__GetServiceCapabilities * SOAP_FMAC4 soap_in__ns5__GetServiceCapabilities(struct soap *soap, const char *tag, struct _ns5__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns5__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns5__GetServiceCapabilities, sizeof(struct _ns5__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns5__GetServiceCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns5__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns5__GetServiceCapabilities, SOAP_TYPE__ns5__GetServiceCapabilities, sizeof(struct _ns5__GetServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns5__GetServiceCapabilities * SOAP_FMAC4 soap_new__ns5__GetServiceCapabilities(struct soap *soap, int n)
{
	struct _ns5__GetServiceCapabilities *p;
	struct _ns5__GetServiceCapabilities *a = (struct _ns5__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns5__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default__ns5__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns5__GetServiceCapabilities(struct soap *soap, const struct _ns5__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__ns5__GetServiceCapabilities(soap, tag ? tag : "ns5:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns5__GetServiceCapabilities * SOAP_FMAC4 soap_get__ns5__GetServiceCapabilities(struct soap *soap, struct _ns5__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns5__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__AccessDoorExtension(struct soap *soap, struct ns5__AccessDoorExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns5__AccessDoorExtension(struct soap *soap, const struct ns5__AccessDoorExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__AccessDoorExtension(struct soap *soap, const char *tag, int id, const struct ns5__AccessDoorExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__AccessDoorExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns5__AccessDoorExtension * SOAP_FMAC4 soap_in_ns5__AccessDoorExtension(struct soap *soap, const char *tag, struct ns5__AccessDoorExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns5__AccessDoorExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__AccessDoorExtension, sizeof(struct ns5__AccessDoorExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns5__AccessDoorExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns5__AccessDoorExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__AccessDoorExtension, SOAP_TYPE_ns5__AccessDoorExtension, sizeof(struct ns5__AccessDoorExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns5__AccessDoorExtension * SOAP_FMAC4 soap_new_ns5__AccessDoorExtension(struct soap *soap, int n)
{
	struct ns5__AccessDoorExtension *p;
	struct ns5__AccessDoorExtension *a = (struct ns5__AccessDoorExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns5__AccessDoorExtension));
	for (p = a; p && n--; p++)
		soap_default_ns5__AccessDoorExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__AccessDoorExtension(struct soap *soap, const struct ns5__AccessDoorExtension *a, const char *tag, const char *type)
{
	if (soap_out_ns5__AccessDoorExtension(soap, tag ? tag : "ns5:AccessDoorExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__AccessDoorExtension * SOAP_FMAC4 soap_get_ns5__AccessDoorExtension(struct soap *soap, struct ns5__AccessDoorExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__AccessDoorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__DoorFault(struct soap *soap, struct ns5__DoorFault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Reason);
	soap_default_ns5__DoorFaultState(soap, &a->State);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns5__DoorFault(struct soap *soap, const struct ns5__DoorFault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Reason);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__DoorFault(struct soap *soap, const char *tag, int id, const struct ns5__DoorFault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__DoorFault), type))
		return soap->error;
	if (soap_out_string(soap, "ns5:Reason", -1, (char*const*)&a->Reason, ""))
		return soap->error;
	if (soap_out_ns5__DoorFaultState(soap, "ns5:State", -1, &a->State, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns5__DoorFault * SOAP_FMAC4 soap_in_ns5__DoorFault(struct soap *soap, const char *tag, struct ns5__DoorFault *a, const char *type)
{
	size_t soap_flag_Reason = 1;
	size_t soap_flag_State = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns5__DoorFault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__DoorFault, sizeof(struct ns5__DoorFault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns5__DoorFault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Reason && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns5:Reason", (char**)&a->Reason, "xsd:string"))
				{	soap_flag_Reason--;
					continue;
				}
			if (soap_flag_State && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns5__DoorFaultState(soap, "ns5:State", &a->State, "ns5:DoorFaultState"))
				{	soap_flag_State--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_State > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns5__DoorFault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__DoorFault, SOAP_TYPE_ns5__DoorFault, sizeof(struct ns5__DoorFault), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns5__DoorFault * SOAP_FMAC4 soap_new_ns5__DoorFault(struct soap *soap, int n)
{
	struct ns5__DoorFault *p;
	struct ns5__DoorFault *a = (struct ns5__DoorFault*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns5__DoorFault));
	for (p = a; p && n--; p++)
		soap_default_ns5__DoorFault(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__DoorFault(struct soap *soap, const struct ns5__DoorFault *a, const char *tag, const char *type)
{
	if (soap_out_ns5__DoorFault(soap, tag ? tag : "ns5:DoorFault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__DoorFault * SOAP_FMAC4 soap_get_ns5__DoorFault(struct soap *soap, struct ns5__DoorFault *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__DoorFault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__DoorTamper(struct soap *soap, struct ns5__DoorTamper *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Reason);
	soap_default_ns5__DoorTamperState(soap, &a->State);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns5__DoorTamper(struct soap *soap, const struct ns5__DoorTamper *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Reason);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__DoorTamper(struct soap *soap, const char *tag, int id, const struct ns5__DoorTamper *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__DoorTamper), type))
		return soap->error;
	if (soap_out_string(soap, "ns5:Reason", -1, (char*const*)&a->Reason, ""))
		return soap->error;
	if (soap_out_ns5__DoorTamperState(soap, "ns5:State", -1, &a->State, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns5__DoorTamper * SOAP_FMAC4 soap_in_ns5__DoorTamper(struct soap *soap, const char *tag, struct ns5__DoorTamper *a, const char *type)
{
	size_t soap_flag_Reason = 1;
	size_t soap_flag_State = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns5__DoorTamper *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__DoorTamper, sizeof(struct ns5__DoorTamper), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns5__DoorTamper(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Reason && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns5:Reason", (char**)&a->Reason, "xsd:string"))
				{	soap_flag_Reason--;
					continue;
				}
			if (soap_flag_State && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns5__DoorTamperState(soap, "ns5:State", &a->State, "ns5:DoorTamperState"))
				{	soap_flag_State--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_State > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns5__DoorTamper *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__DoorTamper, SOAP_TYPE_ns5__DoorTamper, sizeof(struct ns5__DoorTamper), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns5__DoorTamper * SOAP_FMAC4 soap_new_ns5__DoorTamper(struct soap *soap, int n)
{
	struct ns5__DoorTamper *p;
	struct ns5__DoorTamper *a = (struct ns5__DoorTamper*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns5__DoorTamper));
	for (p = a; p && n--; p++)
		soap_default_ns5__DoorTamper(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__DoorTamper(struct soap *soap, const struct ns5__DoorTamper *a, const char *tag, const char *type)
{
	if (soap_out_ns5__DoorTamper(soap, tag ? tag : "ns5:DoorTamper", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__DoorTamper * SOAP_FMAC4 soap_get_ns5__DoorTamper(struct soap *soap, struct ns5__DoorTamper *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__DoorTamper(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__DoorState(struct soap *soap, struct ns5__DoorState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DoorPhysicalState = NULL;
	a->LockPhysicalState = NULL;
	a->DoubleLockPhysicalState = NULL;
	a->Alarm = NULL;
	a->Tamper = NULL;
	a->Fault = NULL;
	soap_default_ns5__DoorMode(soap, &a->DoorMode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns5__DoorState(struct soap *soap, const struct ns5__DoorState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons5__DoorPhysicalState(soap, &a->DoorPhysicalState);
	soap_serialize_PointerTons5__LockPhysicalState(soap, &a->LockPhysicalState);
	soap_serialize_PointerTons5__LockPhysicalState(soap, &a->DoubleLockPhysicalState);
	soap_serialize_PointerTons5__DoorAlarmState(soap, &a->Alarm);
	soap_serialize_PointerTons5__DoorTamper(soap, &a->Tamper);
	soap_serialize_PointerTons5__DoorFault(soap, &a->Fault);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__DoorState(struct soap *soap, const char *tag, int id, const struct ns5__DoorState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__DoorState), type))
		return soap->error;
	if (soap_out_PointerTons5__DoorPhysicalState(soap, "ns5:DoorPhysicalState", -1, &a->DoorPhysicalState, ""))
		return soap->error;
	if (soap_out_PointerTons5__LockPhysicalState(soap, "ns5:LockPhysicalState", -1, &a->LockPhysicalState, ""))
		return soap->error;
	if (soap_out_PointerTons5__LockPhysicalState(soap, "ns5:DoubleLockPhysicalState", -1, &a->DoubleLockPhysicalState, ""))
		return soap->error;
	if (soap_out_PointerTons5__DoorAlarmState(soap, "ns5:Alarm", -1, &a->Alarm, ""))
		return soap->error;
	if (soap_out_PointerTons5__DoorTamper(soap, "ns5:Tamper", -1, &a->Tamper, ""))
		return soap->error;
	if (soap_out_PointerTons5__DoorFault(soap, "ns5:Fault", -1, &a->Fault, ""))
		return soap->error;
	if (soap_out_ns5__DoorMode(soap, "ns5:DoorMode", -1, &a->DoorMode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns5__DoorState * SOAP_FMAC4 soap_in_ns5__DoorState(struct soap *soap, const char *tag, struct ns5__DoorState *a, const char *type)
{
	size_t soap_flag_DoorPhysicalState = 1;
	size_t soap_flag_LockPhysicalState = 1;
	size_t soap_flag_DoubleLockPhysicalState = 1;
	size_t soap_flag_Alarm = 1;
	size_t soap_flag_Tamper = 1;
	size_t soap_flag_Fault = 1;
	size_t soap_flag_DoorMode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns5__DoorState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__DoorState, sizeof(struct ns5__DoorState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns5__DoorState(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DoorPhysicalState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__DoorPhysicalState(soap, "ns5:DoorPhysicalState", &a->DoorPhysicalState, "ns5:DoorPhysicalState"))
				{	soap_flag_DoorPhysicalState--;
					continue;
				}
			if (soap_flag_LockPhysicalState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__LockPhysicalState(soap, "ns5:LockPhysicalState", &a->LockPhysicalState, "ns5:LockPhysicalState"))
				{	soap_flag_LockPhysicalState--;
					continue;
				}
			if (soap_flag_DoubleLockPhysicalState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__LockPhysicalState(soap, "ns5:DoubleLockPhysicalState", &a->DoubleLockPhysicalState, "ns5:LockPhysicalState"))
				{	soap_flag_DoubleLockPhysicalState--;
					continue;
				}
			if (soap_flag_Alarm && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__DoorAlarmState(soap, "ns5:Alarm", &a->Alarm, "ns5:DoorAlarmState"))
				{	soap_flag_Alarm--;
					continue;
				}
			if (soap_flag_Tamper && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__DoorTamper(soap, "ns5:Tamper", &a->Tamper, "ns5:DoorTamper"))
				{	soap_flag_Tamper--;
					continue;
				}
			if (soap_flag_Fault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__DoorFault(soap, "ns5:Fault", &a->Fault, "ns5:DoorFault"))
				{	soap_flag_Fault--;
					continue;
				}
			if (soap_flag_DoorMode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns5__DoorMode(soap, "ns5:DoorMode", &a->DoorMode, "ns5:DoorMode"))
				{	soap_flag_DoorMode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DoorMode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns5__DoorState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__DoorState, SOAP_TYPE_ns5__DoorState, sizeof(struct ns5__DoorState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns5__DoorState * SOAP_FMAC4 soap_new_ns5__DoorState(struct soap *soap, int n)
{
	struct ns5__DoorState *p;
	struct ns5__DoorState *a = (struct ns5__DoorState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns5__DoorState));
	for (p = a; p && n--; p++)
		soap_default_ns5__DoorState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__DoorState(struct soap *soap, const struct ns5__DoorState *a, const char *tag, const char *type)
{
	if (soap_out_ns5__DoorState(soap, tag ? tag : "ns5:DoorState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__DoorState * SOAP_FMAC4 soap_get_ns5__DoorState(struct soap *soap, struct ns5__DoorState *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__DoorState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__DoorCapabilities(struct soap *soap, struct ns5__DoorCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Access = NULL;
	a->AccessTimingOverride = NULL;
	a->Lock = NULL;
	a->Unlock = NULL;
	a->Block = NULL;
	a->DoubleLock = NULL;
	a->LockDown = NULL;
	a->LockOpen = NULL;
	a->DoorMonitor = NULL;
	a->LockMonitor = NULL;
	a->DoubleLockMonitor = NULL;
	a->Alarm = NULL;
	a->Tamper = NULL;
	a->Fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns5__DoorCapabilities(struct soap *soap, const struct ns5__DoorCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__DoorCapabilities(struct soap *soap, const char *tag, int id, const struct ns5__DoorCapabilities *a, const char *type)
{
	if (a->Access)
		soap_set_attr(soap, "Access", soap_xsd__boolean2s(soap, *a->Access), 1);
	if (a->AccessTimingOverride)
		soap_set_attr(soap, "AccessTimingOverride", soap_xsd__boolean2s(soap, *a->AccessTimingOverride), 1);
	if (a->Lock)
		soap_set_attr(soap, "Lock", soap_xsd__boolean2s(soap, *a->Lock), 1);
	if (a->Unlock)
		soap_set_attr(soap, "Unlock", soap_xsd__boolean2s(soap, *a->Unlock), 1);
	if (a->Block)
		soap_set_attr(soap, "Block", soap_xsd__boolean2s(soap, *a->Block), 1);
	if (a->DoubleLock)
		soap_set_attr(soap, "DoubleLock", soap_xsd__boolean2s(soap, *a->DoubleLock), 1);
	if (a->LockDown)
		soap_set_attr(soap, "LockDown", soap_xsd__boolean2s(soap, *a->LockDown), 1);
	if (a->LockOpen)
		soap_set_attr(soap, "LockOpen", soap_xsd__boolean2s(soap, *a->LockOpen), 1);
	if (a->DoorMonitor)
		soap_set_attr(soap, "DoorMonitor", soap_xsd__boolean2s(soap, *a->DoorMonitor), 1);
	if (a->LockMonitor)
		soap_set_attr(soap, "LockMonitor", soap_xsd__boolean2s(soap, *a->LockMonitor), 1);
	if (a->DoubleLockMonitor)
		soap_set_attr(soap, "DoubleLockMonitor", soap_xsd__boolean2s(soap, *a->DoubleLockMonitor), 1);
	if (a->Alarm)
		soap_set_attr(soap, "Alarm", soap_xsd__boolean2s(soap, *a->Alarm), 1);
	if (a->Tamper)
		soap_set_attr(soap, "Tamper", soap_xsd__boolean2s(soap, *a->Tamper), 1);
	if (a->Fault)
		soap_set_attr(soap, "Fault", soap_xsd__boolean2s(soap, *a->Fault), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__DoorCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns5__DoorCapabilities * SOAP_FMAC4 soap_in_ns5__DoorCapabilities(struct soap *soap, const char *tag, struct ns5__DoorCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns5__DoorCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__DoorCapabilities, sizeof(struct ns5__DoorCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns5__DoorCapabilities(soap, a);
	{	const char *t = soap_attr_value(soap, "Access", 0);
		if (t)
		{
			if (!(a->Access = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->Access))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "AccessTimingOverride", 0);
		if (t)
		{
			if (!(a->AccessTimingOverride = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->AccessTimingOverride))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Lock", 0);
		if (t)
		{
			if (!(a->Lock = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->Lock))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Unlock", 0);
		if (t)
		{
			if (!(a->Unlock = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->Unlock))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Block", 0);
		if (t)
		{
			if (!(a->Block = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->Block))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "DoubleLock", 0);
		if (t)
		{
			if (!(a->DoubleLock = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->DoubleLock))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "LockDown", 0);
		if (t)
		{
			if (!(a->LockDown = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->LockDown))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "LockOpen", 0);
		if (t)
		{
			if (!(a->LockOpen = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->LockOpen))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "DoorMonitor", 0);
		if (t)
		{
			if (!(a->DoorMonitor = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->DoorMonitor))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "LockMonitor", 0);
		if (t)
		{
			if (!(a->LockMonitor = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->LockMonitor))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "DoubleLockMonitor", 0);
		if (t)
		{
			if (!(a->DoubleLockMonitor = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->DoubleLockMonitor))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Alarm", 0);
		if (t)
		{
			if (!(a->Alarm = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->Alarm))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Tamper", 0);
		if (t)
		{
			if (!(a->Tamper = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->Tamper))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Fault", 0);
		if (t)
		{
			if (!(a->Fault = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->Fault))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns5__DoorCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__DoorCapabilities, SOAP_TYPE_ns5__DoorCapabilities, sizeof(struct ns5__DoorCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns5__DoorCapabilities * SOAP_FMAC4 soap_new_ns5__DoorCapabilities(struct soap *soap, int n)
{
	struct ns5__DoorCapabilities *p;
	struct ns5__DoorCapabilities *a = (struct ns5__DoorCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns5__DoorCapabilities));
	for (p = a; p && n--; p++)
		soap_default_ns5__DoorCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__DoorCapabilities(struct soap *soap, const struct ns5__DoorCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_ns5__DoorCapabilities(soap, tag ? tag : "ns5:DoorCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__DoorCapabilities * SOAP_FMAC4 soap_get_ns5__DoorCapabilities(struct soap *soap, struct ns5__DoorCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__DoorCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__ServiceCapabilities(struct soap *soap, struct ns5__ServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedInt(soap, &a->MaxLimit);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns5__ServiceCapabilities(struct soap *soap, const struct ns5__ServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__ServiceCapabilities(struct soap *soap, const char *tag, int id, const struct ns5__ServiceCapabilities *a, const char *type)
{
	soap_set_attr(soap, "MaxLimit", soap_unsignedInt2s(soap, a->MaxLimit), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__ServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns5__ServiceCapabilities * SOAP_FMAC4 soap_in_ns5__ServiceCapabilities(struct soap *soap, const char *tag, struct ns5__ServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns5__ServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__ServiceCapabilities, sizeof(struct ns5__ServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns5__ServiceCapabilities(soap, a);
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "MaxLimit", 1), &a->MaxLimit))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns5__ServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__ServiceCapabilities, SOAP_TYPE_ns5__ServiceCapabilities, sizeof(struct ns5__ServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns5__ServiceCapabilities * SOAP_FMAC4 soap_new_ns5__ServiceCapabilities(struct soap *soap, int n)
{
	struct ns5__ServiceCapabilities *p;
	struct ns5__ServiceCapabilities *a = (struct ns5__ServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns5__ServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default_ns5__ServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__ServiceCapabilities(struct soap *soap, const struct ns5__ServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_ns5__ServiceCapabilities(soap, tag ? tag : "ns5:ServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__ServiceCapabilities * SOAP_FMAC4 soap_get_ns5__ServiceCapabilities(struct soap *soap, struct ns5__ServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__ServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__DeletePaneConfigurationResponse(struct soap *soap, struct _tls__DeletePaneConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__DeletePaneConfigurationResponse(struct soap *soap, const struct _tls__DeletePaneConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__DeletePaneConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tls__DeletePaneConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__DeletePaneConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__DeletePaneConfigurationResponse * SOAP_FMAC4 soap_in__tls__DeletePaneConfigurationResponse(struct soap *soap, const char *tag, struct _tls__DeletePaneConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__DeletePaneConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__DeletePaneConfigurationResponse, sizeof(struct _tls__DeletePaneConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__DeletePaneConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tls__DeletePaneConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__DeletePaneConfigurationResponse, SOAP_TYPE__tls__DeletePaneConfigurationResponse, sizeof(struct _tls__DeletePaneConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__DeletePaneConfigurationResponse * SOAP_FMAC4 soap_new__tls__DeletePaneConfigurationResponse(struct soap *soap, int n)
{
	struct _tls__DeletePaneConfigurationResponse *p;
	struct _tls__DeletePaneConfigurationResponse *a = (struct _tls__DeletePaneConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__DeletePaneConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tls__DeletePaneConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__DeletePaneConfigurationResponse(struct soap *soap, const struct _tls__DeletePaneConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tls__DeletePaneConfigurationResponse(soap, tag ? tag : "tls:DeletePaneConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__DeletePaneConfigurationResponse * SOAP_FMAC4 soap_get__tls__DeletePaneConfigurationResponse(struct soap *soap, struct _tls__DeletePaneConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__DeletePaneConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__DeletePaneConfiguration(struct soap *soap, struct _tls__DeletePaneConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoOutput);
	soap_default_tt__ReferenceToken(soap, &a->PaneToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__DeletePaneConfiguration(struct soap *soap, const struct _tls__DeletePaneConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoOutput);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->PaneToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__DeletePaneConfiguration(struct soap *soap, const char *tag, int id, const struct _tls__DeletePaneConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__DeletePaneConfiguration), type))
		return soap->error;
	if (!a->VideoOutput)
	{	if (soap_element_nil(soap, "tls:VideoOutput"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tls:VideoOutput", -1, (char*const*)&a->VideoOutput, ""))
		return soap->error;
	if (!a->PaneToken)
	{	if (soap_element_nil(soap, "tls:PaneToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tls:PaneToken", -1, (char*const*)&a->PaneToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__DeletePaneConfiguration * SOAP_FMAC4 soap_in__tls__DeletePaneConfiguration(struct soap *soap, const char *tag, struct _tls__DeletePaneConfiguration *a, const char *type)
{
	size_t soap_flag_VideoOutput = 1;
	size_t soap_flag_PaneToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__DeletePaneConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__DeletePaneConfiguration, sizeof(struct _tls__DeletePaneConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__DeletePaneConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoOutput && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tls:VideoOutput", (char**)&a->VideoOutput, "tt:ReferenceToken"))
				{	soap_flag_VideoOutput--;
					continue;
				}
			if (soap_flag_PaneToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tls:PaneToken", (char**)&a->PaneToken, "tt:ReferenceToken"))
				{	soap_flag_PaneToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoOutput > 0 || soap_flag_PaneToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tls__DeletePaneConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__DeletePaneConfiguration, SOAP_TYPE__tls__DeletePaneConfiguration, sizeof(struct _tls__DeletePaneConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__DeletePaneConfiguration * SOAP_FMAC4 soap_new__tls__DeletePaneConfiguration(struct soap *soap, int n)
{
	struct _tls__DeletePaneConfiguration *p;
	struct _tls__DeletePaneConfiguration *a = (struct _tls__DeletePaneConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__DeletePaneConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tls__DeletePaneConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__DeletePaneConfiguration(struct soap *soap, const struct _tls__DeletePaneConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tls__DeletePaneConfiguration(soap, tag ? tag : "tls:DeletePaneConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__DeletePaneConfiguration * SOAP_FMAC4 soap_get__tls__DeletePaneConfiguration(struct soap *soap, struct _tls__DeletePaneConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__DeletePaneConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__CreatePaneConfigurationResponse(struct soap *soap, struct _tls__CreatePaneConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->PaneToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__CreatePaneConfigurationResponse(struct soap *soap, const struct _tls__CreatePaneConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->PaneToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__CreatePaneConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tls__CreatePaneConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__CreatePaneConfigurationResponse), type))
		return soap->error;
	if (a->PaneToken)
		soap_element_result(soap, "tls:PaneToken");
	if (!a->PaneToken)
	{	if (soap_element_nil(soap, "tls:PaneToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tls:PaneToken", -1, (char*const*)&a->PaneToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__CreatePaneConfigurationResponse * SOAP_FMAC4 soap_in__tls__CreatePaneConfigurationResponse(struct soap *soap, const char *tag, struct _tls__CreatePaneConfigurationResponse *a, const char *type)
{
	size_t soap_flag_PaneToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__CreatePaneConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__CreatePaneConfigurationResponse, sizeof(struct _tls__CreatePaneConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__CreatePaneConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PaneToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tls:PaneToken", (char**)&a->PaneToken, "tt:ReferenceToken"))
				{	soap_flag_PaneToken--;
					continue;
				}
			soap_check_result(soap, "tls:PaneToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PaneToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tls__CreatePaneConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__CreatePaneConfigurationResponse, SOAP_TYPE__tls__CreatePaneConfigurationResponse, sizeof(struct _tls__CreatePaneConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__CreatePaneConfigurationResponse * SOAP_FMAC4 soap_new__tls__CreatePaneConfigurationResponse(struct soap *soap, int n)
{
	struct _tls__CreatePaneConfigurationResponse *p;
	struct _tls__CreatePaneConfigurationResponse *a = (struct _tls__CreatePaneConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__CreatePaneConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tls__CreatePaneConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__CreatePaneConfigurationResponse(struct soap *soap, const struct _tls__CreatePaneConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tls__CreatePaneConfigurationResponse(soap, tag ? tag : "tls:CreatePaneConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__CreatePaneConfigurationResponse * SOAP_FMAC4 soap_get__tls__CreatePaneConfigurationResponse(struct soap *soap, struct _tls__CreatePaneConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__CreatePaneConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__CreatePaneConfiguration(struct soap *soap, struct _tls__CreatePaneConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoOutput);
	a->PaneConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__CreatePaneConfiguration(struct soap *soap, const struct _tls__CreatePaneConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoOutput);
	soap_serialize_PointerTott__PaneConfiguration(soap, &a->PaneConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__CreatePaneConfiguration(struct soap *soap, const char *tag, int id, const struct _tls__CreatePaneConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__CreatePaneConfiguration), type))
		return soap->error;
	if (!a->VideoOutput)
	{	if (soap_element_nil(soap, "tls:VideoOutput"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tls:VideoOutput", -1, (char*const*)&a->VideoOutput, ""))
		return soap->error;
	if (!a->PaneConfiguration)
	{	if (soap_element_nil(soap, "tls:PaneConfiguration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__PaneConfiguration(soap, "tls:PaneConfiguration", -1, &a->PaneConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__CreatePaneConfiguration * SOAP_FMAC4 soap_in__tls__CreatePaneConfiguration(struct soap *soap, const char *tag, struct _tls__CreatePaneConfiguration *a, const char *type)
{
	size_t soap_flag_VideoOutput = 1;
	size_t soap_flag_PaneConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__CreatePaneConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__CreatePaneConfiguration, sizeof(struct _tls__CreatePaneConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__CreatePaneConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoOutput && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tls:VideoOutput", (char**)&a->VideoOutput, "tt:ReferenceToken"))
				{	soap_flag_VideoOutput--;
					continue;
				}
			if (soap_flag_PaneConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PaneConfiguration(soap, "tls:PaneConfiguration", &a->PaneConfiguration, "tt:PaneConfiguration"))
				{	soap_flag_PaneConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoOutput > 0 || soap_flag_PaneConfiguration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tls__CreatePaneConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__CreatePaneConfiguration, SOAP_TYPE__tls__CreatePaneConfiguration, sizeof(struct _tls__CreatePaneConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__CreatePaneConfiguration * SOAP_FMAC4 soap_new__tls__CreatePaneConfiguration(struct soap *soap, int n)
{
	struct _tls__CreatePaneConfiguration *p;
	struct _tls__CreatePaneConfiguration *a = (struct _tls__CreatePaneConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__CreatePaneConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tls__CreatePaneConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__CreatePaneConfiguration(struct soap *soap, const struct _tls__CreatePaneConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tls__CreatePaneConfiguration(soap, tag ? tag : "tls:CreatePaneConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__CreatePaneConfiguration * SOAP_FMAC4 soap_get__tls__CreatePaneConfiguration(struct soap *soap, struct _tls__CreatePaneConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__CreatePaneConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__SetPaneConfigurationResponse(struct soap *soap, struct _tls__SetPaneConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__SetPaneConfigurationResponse(struct soap *soap, const struct _tls__SetPaneConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__SetPaneConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tls__SetPaneConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__SetPaneConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__SetPaneConfigurationResponse * SOAP_FMAC4 soap_in__tls__SetPaneConfigurationResponse(struct soap *soap, const char *tag, struct _tls__SetPaneConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__SetPaneConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__SetPaneConfigurationResponse, sizeof(struct _tls__SetPaneConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__SetPaneConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tls__SetPaneConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__SetPaneConfigurationResponse, SOAP_TYPE__tls__SetPaneConfigurationResponse, sizeof(struct _tls__SetPaneConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__SetPaneConfigurationResponse * SOAP_FMAC4 soap_new__tls__SetPaneConfigurationResponse(struct soap *soap, int n)
{
	struct _tls__SetPaneConfigurationResponse *p;
	struct _tls__SetPaneConfigurationResponse *a = (struct _tls__SetPaneConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__SetPaneConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__tls__SetPaneConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__SetPaneConfigurationResponse(struct soap *soap, const struct _tls__SetPaneConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tls__SetPaneConfigurationResponse(soap, tag ? tag : "tls:SetPaneConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__SetPaneConfigurationResponse * SOAP_FMAC4 soap_get__tls__SetPaneConfigurationResponse(struct soap *soap, struct _tls__SetPaneConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__SetPaneConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__SetPaneConfiguration(struct soap *soap, struct _tls__SetPaneConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoOutput);
	a->PaneConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__SetPaneConfiguration(struct soap *soap, const struct _tls__SetPaneConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoOutput);
	soap_serialize_PointerTott__PaneConfiguration(soap, &a->PaneConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__SetPaneConfiguration(struct soap *soap, const char *tag, int id, const struct _tls__SetPaneConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__SetPaneConfiguration), type))
		return soap->error;
	if (!a->VideoOutput)
	{	if (soap_element_nil(soap, "tls:VideoOutput"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tls:VideoOutput", -1, (char*const*)&a->VideoOutput, ""))
		return soap->error;
	if (!a->PaneConfiguration)
	{	if (soap_element_nil(soap, "tls:PaneConfiguration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__PaneConfiguration(soap, "tls:PaneConfiguration", -1, &a->PaneConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__SetPaneConfiguration * SOAP_FMAC4 soap_in__tls__SetPaneConfiguration(struct soap *soap, const char *tag, struct _tls__SetPaneConfiguration *a, const char *type)
{
	size_t soap_flag_VideoOutput = 1;
	size_t soap_flag_PaneConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__SetPaneConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__SetPaneConfiguration, sizeof(struct _tls__SetPaneConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__SetPaneConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoOutput && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tls:VideoOutput", (char**)&a->VideoOutput, "tt:ReferenceToken"))
				{	soap_flag_VideoOutput--;
					continue;
				}
			if (soap_flag_PaneConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PaneConfiguration(soap, "tls:PaneConfiguration", &a->PaneConfiguration, "tt:PaneConfiguration"))
				{	soap_flag_PaneConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoOutput > 0 || soap_flag_PaneConfiguration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tls__SetPaneConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__SetPaneConfiguration, SOAP_TYPE__tls__SetPaneConfiguration, sizeof(struct _tls__SetPaneConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tls__SetPaneConfiguration * SOAP_FMAC4 soap_new__tls__SetPaneConfiguration(struct soap *soap, int n)
{
	struct _tls__SetPaneConfiguration *p;
	struct _tls__SetPaneConfiguration *a = (struct _tls__SetPaneConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tls__SetPaneConfiguration));
	for (p = a; p && n--; p++)
		soap_default__tls__SetPaneConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__SetPaneConfiguration(struct soap *soap, const struct _tls__SetPaneConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__tls__SetPaneConfiguration(soap, tag ? tag : "tls:SetPaneConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__SetPaneConfiguration * SOAP_FMAC4 soap_get__tls__SetPaneConfiguration(struct soap *soap, struct _tls__SetPaneConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__SetPaneConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
