/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:59 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__MessageID(soap, &a->wsa__MessageID);
	a->wsa__RelatesTo = NULL;
	a->wsa__From = NULL;
	a->wsa__ReplyTo = NULL;
	a->wsa__FaultTo = NULL;
	soap_default__wsa__To(soap, &a->wsa__To);
	soap_default__wsa__Action(soap, &a->wsa__Action);
	a->wsdd__AppSequence = NULL;
	soap_default__wsa5__MessageID(soap, &a->wsa5__MessageID);
	a->wsa5__RelatesTo = NULL;
	a->wsa5__From = NULL;
	a->wsa5__ReplyTo = NULL;
	a->wsa5__FaultTo = NULL;
	soap_default__wsa5__To(soap, &a->wsa5__To);
	soap_default__wsa5__Action(soap, &a->wsa5__Action);
	a->chan__ChannelInstance = NULL;
	a->wsse__Security = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsa__MessageID(soap, (char*const*)&a->wsa__MessageID);
	soap_serialize_PointerTo_wsa__RelatesTo(soap, &a->wsa__RelatesTo);
	soap_serialize_PointerTo_wsa__From(soap, &a->wsa__From);
	soap_serialize_PointerTo_wsa__ReplyTo(soap, &a->wsa__ReplyTo);
	soap_serialize_PointerTo_wsa__FaultTo(soap, &a->wsa__FaultTo);
	soap_serialize__wsa__To(soap, (char*const*)&a->wsa__To);
	soap_serialize__wsa__Action(soap, (char*const*)&a->wsa__Action);
	soap_serialize_PointerTowsdd__AppSequenceType(soap, &a->wsdd__AppSequence);
	soap_serialize__wsa5__MessageID(soap, (char*const*)&a->wsa5__MessageID);
	soap_serialize_PointerTo_wsa5__RelatesTo(soap, &a->wsa5__RelatesTo);
	soap_serialize_PointerTo_wsa5__From(soap, &a->wsa5__From);
	soap_serialize_PointerTo_wsa5__ReplyTo(soap, &a->wsa5__ReplyTo);
	soap_serialize_PointerTo_wsa5__FaultTo(soap, &a->wsa5__FaultTo);
	soap_serialize__wsa5__To(soap, (char*const*)&a->wsa5__To);
	soap_serialize__wsa5__Action(soap, (char*const*)&a->wsa5__Action);
	soap_serialize_PointerTochan__ChannelInstanceType(soap, &a->chan__ChannelInstance);
	soap_serialize_PointerTo_wsse__Security(soap, &a->wsse__Security);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	if (soap_out__wsa__MessageID(soap, "wsa:MessageID", -1, (char*const*)&a->wsa__MessageID, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa__RelatesTo(soap, "wsa:RelatesTo", -1, &a->wsa__RelatesTo, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa__From(soap, "wsa:From", -1, &a->wsa__From, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa__ReplyTo(soap, "wsa:ReplyTo", -1, &a->wsa__ReplyTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa__FaultTo(soap, "wsa:FaultTo", -1, &a->wsa__FaultTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa__To(soap, "wsa:To", -1, (char*const*)&a->wsa__To, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa__Action(soap, "wsa:Action", -1, (char*const*)&a->wsa__Action, ""))
		return soap->error;
	if (soap_out_PointerTowsdd__AppSequenceType(soap, "wsdd:AppSequence", -1, &a->wsdd__AppSequence, ""))
		return soap->error;
	if (soap_out__wsa5__MessageID(soap, "wsa5:MessageID", -1, (char*const*)&a->wsa5__MessageID, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", -1, &a->wsa5__RelatesTo, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__From(soap, "wsa5:From", -1, &a->wsa5__From, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", -1, &a->wsa5__ReplyTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", -1, &a->wsa5__FaultTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__To(soap, "wsa5:To", -1, (char*const*)&a->wsa5__To, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__Action(soap, "wsa5:Action", -1, (char*const*)&a->wsa5__Action, ""))
		return soap->error;
	if (soap_out_PointerTochan__ChannelInstanceType(soap, "chan:ChannelInstance", -1, &a->chan__ChannelInstance, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsse__Security(soap, "wsse:Security", -1, &a->wsse__Security, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_wsa__MessageID = 1;
	size_t soap_flag_wsa__RelatesTo = 1;
	size_t soap_flag_wsa__From = 1;
	size_t soap_flag_wsa__ReplyTo = 1;
	size_t soap_flag_wsa__FaultTo = 1;
	size_t soap_flag_wsa__To = 1;
	size_t soap_flag_wsa__Action = 1;
	size_t soap_flag_wsdd__AppSequence = 1;
	size_t soap_flag_wsa5__MessageID = 1;
	size_t soap_flag_wsa5__RelatesTo = 1;
	size_t soap_flag_wsa5__From = 1;
	size_t soap_flag_wsa5__ReplyTo = 1;
	size_t soap_flag_wsa5__FaultTo = 1;
	size_t soap_flag_wsa5__To = 1;
	size_t soap_flag_wsa5__Action = 1;
	size_t soap_flag_chan__ChannelInstance = 1;
	size_t soap_flag_wsse__Security = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__MessageID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa__MessageID(soap, "wsa:MessageID", (char**)&a->wsa__MessageID, ""))
				{	soap_flag_wsa__MessageID--;
					continue;
				}
			if (soap_flag_wsa__RelatesTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa__RelatesTo(soap, "wsa:RelatesTo", &a->wsa__RelatesTo, ""))
				{	soap_flag_wsa__RelatesTo--;
					continue;
				}
			if (soap_flag_wsa__From && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa__From(soap, "wsa:From", &a->wsa__From, ""))
				{	soap_flag_wsa__From--;
					continue;
				}
			if (soap_flag_wsa__ReplyTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa__ReplyTo(soap, "wsa:ReplyTo", &a->wsa__ReplyTo, ""))
				{	soap_flag_wsa__ReplyTo--;
					continue;
				}
			if (soap_flag_wsa__FaultTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa__FaultTo(soap, "wsa:FaultTo", &a->wsa__FaultTo, ""))
				{	soap_flag_wsa__FaultTo--;
					continue;
				}
			if (soap_flag_wsa__To && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa__To(soap, "wsa:To", (char**)&a->wsa__To, ""))
				{	soap_flag_wsa__To--;
					continue;
				}
			if (soap_flag_wsa__Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa__Action(soap, "wsa:Action", (char**)&a->wsa__Action, ""))
				{	soap_flag_wsa__Action--;
					continue;
				}
			if (soap_flag_wsdd__AppSequence && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsdd__AppSequenceType(soap, "wsdd:AppSequence", &a->wsdd__AppSequence, "wsdd:AppSequenceType"))
				{	soap_flag_wsdd__AppSequence--;
					continue;
				}
			if (soap_flag_wsa5__MessageID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa5__MessageID(soap, "wsa5:MessageID", (char**)&a->wsa5__MessageID, ""))
				{	soap_flag_wsa5__MessageID--;
					continue;
				}
			if (soap_flag_wsa5__RelatesTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", &a->wsa5__RelatesTo, ""))
				{	soap_flag_wsa5__RelatesTo--;
					continue;
				}
			if (soap_flag_wsa5__From && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__From(soap, "wsa5:From", &a->wsa5__From, ""))
				{	soap_flag_wsa5__From--;
					continue;
				}
			if (soap_flag_wsa5__ReplyTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", &a->wsa5__ReplyTo, ""))
				{	soap_flag_wsa5__ReplyTo--;
					continue;
				}
			if (soap_flag_wsa5__FaultTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", &a->wsa5__FaultTo, ""))
				{	soap_flag_wsa5__FaultTo--;
					continue;
				}
			if (soap_flag_wsa5__To && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa5__To(soap, "wsa5:To", (char**)&a->wsa5__To, ""))
				{	soap_flag_wsa5__To--;
					continue;
				}
			if (soap_flag_wsa5__Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa5__Action(soap, "wsa5:Action", (char**)&a->wsa5__Action, ""))
				{	soap_flag_wsa5__Action--;
					continue;
				}
			if (soap_flag_chan__ChannelInstance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTochan__ChannelInstanceType(soap, "chan:ChannelInstance", &a->chan__ChannelInstance, "chan:ChannelInstanceType"))
				{	soap_flag_chan__ChannelInstance--;
					continue;
				}
			if (soap_flag_wsse__Security && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Security(soap, "wsse:Security", &a->wsse__Security, ""))
				{	soap_flag_wsse__Security--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{
	struct SOAP_ENV__Header *p;
	struct SOAP_ENV__Header *a = (struct SOAP_ENV__Header*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Header));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Header(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__Relationship(struct soap *soap, struct wsa__Relationship *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__QName(soap, &a->RelationshipType);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__Relationship(struct soap *soap, const struct wsa__Relationship *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__Relationship(struct soap *soap, const char *tag, int id, const struct wsa__Relationship *a, const char *type)
{
	if (a->RelationshipType)
		soap_set_attr(soap, "RelationshipType", soap__QName2s(soap, a->RelationshipType), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct wsa__Relationship * SOAP_FMAC4 soap_in_wsa__Relationship(struct soap *soap, const char *tag, struct wsa__Relationship *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__Relationship *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__Relationship, sizeof(struct wsa__Relationship), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa__Relationship(soap, a);
	if (soap_s2_QName(soap, soap_attr_value(soap, "RelationshipType", 0), &a->RelationshipType))
		return NULL;
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1, NULL))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "wsa:Relationship"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct wsa__Relationship * SOAP_FMAC4 soap_new_wsa__Relationship(struct soap *soap, int n)
{
	struct wsa__Relationship *p;
	struct wsa__Relationship *a = (struct wsa__Relationship*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa__Relationship));
	for (p = a; p && n--; p++)
		soap_default_wsa__Relationship(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__Relationship(struct soap *soap, const struct wsa__Relationship *a, const char *tag, const char *type)
{
	if (soap_out_wsa__Relationship(soap, tag ? tag : "wsa:Relationship", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__Relationship * SOAP_FMAC4 soap_get_wsa__Relationship(struct soap *soap, struct wsa__Relationship *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__Relationship(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->__item);
	soap_default_string(soap, &a->PortName);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__ServiceNameType(struct soap *soap, const struct wsa__ServiceNameType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ServiceNameType(struct soap *soap, const char *tag, int id, const struct wsa__ServiceNameType *a, const char *type)
{
	const char *soap_tmp___item = soap_QName2s(soap, a->__item);
	if (a->PortName)
		soap_set_attr(soap, "PortName", soap_string2s(soap, a->PortName), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out__QName(soap, tag, id, (char*const*)(void*)&soap_tmp___item, "");
}

SOAP_FMAC3 struct wsa__ServiceNameType * SOAP_FMAC4 soap_in_wsa__ServiceNameType(struct soap *soap, const char *tag, struct wsa__ServiceNameType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__ServiceNameType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ServiceNameType, sizeof(struct wsa__ServiceNameType), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa__ServiceNameType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "PortName", 0), &a->PortName))
		return NULL;
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1, NULL))
		return NULL;
	if (!soap_in__QName(soap, tag, (char**)&a->__item, "wsa:ServiceNameType"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct wsa__ServiceNameType * SOAP_FMAC4 soap_new_wsa__ServiceNameType(struct soap *soap, int n)
{
	struct wsa__ServiceNameType *p;
	struct wsa__ServiceNameType *a = (struct wsa__ServiceNameType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa__ServiceNameType));
	for (p = a; p && n--; p++)
		soap_default_wsa__ServiceNameType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__ServiceNameType(struct soap *soap, const struct wsa__ServiceNameType *a, const char *tag, const char *type)
{
	if (soap_out_wsa__ServiceNameType(soap, tag ? tag : "wsa:ServiceNameType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ServiceNameType * SOAP_FMAC4 soap_get_wsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ServiceNameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__ReferenceParametersType(struct soap *soap, const struct wsa__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ReferenceParametersType(struct soap *soap, const char *tag, int id, const struct wsa__ReferenceParametersType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__ReferenceParametersType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__ReferenceParametersType * SOAP_FMAC4 soap_in_wsa__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa__ReferenceParametersType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__ReferenceParametersType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ReferenceParametersType, sizeof(struct wsa__ReferenceParametersType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__ReferenceParametersType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__ReferenceParametersType, SOAP_TYPE_wsa__ReferenceParametersType, sizeof(struct wsa__ReferenceParametersType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsa__ReferenceParametersType * SOAP_FMAC4 soap_new_wsa__ReferenceParametersType(struct soap *soap, int n)
{
	struct wsa__ReferenceParametersType *p;
	struct wsa__ReferenceParametersType *a = (struct wsa__ReferenceParametersType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa__ReferenceParametersType));
	for (p = a; p && n--; p++)
		soap_default_wsa__ReferenceParametersType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__ReferenceParametersType(struct soap *soap, const struct wsa__ReferenceParametersType *a, const char *tag, const char *type)
{
	if (soap_out_wsa__ReferenceParametersType(soap, tag ? tag : "wsa:ReferenceParametersType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ReferenceParametersType * SOAP_FMAC4 soap_get_wsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__ReferencePropertiesType(struct soap *soap, const struct wsa__ReferencePropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ReferencePropertiesType(struct soap *soap, const char *tag, int id, const struct wsa__ReferencePropertiesType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__ReferencePropertiesType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType * SOAP_FMAC4 soap_in_wsa__ReferencePropertiesType(struct soap *soap, const char *tag, struct wsa__ReferencePropertiesType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__ReferencePropertiesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ReferencePropertiesType, sizeof(struct wsa__ReferencePropertiesType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__ReferencePropertiesType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__ReferencePropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__ReferencePropertiesType, SOAP_TYPE_wsa__ReferencePropertiesType, sizeof(struct wsa__ReferencePropertiesType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType * SOAP_FMAC4 soap_new_wsa__ReferencePropertiesType(struct soap *soap, int n)
{
	struct wsa__ReferencePropertiesType *p;
	struct wsa__ReferencePropertiesType *a = (struct wsa__ReferencePropertiesType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa__ReferencePropertiesType));
	for (p = a; p && n--; p++)
		soap_default_wsa__ReferencePropertiesType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__ReferencePropertiesType(struct soap *soap, const struct wsa__ReferencePropertiesType *a, const char *tag, const char *type)
{
	if (soap_out_wsa__ReferencePropertiesType(soap, tag ? tag : "wsa:ReferencePropertiesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType * SOAP_FMAC4 soap_get_wsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ReferencePropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__EndpointReferenceType(struct soap *soap, struct wsa__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Address);
	a->ReferenceProperties = NULL;
	a->ReferenceParameters = NULL;
	a->PortType = NULL;
	a->ServiceName = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__EndpointReferenceType(struct soap *soap, const struct wsa__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Address);
	soap_serialize_PointerTowsa__ReferencePropertiesType(soap, &a->ReferenceProperties);
	soap_serialize_PointerTowsa__ReferenceParametersType(soap, &a->ReferenceParameters);
	soap_serialize_PointerTo_QName(soap, &a->PortType);
	soap_serialize_PointerTowsa__ServiceNameType(soap, &a->ServiceName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__EndpointReferenceType(struct soap *soap, const char *tag, int id, const struct wsa__EndpointReferenceType *a, const char *type)
{
	const char *soap_tmp_PortType = a->PortType ? soap_QName2s(soap, *a->PortType) : NULL;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__EndpointReferenceType), type))
		return soap->error;
	if (!a->Address)
	{	if (soap_element_nil(soap, "wsa:Address"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "wsa:Address", -1, (char*const*)&a->Address, ""))
		return soap->error;
	if (soap_out_PointerTowsa__ReferencePropertiesType(soap, "wsa:ReferenceProperties", -1, &a->ReferenceProperties, ""))
		return soap->error;
	if (soap_out_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", -1, &a->ReferenceParameters, ""))
		return soap->error;
	if (soap_out__QName(soap, "wsa:PortType", -1, (char*const*)(void*)&soap_tmp_PortType, ""))
		return soap->error;
	if (soap_out_PointerTowsa__ServiceNameType(soap, "wsa:ServiceName", -1, &a->ServiceName, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_in_wsa__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_ReferenceProperties = 1;
	size_t soap_flag_ReferenceParameters = 1;
	size_t soap_flag_PortType = 1;
	size_t soap_flag_ServiceName = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__EndpointReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__EndpointReferenceType, sizeof(struct wsa__EndpointReferenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__EndpointReferenceType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1, NULL))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsa:Address", (char**)&a->Address, "xsd:string"))
				{	soap_flag_Address--;
					continue;
				}
			if (soap_flag_ReferenceProperties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__ReferencePropertiesType(soap, "wsa:ReferenceProperties", &a->ReferenceProperties, "wsa:ReferencePropertiesType"))
				{	soap_flag_ReferenceProperties--;
					continue;
				}
			if (soap_flag_ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", &a->ReferenceParameters, "wsa:ReferenceParametersType"))
				{	soap_flag_ReferenceParameters--;
					continue;
				}
			if (soap_flag_PortType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_QName(soap, "wsa:PortType", &a->PortType, ""))
				{	soap_flag_PortType--;
					continue;
				}
			if (soap_flag_ServiceName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__ServiceNameType(soap, "wsa:ServiceName", &a->ServiceName, "wsa:ServiceNameType"))
				{	soap_flag_ServiceName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsa__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__EndpointReferenceType, SOAP_TYPE_wsa__EndpointReferenceType, sizeof(struct wsa__EndpointReferenceType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_new_wsa__EndpointReferenceType(struct soap *soap, int n)
{
	struct wsa__EndpointReferenceType *p;
	struct wsa__EndpointReferenceType *a = (struct wsa__EndpointReferenceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsa__EndpointReferenceType));
	for (p = a; p && n--; p++)
		soap_default_wsa__EndpointReferenceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__EndpointReferenceType(struct soap *soap, const struct wsa__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out_wsa__EndpointReferenceType(soap, tag ? tag : "wsa:EndpointReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_get_wsa__EndpointReferenceType(struct soap *soap, struct wsa__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__union_EventStream(struct soap *soap, int choice, const union _tt__union_EventStream *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__tt__union_EventStream_wsnt__NotificationMessage:
		soap_serialize_PointerTowsnt__NotificationMessageHolderType(soap, &a->wsnt__NotificationMessage);
		break;
	case SOAP_UNION__tt__union_EventStream_Extension:
		soap_serialize_PointerTott__EventStreamExtension(soap, &a->Extension);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__union_EventStream(struct soap *soap, int choice, const union _tt__union_EventStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__tt__union_EventStream_wsnt__NotificationMessage:
		return soap_out_PointerTowsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", -1, &a->wsnt__NotificationMessage, "");
	case SOAP_UNION__tt__union_EventStream_Extension:
		return soap_out_PointerTott__EventStreamExtension(soap, "tt:Extension", -1, &a->Extension, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _tt__union_EventStream * SOAP_FMAC4 soap_in__tt__union_EventStream(struct soap *soap, int *choice, union _tt__union_EventStream *a)
{
	(void)a; /* appease -Wall -Werror */	soap->error = SOAP_TAG_MISMATCH;
	a->wsnt__NotificationMessage = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTowsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", &a->wsnt__NotificationMessage, "wsnt:NotificationMessageHolderType"))
	{	*choice = SOAP_UNION__tt__union_EventStream_wsnt__NotificationMessage;
		return a;
	}
	a->Extension = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__EventStreamExtension(soap, "tt:Extension", &a->Extension, "tt:EventStreamExtension"))
	{	*choice = SOAP_UNION__tt__union_EventStream_Extension;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__union_PTZStream(struct soap *soap, int choice, const union _tt__union_PTZStream *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__tt__union_PTZStream_PTZStatus:
		soap_serialize_PointerTott__PTZStatus(soap, &a->PTZStatus);
		break;
	case SOAP_UNION__tt__union_PTZStream_Extension:
		soap_serialize_PointerTott__PTZStreamExtension(soap, &a->Extension);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__union_PTZStream(struct soap *soap, int choice, const union _tt__union_PTZStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__tt__union_PTZStream_PTZStatus:
		return soap_out_PointerTott__PTZStatus(soap, "tt:PTZStatus", -1, &a->PTZStatus, "");
	case SOAP_UNION__tt__union_PTZStream_Extension:
		return soap_out_PointerTott__PTZStreamExtension(soap, "tt:Extension", -1, &a->Extension, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _tt__union_PTZStream * SOAP_FMAC4 soap_in__tt__union_PTZStream(struct soap *soap, int *choice, union _tt__union_PTZStream *a)
{
	(void)a; /* appease -Wall -Werror */	soap->error = SOAP_TAG_MISMATCH;
	a->PTZStatus = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__PTZStatus(soap, "tt:PTZStatus", &a->PTZStatus, "tt:PTZStatus"))
	{	*choice = SOAP_UNION__tt__union_PTZStream_PTZStatus;
		return a;
	}
	a->Extension = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__PTZStreamExtension(soap, "tt:Extension", &a->Extension, "tt:PTZStreamExtension"))
	{	*choice = SOAP_UNION__tt__union_PTZStream_Extension;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__union_VideoAnalyticsStream(struct soap *soap, int choice, const union _tt__union_VideoAnalyticsStream *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__tt__union_VideoAnalyticsStream_Frame:
		soap_serialize_PointerTott__Frame(soap, &a->Frame);
		break;
	case SOAP_UNION__tt__union_VideoAnalyticsStream_Extension:
		soap_serialize_PointerTott__VideoAnalyticsStreamExtension(soap, &a->Extension);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__union_VideoAnalyticsStream(struct soap *soap, int choice, const union _tt__union_VideoAnalyticsStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__tt__union_VideoAnalyticsStream_Frame:
		return soap_out_PointerTott__Frame(soap, "tt:Frame", -1, &a->Frame, "");
	case SOAP_UNION__tt__union_VideoAnalyticsStream_Extension:
		return soap_out_PointerTott__VideoAnalyticsStreamExtension(soap, "tt:Extension", -1, &a->Extension, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _tt__union_VideoAnalyticsStream * SOAP_FMAC4 soap_in__tt__union_VideoAnalyticsStream(struct soap *soap, int *choice, union _tt__union_VideoAnalyticsStream *a)
{
	(void)a; /* appease -Wall -Werror */	soap->error = SOAP_TAG_MISMATCH;
	a->Frame = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__Frame(soap, "tt:Frame", &a->Frame, "tt:Frame"))
	{	*choice = SOAP_UNION__tt__union_VideoAnalyticsStream_Frame;
		return a;
	}
	a->Extension = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__VideoAnalyticsStreamExtension(soap, "tt:Extension", &a->Extension, "tt:VideoAnalyticsStreamExtension"))
	{	*choice = SOAP_UNION__tt__union_VideoAnalyticsStream_Extension;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__union_MetadataStream(struct soap *soap, int choice, const union _tt__union_MetadataStream *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__tt__union_MetadataStream_VideoAnalytics:
		soap_serialize_PointerTott__VideoAnalyticsStream(soap, &a->VideoAnalytics);
		break;
	case SOAP_UNION__tt__union_MetadataStream_PTZ:
		soap_serialize_PointerTott__PTZStream(soap, &a->PTZ);
		break;
	case SOAP_UNION__tt__union_MetadataStream_Event:
		soap_serialize_PointerTott__EventStream(soap, &a->Event);
		break;
	case SOAP_UNION__tt__union_MetadataStream_Extension:
		soap_serialize_PointerTott__MetadataStreamExtension(soap, &a->Extension);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__union_MetadataStream(struct soap *soap, int choice, const union _tt__union_MetadataStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__tt__union_MetadataStream_VideoAnalytics:
		return soap_out_PointerTott__VideoAnalyticsStream(soap, "tt:VideoAnalytics", -1, &a->VideoAnalytics, "");
	case SOAP_UNION__tt__union_MetadataStream_PTZ:
		return soap_out_PointerTott__PTZStream(soap, "tt:PTZ", -1, &a->PTZ, "");
	case SOAP_UNION__tt__union_MetadataStream_Event:
		return soap_out_PointerTott__EventStream(soap, "tt:Event", -1, &a->Event, "");
	case SOAP_UNION__tt__union_MetadataStream_Extension:
		return soap_out_PointerTott__MetadataStreamExtension(soap, "tt:Extension", -1, &a->Extension, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _tt__union_MetadataStream * SOAP_FMAC4 soap_in__tt__union_MetadataStream(struct soap *soap, int *choice, union _tt__union_MetadataStream *a)
{
	(void)a; /* appease -Wall -Werror */	soap->error = SOAP_TAG_MISMATCH;
	a->VideoAnalytics = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__VideoAnalyticsStream(soap, "tt:VideoAnalytics", &a->VideoAnalytics, "tt:VideoAnalyticsStream"))
	{	*choice = SOAP_UNION__tt__union_MetadataStream_VideoAnalytics;
		return a;
	}
	a->PTZ = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__PTZStream(soap, "tt:PTZ", &a->PTZ, "tt:PTZStream"))
	{	*choice = SOAP_UNION__tt__union_MetadataStream_PTZ;
		return a;
	}
	a->Event = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__EventStream(soap, "tt:Event", &a->Event, "tt:EventStream"))
	{	*choice = SOAP_UNION__tt__union_MetadataStream_Event;
		return a;
	}
	a->Extension = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__MetadataStreamExtension(soap, "tt:Extension", &a->Extension, "tt:MetadataStreamExtension"))
	{	*choice = SOAP_UNION__tt__union_MetadataStream_Extension;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__union_PTZPresetTourPresetDetail(struct soap *soap, int choice, const union _tt__union_PTZPresetTourPresetDetail *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PresetToken:
		soap_serialize_tt__ReferenceToken(soap, &a->PresetToken);
		break;
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_Home:
		soap_embedded(soap, &a->Home, SOAP_TYPE_xsd__boolean);
		break;
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PTZPosition:
		soap_serialize_PointerTott__PTZVector(soap, &a->PTZPosition);
		break;
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_TypeExtension:
		soap_serialize_PointerTott__PTZPresetTourTypeExtension(soap, &a->TypeExtension);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__union_PTZPresetTourPresetDetail(struct soap *soap, int choice, const union _tt__union_PTZPresetTourPresetDetail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PresetToken:
		return soap_out_tt__ReferenceToken(soap, "tt:PresetToken", -1, (char*const*)&a->PresetToken, "");
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_Home:
		return soap_out_xsd__boolean(soap, "tt:Home", -1, &a->Home, "");
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PTZPosition:
		return soap_out_PointerTott__PTZVector(soap, "tt:PTZPosition", -1, &a->PTZPosition, "");
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_TypeExtension:
		return soap_out_PointerTott__PTZPresetTourTypeExtension(soap, "tt:TypeExtension", -1, &a->TypeExtension, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _tt__union_PTZPresetTourPresetDetail * SOAP_FMAC4 soap_in__tt__union_PTZPresetTourPresetDetail(struct soap *soap, int *choice, union _tt__union_PTZPresetTourPresetDetail *a)
{
	(void)a; /* appease -Wall -Werror */	soap->error = SOAP_TAG_MISMATCH;
	a->PresetToken = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_tt__ReferenceToken(soap, "tt:PresetToken", &a->PresetToken, "tt:ReferenceToken"))
	{	*choice = SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PresetToken;
		return a;
	}
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_xsd__boolean(soap, "tt:Home", &a->Home, "xsd:boolean"))
	{	*choice = SOAP_UNION__tt__union_PTZPresetTourPresetDetail_Home;
		return a;
	}
	a->PTZPosition = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__PTZVector(soap, "tt:PTZPosition", &a->PTZPosition, "tt:PTZVector"))
	{	*choice = SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PTZPosition;
		return a;
	}
	a->TypeExtension = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__PTZPresetTourTypeExtension(soap, "tt:TypeExtension", &a->TypeExtension, "tt:PTZPresetTourTypeExtension"))
	{	*choice = SOAP_UNION__tt__union_PTZPresetTourPresetDetail_TypeExtension;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns4__union_FtpContentConfiguration(struct soap *soap, int choice, const union _ns4__union_FtpContentConfiguration *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__ns4__union_FtpContentConfiguration_UploadImages:
		soap_serialize_PointerTons4__FtpContentConfigurationUploadImages(soap, &a->UploadImages);
		break;
	case SOAP_UNION__ns4__union_FtpContentConfiguration_UploadFile:
		soap_serialize_PointerTons4__FtpContentConfigurationUploadFile(soap, &a->UploadFile);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns4__union_FtpContentConfiguration(struct soap *soap, int choice, const union _ns4__union_FtpContentConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns4__union_FtpContentConfiguration_UploadImages:
		return soap_out_PointerTons4__FtpContentConfigurationUploadImages(soap, "ns4:UploadImages", -1, &a->UploadImages, "");
	case SOAP_UNION__ns4__union_FtpContentConfiguration_UploadFile:
		return soap_out_PointerTons4__FtpContentConfigurationUploadFile(soap, "ns4:UploadFile", -1, &a->UploadFile, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns4__union_FtpContentConfiguration * SOAP_FMAC4 soap_in__ns4__union_FtpContentConfiguration(struct soap *soap, int *choice, union _ns4__union_FtpContentConfiguration *a)
{
	(void)a; /* appease -Wall -Werror */	soap->error = SOAP_TAG_MISMATCH;
	a->UploadImages = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons4__FtpContentConfigurationUploadImages(soap, "ns4:UploadImages", &a->UploadImages, "ns4:FtpContentConfigurationUploadImages"))
	{	*choice = SOAP_UNION__ns4__union_FtpContentConfiguration_UploadImages;
		return a;
	}
	a->UploadFile = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons4__FtpContentConfigurationUploadFile(soap, "ns4:UploadFile", &a->UploadFile, "ns4:FtpContentConfigurationUploadFile"))
	{	*choice = SOAP_UNION__ns4__union_FtpContentConfiguration_UploadFile;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsc__union_DerivedKeyTokenType(struct soap *soap, int choice, const union _wsc__union_DerivedKeyTokenType *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation:
		soap_embedded(soap, &a->Generation, SOAP_TYPE_ULONG64);
		break;
	case SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset:
		soap_embedded(soap, &a->Offset, SOAP_TYPE_ULONG64);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsc__union_DerivedKeyTokenType(struct soap *soap, int choice, const union _wsc__union_DerivedKeyTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation:
		return soap_out_ULONG64(soap, "wsc:Generation", -1, &a->Generation, "");
	case SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset:
		return soap_out_ULONG64(soap, "wsc:Offset", -1, &a->Offset, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _wsc__union_DerivedKeyTokenType * SOAP_FMAC4 soap_in__wsc__union_DerivedKeyTokenType(struct soap *soap, int *choice, union _wsc__union_DerivedKeyTokenType *a)
{
	(void)a; /* appease -Wall -Werror */	soap->error = SOAP_TAG_MISMATCH;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_ULONG64(soap, "wsc:Generation", &a->Generation, "xsd:unsignedLong"))
	{	*choice = SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation;
		return a;
	}
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_ULONG64(soap, "wsc:Offset", &a->Offset, "xsd:unsignedLong"))
	{	*choice = SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetMetadataSearchResultsResponse(struct soap *soap, struct _tse__GetMetadataSearchResultsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetMetadataSearchResultsResponse))
		soap_serialize__tse__GetMetadataSearchResultsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetMetadataSearchResultsResponse(struct soap *soap, const char *tag, int id, struct _tse__GetMetadataSearchResultsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetMetadataSearchResultsResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetMetadataSearchResultsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetMetadataSearchResultsResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__GetMetadataSearchResultsResponse(struct soap *soap, const char *tag, struct _tse__GetMetadataSearchResultsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetMetadataSearchResultsResponse **)soap_malloc(soap, sizeof(struct _tse__GetMetadataSearchResultsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetMetadataSearchResultsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetMetadataSearchResultsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetMetadataSearchResultsResponse, sizeof(struct _tse__GetMetadataSearchResultsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetMetadataSearchResultsResponse(struct soap *soap, struct _tse__GetMetadataSearchResultsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetMetadataSearchResultsResponse(soap, tag ? tag : "tse:GetMetadataSearchResultsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetMetadataSearchResultsResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__GetMetadataSearchResultsResponse(struct soap *soap, struct _tse__GetMetadataSearchResultsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetMetadataSearchResultsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetMetadataSearchResults(struct soap *soap, struct _tse__GetMetadataSearchResults *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetMetadataSearchResults))
		soap_serialize__tse__GetMetadataSearchResults(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetMetadataSearchResults(struct soap *soap, const char *tag, int id, struct _tse__GetMetadataSearchResults *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetMetadataSearchResults, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetMetadataSearchResults(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetMetadataSearchResults ** SOAP_FMAC4 soap_in_PointerTo_tse__GetMetadataSearchResults(struct soap *soap, const char *tag, struct _tse__GetMetadataSearchResults **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetMetadataSearchResults **)soap_malloc(soap, sizeof(struct _tse__GetMetadataSearchResults *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetMetadataSearchResults(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetMetadataSearchResults **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetMetadataSearchResults, sizeof(struct _tse__GetMetadataSearchResults), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetMetadataSearchResults(struct soap *soap, struct _tse__GetMetadataSearchResults *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetMetadataSearchResults(soap, tag ? tag : "tse:GetMetadataSearchResults", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetMetadataSearchResults ** SOAP_FMAC4 soap_get_PointerTo_tse__GetMetadataSearchResults(struct soap *soap, struct _tse__GetMetadataSearchResults **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetMetadataSearchResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__FindMetadataResponse(struct soap *soap, struct _tse__FindMetadataResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__FindMetadataResponse))
		soap_serialize__tse__FindMetadataResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__FindMetadataResponse(struct soap *soap, const char *tag, int id, struct _tse__FindMetadataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__FindMetadataResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__FindMetadataResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__FindMetadataResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__FindMetadataResponse(struct soap *soap, const char *tag, struct _tse__FindMetadataResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__FindMetadataResponse **)soap_malloc(soap, sizeof(struct _tse__FindMetadataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__FindMetadataResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__FindMetadataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__FindMetadataResponse, sizeof(struct _tse__FindMetadataResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__FindMetadataResponse(struct soap *soap, struct _tse__FindMetadataResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__FindMetadataResponse(soap, tag ? tag : "tse:FindMetadataResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindMetadataResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__FindMetadataResponse(struct soap *soap, struct _tse__FindMetadataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__FindMetadataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__FindMetadata(struct soap *soap, struct _tse__FindMetadata *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__FindMetadata))
		soap_serialize__tse__FindMetadata(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__FindMetadata(struct soap *soap, const char *tag, int id, struct _tse__FindMetadata *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__FindMetadata, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__FindMetadata(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__FindMetadata ** SOAP_FMAC4 soap_in_PointerTo_tse__FindMetadata(struct soap *soap, const char *tag, struct _tse__FindMetadata **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__FindMetadata **)soap_malloc(soap, sizeof(struct _tse__FindMetadata *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__FindMetadata(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__FindMetadata **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__FindMetadata, sizeof(struct _tse__FindMetadata), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__FindMetadata(struct soap *soap, struct _tse__FindMetadata *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__FindMetadata(soap, tag ? tag : "tse:FindMetadata", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindMetadata ** SOAP_FMAC4 soap_get_PointerTo_tse__FindMetadata(struct soap *soap, struct _tse__FindMetadata **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__FindMetadata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__EndSearchResponse(struct soap *soap, struct _tse__EndSearchResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__EndSearchResponse))
		soap_serialize__tse__EndSearchResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__EndSearchResponse(struct soap *soap, const char *tag, int id, struct _tse__EndSearchResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__EndSearchResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__EndSearchResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__EndSearchResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__EndSearchResponse(struct soap *soap, const char *tag, struct _tse__EndSearchResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__EndSearchResponse **)soap_malloc(soap, sizeof(struct _tse__EndSearchResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__EndSearchResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__EndSearchResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__EndSearchResponse, sizeof(struct _tse__EndSearchResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__EndSearchResponse(struct soap *soap, struct _tse__EndSearchResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__EndSearchResponse(soap, tag ? tag : "tse:EndSearchResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__EndSearchResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__EndSearchResponse(struct soap *soap, struct _tse__EndSearchResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__EndSearchResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__EndSearch(struct soap *soap, struct _tse__EndSearch *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__EndSearch))
		soap_serialize__tse__EndSearch(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__EndSearch(struct soap *soap, const char *tag, int id, struct _tse__EndSearch *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__EndSearch, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__EndSearch(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__EndSearch ** SOAP_FMAC4 soap_in_PointerTo_tse__EndSearch(struct soap *soap, const char *tag, struct _tse__EndSearch **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__EndSearch **)soap_malloc(soap, sizeof(struct _tse__EndSearch *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__EndSearch(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__EndSearch **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__EndSearch, sizeof(struct _tse__EndSearch), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__EndSearch(struct soap *soap, struct _tse__EndSearch *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__EndSearch(soap, tag ? tag : "tse:EndSearch", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__EndSearch ** SOAP_FMAC4 soap_get_PointerTo_tse__EndSearch(struct soap *soap, struct _tse__EndSearch **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__EndSearch(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetSearchStateResponse(struct soap *soap, struct _tse__GetSearchStateResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetSearchStateResponse))
		soap_serialize__tse__GetSearchStateResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetSearchStateResponse(struct soap *soap, const char *tag, int id, struct _tse__GetSearchStateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetSearchStateResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetSearchStateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetSearchStateResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__GetSearchStateResponse(struct soap *soap, const char *tag, struct _tse__GetSearchStateResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetSearchStateResponse **)soap_malloc(soap, sizeof(struct _tse__GetSearchStateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetSearchStateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetSearchStateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetSearchStateResponse, sizeof(struct _tse__GetSearchStateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetSearchStateResponse(struct soap *soap, struct _tse__GetSearchStateResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetSearchStateResponse(soap, tag ? tag : "tse:GetSearchStateResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetSearchStateResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__GetSearchStateResponse(struct soap *soap, struct _tse__GetSearchStateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetSearchStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetSearchState(struct soap *soap, struct _tse__GetSearchState *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetSearchState))
		soap_serialize__tse__GetSearchState(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetSearchState(struct soap *soap, const char *tag, int id, struct _tse__GetSearchState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetSearchState, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetSearchState(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetSearchState ** SOAP_FMAC4 soap_in_PointerTo_tse__GetSearchState(struct soap *soap, const char *tag, struct _tse__GetSearchState **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetSearchState **)soap_malloc(soap, sizeof(struct _tse__GetSearchState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetSearchState(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetSearchState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetSearchState, sizeof(struct _tse__GetSearchState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetSearchState(struct soap *soap, struct _tse__GetSearchState *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetSearchState(soap, tag ? tag : "tse:GetSearchState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetSearchState ** SOAP_FMAC4 soap_get_PointerTo_tse__GetSearchState(struct soap *soap, struct _tse__GetSearchState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetSearchState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetPTZPositionSearchResultsResponse(struct soap *soap, struct _tse__GetPTZPositionSearchResultsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetPTZPositionSearchResultsResponse))
		soap_serialize__tse__GetPTZPositionSearchResultsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetPTZPositionSearchResultsResponse(struct soap *soap, const char *tag, int id, struct _tse__GetPTZPositionSearchResultsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetPTZPositionSearchResultsResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetPTZPositionSearchResultsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetPTZPositionSearchResultsResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__GetPTZPositionSearchResultsResponse(struct soap *soap, const char *tag, struct _tse__GetPTZPositionSearchResultsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetPTZPositionSearchResultsResponse **)soap_malloc(soap, sizeof(struct _tse__GetPTZPositionSearchResultsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetPTZPositionSearchResultsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetPTZPositionSearchResultsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetPTZPositionSearchResultsResponse, sizeof(struct _tse__GetPTZPositionSearchResultsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetPTZPositionSearchResultsResponse(struct soap *soap, struct _tse__GetPTZPositionSearchResultsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetPTZPositionSearchResultsResponse(soap, tag ? tag : "tse:GetPTZPositionSearchResultsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetPTZPositionSearchResultsResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__GetPTZPositionSearchResultsResponse(struct soap *soap, struct _tse__GetPTZPositionSearchResultsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetPTZPositionSearchResultsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetPTZPositionSearchResults(struct soap *soap, struct _tse__GetPTZPositionSearchResults *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetPTZPositionSearchResults))
		soap_serialize__tse__GetPTZPositionSearchResults(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetPTZPositionSearchResults(struct soap *soap, const char *tag, int id, struct _tse__GetPTZPositionSearchResults *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetPTZPositionSearchResults, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetPTZPositionSearchResults(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetPTZPositionSearchResults ** SOAP_FMAC4 soap_in_PointerTo_tse__GetPTZPositionSearchResults(struct soap *soap, const char *tag, struct _tse__GetPTZPositionSearchResults **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetPTZPositionSearchResults **)soap_malloc(soap, sizeof(struct _tse__GetPTZPositionSearchResults *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetPTZPositionSearchResults(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetPTZPositionSearchResults **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetPTZPositionSearchResults, sizeof(struct _tse__GetPTZPositionSearchResults), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetPTZPositionSearchResults(struct soap *soap, struct _tse__GetPTZPositionSearchResults *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetPTZPositionSearchResults(soap, tag ? tag : "tse:GetPTZPositionSearchResults", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetPTZPositionSearchResults ** SOAP_FMAC4 soap_get_PointerTo_tse__GetPTZPositionSearchResults(struct soap *soap, struct _tse__GetPTZPositionSearchResults **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetPTZPositionSearchResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__FindPTZPositionResponse(struct soap *soap, struct _tse__FindPTZPositionResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__FindPTZPositionResponse))
		soap_serialize__tse__FindPTZPositionResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__FindPTZPositionResponse(struct soap *soap, const char *tag, int id, struct _tse__FindPTZPositionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__FindPTZPositionResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__FindPTZPositionResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__FindPTZPositionResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__FindPTZPositionResponse(struct soap *soap, const char *tag, struct _tse__FindPTZPositionResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__FindPTZPositionResponse **)soap_malloc(soap, sizeof(struct _tse__FindPTZPositionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__FindPTZPositionResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__FindPTZPositionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__FindPTZPositionResponse, sizeof(struct _tse__FindPTZPositionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__FindPTZPositionResponse(struct soap *soap, struct _tse__FindPTZPositionResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__FindPTZPositionResponse(soap, tag ? tag : "tse:FindPTZPositionResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindPTZPositionResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__FindPTZPositionResponse(struct soap *soap, struct _tse__FindPTZPositionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__FindPTZPositionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__FindPTZPosition(struct soap *soap, struct _tse__FindPTZPosition *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__FindPTZPosition))
		soap_serialize__tse__FindPTZPosition(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__FindPTZPosition(struct soap *soap, const char *tag, int id, struct _tse__FindPTZPosition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__FindPTZPosition, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__FindPTZPosition(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__FindPTZPosition ** SOAP_FMAC4 soap_in_PointerTo_tse__FindPTZPosition(struct soap *soap, const char *tag, struct _tse__FindPTZPosition **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__FindPTZPosition **)soap_malloc(soap, sizeof(struct _tse__FindPTZPosition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__FindPTZPosition(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__FindPTZPosition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__FindPTZPosition, sizeof(struct _tse__FindPTZPosition), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__FindPTZPosition(struct soap *soap, struct _tse__FindPTZPosition *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__FindPTZPosition(soap, tag ? tag : "tse:FindPTZPosition", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindPTZPosition ** SOAP_FMAC4 soap_get_PointerTo_tse__FindPTZPosition(struct soap *soap, struct _tse__FindPTZPosition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__FindPTZPosition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetEventSearchResultsResponse(struct soap *soap, struct _tse__GetEventSearchResultsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetEventSearchResultsResponse))
		soap_serialize__tse__GetEventSearchResultsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetEventSearchResultsResponse(struct soap *soap, const char *tag, int id, struct _tse__GetEventSearchResultsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetEventSearchResultsResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetEventSearchResultsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetEventSearchResultsResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__GetEventSearchResultsResponse(struct soap *soap, const char *tag, struct _tse__GetEventSearchResultsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetEventSearchResultsResponse **)soap_malloc(soap, sizeof(struct _tse__GetEventSearchResultsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetEventSearchResultsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetEventSearchResultsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetEventSearchResultsResponse, sizeof(struct _tse__GetEventSearchResultsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetEventSearchResultsResponse(struct soap *soap, struct _tse__GetEventSearchResultsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetEventSearchResultsResponse(soap, tag ? tag : "tse:GetEventSearchResultsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetEventSearchResultsResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__GetEventSearchResultsResponse(struct soap *soap, struct _tse__GetEventSearchResultsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetEventSearchResultsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetEventSearchResults(struct soap *soap, struct _tse__GetEventSearchResults *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetEventSearchResults))
		soap_serialize__tse__GetEventSearchResults(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetEventSearchResults(struct soap *soap, const char *tag, int id, struct _tse__GetEventSearchResults *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetEventSearchResults, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetEventSearchResults(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetEventSearchResults ** SOAP_FMAC4 soap_in_PointerTo_tse__GetEventSearchResults(struct soap *soap, const char *tag, struct _tse__GetEventSearchResults **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetEventSearchResults **)soap_malloc(soap, sizeof(struct _tse__GetEventSearchResults *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetEventSearchResults(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetEventSearchResults **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetEventSearchResults, sizeof(struct _tse__GetEventSearchResults), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetEventSearchResults(struct soap *soap, struct _tse__GetEventSearchResults *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetEventSearchResults(soap, tag ? tag : "tse:GetEventSearchResults", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetEventSearchResults ** SOAP_FMAC4 soap_get_PointerTo_tse__GetEventSearchResults(struct soap *soap, struct _tse__GetEventSearchResults **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetEventSearchResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__FindEventsResponse(struct soap *soap, struct _tse__FindEventsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__FindEventsResponse))
		soap_serialize__tse__FindEventsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__FindEventsResponse(struct soap *soap, const char *tag, int id, struct _tse__FindEventsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__FindEventsResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__FindEventsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__FindEventsResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__FindEventsResponse(struct soap *soap, const char *tag, struct _tse__FindEventsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__FindEventsResponse **)soap_malloc(soap, sizeof(struct _tse__FindEventsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__FindEventsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__FindEventsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__FindEventsResponse, sizeof(struct _tse__FindEventsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__FindEventsResponse(struct soap *soap, struct _tse__FindEventsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__FindEventsResponse(soap, tag ? tag : "tse:FindEventsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindEventsResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__FindEventsResponse(struct soap *soap, struct _tse__FindEventsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__FindEventsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__FindEvents(struct soap *soap, struct _tse__FindEvents *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__FindEvents))
		soap_serialize__tse__FindEvents(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__FindEvents(struct soap *soap, const char *tag, int id, struct _tse__FindEvents *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__FindEvents, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__FindEvents(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__FindEvents ** SOAP_FMAC4 soap_in_PointerTo_tse__FindEvents(struct soap *soap, const char *tag, struct _tse__FindEvents **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__FindEvents **)soap_malloc(soap, sizeof(struct _tse__FindEvents *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__FindEvents(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__FindEvents **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__FindEvents, sizeof(struct _tse__FindEvents), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__FindEvents(struct soap *soap, struct _tse__FindEvents *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__FindEvents(soap, tag ? tag : "tse:FindEvents", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindEvents ** SOAP_FMAC4 soap_get_PointerTo_tse__FindEvents(struct soap *soap, struct _tse__FindEvents **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__FindEvents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetRecordingSearchResultsResponse(struct soap *soap, struct _tse__GetRecordingSearchResultsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetRecordingSearchResultsResponse))
		soap_serialize__tse__GetRecordingSearchResultsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetRecordingSearchResultsResponse(struct soap *soap, const char *tag, int id, struct _tse__GetRecordingSearchResultsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetRecordingSearchResultsResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetRecordingSearchResultsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetRecordingSearchResultsResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__GetRecordingSearchResultsResponse(struct soap *soap, const char *tag, struct _tse__GetRecordingSearchResultsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetRecordingSearchResultsResponse **)soap_malloc(soap, sizeof(struct _tse__GetRecordingSearchResultsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetRecordingSearchResultsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingSearchResultsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetRecordingSearchResultsResponse, sizeof(struct _tse__GetRecordingSearchResultsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetRecordingSearchResultsResponse(struct soap *soap, struct _tse__GetRecordingSearchResultsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetRecordingSearchResultsResponse(soap, tag ? tag : "tse:GetRecordingSearchResultsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingSearchResultsResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__GetRecordingSearchResultsResponse(struct soap *soap, struct _tse__GetRecordingSearchResultsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetRecordingSearchResultsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetRecordingSearchResults(struct soap *soap, struct _tse__GetRecordingSearchResults *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetRecordingSearchResults))
		soap_serialize__tse__GetRecordingSearchResults(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetRecordingSearchResults(struct soap *soap, const char *tag, int id, struct _tse__GetRecordingSearchResults *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetRecordingSearchResults, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetRecordingSearchResults(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetRecordingSearchResults ** SOAP_FMAC4 soap_in_PointerTo_tse__GetRecordingSearchResults(struct soap *soap, const char *tag, struct _tse__GetRecordingSearchResults **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetRecordingSearchResults **)soap_malloc(soap, sizeof(struct _tse__GetRecordingSearchResults *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetRecordingSearchResults(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingSearchResults **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetRecordingSearchResults, sizeof(struct _tse__GetRecordingSearchResults), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetRecordingSearchResults(struct soap *soap, struct _tse__GetRecordingSearchResults *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetRecordingSearchResults(soap, tag ? tag : "tse:GetRecordingSearchResults", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingSearchResults ** SOAP_FMAC4 soap_get_PointerTo_tse__GetRecordingSearchResults(struct soap *soap, struct _tse__GetRecordingSearchResults **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetRecordingSearchResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__FindRecordingsResponse(struct soap *soap, struct _tse__FindRecordingsResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__FindRecordingsResponse))
		soap_serialize__tse__FindRecordingsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__FindRecordingsResponse(struct soap *soap, const char *tag, int id, struct _tse__FindRecordingsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__FindRecordingsResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__FindRecordingsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__FindRecordingsResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__FindRecordingsResponse(struct soap *soap, const char *tag, struct _tse__FindRecordingsResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__FindRecordingsResponse **)soap_malloc(soap, sizeof(struct _tse__FindRecordingsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__FindRecordingsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__FindRecordingsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__FindRecordingsResponse, sizeof(struct _tse__FindRecordingsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__FindRecordingsResponse(struct soap *soap, struct _tse__FindRecordingsResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__FindRecordingsResponse(soap, tag ? tag : "tse:FindRecordingsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindRecordingsResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__FindRecordingsResponse(struct soap *soap, struct _tse__FindRecordingsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__FindRecordingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__FindRecordings(struct soap *soap, struct _tse__FindRecordings *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__FindRecordings))
		soap_serialize__tse__FindRecordings(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__FindRecordings(struct soap *soap, const char *tag, int id, struct _tse__FindRecordings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__FindRecordings, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__FindRecordings(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__FindRecordings ** SOAP_FMAC4 soap_in_PointerTo_tse__FindRecordings(struct soap *soap, const char *tag, struct _tse__FindRecordings **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__FindRecordings **)soap_malloc(soap, sizeof(struct _tse__FindRecordings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__FindRecordings(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__FindRecordings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__FindRecordings, sizeof(struct _tse__FindRecordings), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__FindRecordings(struct soap *soap, struct _tse__FindRecordings *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__FindRecordings(soap, tag ? tag : "tse:FindRecordings", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindRecordings ** SOAP_FMAC4 soap_get_PointerTo_tse__FindRecordings(struct soap *soap, struct _tse__FindRecordings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__FindRecordings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetMediaAttributesResponse(struct soap *soap, struct _tse__GetMediaAttributesResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetMediaAttributesResponse))
		soap_serialize__tse__GetMediaAttributesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetMediaAttributesResponse(struct soap *soap, const char *tag, int id, struct _tse__GetMediaAttributesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetMediaAttributesResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetMediaAttributesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetMediaAttributesResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__GetMediaAttributesResponse(struct soap *soap, const char *tag, struct _tse__GetMediaAttributesResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetMediaAttributesResponse **)soap_malloc(soap, sizeof(struct _tse__GetMediaAttributesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetMediaAttributesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetMediaAttributesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetMediaAttributesResponse, sizeof(struct _tse__GetMediaAttributesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetMediaAttributesResponse(struct soap *soap, struct _tse__GetMediaAttributesResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetMediaAttributesResponse(soap, tag ? tag : "tse:GetMediaAttributesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetMediaAttributesResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__GetMediaAttributesResponse(struct soap *soap, struct _tse__GetMediaAttributesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetMediaAttributesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetMediaAttributes(struct soap *soap, struct _tse__GetMediaAttributes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetMediaAttributes))
		soap_serialize__tse__GetMediaAttributes(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetMediaAttributes(struct soap *soap, const char *tag, int id, struct _tse__GetMediaAttributes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetMediaAttributes, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetMediaAttributes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetMediaAttributes ** SOAP_FMAC4 soap_in_PointerTo_tse__GetMediaAttributes(struct soap *soap, const char *tag, struct _tse__GetMediaAttributes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetMediaAttributes **)soap_malloc(soap, sizeof(struct _tse__GetMediaAttributes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetMediaAttributes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetMediaAttributes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetMediaAttributes, sizeof(struct _tse__GetMediaAttributes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetMediaAttributes(struct soap *soap, struct _tse__GetMediaAttributes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetMediaAttributes(soap, tag ? tag : "tse:GetMediaAttributes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetMediaAttributes ** SOAP_FMAC4 soap_get_PointerTo_tse__GetMediaAttributes(struct soap *soap, struct _tse__GetMediaAttributes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetMediaAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetRecordingInformationResponse(struct soap *soap, struct _tse__GetRecordingInformationResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetRecordingInformationResponse))
		soap_serialize__tse__GetRecordingInformationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetRecordingInformationResponse(struct soap *soap, const char *tag, int id, struct _tse__GetRecordingInformationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetRecordingInformationResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetRecordingInformationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetRecordingInformationResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__GetRecordingInformationResponse(struct soap *soap, const char *tag, struct _tse__GetRecordingInformationResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetRecordingInformationResponse **)soap_malloc(soap, sizeof(struct _tse__GetRecordingInformationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetRecordingInformationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingInformationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetRecordingInformationResponse, sizeof(struct _tse__GetRecordingInformationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetRecordingInformationResponse(struct soap *soap, struct _tse__GetRecordingInformationResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetRecordingInformationResponse(soap, tag ? tag : "tse:GetRecordingInformationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingInformationResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__GetRecordingInformationResponse(struct soap *soap, struct _tse__GetRecordingInformationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetRecordingInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetRecordingInformation(struct soap *soap, struct _tse__GetRecordingInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetRecordingInformation))
		soap_serialize__tse__GetRecordingInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetRecordingInformation(struct soap *soap, const char *tag, int id, struct _tse__GetRecordingInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetRecordingInformation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetRecordingInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetRecordingInformation ** SOAP_FMAC4 soap_in_PointerTo_tse__GetRecordingInformation(struct soap *soap, const char *tag, struct _tse__GetRecordingInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetRecordingInformation **)soap_malloc(soap, sizeof(struct _tse__GetRecordingInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetRecordingInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetRecordingInformation, sizeof(struct _tse__GetRecordingInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetRecordingInformation(struct soap *soap, struct _tse__GetRecordingInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetRecordingInformation(soap, tag ? tag : "tse:GetRecordingInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingInformation ** SOAP_FMAC4 soap_get_PointerTo_tse__GetRecordingInformation(struct soap *soap, struct _tse__GetRecordingInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetRecordingInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetRecordingSummaryResponse(struct soap *soap, struct _tse__GetRecordingSummaryResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetRecordingSummaryResponse))
		soap_serialize__tse__GetRecordingSummaryResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetRecordingSummaryResponse(struct soap *soap, const char *tag, int id, struct _tse__GetRecordingSummaryResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetRecordingSummaryResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetRecordingSummaryResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetRecordingSummaryResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__GetRecordingSummaryResponse(struct soap *soap, const char *tag, struct _tse__GetRecordingSummaryResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetRecordingSummaryResponse **)soap_malloc(soap, sizeof(struct _tse__GetRecordingSummaryResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetRecordingSummaryResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingSummaryResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetRecordingSummaryResponse, sizeof(struct _tse__GetRecordingSummaryResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetRecordingSummaryResponse(struct soap *soap, struct _tse__GetRecordingSummaryResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetRecordingSummaryResponse(soap, tag ? tag : "tse:GetRecordingSummaryResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingSummaryResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__GetRecordingSummaryResponse(struct soap *soap, struct _tse__GetRecordingSummaryResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetRecordingSummaryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetRecordingSummary(struct soap *soap, struct _tse__GetRecordingSummary *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetRecordingSummary))
		soap_serialize__tse__GetRecordingSummary(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetRecordingSummary(struct soap *soap, const char *tag, int id, struct _tse__GetRecordingSummary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetRecordingSummary, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetRecordingSummary(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetRecordingSummary ** SOAP_FMAC4 soap_in_PointerTo_tse__GetRecordingSummary(struct soap *soap, const char *tag, struct _tse__GetRecordingSummary **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetRecordingSummary **)soap_malloc(soap, sizeof(struct _tse__GetRecordingSummary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetRecordingSummary(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingSummary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetRecordingSummary, sizeof(struct _tse__GetRecordingSummary), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetRecordingSummary(struct soap *soap, struct _tse__GetRecordingSummary *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetRecordingSummary(soap, tag ? tag : "tse:GetRecordingSummary", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingSummary ** SOAP_FMAC4 soap_get_PointerTo_tse__GetRecordingSummary(struct soap *soap, struct _tse__GetRecordingSummary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetRecordingSummary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetServiceCapabilitiesResponse(struct soap *soap, struct _tse__GetServiceCapabilitiesResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetServiceCapabilitiesResponse))
		soap_serialize__tse__GetServiceCapabilitiesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, struct _tse__GetServiceCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetServiceCapabilitiesResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetServiceCapabilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tse__GetServiceCapabilitiesResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetServiceCapabilitiesResponse **)soap_malloc(soap, sizeof(struct _tse__GetServiceCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetServiceCapabilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetServiceCapabilitiesResponse, sizeof(struct _tse__GetServiceCapabilitiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetServiceCapabilitiesResponse(struct soap *soap, struct _tse__GetServiceCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetServiceCapabilitiesResponse(soap, tag ? tag : "tse:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__GetServiceCapabilitiesResponse(struct soap *soap, struct _tse__GetServiceCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetServiceCapabilities(struct soap *soap, struct _tse__GetServiceCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetServiceCapabilities))
		soap_serialize__tse__GetServiceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetServiceCapabilities(struct soap *soap, const char *tag, int id, struct _tse__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetServiceCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_tse__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tse__GetServiceCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetServiceCapabilities **)soap_malloc(soap, sizeof(struct _tse__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetServiceCapabilities, sizeof(struct _tse__GetServiceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetServiceCapabilities(struct soap *soap, struct _tse__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tse__GetServiceCapabilities(soap, tag ? tag : "tse:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_tse__GetServiceCapabilities(struct soap *soap, struct _tse__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__GetReceiverStateResponse(struct soap *soap, struct _trv__GetReceiverStateResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__GetReceiverStateResponse))
		soap_serialize__trv__GetReceiverStateResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__GetReceiverStateResponse(struct soap *soap, const char *tag, int id, struct _trv__GetReceiverStateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__GetReceiverStateResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trv__GetReceiverStateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__GetReceiverStateResponse ** SOAP_FMAC4 soap_in_PointerTo_trv__GetReceiverStateResponse(struct soap *soap, const char *tag, struct _trv__GetReceiverStateResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__GetReceiverStateResponse **)soap_malloc(soap, sizeof(struct _trv__GetReceiverStateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__GetReceiverStateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__GetReceiverStateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__GetReceiverStateResponse, sizeof(struct _trv__GetReceiverStateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__GetReceiverStateResponse(struct soap *soap, struct _trv__GetReceiverStateResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trv__GetReceiverStateResponse(soap, tag ? tag : "trv:GetReceiverStateResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetReceiverStateResponse ** SOAP_FMAC4 soap_get_PointerTo_trv__GetReceiverStateResponse(struct soap *soap, struct _trv__GetReceiverStateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__GetReceiverStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__GetReceiverState(struct soap *soap, struct _trv__GetReceiverState *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__GetReceiverState))
		soap_serialize__trv__GetReceiverState(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__GetReceiverState(struct soap *soap, const char *tag, int id, struct _trv__GetReceiverState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__GetReceiverState, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trv__GetReceiverState(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__GetReceiverState ** SOAP_FMAC4 soap_in_PointerTo_trv__GetReceiverState(struct soap *soap, const char *tag, struct _trv__GetReceiverState **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__GetReceiverState **)soap_malloc(soap, sizeof(struct _trv__GetReceiverState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__GetReceiverState(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__GetReceiverState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__GetReceiverState, sizeof(struct _trv__GetReceiverState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__GetReceiverState(struct soap *soap, struct _trv__GetReceiverState *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trv__GetReceiverState(soap, tag ? tag : "trv:GetReceiverState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetReceiverState ** SOAP_FMAC4 soap_get_PointerTo_trv__GetReceiverState(struct soap *soap, struct _trv__GetReceiverState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__GetReceiverState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__SetReceiverModeResponse(struct soap *soap, struct _trv__SetReceiverModeResponse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__SetReceiverModeResponse))
		soap_serialize__trv__SetReceiverModeResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__SetReceiverModeResponse(struct soap *soap, const char *tag, int id, struct _trv__SetReceiverModeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__SetReceiverModeResponse, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trv__SetReceiverModeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__SetReceiverModeResponse ** SOAP_FMAC4 soap_in_PointerTo_trv__SetReceiverModeResponse(struct soap *soap, const char *tag, struct _trv__SetReceiverModeResponse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__SetReceiverModeResponse **)soap_malloc(soap, sizeof(struct _trv__SetReceiverModeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__SetReceiverModeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__SetReceiverModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__SetReceiverModeResponse, sizeof(struct _trv__SetReceiverModeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__SetReceiverModeResponse(struct soap *soap, struct _trv__SetReceiverModeResponse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trv__SetReceiverModeResponse(soap, tag ? tag : "trv:SetReceiverModeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__SetReceiverModeResponse ** SOAP_FMAC4 soap_get_PointerTo_trv__SetReceiverModeResponse(struct soap *soap, struct _trv__SetReceiverModeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__SetReceiverModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__SetReceiverMode(struct soap *soap, struct _trv__SetReceiverMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__SetReceiverMode))
		soap_serialize__trv__SetReceiverMode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__SetReceiverMode(struct soap *soap, const char *tag, int id, struct _trv__SetReceiverMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__SetReceiverMode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__trv__SetReceiverMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__SetReceiverMode ** SOAP_FMAC4 soap_in_PointerTo_trv__SetReceiverMode(struct soap *soap, const char *tag, struct _trv__SetReceiverMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__SetReceiverMode **)soap_malloc(soap, sizeof(struct _trv__SetReceiverMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__SetReceiverMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__SetReceiverMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__SetReceiverMode, sizeof(struct _trv__SetReceiverMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__SetReceiverMode(struct soap *soap, struct _trv__SetReceiverMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trv__SetReceiverMode(soap, tag ? tag : "trv:SetReceiverMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__SetReceiverMode ** SOAP_FMAC4 soap_get_PointerTo_trv__SetReceiverMode(struct soap *soap, struct _trv__SetReceiverMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__SetReceiverMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
