/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:59 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__ConfigurationRef(struct soap *soap, struct ns6__ConfigurationRef *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Type);
	soap_default_tt__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__ConfigurationRef(struct soap *soap, const struct ns6__ConfigurationRef *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Type);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__ConfigurationRef(struct soap *soap, const char *tag, int id, const struct ns6__ConfigurationRef *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ConfigurationRef), type))
		return soap->error;
	if (!a->Type)
	{	if (soap_element_nil(soap, "ns6:Type"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns6:Type", -1, (char*const*)&a->Type, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "ns6:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__ConfigurationRef * SOAP_FMAC4 soap_in_ns6__ConfigurationRef(struct soap *soap, const char *tag, struct ns6__ConfigurationRef *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__ConfigurationRef *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ConfigurationRef, sizeof(struct ns6__ConfigurationRef), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__ConfigurationRef(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns6:Type", (char**)&a->Type, "xsd:string"))
				{	soap_flag_Type--;
					continue;
				}
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "ns6:Token", (char**)&a->Token, "tt:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns6__ConfigurationRef *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ConfigurationRef, SOAP_TYPE_ns6__ConfigurationRef, sizeof(struct ns6__ConfigurationRef), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns6__ConfigurationRef * SOAP_FMAC4 soap_new_ns6__ConfigurationRef(struct soap *soap, int n)
{
	struct ns6__ConfigurationRef *p;
	struct ns6__ConfigurationRef *a = (struct ns6__ConfigurationRef*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns6__ConfigurationRef));
	for (p = a; p && n--; p++)
		soap_default_ns6__ConfigurationRef(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__ConfigurationRef(struct soap *soap, const struct ns6__ConfigurationRef *a, const char *tag, const char *type)
{
	if (soap_out_ns6__ConfigurationRef(soap, tag ? tag : "ns6:ConfigurationRef", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns6__ConfigurationRef * SOAP_FMAC4 soap_get_ns6__ConfigurationRef(struct soap *soap, struct ns6__ConfigurationRef *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__ConfigurationRef(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__StreamingCapabilities(struct soap *soap, struct ns6__StreamingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RTSPStreaming = NULL;
	a->RTPMulticast = NULL;
	a->RTP_USCORERTSP_USCORETCP = NULL;
	a->NonAggregateControl = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__StreamingCapabilities(struct soap *soap, const struct ns6__StreamingCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__StreamingCapabilities(struct soap *soap, const char *tag, int id, const struct ns6__StreamingCapabilities *a, const char *type)
{
	if (a->RTSPStreaming)
		soap_set_attr(soap, "RTSPStreaming", soap_xsd__boolean2s(soap, *a->RTSPStreaming), 1);
	if (a->RTPMulticast)
		soap_set_attr(soap, "RTPMulticast", soap_xsd__boolean2s(soap, *a->RTPMulticast), 1);
	if (a->RTP_USCORERTSP_USCORETCP)
		soap_set_attr(soap, "RTP_RTSP_TCP", soap_xsd__boolean2s(soap, *a->RTP_USCORERTSP_USCORETCP), 1);
	if (a->NonAggregateControl)
		soap_set_attr(soap, "NonAggregateControl", soap_xsd__boolean2s(soap, *a->NonAggregateControl), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__StreamingCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__StreamingCapabilities * SOAP_FMAC4 soap_in_ns6__StreamingCapabilities(struct soap *soap, const char *tag, struct ns6__StreamingCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__StreamingCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__StreamingCapabilities, sizeof(struct ns6__StreamingCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__StreamingCapabilities(soap, a);
	{	const char *t = soap_attr_value(soap, "RTSPStreaming", 0);
		if (t)
		{
			if (!(a->RTSPStreaming = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->RTSPStreaming))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "RTPMulticast", 0);
		if (t)
		{
			if (!(a->RTPMulticast = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->RTPMulticast))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "RTP_RTSP_TCP", 0);
		if (t)
		{
			if (!(a->RTP_USCORERTSP_USCORETCP = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->RTP_USCORERTSP_USCORETCP))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "NonAggregateControl", 0);
		if (t)
		{
			if (!(a->NonAggregateControl = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->NonAggregateControl))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__StreamingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__StreamingCapabilities, SOAP_TYPE_ns6__StreamingCapabilities, sizeof(struct ns6__StreamingCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns6__StreamingCapabilities * SOAP_FMAC4 soap_new_ns6__StreamingCapabilities(struct soap *soap, int n)
{
	struct ns6__StreamingCapabilities *p;
	struct ns6__StreamingCapabilities *a = (struct ns6__StreamingCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns6__StreamingCapabilities));
	for (p = a; p && n--; p++)
		soap_default_ns6__StreamingCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__StreamingCapabilities(struct soap *soap, const struct ns6__StreamingCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_ns6__StreamingCapabilities(soap, tag ? tag : "ns6:StreamingCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns6__StreamingCapabilities * SOAP_FMAC4 soap_get_ns6__StreamingCapabilities(struct soap *soap, struct ns6__StreamingCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__StreamingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__ProfileCapabilities(struct soap *soap, struct ns6__ProfileCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MaximumNumberOfProfiles = NULL;
	soap_default_tt__StringAttrList(soap, &a->ConfigurationsSupported);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__ProfileCapabilities(struct soap *soap, const struct ns6__ProfileCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__ProfileCapabilities(struct soap *soap, const char *tag, int id, const struct ns6__ProfileCapabilities *a, const char *type)
{
	if (a->MaximumNumberOfProfiles)
		soap_set_attr(soap, "MaximumNumberOfProfiles", soap_int2s(soap, *a->MaximumNumberOfProfiles), 1);
	if (a->ConfigurationsSupported)
		soap_set_attr(soap, "ConfigurationsSupported", soap_tt__StringAttrList2s(soap, a->ConfigurationsSupported), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__ProfileCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__ProfileCapabilities * SOAP_FMAC4 soap_in_ns6__ProfileCapabilities(struct soap *soap, const char *tag, struct ns6__ProfileCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__ProfileCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__ProfileCapabilities, sizeof(struct ns6__ProfileCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__ProfileCapabilities(soap, a);
	{	const char *t = soap_attr_value(soap, "MaximumNumberOfProfiles", 0);
		if (t)
		{
			if (!(a->MaximumNumberOfProfiles = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->MaximumNumberOfProfiles))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2tt__StringAttrList(soap, soap_attr_value(soap, "ConfigurationsSupported", 0), &a->ConfigurationsSupported))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__ProfileCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__ProfileCapabilities, SOAP_TYPE_ns6__ProfileCapabilities, sizeof(struct ns6__ProfileCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns6__ProfileCapabilities * SOAP_FMAC4 soap_new_ns6__ProfileCapabilities(struct soap *soap, int n)
{
	struct ns6__ProfileCapabilities *p;
	struct ns6__ProfileCapabilities *a = (struct ns6__ProfileCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns6__ProfileCapabilities));
	for (p = a; p && n--; p++)
		soap_default_ns6__ProfileCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__ProfileCapabilities(struct soap *soap, const struct ns6__ProfileCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_ns6__ProfileCapabilities(soap, tag ? tag : "ns6:ProfileCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns6__ProfileCapabilities * SOAP_FMAC4 soap_get_ns6__ProfileCapabilities(struct soap *soap, struct ns6__ProfileCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__ProfileCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__Capabilities2(struct soap *soap, struct ns6__Capabilities2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ProfileCapabilities = NULL;
	a->StreamingCapabilities = NULL;
	a->SnapshotUri = NULL;
	a->Rotation = NULL;
	a->VideoSourceMode = NULL;
	a->OSD = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__Capabilities2(struct soap *soap, const struct ns6__Capabilities2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons6__ProfileCapabilities(soap, &a->ProfileCapabilities);
	soap_serialize_PointerTons6__StreamingCapabilities(soap, &a->StreamingCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__Capabilities2(struct soap *soap, const char *tag, int id, const struct ns6__Capabilities2 *a, const char *type)
{
	if (a->SnapshotUri)
		soap_set_attr(soap, "SnapshotUri", soap_xsd__boolean2s(soap, *a->SnapshotUri), 1);
	if (a->Rotation)
		soap_set_attr(soap, "Rotation", soap_xsd__boolean2s(soap, *a->Rotation), 1);
	if (a->VideoSourceMode)
		soap_set_attr(soap, "VideoSourceMode", soap_xsd__boolean2s(soap, *a->VideoSourceMode), 1);
	if (a->OSD)
		soap_set_attr(soap, "OSD", soap_xsd__boolean2s(soap, *a->OSD), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__Capabilities2), type))
		return soap->error;
	if (!a->ProfileCapabilities)
	{	if (soap_element_nil(soap, "ns6:ProfileCapabilities"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons6__ProfileCapabilities(soap, "ns6:ProfileCapabilities", -1, &a->ProfileCapabilities, ""))
		return soap->error;
	if (!a->StreamingCapabilities)
	{	if (soap_element_nil(soap, "ns6:StreamingCapabilities"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons6__StreamingCapabilities(soap, "ns6:StreamingCapabilities", -1, &a->StreamingCapabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__Capabilities2 * SOAP_FMAC4 soap_in_ns6__Capabilities2(struct soap *soap, const char *tag, struct ns6__Capabilities2 *a, const char *type)
{
	size_t soap_flag_ProfileCapabilities = 1;
	size_t soap_flag_StreamingCapabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__Capabilities2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__Capabilities2, sizeof(struct ns6__Capabilities2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__Capabilities2(soap, a);
	{	const char *t = soap_attr_value(soap, "SnapshotUri", 0);
		if (t)
		{
			if (!(a->SnapshotUri = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->SnapshotUri))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Rotation", 0);
		if (t)
		{
			if (!(a->Rotation = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->Rotation))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "VideoSourceMode", 0);
		if (t)
		{
			if (!(a->VideoSourceMode = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->VideoSourceMode))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "OSD", 0);
		if (t)
		{
			if (!(a->OSD = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->OSD))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileCapabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__ProfileCapabilities(soap, "ns6:ProfileCapabilities", &a->ProfileCapabilities, "ns6:ProfileCapabilities"))
				{	soap_flag_ProfileCapabilities--;
					continue;
				}
			if (soap_flag_StreamingCapabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons6__StreamingCapabilities(soap, "ns6:StreamingCapabilities", &a->StreamingCapabilities, "ns6:StreamingCapabilities"))
				{	soap_flag_StreamingCapabilities--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileCapabilities > 0 || soap_flag_StreamingCapabilities > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns6__Capabilities2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__Capabilities2, SOAP_TYPE_ns6__Capabilities2, sizeof(struct ns6__Capabilities2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns6__Capabilities2 * SOAP_FMAC4 soap_new_ns6__Capabilities2(struct soap *soap, int n)
{
	struct ns6__Capabilities2 *p;
	struct ns6__Capabilities2 *a = (struct ns6__Capabilities2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns6__Capabilities2));
	for (p = a; p && n--; p++)
		soap_default_ns6__Capabilities2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__Capabilities2(struct soap *soap, const struct ns6__Capabilities2 *a, const char *tag, const char *type)
{
	if (soap_out_ns6__Capabilities2(soap, tag ? tag : "ns6:Capabilities2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns6__Capabilities2 * SOAP_FMAC4 soap_get_ns6__Capabilities2(struct soap *soap, struct ns6__Capabilities2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__Capabilities2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__DeleteOSDResponse(struct soap *soap, struct _trt__DeleteOSDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__DeleteOSDResponse(struct soap *soap, const struct _trt__DeleteOSDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__DeleteOSDResponse(struct soap *soap, const char *tag, int id, const struct _trt__DeleteOSDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__DeleteOSDResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__DeleteOSDResponse * SOAP_FMAC4 soap_in__trt__DeleteOSDResponse(struct soap *soap, const char *tag, struct _trt__DeleteOSDResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__DeleteOSDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__DeleteOSDResponse, sizeof(struct _trt__DeleteOSDResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__DeleteOSDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__DeleteOSDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__DeleteOSDResponse, SOAP_TYPE__trt__DeleteOSDResponse, sizeof(struct _trt__DeleteOSDResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__DeleteOSDResponse * SOAP_FMAC4 soap_new__trt__DeleteOSDResponse(struct soap *soap, int n)
{
	struct _trt__DeleteOSDResponse *p;
	struct _trt__DeleteOSDResponse *a = (struct _trt__DeleteOSDResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__DeleteOSDResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__DeleteOSDResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__DeleteOSDResponse(struct soap *soap, const struct _trt__DeleteOSDResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__DeleteOSDResponse(soap, tag ? tag : "trt:DeleteOSDResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__DeleteOSDResponse * SOAP_FMAC4 soap_get__trt__DeleteOSDResponse(struct soap *soap, struct _trt__DeleteOSDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__DeleteOSDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__DeleteOSD(struct soap *soap, struct _trt__DeleteOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->OSDToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__DeleteOSD(struct soap *soap, const struct _trt__DeleteOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->OSDToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__DeleteOSD(struct soap *soap, const char *tag, int id, const struct _trt__DeleteOSD *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__DeleteOSD), type))
		return soap->error;
	if (!a->OSDToken)
	{	if (soap_element_nil(soap, "trt:OSDToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:OSDToken", -1, (char*const*)&a->OSDToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__DeleteOSD * SOAP_FMAC4 soap_in__trt__DeleteOSD(struct soap *soap, const char *tag, struct _trt__DeleteOSD *a, const char *type)
{
	size_t soap_flag_OSDToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__DeleteOSD *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__DeleteOSD, sizeof(struct _trt__DeleteOSD), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__DeleteOSD(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OSDToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:OSDToken", (char**)&a->OSDToken, "tt:ReferenceToken"))
				{	soap_flag_OSDToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OSDToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__DeleteOSD *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__DeleteOSD, SOAP_TYPE__trt__DeleteOSD, sizeof(struct _trt__DeleteOSD), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__DeleteOSD * SOAP_FMAC4 soap_new__trt__DeleteOSD(struct soap *soap, int n)
{
	struct _trt__DeleteOSD *p;
	struct _trt__DeleteOSD *a = (struct _trt__DeleteOSD*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__DeleteOSD));
	for (p = a; p && n--; p++)
		soap_default__trt__DeleteOSD(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__DeleteOSD(struct soap *soap, const struct _trt__DeleteOSD *a, const char *tag, const char *type)
{
	if (soap_out__trt__DeleteOSD(soap, tag ? tag : "trt:DeleteOSD", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__DeleteOSD * SOAP_FMAC4 soap_get__trt__DeleteOSD(struct soap *soap, struct _trt__DeleteOSD *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__DeleteOSD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__CreateOSDResponse(struct soap *soap, struct _trt__CreateOSDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->OSDToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__CreateOSDResponse(struct soap *soap, const struct _trt__CreateOSDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->OSDToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__CreateOSDResponse(struct soap *soap, const char *tag, int id, const struct _trt__CreateOSDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__CreateOSDResponse), type))
		return soap->error;
	if (a->OSDToken)
		soap_element_result(soap, "trt:OSDToken");
	if (!a->OSDToken)
	{	if (soap_element_nil(soap, "trt:OSDToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:OSDToken", -1, (char*const*)&a->OSDToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__CreateOSDResponse * SOAP_FMAC4 soap_in__trt__CreateOSDResponse(struct soap *soap, const char *tag, struct _trt__CreateOSDResponse *a, const char *type)
{
	size_t soap_flag_OSDToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__CreateOSDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__CreateOSDResponse, sizeof(struct _trt__CreateOSDResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__CreateOSDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OSDToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:OSDToken", (char**)&a->OSDToken, "tt:ReferenceToken"))
				{	soap_flag_OSDToken--;
					continue;
				}
			soap_check_result(soap, "trt:OSDToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OSDToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__CreateOSDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__CreateOSDResponse, SOAP_TYPE__trt__CreateOSDResponse, sizeof(struct _trt__CreateOSDResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__CreateOSDResponse * SOAP_FMAC4 soap_new__trt__CreateOSDResponse(struct soap *soap, int n)
{
	struct _trt__CreateOSDResponse *p;
	struct _trt__CreateOSDResponse *a = (struct _trt__CreateOSDResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__CreateOSDResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__CreateOSDResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__CreateOSDResponse(struct soap *soap, const struct _trt__CreateOSDResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__CreateOSDResponse(soap, tag ? tag : "trt:CreateOSDResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__CreateOSDResponse * SOAP_FMAC4 soap_get__trt__CreateOSDResponse(struct soap *soap, struct _trt__CreateOSDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__CreateOSDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__CreateOSD(struct soap *soap, struct _trt__CreateOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->OSD = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__CreateOSD(struct soap *soap, const struct _trt__CreateOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__OSDConfiguration(soap, &a->OSD);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__CreateOSD(struct soap *soap, const char *tag, int id, const struct _trt__CreateOSD *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__CreateOSD), type))
		return soap->error;
	if (!a->OSD)
	{	if (soap_element_nil(soap, "trt:OSD"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__OSDConfiguration(soap, "trt:OSD", -1, &a->OSD, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__CreateOSD * SOAP_FMAC4 soap_in__trt__CreateOSD(struct soap *soap, const char *tag, struct _trt__CreateOSD *a, const char *type)
{
	size_t soap_flag_OSD = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__CreateOSD *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__CreateOSD, sizeof(struct _trt__CreateOSD), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__CreateOSD(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OSD && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__OSDConfiguration(soap, "trt:OSD", &a->OSD, "tt:OSDConfiguration"))
				{	soap_flag_OSD--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OSD > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__CreateOSD *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__CreateOSD, SOAP_TYPE__trt__CreateOSD, sizeof(struct _trt__CreateOSD), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__CreateOSD * SOAP_FMAC4 soap_new__trt__CreateOSD(struct soap *soap, int n)
{
	struct _trt__CreateOSD *p;
	struct _trt__CreateOSD *a = (struct _trt__CreateOSD*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__CreateOSD));
	for (p = a; p && n--; p++)
		soap_default__trt__CreateOSD(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__CreateOSD(struct soap *soap, const struct _trt__CreateOSD *a, const char *tag, const char *type)
{
	if (soap_out__trt__CreateOSD(soap, tag ? tag : "trt:CreateOSD", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__CreateOSD * SOAP_FMAC4 soap_get__trt__CreateOSD(struct soap *soap, struct _trt__CreateOSD *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__CreateOSD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetOSDOptionsResponse(struct soap *soap, struct _trt__GetOSDOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->OSDOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetOSDOptionsResponse(struct soap *soap, const struct _trt__GetOSDOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__OSDConfigurationOptions(soap, &a->OSDOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetOSDOptionsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetOSDOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetOSDOptionsResponse), type))
		return soap->error;
	if (a->OSDOptions)
		soap_element_result(soap, "trt:OSDOptions");
	if (!a->OSDOptions)
	{	if (soap_element_nil(soap, "trt:OSDOptions"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__OSDConfigurationOptions(soap, "trt:OSDOptions", -1, &a->OSDOptions, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetOSDOptionsResponse * SOAP_FMAC4 soap_in__trt__GetOSDOptionsResponse(struct soap *soap, const char *tag, struct _trt__GetOSDOptionsResponse *a, const char *type)
{
	size_t soap_flag_OSDOptions = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetOSDOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetOSDOptionsResponse, sizeof(struct _trt__GetOSDOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetOSDOptionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OSDOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__OSDConfigurationOptions(soap, "trt:OSDOptions", &a->OSDOptions, "tt:OSDConfigurationOptions"))
				{	soap_flag_OSDOptions--;
					continue;
				}
			soap_check_result(soap, "trt:OSDOptions");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OSDOptions > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetOSDOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetOSDOptionsResponse, SOAP_TYPE__trt__GetOSDOptionsResponse, sizeof(struct _trt__GetOSDOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetOSDOptionsResponse * SOAP_FMAC4 soap_new__trt__GetOSDOptionsResponse(struct soap *soap, int n)
{
	struct _trt__GetOSDOptionsResponse *p;
	struct _trt__GetOSDOptionsResponse *a = (struct _trt__GetOSDOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetOSDOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetOSDOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetOSDOptionsResponse(struct soap *soap, const struct _trt__GetOSDOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetOSDOptionsResponse(soap, tag ? tag : "trt:GetOSDOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetOSDOptionsResponse * SOAP_FMAC4 soap_get__trt__GetOSDOptionsResponse(struct soap *soap, struct _trt__GetOSDOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetOSDOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetOSDOptions(struct soap *soap, struct _trt__GetOSDOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetOSDOptions(struct soap *soap, const struct _trt__GetOSDOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetOSDOptions(struct soap *soap, const char *tag, int id, const struct _trt__GetOSDOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetOSDOptions), type))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_nil(soap, "trt:ConfigurationToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetOSDOptions * SOAP_FMAC4 soap_in__trt__GetOSDOptions(struct soap *soap, const char *tag, struct _trt__GetOSDOptions *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetOSDOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetOSDOptions, sizeof(struct _trt__GetOSDOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetOSDOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetOSDOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetOSDOptions, SOAP_TYPE__trt__GetOSDOptions, sizeof(struct _trt__GetOSDOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetOSDOptions * SOAP_FMAC4 soap_new__trt__GetOSDOptions(struct soap *soap, int n)
{
	struct _trt__GetOSDOptions *p;
	struct _trt__GetOSDOptions *a = (struct _trt__GetOSDOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetOSDOptions));
	for (p = a; p && n--; p++)
		soap_default__trt__GetOSDOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetOSDOptions(struct soap *soap, const struct _trt__GetOSDOptions *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetOSDOptions(soap, tag ? tag : "trt:GetOSDOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetOSDOptions * SOAP_FMAC4 soap_get__trt__GetOSDOptions(struct soap *soap, struct _trt__GetOSDOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetOSDOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__SetOSDResponse(struct soap *soap, struct _trt__SetOSDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__SetOSDResponse(struct soap *soap, const struct _trt__SetOSDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__SetOSDResponse(struct soap *soap, const char *tag, int id, const struct _trt__SetOSDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__SetOSDResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__SetOSDResponse * SOAP_FMAC4 soap_in__trt__SetOSDResponse(struct soap *soap, const char *tag, struct _trt__SetOSDResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__SetOSDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetOSDResponse, sizeof(struct _trt__SetOSDResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__SetOSDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__SetOSDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetOSDResponse, SOAP_TYPE__trt__SetOSDResponse, sizeof(struct _trt__SetOSDResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__SetOSDResponse * SOAP_FMAC4 soap_new__trt__SetOSDResponse(struct soap *soap, int n)
{
	struct _trt__SetOSDResponse *p;
	struct _trt__SetOSDResponse *a = (struct _trt__SetOSDResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__SetOSDResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__SetOSDResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__SetOSDResponse(struct soap *soap, const struct _trt__SetOSDResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__SetOSDResponse(soap, tag ? tag : "trt:SetOSDResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetOSDResponse * SOAP_FMAC4 soap_get__trt__SetOSDResponse(struct soap *soap, struct _trt__SetOSDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__SetOSDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__SetOSD(struct soap *soap, struct _trt__SetOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->OSD = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__SetOSD(struct soap *soap, const struct _trt__SetOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__OSDConfiguration(soap, &a->OSD);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__SetOSD(struct soap *soap, const char *tag, int id, const struct _trt__SetOSD *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__SetOSD), type))
		return soap->error;
	if (!a->OSD)
	{	if (soap_element_nil(soap, "trt:OSD"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__OSDConfiguration(soap, "trt:OSD", -1, &a->OSD, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__SetOSD * SOAP_FMAC4 soap_in__trt__SetOSD(struct soap *soap, const char *tag, struct _trt__SetOSD *a, const char *type)
{
	size_t soap_flag_OSD = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__SetOSD *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetOSD, sizeof(struct _trt__SetOSD), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__SetOSD(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OSD && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__OSDConfiguration(soap, "trt:OSD", &a->OSD, "tt:OSDConfiguration"))
				{	soap_flag_OSD--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OSD > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__SetOSD *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetOSD, SOAP_TYPE__trt__SetOSD, sizeof(struct _trt__SetOSD), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__SetOSD * SOAP_FMAC4 soap_new__trt__SetOSD(struct soap *soap, int n)
{
	struct _trt__SetOSD *p;
	struct _trt__SetOSD *a = (struct _trt__SetOSD*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__SetOSD));
	for (p = a; p && n--; p++)
		soap_default__trt__SetOSD(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__SetOSD(struct soap *soap, const struct _trt__SetOSD *a, const char *tag, const char *type)
{
	if (soap_out__trt__SetOSD(soap, tag ? tag : "trt:SetOSD", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetOSD * SOAP_FMAC4 soap_get__trt__SetOSD(struct soap *soap, struct _trt__SetOSD *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__SetOSD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetOSDResponse(struct soap *soap, struct _trt__GetOSDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->OSD = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetOSDResponse(struct soap *soap, const struct _trt__GetOSDResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__OSDConfiguration(soap, &a->OSD);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetOSDResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetOSDResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetOSDResponse), type))
		return soap->error;
	if (a->OSD)
		soap_element_result(soap, "trt:OSD");
	if (!a->OSD)
	{	if (soap_element_nil(soap, "trt:OSD"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__OSDConfiguration(soap, "trt:OSD", -1, &a->OSD, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetOSDResponse * SOAP_FMAC4 soap_in__trt__GetOSDResponse(struct soap *soap, const char *tag, struct _trt__GetOSDResponse *a, const char *type)
{
	size_t soap_flag_OSD = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetOSDResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetOSDResponse, sizeof(struct _trt__GetOSDResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetOSDResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OSD && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__OSDConfiguration(soap, "trt:OSD", &a->OSD, "tt:OSDConfiguration"))
				{	soap_flag_OSD--;
					continue;
				}
			soap_check_result(soap, "trt:OSD");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OSD > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetOSDResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetOSDResponse, SOAP_TYPE__trt__GetOSDResponse, sizeof(struct _trt__GetOSDResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetOSDResponse * SOAP_FMAC4 soap_new__trt__GetOSDResponse(struct soap *soap, int n)
{
	struct _trt__GetOSDResponse *p;
	struct _trt__GetOSDResponse *a = (struct _trt__GetOSDResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetOSDResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetOSDResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetOSDResponse(struct soap *soap, const struct _trt__GetOSDResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetOSDResponse(soap, tag ? tag : "trt:GetOSDResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetOSDResponse * SOAP_FMAC4 soap_get__trt__GetOSDResponse(struct soap *soap, struct _trt__GetOSDResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetOSDResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetOSD(struct soap *soap, struct _trt__GetOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->OSDToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetOSD(struct soap *soap, const struct _trt__GetOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->OSDToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetOSD(struct soap *soap, const char *tag, int id, const struct _trt__GetOSD *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetOSD), type))
		return soap->error;
	if (!a->OSDToken)
	{	if (soap_element_nil(soap, "trt:OSDToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:OSDToken", -1, (char*const*)&a->OSDToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetOSD * SOAP_FMAC4 soap_in__trt__GetOSD(struct soap *soap, const char *tag, struct _trt__GetOSD *a, const char *type)
{
	size_t soap_flag_OSDToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetOSD *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetOSD, sizeof(struct _trt__GetOSD), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetOSD(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OSDToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:OSDToken", (char**)&a->OSDToken, "tt:ReferenceToken"))
				{	soap_flag_OSDToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_OSDToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetOSD *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetOSD, SOAP_TYPE__trt__GetOSD, sizeof(struct _trt__GetOSD), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetOSD * SOAP_FMAC4 soap_new__trt__GetOSD(struct soap *soap, int n)
{
	struct _trt__GetOSD *p;
	struct _trt__GetOSD *a = (struct _trt__GetOSD*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetOSD));
	for (p = a; p && n--; p++)
		soap_default__trt__GetOSD(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetOSD(struct soap *soap, const struct _trt__GetOSD *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetOSD(soap, tag ? tag : "trt:GetOSD", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetOSD * SOAP_FMAC4 soap_get__trt__GetOSD(struct soap *soap, struct _trt__GetOSD *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetOSD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDConfiguration(struct soap *soap, struct tt__OSDConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->VideoSourceConfigurationToken = NULL;
	soap_default_tt__OSDType(soap, &a->Type);
	a->Position = NULL;
	a->TextString = NULL;
	a->Image = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDConfiguration(struct soap *soap, const struct tt__OSDConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__OSDReference(soap, &a->VideoSourceConfigurationToken);
	soap_embedded(soap, &a->Type, SOAP_TYPE_tt__OSDType);
	soap_serialize_PointerTott__OSDPosConfiguration(soap, &a->Position);
	soap_serialize_PointerTott__OSDTextConfiguration(soap, &a->TextString);
	soap_serialize_PointerTott__OSDImgConfiguration(soap, &a->Image);
	soap_serialize_PointerTott__OSDConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDConfiguration(struct soap *soap, const char *tag, int id, const struct tt__OSDConfiguration *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, a->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDConfiguration), type))
		return soap->error;
	if (!a->VideoSourceConfigurationToken)
	{	if (soap_element_nil(soap, "tt:VideoSourceConfigurationToken"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__OSDReference(soap, "tt:VideoSourceConfigurationToken", -1, &a->VideoSourceConfigurationToken, ""))
		return soap->error;
	if (soap_out_tt__OSDType(soap, "tt:Type", -1, &a->Type, ""))
		return soap->error;
	if (!a->Position)
	{	if (soap_element_nil(soap, "tt:Position"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__OSDPosConfiguration(soap, "tt:Position", -1, &a->Position, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDTextConfiguration(soap, "tt:TextString", -1, &a->TextString, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDImgConfiguration(soap, "tt:Image", -1, &a->Image, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OSDConfiguration * SOAP_FMAC4 soap_in_tt__OSDConfiguration(struct soap *soap, const char *tag, struct tt__OSDConfiguration *a, const char *type)
{
	size_t soap_flag_VideoSourceConfigurationToken = 1;
	size_t soap_flag_Type = 1;
	size_t soap_flag_Position = 1;
	size_t soap_flag_TextString = 1;
	size_t soap_flag_Image = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__OSDConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDConfiguration, sizeof(struct tt__OSDConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OSDConfiguration(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceConfigurationToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__OSDReference(soap, "tt:VideoSourceConfigurationToken", &a->VideoSourceConfigurationToken, "tt:OSDReference"))
				{	soap_flag_VideoSourceConfigurationToken--;
					continue;
				}
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__OSDType(soap, "tt:Type", &a->Type, "tt:OSDType"))
				{	soap_flag_Type--;
					continue;
				}
			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__OSDPosConfiguration(soap, "tt:Position", &a->Position, "tt:OSDPosConfiguration"))
				{	soap_flag_Position--;
					continue;
				}
			if (soap_flag_TextString && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__OSDTextConfiguration(soap, "tt:TextString", &a->TextString, "tt:OSDTextConfiguration"))
				{	soap_flag_TextString--;
					continue;
				}
			if (soap_flag_Image && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__OSDImgConfiguration(soap, "tt:Image", &a->Image, "tt:OSDImgConfiguration"))
				{	soap_flag_Image--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__OSDConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:OSDConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoSourceConfigurationToken > 0 || soap_flag_Type > 0 || soap_flag_Position > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__OSDConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDConfiguration, SOAP_TYPE_tt__OSDConfiguration, sizeof(struct tt__OSDConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OSDConfiguration * SOAP_FMAC4 soap_new_tt__OSDConfiguration(struct soap *soap, int n)
{
	struct tt__OSDConfiguration *p;
	struct tt__OSDConfiguration *a = (struct tt__OSDConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDConfiguration(struct soap *soap, const struct tt__OSDConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDConfiguration(soap, tag ? tag : "tt:OSDConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDConfiguration * SOAP_FMAC4 soap_get_tt__OSDConfiguration(struct soap *soap, struct tt__OSDConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetOSDsResponse(struct soap *soap, struct _trt__GetOSDsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeOSDs = 0;
	a->OSDs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetOSDsResponse(struct soap *soap, const struct _trt__GetOSDsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->OSDs)
	{	int i;
		for (i = 0; i < (int)a->__sizeOSDs; i++)
		{
			soap_embedded(soap, a->OSDs + i, SOAP_TYPE_tt__OSDConfiguration);
			soap_serialize_tt__OSDConfiguration(soap, a->OSDs + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetOSDsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetOSDsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetOSDsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeOSDs");
	if (a->OSDs)
	{	int i;
		for (i = 0; i < (int)a->__sizeOSDs; i++)
			if (soap_out_tt__OSDConfiguration(soap, "trt:OSDs", -1, a->OSDs + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetOSDsResponse * SOAP_FMAC4 soap_in__trt__GetOSDsResponse(struct soap *soap, const char *tag, struct _trt__GetOSDsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_OSDs = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetOSDsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetOSDsResponse, sizeof(struct _trt__GetOSDsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetOSDsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:OSDs", 1, NULL))
			{	if (a->OSDs == NULL)
				{	if (soap_blist_OSDs == NULL)
						soap_blist_OSDs = soap_alloc_block(soap);
					a->OSDs = (struct tt__OSDConfiguration *)soap_push_block_max(soap, soap_blist_OSDs, sizeof(struct tt__OSDConfiguration));
					if (a->OSDs == NULL)
						return NULL;
					soap_default_tt__OSDConfiguration(soap, a->OSDs);
				}
				soap_revert(soap);
				if (soap_in_tt__OSDConfiguration(soap, "trt:OSDs", a->OSDs, "tt:OSDConfiguration"))
				{	a->__sizeOSDs++;
					a->OSDs = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeOSDs");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->OSDs)
			soap_pop_block(soap, soap_blist_OSDs);
		if (a->__sizeOSDs)
		{	a->OSDs = (struct tt__OSDConfiguration *)soap_save_block(soap, soap_blist_OSDs, NULL, 1);
		}
		else
		{	a->OSDs = NULL;
			if (soap_blist_OSDs)
				soap_end_block(soap, soap_blist_OSDs);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetOSDsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetOSDsResponse, SOAP_TYPE__trt__GetOSDsResponse, sizeof(struct _trt__GetOSDsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetOSDsResponse * SOAP_FMAC4 soap_new__trt__GetOSDsResponse(struct soap *soap, int n)
{
	struct _trt__GetOSDsResponse *p;
	struct _trt__GetOSDsResponse *a = (struct _trt__GetOSDsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetOSDsResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetOSDsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetOSDsResponse(struct soap *soap, const struct _trt__GetOSDsResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetOSDsResponse(soap, tag ? tag : "trt:GetOSDsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetOSDsResponse * SOAP_FMAC4 soap_get__trt__GetOSDsResponse(struct soap *soap, struct _trt__GetOSDsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetOSDsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetOSDs(struct soap *soap, struct _trt__GetOSDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetOSDs(struct soap *soap, const struct _trt__GetOSDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetOSDs(struct soap *soap, const char *tag, int id, const struct _trt__GetOSDs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetOSDs), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetOSDs * SOAP_FMAC4 soap_in__trt__GetOSDs(struct soap *soap, const char *tag, struct _trt__GetOSDs *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetOSDs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetOSDs, sizeof(struct _trt__GetOSDs), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetOSDs(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetOSDs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetOSDs, SOAP_TYPE__trt__GetOSDs, sizeof(struct _trt__GetOSDs), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetOSDs * SOAP_FMAC4 soap_new__trt__GetOSDs(struct soap *soap, int n)
{
	struct _trt__GetOSDs *p;
	struct _trt__GetOSDs *a = (struct _trt__GetOSDs*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetOSDs));
	for (p = a; p && n--; p++)
		soap_default__trt__GetOSDs(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetOSDs(struct soap *soap, const struct _trt__GetOSDs *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetOSDs(soap, tag ? tag : "trt:GetOSDs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetOSDs * SOAP_FMAC4 soap_get__trt__GetOSDs(struct soap *soap, struct _trt__GetOSDs *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetOSDs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__SetVideoSourceModeResponse(struct soap *soap, struct _trt__SetVideoSourceModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->Reboot);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__SetVideoSourceModeResponse(struct soap *soap, const struct _trt__SetVideoSourceModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Reboot, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__SetVideoSourceModeResponse(struct soap *soap, const char *tag, int id, const struct _trt__SetVideoSourceModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__SetVideoSourceModeResponse), type))
		return soap->error;
	soap_element_result(soap, "trt:Reboot");
	if (soap_out_xsd__boolean(soap, "trt:Reboot", -1, &a->Reboot, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__SetVideoSourceModeResponse * SOAP_FMAC4 soap_in__trt__SetVideoSourceModeResponse(struct soap *soap, const char *tag, struct _trt__SetVideoSourceModeResponse *a, const char *type)
{
	size_t soap_flag_Reboot = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__SetVideoSourceModeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetVideoSourceModeResponse, sizeof(struct _trt__SetVideoSourceModeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__SetVideoSourceModeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Reboot && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "trt:Reboot", &a->Reboot, "xsd:boolean"))
				{	soap_flag_Reboot--;
					continue;
				}
			soap_check_result(soap, "trt:Reboot");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Reboot > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__SetVideoSourceModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetVideoSourceModeResponse, SOAP_TYPE__trt__SetVideoSourceModeResponse, sizeof(struct _trt__SetVideoSourceModeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__SetVideoSourceModeResponse * SOAP_FMAC4 soap_new__trt__SetVideoSourceModeResponse(struct soap *soap, int n)
{
	struct _trt__SetVideoSourceModeResponse *p;
	struct _trt__SetVideoSourceModeResponse *a = (struct _trt__SetVideoSourceModeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__SetVideoSourceModeResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__SetVideoSourceModeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__SetVideoSourceModeResponse(struct soap *soap, const struct _trt__SetVideoSourceModeResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__SetVideoSourceModeResponse(soap, tag ? tag : "trt:SetVideoSourceModeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetVideoSourceModeResponse * SOAP_FMAC4 soap_get__trt__SetVideoSourceModeResponse(struct soap *soap, struct _trt__SetVideoSourceModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__SetVideoSourceModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__SetVideoSourceMode(struct soap *soap, struct _trt__SetVideoSourceMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceModeToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__SetVideoSourceMode(struct soap *soap, const struct _trt__SetVideoSourceMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoSourceToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoSourceModeToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__SetVideoSourceMode(struct soap *soap, const char *tag, int id, const struct _trt__SetVideoSourceMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__SetVideoSourceMode), type))
		return soap->error;
	if (!a->VideoSourceToken)
	{	if (soap_element_nil(soap, "trt:VideoSourceToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:VideoSourceToken", -1, (char*const*)&a->VideoSourceToken, ""))
		return soap->error;
	if (!a->VideoSourceModeToken)
	{	if (soap_element_nil(soap, "trt:VideoSourceModeToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:VideoSourceModeToken", -1, (char*const*)&a->VideoSourceModeToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__SetVideoSourceMode * SOAP_FMAC4 soap_in__trt__SetVideoSourceMode(struct soap *soap, const char *tag, struct _trt__SetVideoSourceMode *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	size_t soap_flag_VideoSourceModeToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__SetVideoSourceMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetVideoSourceMode, sizeof(struct _trt__SetVideoSourceMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__SetVideoSourceMode(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:VideoSourceToken", (char**)&a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			if (soap_flag_VideoSourceModeToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:VideoSourceModeToken", (char**)&a->VideoSourceModeToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceModeToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoSourceToken > 0 || soap_flag_VideoSourceModeToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__SetVideoSourceMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetVideoSourceMode, SOAP_TYPE__trt__SetVideoSourceMode, sizeof(struct _trt__SetVideoSourceMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__SetVideoSourceMode * SOAP_FMAC4 soap_new__trt__SetVideoSourceMode(struct soap *soap, int n)
{
	struct _trt__SetVideoSourceMode *p;
	struct _trt__SetVideoSourceMode *a = (struct _trt__SetVideoSourceMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__SetVideoSourceMode));
	for (p = a; p && n--; p++)
		soap_default__trt__SetVideoSourceMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__SetVideoSourceMode(struct soap *soap, const struct _trt__SetVideoSourceMode *a, const char *tag, const char *type)
{
	if (soap_out__trt__SetVideoSourceMode(soap, tag ? tag : "trt:SetVideoSourceMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetVideoSourceMode * SOAP_FMAC4 soap_get__trt__SetVideoSourceMode(struct soap *soap, struct _trt__SetVideoSourceMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__SetVideoSourceMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoSourceModesResponse(struct soap *soap, struct _trt__GetVideoSourceModesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeVideoSourceModes = 0;
	a->VideoSourceModes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoSourceModesResponse(struct soap *soap, const struct _trt__GetVideoSourceModesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->VideoSourceModes)
	{	int i;
		for (i = 0; i < (int)a->__sizeVideoSourceModes; i++)
		{
			soap_embedded(soap, a->VideoSourceModes + i, SOAP_TYPE_trt__VideoSourceMode);
			soap_serialize_trt__VideoSourceMode(soap, a->VideoSourceModes + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoSourceModesResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoSourceModesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoSourceModesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeVideoSourceModes");
	if (a->VideoSourceModes)
	{	int i;
		for (i = 0; i < (int)a->__sizeVideoSourceModes; i++)
			if (soap_out_trt__VideoSourceMode(soap, "trt:VideoSourceModes", -1, a->VideoSourceModes + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoSourceModesResponse * SOAP_FMAC4 soap_in__trt__GetVideoSourceModesResponse(struct soap *soap, const char *tag, struct _trt__GetVideoSourceModesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_VideoSourceModes = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetVideoSourceModesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoSourceModesResponse, sizeof(struct _trt__GetVideoSourceModesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoSourceModesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trt:VideoSourceModes", 1, NULL))
			{	if (a->VideoSourceModes == NULL)
				{	if (soap_blist_VideoSourceModes == NULL)
						soap_blist_VideoSourceModes = soap_alloc_block(soap);
					a->VideoSourceModes = (struct trt__VideoSourceMode *)soap_push_block_max(soap, soap_blist_VideoSourceModes, sizeof(struct trt__VideoSourceMode));
					if (a->VideoSourceModes == NULL)
						return NULL;
					soap_default_trt__VideoSourceMode(soap, a->VideoSourceModes);
				}
				soap_revert(soap);
				if (soap_in_trt__VideoSourceMode(soap, "trt:VideoSourceModes", a->VideoSourceModes, "trt:VideoSourceMode"))
				{	a->__sizeVideoSourceModes++;
					a->VideoSourceModes = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeVideoSourceModes");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->VideoSourceModes)
			soap_pop_block(soap, soap_blist_VideoSourceModes);
		if (a->__sizeVideoSourceModes)
		{	a->VideoSourceModes = (struct trt__VideoSourceMode *)soap_save_block(soap, soap_blist_VideoSourceModes, NULL, 1);
		}
		else
		{	a->VideoSourceModes = NULL;
			if (soap_blist_VideoSourceModes)
				soap_end_block(soap, soap_blist_VideoSourceModes);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeVideoSourceModes < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSourceModesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoSourceModesResponse, SOAP_TYPE__trt__GetVideoSourceModesResponse, sizeof(struct _trt__GetVideoSourceModesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetVideoSourceModesResponse * SOAP_FMAC4 soap_new__trt__GetVideoSourceModesResponse(struct soap *soap, int n)
{
	struct _trt__GetVideoSourceModesResponse *p;
	struct _trt__GetVideoSourceModesResponse *a = (struct _trt__GetVideoSourceModesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetVideoSourceModesResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetVideoSourceModesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoSourceModesResponse(struct soap *soap, const struct _trt__GetVideoSourceModesResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetVideoSourceModesResponse(soap, tag ? tag : "trt:GetVideoSourceModesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSourceModesResponse * SOAP_FMAC4 soap_get__trt__GetVideoSourceModesResponse(struct soap *soap, struct _trt__GetVideoSourceModesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoSourceModesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoSourceModes(struct soap *soap, struct _trt__GetVideoSourceModes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoSourceModes(struct soap *soap, const struct _trt__GetVideoSourceModes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoSourceToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoSourceModes(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoSourceModes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoSourceModes), type))
		return soap->error;
	if (!a->VideoSourceToken)
	{	if (soap_element_nil(soap, "trt:VideoSourceToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:VideoSourceToken", -1, (char*const*)&a->VideoSourceToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoSourceModes * SOAP_FMAC4 soap_in__trt__GetVideoSourceModes(struct soap *soap, const char *tag, struct _trt__GetVideoSourceModes *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetVideoSourceModes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoSourceModes, sizeof(struct _trt__GetVideoSourceModes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoSourceModes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:VideoSourceToken", (char**)&a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoSourceToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSourceModes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoSourceModes, SOAP_TYPE__trt__GetVideoSourceModes, sizeof(struct _trt__GetVideoSourceModes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetVideoSourceModes * SOAP_FMAC4 soap_new__trt__GetVideoSourceModes(struct soap *soap, int n)
{
	struct _trt__GetVideoSourceModes *p;
	struct _trt__GetVideoSourceModes *a = (struct _trt__GetVideoSourceModes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetVideoSourceModes));
	for (p = a; p && n--; p++)
		soap_default__trt__GetVideoSourceModes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoSourceModes(struct soap *soap, const struct _trt__GetVideoSourceModes *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetVideoSourceModes(soap, tag ? tag : "trt:GetVideoSourceModes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSourceModes * SOAP_FMAC4 soap_get__trt__GetVideoSourceModes(struct soap *soap, struct _trt__GetVideoSourceModes *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoSourceModes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetSnapshotUriResponse(struct soap *soap, struct _trt__GetSnapshotUriResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MediaUri = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetSnapshotUriResponse(struct soap *soap, const struct _trt__GetSnapshotUriResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__MediaUri(soap, &a->MediaUri);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetSnapshotUriResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetSnapshotUriResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetSnapshotUriResponse), type))
		return soap->error;
	if (a->MediaUri)
		soap_element_result(soap, "trt:MediaUri");
	if (!a->MediaUri)
	{	if (soap_element_nil(soap, "trt:MediaUri"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__MediaUri(soap, "trt:MediaUri", -1, &a->MediaUri, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetSnapshotUriResponse * SOAP_FMAC4 soap_in__trt__GetSnapshotUriResponse(struct soap *soap, const char *tag, struct _trt__GetSnapshotUriResponse *a, const char *type)
{
	size_t soap_flag_MediaUri = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetSnapshotUriResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetSnapshotUriResponse, sizeof(struct _trt__GetSnapshotUriResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetSnapshotUriResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MediaUri && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MediaUri(soap, "trt:MediaUri", &a->MediaUri, "tt:MediaUri"))
				{	soap_flag_MediaUri--;
					continue;
				}
			soap_check_result(soap, "trt:MediaUri");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MediaUri > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetSnapshotUriResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetSnapshotUriResponse, SOAP_TYPE__trt__GetSnapshotUriResponse, sizeof(struct _trt__GetSnapshotUriResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetSnapshotUriResponse * SOAP_FMAC4 soap_new__trt__GetSnapshotUriResponse(struct soap *soap, int n)
{
	struct _trt__GetSnapshotUriResponse *p;
	struct _trt__GetSnapshotUriResponse *a = (struct _trt__GetSnapshotUriResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetSnapshotUriResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetSnapshotUriResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetSnapshotUriResponse(struct soap *soap, const struct _trt__GetSnapshotUriResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetSnapshotUriResponse(soap, tag ? tag : "trt:GetSnapshotUriResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetSnapshotUriResponse * SOAP_FMAC4 soap_get__trt__GetSnapshotUriResponse(struct soap *soap, struct _trt__GetSnapshotUriResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetSnapshotUriResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetSnapshotUri(struct soap *soap, struct _trt__GetSnapshotUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetSnapshotUri(struct soap *soap, const struct _trt__GetSnapshotUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetSnapshotUri(struct soap *soap, const char *tag, int id, const struct _trt__GetSnapshotUri *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetSnapshotUri), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "trt:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetSnapshotUri * SOAP_FMAC4 soap_in__trt__GetSnapshotUri(struct soap *soap, const char *tag, struct _trt__GetSnapshotUri *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetSnapshotUri *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetSnapshotUri, sizeof(struct _trt__GetSnapshotUri), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetSnapshotUri(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetSnapshotUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetSnapshotUri, SOAP_TYPE__trt__GetSnapshotUri, sizeof(struct _trt__GetSnapshotUri), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetSnapshotUri * SOAP_FMAC4 soap_new__trt__GetSnapshotUri(struct soap *soap, int n)
{
	struct _trt__GetSnapshotUri *p;
	struct _trt__GetSnapshotUri *a = (struct _trt__GetSnapshotUri*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetSnapshotUri));
	for (p = a; p && n--; p++)
		soap_default__trt__GetSnapshotUri(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetSnapshotUri(struct soap *soap, const struct _trt__GetSnapshotUri *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetSnapshotUri(soap, tag ? tag : "trt:GetSnapshotUri", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetSnapshotUri * SOAP_FMAC4 soap_get__trt__GetSnapshotUri(struct soap *soap, struct _trt__GetSnapshotUri *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetSnapshotUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__SetSynchronizationPointResponse(struct soap *soap, struct _trt__SetSynchronizationPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__SetSynchronizationPointResponse(struct soap *soap, const struct _trt__SetSynchronizationPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__SetSynchronizationPointResponse(struct soap *soap, const char *tag, int id, const struct _trt__SetSynchronizationPointResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__SetSynchronizationPointResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__SetSynchronizationPointResponse * SOAP_FMAC4 soap_in__trt__SetSynchronizationPointResponse(struct soap *soap, const char *tag, struct _trt__SetSynchronizationPointResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__SetSynchronizationPointResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetSynchronizationPointResponse, sizeof(struct _trt__SetSynchronizationPointResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__SetSynchronizationPointResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__SetSynchronizationPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetSynchronizationPointResponse, SOAP_TYPE__trt__SetSynchronizationPointResponse, sizeof(struct _trt__SetSynchronizationPointResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__SetSynchronizationPointResponse * SOAP_FMAC4 soap_new__trt__SetSynchronizationPointResponse(struct soap *soap, int n)
{
	struct _trt__SetSynchronizationPointResponse *p;
	struct _trt__SetSynchronizationPointResponse *a = (struct _trt__SetSynchronizationPointResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__SetSynchronizationPointResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__SetSynchronizationPointResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__SetSynchronizationPointResponse(struct soap *soap, const struct _trt__SetSynchronizationPointResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__SetSynchronizationPointResponse(soap, tag ? tag : "trt:SetSynchronizationPointResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetSynchronizationPointResponse * SOAP_FMAC4 soap_get__trt__SetSynchronizationPointResponse(struct soap *soap, struct _trt__SetSynchronizationPointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__SetSynchronizationPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__SetSynchronizationPoint(struct soap *soap, struct _trt__SetSynchronizationPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__SetSynchronizationPoint(struct soap *soap, const struct _trt__SetSynchronizationPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__SetSynchronizationPoint(struct soap *soap, const char *tag, int id, const struct _trt__SetSynchronizationPoint *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__SetSynchronizationPoint), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "trt:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__SetSynchronizationPoint * SOAP_FMAC4 soap_in__trt__SetSynchronizationPoint(struct soap *soap, const char *tag, struct _trt__SetSynchronizationPoint *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__SetSynchronizationPoint *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetSynchronizationPoint, sizeof(struct _trt__SetSynchronizationPoint), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__SetSynchronizationPoint(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__SetSynchronizationPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetSynchronizationPoint, SOAP_TYPE__trt__SetSynchronizationPoint, sizeof(struct _trt__SetSynchronizationPoint), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__SetSynchronizationPoint * SOAP_FMAC4 soap_new__trt__SetSynchronizationPoint(struct soap *soap, int n)
{
	struct _trt__SetSynchronizationPoint *p;
	struct _trt__SetSynchronizationPoint *a = (struct _trt__SetSynchronizationPoint*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__SetSynchronizationPoint));
	for (p = a; p && n--; p++)
		soap_default__trt__SetSynchronizationPoint(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__SetSynchronizationPoint(struct soap *soap, const struct _trt__SetSynchronizationPoint *a, const char *tag, const char *type)
{
	if (soap_out__trt__SetSynchronizationPoint(soap, tag ? tag : "trt:SetSynchronizationPoint", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetSynchronizationPoint * SOAP_FMAC4 soap_get__trt__SetSynchronizationPoint(struct soap *soap, struct _trt__SetSynchronizationPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__SetSynchronizationPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__StopMulticastStreamingResponse(struct soap *soap, struct _trt__StopMulticastStreamingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__StopMulticastStreamingResponse(struct soap *soap, const struct _trt__StopMulticastStreamingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__StopMulticastStreamingResponse(struct soap *soap, const char *tag, int id, const struct _trt__StopMulticastStreamingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__StopMulticastStreamingResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__StopMulticastStreamingResponse * SOAP_FMAC4 soap_in__trt__StopMulticastStreamingResponse(struct soap *soap, const char *tag, struct _trt__StopMulticastStreamingResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__StopMulticastStreamingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__StopMulticastStreamingResponse, sizeof(struct _trt__StopMulticastStreamingResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__StopMulticastStreamingResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__StopMulticastStreamingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__StopMulticastStreamingResponse, SOAP_TYPE__trt__StopMulticastStreamingResponse, sizeof(struct _trt__StopMulticastStreamingResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__StopMulticastStreamingResponse * SOAP_FMAC4 soap_new__trt__StopMulticastStreamingResponse(struct soap *soap, int n)
{
	struct _trt__StopMulticastStreamingResponse *p;
	struct _trt__StopMulticastStreamingResponse *a = (struct _trt__StopMulticastStreamingResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__StopMulticastStreamingResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__StopMulticastStreamingResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__StopMulticastStreamingResponse(struct soap *soap, const struct _trt__StopMulticastStreamingResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__StopMulticastStreamingResponse(soap, tag ? tag : "trt:StopMulticastStreamingResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__StopMulticastStreamingResponse * SOAP_FMAC4 soap_get__trt__StopMulticastStreamingResponse(struct soap *soap, struct _trt__StopMulticastStreamingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__StopMulticastStreamingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__StopMulticastStreaming(struct soap *soap, struct _trt__StopMulticastStreaming *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__StopMulticastStreaming(struct soap *soap, const struct _trt__StopMulticastStreaming *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__StopMulticastStreaming(struct soap *soap, const char *tag, int id, const struct _trt__StopMulticastStreaming *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__StopMulticastStreaming), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "trt:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__StopMulticastStreaming * SOAP_FMAC4 soap_in__trt__StopMulticastStreaming(struct soap *soap, const char *tag, struct _trt__StopMulticastStreaming *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__StopMulticastStreaming *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__StopMulticastStreaming, sizeof(struct _trt__StopMulticastStreaming), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__StopMulticastStreaming(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__StopMulticastStreaming *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__StopMulticastStreaming, SOAP_TYPE__trt__StopMulticastStreaming, sizeof(struct _trt__StopMulticastStreaming), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__StopMulticastStreaming * SOAP_FMAC4 soap_new__trt__StopMulticastStreaming(struct soap *soap, int n)
{
	struct _trt__StopMulticastStreaming *p;
	struct _trt__StopMulticastStreaming *a = (struct _trt__StopMulticastStreaming*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__StopMulticastStreaming));
	for (p = a; p && n--; p++)
		soap_default__trt__StopMulticastStreaming(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__StopMulticastStreaming(struct soap *soap, const struct _trt__StopMulticastStreaming *a, const char *tag, const char *type)
{
	if (soap_out__trt__StopMulticastStreaming(soap, tag ? tag : "trt:StopMulticastStreaming", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__StopMulticastStreaming * SOAP_FMAC4 soap_get__trt__StopMulticastStreaming(struct soap *soap, struct _trt__StopMulticastStreaming *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__StopMulticastStreaming(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__StartMulticastStreamingResponse(struct soap *soap, struct _trt__StartMulticastStreamingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__StartMulticastStreamingResponse(struct soap *soap, const struct _trt__StartMulticastStreamingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__StartMulticastStreamingResponse(struct soap *soap, const char *tag, int id, const struct _trt__StartMulticastStreamingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__StartMulticastStreamingResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__StartMulticastStreamingResponse * SOAP_FMAC4 soap_in__trt__StartMulticastStreamingResponse(struct soap *soap, const char *tag, struct _trt__StartMulticastStreamingResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__StartMulticastStreamingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__StartMulticastStreamingResponse, sizeof(struct _trt__StartMulticastStreamingResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__StartMulticastStreamingResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__StartMulticastStreamingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__StartMulticastStreamingResponse, SOAP_TYPE__trt__StartMulticastStreamingResponse, sizeof(struct _trt__StartMulticastStreamingResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__StartMulticastStreamingResponse * SOAP_FMAC4 soap_new__trt__StartMulticastStreamingResponse(struct soap *soap, int n)
{
	struct _trt__StartMulticastStreamingResponse *p;
	struct _trt__StartMulticastStreamingResponse *a = (struct _trt__StartMulticastStreamingResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__StartMulticastStreamingResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__StartMulticastStreamingResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__StartMulticastStreamingResponse(struct soap *soap, const struct _trt__StartMulticastStreamingResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__StartMulticastStreamingResponse(soap, tag ? tag : "trt:StartMulticastStreamingResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__StartMulticastStreamingResponse * SOAP_FMAC4 soap_get__trt__StartMulticastStreamingResponse(struct soap *soap, struct _trt__StartMulticastStreamingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__StartMulticastStreamingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__StartMulticastStreaming(struct soap *soap, struct _trt__StartMulticastStreaming *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__StartMulticastStreaming(struct soap *soap, const struct _trt__StartMulticastStreaming *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__StartMulticastStreaming(struct soap *soap, const char *tag, int id, const struct _trt__StartMulticastStreaming *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__StartMulticastStreaming), type))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "trt:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__StartMulticastStreaming * SOAP_FMAC4 soap_in__trt__StartMulticastStreaming(struct soap *soap, const char *tag, struct _trt__StartMulticastStreaming *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__StartMulticastStreaming *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__StartMulticastStreaming, sizeof(struct _trt__StartMulticastStreaming), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__StartMulticastStreaming(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__StartMulticastStreaming *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__StartMulticastStreaming, SOAP_TYPE__trt__StartMulticastStreaming, sizeof(struct _trt__StartMulticastStreaming), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__StartMulticastStreaming * SOAP_FMAC4 soap_new__trt__StartMulticastStreaming(struct soap *soap, int n)
{
	struct _trt__StartMulticastStreaming *p;
	struct _trt__StartMulticastStreaming *a = (struct _trt__StartMulticastStreaming*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__StartMulticastStreaming));
	for (p = a; p && n--; p++)
		soap_default__trt__StartMulticastStreaming(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__StartMulticastStreaming(struct soap *soap, const struct _trt__StartMulticastStreaming *a, const char *tag, const char *type)
{
	if (soap_out__trt__StartMulticastStreaming(soap, tag ? tag : "trt:StartMulticastStreaming", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__StartMulticastStreaming * SOAP_FMAC4 soap_get__trt__StartMulticastStreaming(struct soap *soap, struct _trt__StartMulticastStreaming *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__StartMulticastStreaming(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetStreamUriResponse(struct soap *soap, struct _trt__GetStreamUriResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MediaUri = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetStreamUriResponse(struct soap *soap, const struct _trt__GetStreamUriResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__MediaUri(soap, &a->MediaUri);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetStreamUriResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetStreamUriResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetStreamUriResponse), type))
		return soap->error;
	if (a->MediaUri)
		soap_element_result(soap, "trt:MediaUri");
	if (!a->MediaUri)
	{	if (soap_element_nil(soap, "trt:MediaUri"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__MediaUri(soap, "trt:MediaUri", -1, &a->MediaUri, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetStreamUriResponse * SOAP_FMAC4 soap_in__trt__GetStreamUriResponse(struct soap *soap, const char *tag, struct _trt__GetStreamUriResponse *a, const char *type)
{
	size_t soap_flag_MediaUri = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetStreamUriResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetStreamUriResponse, sizeof(struct _trt__GetStreamUriResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetStreamUriResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MediaUri && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MediaUri(soap, "trt:MediaUri", &a->MediaUri, "tt:MediaUri"))
				{	soap_flag_MediaUri--;
					continue;
				}
			soap_check_result(soap, "trt:MediaUri");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MediaUri > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetStreamUriResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetStreamUriResponse, SOAP_TYPE__trt__GetStreamUriResponse, sizeof(struct _trt__GetStreamUriResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetStreamUriResponse * SOAP_FMAC4 soap_new__trt__GetStreamUriResponse(struct soap *soap, int n)
{
	struct _trt__GetStreamUriResponse *p;
	struct _trt__GetStreamUriResponse *a = (struct _trt__GetStreamUriResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetStreamUriResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetStreamUriResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetStreamUriResponse(struct soap *soap, const struct _trt__GetStreamUriResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetStreamUriResponse(soap, tag ? tag : "trt:GetStreamUriResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetStreamUriResponse * SOAP_FMAC4 soap_get__trt__GetStreamUriResponse(struct soap *soap, struct _trt__GetStreamUriResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetStreamUriResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetStreamUri(struct soap *soap, struct _trt__GetStreamUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->StreamSetup = NULL;
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetStreamUri(struct soap *soap, const struct _trt__GetStreamUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__StreamSetup(soap, &a->StreamSetup);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetStreamUri(struct soap *soap, const char *tag, int id, const struct _trt__GetStreamUri *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetStreamUri), type))
		return soap->error;
	if (!a->StreamSetup)
	{	if (soap_element_nil(soap, "trt:StreamSetup"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__StreamSetup(soap, "trt:StreamSetup", -1, &a->StreamSetup, ""))
		return soap->error;
	if (!a->ProfileToken)
	{	if (soap_element_nil(soap, "trt:ProfileToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetStreamUri * SOAP_FMAC4 soap_in__trt__GetStreamUri(struct soap *soap, const char *tag, struct _trt__GetStreamUri *a, const char *type)
{
	size_t soap_flag_StreamSetup = 1;
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetStreamUri *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetStreamUri, sizeof(struct _trt__GetStreamUri), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetStreamUri(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StreamSetup && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__StreamSetup(soap, "trt:StreamSetup", &a->StreamSetup, "tt:StreamSetup"))
				{	soap_flag_StreamSetup--;
					continue;
				}
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StreamSetup > 0 || soap_flag_ProfileToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetStreamUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetStreamUri, SOAP_TYPE__trt__GetStreamUri, sizeof(struct _trt__GetStreamUri), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetStreamUri * SOAP_FMAC4 soap_new__trt__GetStreamUri(struct soap *soap, int n)
{
	struct _trt__GetStreamUri *p;
	struct _trt__GetStreamUri *a = (struct _trt__GetStreamUri*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetStreamUri));
	for (p = a; p && n--; p++)
		soap_default__trt__GetStreamUri(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetStreamUri(struct soap *soap, const struct _trt__GetStreamUri *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetStreamUri(soap, tag ? tag : "trt:GetStreamUri", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetStreamUri * SOAP_FMAC4 soap_get__trt__GetStreamUri(struct soap *soap, struct _trt__GetStreamUri *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetStreamUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap *soap, struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->TotalNumber);
	a->JPEG = NULL;
	a->H264 = NULL;
	a->MPEG4 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap *soap, const struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->TotalNumber, SOAP_TYPE_int);
	soap_serialize_PointerToint(soap, &a->JPEG);
	soap_serialize_PointerToint(soap, &a->H264);
	soap_serialize_PointerToint(soap, &a->MPEG4);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse), type))
		return soap->error;
	soap_element_result(soap, "trt:TotalNumber");
	if (soap_out_int(soap, "trt:TotalNumber", -1, &a->TotalNumber, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "trt:JPEG", -1, &a->JPEG, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "trt:H264", -1, &a->H264, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "trt:MPEG4", -1, &a->MPEG4, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse * SOAP_FMAC4 soap_in__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap *soap, const char *tag, struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *a, const char *type)
{
	size_t soap_flag_TotalNumber = 1;
	size_t soap_flag_JPEG = 1;
	size_t soap_flag_H264 = 1;
	size_t soap_flag_MPEG4 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse, sizeof(struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TotalNumber && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "trt:TotalNumber", &a->TotalNumber, "xsd:int"))
				{	soap_flag_TotalNumber--;
					continue;
				}
			if (soap_flag_JPEG && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "trt:JPEG", &a->JPEG, "xsd:int"))
				{	soap_flag_JPEG--;
					continue;
				}
			if (soap_flag_H264 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "trt:H264", &a->H264, "xsd:int"))
				{	soap_flag_H264--;
					continue;
				}
			if (soap_flag_MPEG4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "trt:MPEG4", &a->MPEG4, "xsd:int"))
				{	soap_flag_MPEG4--;
					continue;
				}
			soap_check_result(soap, "trt:TotalNumber");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TotalNumber > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse, sizeof(struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse * SOAP_FMAC4 soap_new__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap *soap, int n)
{
	struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *p;
	struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *a = (struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap *soap, const struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(soap, tag ? tag : "trt:GetGuaranteedNumberOfVideoEncoderInstancesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse * SOAP_FMAC4 soap_get__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap *soap, struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, struct _trt__GetGuaranteedNumberOfVideoEncoderInstances *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, const struct _trt__GetGuaranteedNumberOfVideoEncoderInstances *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, const char *tag, int id, const struct _trt__GetGuaranteedNumberOfVideoEncoderInstances *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances), type))
		return soap->error;
	if (!a->ConfigurationToken)
	{	if (soap_element_nil(soap, "trt:ConfigurationToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetGuaranteedNumberOfVideoEncoderInstances * SOAP_FMAC4 soap_in__trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, const char *tag, struct _trt__GetGuaranteedNumberOfVideoEncoderInstances *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetGuaranteedNumberOfVideoEncoderInstances *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances, sizeof(struct _trt__GetGuaranteedNumberOfVideoEncoderInstances), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetGuaranteedNumberOfVideoEncoderInstances *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances, sizeof(struct _trt__GetGuaranteedNumberOfVideoEncoderInstances), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetGuaranteedNumberOfVideoEncoderInstances * SOAP_FMAC4 soap_new__trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, int n)
{
	struct _trt__GetGuaranteedNumberOfVideoEncoderInstances *p;
	struct _trt__GetGuaranteedNumberOfVideoEncoderInstances *a = (struct _trt__GetGuaranteedNumberOfVideoEncoderInstances*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetGuaranteedNumberOfVideoEncoderInstances));
	for (p = a; p && n--; p++)
		soap_default__trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, const struct _trt__GetGuaranteedNumberOfVideoEncoderInstances *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, tag ? tag : "trt:GetGuaranteedNumberOfVideoEncoderInstances", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetGuaranteedNumberOfVideoEncoderInstances * SOAP_FMAC4 soap_get__trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, struct _trt__GetGuaranteedNumberOfVideoEncoderInstances *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioDecoderConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, const struct _trt__GetAudioDecoderConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AudioDecoderConfigurationOptions(soap, &a->Options);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioDecoderConfigurationOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse), type))
		return soap->error;
	if (a->Options)
		soap_element_result(soap, "trt:Options");
	if (!a->Options)
	{	if (soap_element_nil(soap, "trt:Options"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__AudioDecoderConfigurationOptions(soap, "trt:Options", -1, &a->Options, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurationOptionsResponse * SOAP_FMAC4 soap_in__trt__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioDecoderConfigurationOptionsResponse *a, const char *type)
{
	size_t soap_flag_Options = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetAudioDecoderConfigurationOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse, sizeof(struct _trt__GetAudioDecoderConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioDecoderConfigurationOptionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Options && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioDecoderConfigurationOptions(soap, "trt:Options", &a->Options, "tt:AudioDecoderConfigurationOptions"))
				{	soap_flag_Options--;
					continue;
				}
			soap_check_result(soap, "trt:Options");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Options > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetAudioDecoderConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse, sizeof(struct _trt__GetAudioDecoderConfigurationOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurationOptionsResponse * SOAP_FMAC4 soap_new__trt__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, int n)
{
	struct _trt__GetAudioDecoderConfigurationOptionsResponse *p;
	struct _trt__GetAudioDecoderConfigurationOptionsResponse *a = (struct _trt__GetAudioDecoderConfigurationOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetAudioDecoderConfigurationOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetAudioDecoderConfigurationOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, const struct _trt__GetAudioDecoderConfigurationOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetAudioDecoderConfigurationOptionsResponse(soap, tag ? tag : "trt:GetAudioDecoderConfigurationOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurationOptionsResponse * SOAP_FMAC4 soap_get__trt__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioDecoderConfigurationOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioDecoderConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioDecoderConfigurationOptions(struct soap *soap, struct _trt__GetAudioDecoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioDecoderConfigurationOptions(struct soap *soap, const struct _trt__GetAudioDecoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioDecoderConfigurationOptions(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioDecoderConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurationOptions * SOAP_FMAC4 soap_in__trt__GetAudioDecoderConfigurationOptions(struct soap *soap, const char *tag, struct _trt__GetAudioDecoderConfigurationOptions *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetAudioDecoderConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions, sizeof(struct _trt__GetAudioDecoderConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioDecoderConfigurationOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioDecoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions, sizeof(struct _trt__GetAudioDecoderConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurationOptions * SOAP_FMAC4 soap_new__trt__GetAudioDecoderConfigurationOptions(struct soap *soap, int n)
{
	struct _trt__GetAudioDecoderConfigurationOptions *p;
	struct _trt__GetAudioDecoderConfigurationOptions *a = (struct _trt__GetAudioDecoderConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetAudioDecoderConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default__trt__GetAudioDecoderConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioDecoderConfigurationOptions(struct soap *soap, const struct _trt__GetAudioDecoderConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetAudioDecoderConfigurationOptions(soap, tag ? tag : "trt:GetAudioDecoderConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurationOptions * SOAP_FMAC4 soap_get__trt__GetAudioDecoderConfigurationOptions(struct soap *soap, struct _trt__GetAudioDecoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioDecoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioOutputConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, const struct _trt__GetAudioOutputConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AudioOutputConfigurationOptions(soap, &a->Options);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioOutputConfigurationOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse), type))
		return soap->error;
	if (a->Options)
		soap_element_result(soap, "trt:Options");
	if (!a->Options)
	{	if (soap_element_nil(soap, "trt:Options"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__AudioOutputConfigurationOptions(soap, "trt:Options", -1, &a->Options, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurationOptionsResponse * SOAP_FMAC4 soap_in__trt__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioOutputConfigurationOptionsResponse *a, const char *type)
{
	size_t soap_flag_Options = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetAudioOutputConfigurationOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse, sizeof(struct _trt__GetAudioOutputConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioOutputConfigurationOptionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Options && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioOutputConfigurationOptions(soap, "trt:Options", &a->Options, "tt:AudioOutputConfigurationOptions"))
				{	soap_flag_Options--;
					continue;
				}
			soap_check_result(soap, "trt:Options");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Options > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetAudioOutputConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse, SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse, sizeof(struct _trt__GetAudioOutputConfigurationOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurationOptionsResponse * SOAP_FMAC4 soap_new__trt__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, int n)
{
	struct _trt__GetAudioOutputConfigurationOptionsResponse *p;
	struct _trt__GetAudioOutputConfigurationOptionsResponse *a = (struct _trt__GetAudioOutputConfigurationOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetAudioOutputConfigurationOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetAudioOutputConfigurationOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, const struct _trt__GetAudioOutputConfigurationOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetAudioOutputConfigurationOptionsResponse(soap, tag ? tag : "trt:GetAudioOutputConfigurationOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurationOptionsResponse * SOAP_FMAC4 soap_get__trt__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioOutputConfigurationOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioOutputConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioOutputConfigurationOptions(struct soap *soap, struct _trt__GetAudioOutputConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioOutputConfigurationOptions(struct soap *soap, const struct _trt__GetAudioOutputConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioOutputConfigurationOptions(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioOutputConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioOutputConfigurationOptions), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurationOptions * SOAP_FMAC4 soap_in__trt__GetAudioOutputConfigurationOptions(struct soap *soap, const char *tag, struct _trt__GetAudioOutputConfigurationOptions *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetAudioOutputConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioOutputConfigurationOptions, sizeof(struct _trt__GetAudioOutputConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioOutputConfigurationOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioOutputConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioOutputConfigurationOptions, SOAP_TYPE__trt__GetAudioOutputConfigurationOptions, sizeof(struct _trt__GetAudioOutputConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurationOptions * SOAP_FMAC4 soap_new__trt__GetAudioOutputConfigurationOptions(struct soap *soap, int n)
{
	struct _trt__GetAudioOutputConfigurationOptions *p;
	struct _trt__GetAudioOutputConfigurationOptions *a = (struct _trt__GetAudioOutputConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetAudioOutputConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default__trt__GetAudioOutputConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioOutputConfigurationOptions(struct soap *soap, const struct _trt__GetAudioOutputConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetAudioOutputConfigurationOptions(soap, tag ? tag : "trt:GetAudioOutputConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurationOptions * SOAP_FMAC4 soap_get__trt__GetAudioOutputConfigurationOptions(struct soap *soap, struct _trt__GetAudioOutputConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioOutputConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetMetadataConfigurationOptionsResponse(struct soap *soap, struct _trt__GetMetadataConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetMetadataConfigurationOptionsResponse(struct soap *soap, const struct _trt__GetMetadataConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__MetadataConfigurationOptions(soap, &a->Options);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetMetadataConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetMetadataConfigurationOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse), type))
		return soap->error;
	if (a->Options)
		soap_element_result(soap, "trt:Options");
	if (!a->Options)
	{	if (soap_element_nil(soap, "trt:Options"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__MetadataConfigurationOptions(soap, "trt:Options", -1, &a->Options, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationOptionsResponse * SOAP_FMAC4 soap_in__trt__GetMetadataConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _trt__GetMetadataConfigurationOptionsResponse *a, const char *type)
{
	size_t soap_flag_Options = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetMetadataConfigurationOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse, sizeof(struct _trt__GetMetadataConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetMetadataConfigurationOptionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Options && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MetadataConfigurationOptions(soap, "trt:Options", &a->Options, "tt:MetadataConfigurationOptions"))
				{	soap_flag_Options--;
					continue;
				}
			soap_check_result(soap, "trt:Options");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Options > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetMetadataConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse, SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse, sizeof(struct _trt__GetMetadataConfigurationOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationOptionsResponse * SOAP_FMAC4 soap_new__trt__GetMetadataConfigurationOptionsResponse(struct soap *soap, int n)
{
	struct _trt__GetMetadataConfigurationOptionsResponse *p;
	struct _trt__GetMetadataConfigurationOptionsResponse *a = (struct _trt__GetMetadataConfigurationOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetMetadataConfigurationOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetMetadataConfigurationOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetMetadataConfigurationOptionsResponse(struct soap *soap, const struct _trt__GetMetadataConfigurationOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetMetadataConfigurationOptionsResponse(soap, tag ? tag : "trt:GetMetadataConfigurationOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationOptionsResponse * SOAP_FMAC4 soap_get__trt__GetMetadataConfigurationOptionsResponse(struct soap *soap, struct _trt__GetMetadataConfigurationOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetMetadataConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetMetadataConfigurationOptions(struct soap *soap, struct _trt__GetMetadataConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetMetadataConfigurationOptions(struct soap *soap, const struct _trt__GetMetadataConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetMetadataConfigurationOptions(struct soap *soap, const char *tag, int id, const struct _trt__GetMetadataConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetMetadataConfigurationOptions), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationOptions * SOAP_FMAC4 soap_in__trt__GetMetadataConfigurationOptions(struct soap *soap, const char *tag, struct _trt__GetMetadataConfigurationOptions *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetMetadataConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetMetadataConfigurationOptions, sizeof(struct _trt__GetMetadataConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetMetadataConfigurationOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetMetadataConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetMetadataConfigurationOptions, SOAP_TYPE__trt__GetMetadataConfigurationOptions, sizeof(struct _trt__GetMetadataConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationOptions * SOAP_FMAC4 soap_new__trt__GetMetadataConfigurationOptions(struct soap *soap, int n)
{
	struct _trt__GetMetadataConfigurationOptions *p;
	struct _trt__GetMetadataConfigurationOptions *a = (struct _trt__GetMetadataConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetMetadataConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default__trt__GetMetadataConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetMetadataConfigurationOptions(struct soap *soap, const struct _trt__GetMetadataConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetMetadataConfigurationOptions(soap, tag ? tag : "trt:GetMetadataConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationOptions * SOAP_FMAC4 soap_get__trt__GetMetadataConfigurationOptions(struct soap *soap, struct _trt__GetMetadataConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetMetadataConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioEncoderConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, const struct _trt__GetAudioEncoderConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AudioEncoderConfigurationOptions(soap, &a->Options);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioEncoderConfigurationOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse), type))
		return soap->error;
	if (a->Options)
		soap_element_result(soap, "trt:Options");
	if (!a->Options)
	{	if (soap_element_nil(soap, "trt:Options"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__AudioEncoderConfigurationOptions(soap, "trt:Options", -1, &a->Options, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationOptionsResponse * SOAP_FMAC4 soap_in__trt__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioEncoderConfigurationOptionsResponse *a, const char *type)
{
	size_t soap_flag_Options = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetAudioEncoderConfigurationOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse, sizeof(struct _trt__GetAudioEncoderConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioEncoderConfigurationOptionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Options && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioEncoderConfigurationOptions(soap, "trt:Options", &a->Options, "tt:AudioEncoderConfigurationOptions"))
				{	soap_flag_Options--;
					continue;
				}
			soap_check_result(soap, "trt:Options");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Options > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetAudioEncoderConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse, sizeof(struct _trt__GetAudioEncoderConfigurationOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationOptionsResponse * SOAP_FMAC4 soap_new__trt__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, int n)
{
	struct _trt__GetAudioEncoderConfigurationOptionsResponse *p;
	struct _trt__GetAudioEncoderConfigurationOptionsResponse *a = (struct _trt__GetAudioEncoderConfigurationOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetAudioEncoderConfigurationOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetAudioEncoderConfigurationOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, const struct _trt__GetAudioEncoderConfigurationOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetAudioEncoderConfigurationOptionsResponse(soap, tag ? tag : "trt:GetAudioEncoderConfigurationOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationOptionsResponse * SOAP_FMAC4 soap_get__trt__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioEncoderConfigurationOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioEncoderConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioEncoderConfigurationOptions(struct soap *soap, struct _trt__GetAudioEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioEncoderConfigurationOptions(struct soap *soap, const struct _trt__GetAudioEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioEncoderConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationOptions * SOAP_FMAC4 soap_in__trt__GetAudioEncoderConfigurationOptions(struct soap *soap, const char *tag, struct _trt__GetAudioEncoderConfigurationOptions *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetAudioEncoderConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions, sizeof(struct _trt__GetAudioEncoderConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioEncoderConfigurationOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioEncoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions, sizeof(struct _trt__GetAudioEncoderConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationOptions * SOAP_FMAC4 soap_new__trt__GetAudioEncoderConfigurationOptions(struct soap *soap, int n)
{
	struct _trt__GetAudioEncoderConfigurationOptions *p;
	struct _trt__GetAudioEncoderConfigurationOptions *a = (struct _trt__GetAudioEncoderConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetAudioEncoderConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default__trt__GetAudioEncoderConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioEncoderConfigurationOptions(struct soap *soap, const struct _trt__GetAudioEncoderConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetAudioEncoderConfigurationOptions(soap, tag ? tag : "trt:GetAudioEncoderConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationOptions * SOAP_FMAC4 soap_get__trt__GetAudioEncoderConfigurationOptions(struct soap *soap, struct _trt__GetAudioEncoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioSourceConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, const struct _trt__GetAudioSourceConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AudioSourceConfigurationOptions(soap, &a->Options);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioSourceConfigurationOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse), type))
		return soap->error;
	if (a->Options)
		soap_element_result(soap, "trt:Options");
	if (!a->Options)
	{	if (soap_element_nil(soap, "trt:Options"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__AudioSourceConfigurationOptions(soap, "trt:Options", -1, &a->Options, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurationOptionsResponse * SOAP_FMAC4 soap_in__trt__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioSourceConfigurationOptionsResponse *a, const char *type)
{
	size_t soap_flag_Options = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetAudioSourceConfigurationOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse, sizeof(struct _trt__GetAudioSourceConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioSourceConfigurationOptionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Options && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioSourceConfigurationOptions(soap, "trt:Options", &a->Options, "tt:AudioSourceConfigurationOptions"))
				{	soap_flag_Options--;
					continue;
				}
			soap_check_result(soap, "trt:Options");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Options > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetAudioSourceConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse, SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse, sizeof(struct _trt__GetAudioSourceConfigurationOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurationOptionsResponse * SOAP_FMAC4 soap_new__trt__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, int n)
{
	struct _trt__GetAudioSourceConfigurationOptionsResponse *p;
	struct _trt__GetAudioSourceConfigurationOptionsResponse *a = (struct _trt__GetAudioSourceConfigurationOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetAudioSourceConfigurationOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetAudioSourceConfigurationOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, const struct _trt__GetAudioSourceConfigurationOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetAudioSourceConfigurationOptionsResponse(soap, tag ? tag : "trt:GetAudioSourceConfigurationOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurationOptionsResponse * SOAP_FMAC4 soap_get__trt__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioSourceConfigurationOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioSourceConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetAudioSourceConfigurationOptions(struct soap *soap, struct _trt__GetAudioSourceConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetAudioSourceConfigurationOptions(struct soap *soap, const struct _trt__GetAudioSourceConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetAudioSourceConfigurationOptions(struct soap *soap, const char *tag, int id, const struct _trt__GetAudioSourceConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetAudioSourceConfigurationOptions), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurationOptions * SOAP_FMAC4 soap_in__trt__GetAudioSourceConfigurationOptions(struct soap *soap, const char *tag, struct _trt__GetAudioSourceConfigurationOptions *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetAudioSourceConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetAudioSourceConfigurationOptions, sizeof(struct _trt__GetAudioSourceConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetAudioSourceConfigurationOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioSourceConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetAudioSourceConfigurationOptions, SOAP_TYPE__trt__GetAudioSourceConfigurationOptions, sizeof(struct _trt__GetAudioSourceConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurationOptions * SOAP_FMAC4 soap_new__trt__GetAudioSourceConfigurationOptions(struct soap *soap, int n)
{
	struct _trt__GetAudioSourceConfigurationOptions *p;
	struct _trt__GetAudioSourceConfigurationOptions *a = (struct _trt__GetAudioSourceConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetAudioSourceConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default__trt__GetAudioSourceConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetAudioSourceConfigurationOptions(struct soap *soap, const struct _trt__GetAudioSourceConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetAudioSourceConfigurationOptions(soap, tag ? tag : "trt:GetAudioSourceConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurationOptions * SOAP_FMAC4 soap_get__trt__GetAudioSourceConfigurationOptions(struct soap *soap, struct _trt__GetAudioSourceConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetAudioSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, const struct _trt__GetVideoEncoderConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__VideoEncoderConfigurationOptions(soap, &a->Options);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoEncoderConfigurationOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse), type))
		return soap->error;
	if (a->Options)
		soap_element_result(soap, "trt:Options");
	if (!a->Options)
	{	if (soap_element_nil(soap, "trt:Options"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__VideoEncoderConfigurationOptions(soap, "trt:Options", -1, &a->Options, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationOptionsResponse * SOAP_FMAC4 soap_in__trt__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _trt__GetVideoEncoderConfigurationOptionsResponse *a, const char *type)
{
	size_t soap_flag_Options = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetVideoEncoderConfigurationOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse, sizeof(struct _trt__GetVideoEncoderConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoEncoderConfigurationOptionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Options && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoEncoderConfigurationOptions(soap, "trt:Options", &a->Options, "tt:VideoEncoderConfigurationOptions"))
				{	soap_flag_Options--;
					continue;
				}
			soap_check_result(soap, "trt:Options");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Options > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetVideoEncoderConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse, sizeof(struct _trt__GetVideoEncoderConfigurationOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationOptionsResponse * SOAP_FMAC4 soap_new__trt__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, int n)
{
	struct _trt__GetVideoEncoderConfigurationOptionsResponse *p;
	struct _trt__GetVideoEncoderConfigurationOptionsResponse *a = (struct _trt__GetVideoEncoderConfigurationOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetVideoEncoderConfigurationOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetVideoEncoderConfigurationOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, const struct _trt__GetVideoEncoderConfigurationOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetVideoEncoderConfigurationOptionsResponse(soap, tag ? tag : "trt:GetVideoEncoderConfigurationOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationOptionsResponse * SOAP_FMAC4 soap_get__trt__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoEncoderConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoEncoderConfigurationOptions(struct soap *soap, struct _trt__GetVideoEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const struct _trt__GetVideoEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoEncoderConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationOptions * SOAP_FMAC4 soap_in__trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const char *tag, struct _trt__GetVideoEncoderConfigurationOptions *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetVideoEncoderConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions, sizeof(struct _trt__GetVideoEncoderConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoEncoderConfigurationOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoEncoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions, sizeof(struct _trt__GetVideoEncoderConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationOptions * SOAP_FMAC4 soap_new__trt__GetVideoEncoderConfigurationOptions(struct soap *soap, int n)
{
	struct _trt__GetVideoEncoderConfigurationOptions *p;
	struct _trt__GetVideoEncoderConfigurationOptions *a = (struct _trt__GetVideoEncoderConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetVideoEncoderConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default__trt__GetVideoEncoderConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const struct _trt__GetVideoEncoderConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetVideoEncoderConfigurationOptions(soap, tag ? tag : "trt:GetVideoEncoderConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationOptions * SOAP_FMAC4 soap_get__trt__GetVideoEncoderConfigurationOptions(struct soap *soap, struct _trt__GetVideoEncoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, struct _trt__GetVideoSourceConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, const struct _trt__GetVideoSourceConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__VideoSourceConfigurationOptions(soap, &a->Options);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoSourceConfigurationOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse), type))
		return soap->error;
	if (a->Options)
		soap_element_result(soap, "trt:Options");
	if (!a->Options)
	{	if (soap_element_nil(soap, "trt:Options"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__VideoSourceConfigurationOptions(soap, "trt:Options", -1, &a->Options, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurationOptionsResponse * SOAP_FMAC4 soap_in__trt__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _trt__GetVideoSourceConfigurationOptionsResponse *a, const char *type)
{
	size_t soap_flag_Options = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetVideoSourceConfigurationOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse, sizeof(struct _trt__GetVideoSourceConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoSourceConfigurationOptionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Options && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoSourceConfigurationOptions(soap, "trt:Options", &a->Options, "tt:VideoSourceConfigurationOptions"))
				{	soap_flag_Options--;
					continue;
				}
			soap_check_result(soap, "trt:Options");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Options > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSourceConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse, SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse, sizeof(struct _trt__GetVideoSourceConfigurationOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurationOptionsResponse * SOAP_FMAC4 soap_new__trt__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, int n)
{
	struct _trt__GetVideoSourceConfigurationOptionsResponse *p;
	struct _trt__GetVideoSourceConfigurationOptionsResponse *a = (struct _trt__GetVideoSourceConfigurationOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetVideoSourceConfigurationOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__GetVideoSourceConfigurationOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, const struct _trt__GetVideoSourceConfigurationOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetVideoSourceConfigurationOptionsResponse(soap, tag ? tag : "trt:GetVideoSourceConfigurationOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurationOptionsResponse * SOAP_FMAC4 soap_get__trt__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, struct _trt__GetVideoSourceConfigurationOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoSourceConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__GetVideoSourceConfigurationOptions(struct soap *soap, struct _trt__GetVideoSourceConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__GetVideoSourceConfigurationOptions(struct soap *soap, const struct _trt__GetVideoSourceConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ConfigurationToken);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__GetVideoSourceConfigurationOptions(struct soap *soap, const char *tag, int id, const struct _trt__GetVideoSourceConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__GetVideoSourceConfigurationOptions), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "trt:ConfigurationToken", -1, (char*const*)&a->ConfigurationToken, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "trt:ProfileToken", -1, (char*const*)&a->ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurationOptions * SOAP_FMAC4 soap_in__trt__GetVideoSourceConfigurationOptions(struct soap *soap, const char *tag, struct _trt__GetVideoSourceConfigurationOptions *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__GetVideoSourceConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__GetVideoSourceConfigurationOptions, sizeof(struct _trt__GetVideoSourceConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__GetVideoSourceConfigurationOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ConfigurationToken", (char**)&a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trt:ProfileToken", (char**)&a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSourceConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__GetVideoSourceConfigurationOptions, SOAP_TYPE__trt__GetVideoSourceConfigurationOptions, sizeof(struct _trt__GetVideoSourceConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurationOptions * SOAP_FMAC4 soap_new__trt__GetVideoSourceConfigurationOptions(struct soap *soap, int n)
{
	struct _trt__GetVideoSourceConfigurationOptions *p;
	struct _trt__GetVideoSourceConfigurationOptions *a = (struct _trt__GetVideoSourceConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__GetVideoSourceConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default__trt__GetVideoSourceConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__GetVideoSourceConfigurationOptions(struct soap *soap, const struct _trt__GetVideoSourceConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out__trt__GetVideoSourceConfigurationOptions(soap, tag ? tag : "trt:GetVideoSourceConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurationOptions * SOAP_FMAC4 soap_get__trt__GetVideoSourceConfigurationOptions(struct soap *soap, struct _trt__GetVideoSourceConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__GetVideoSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__SetAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__SetAudioDecoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__SetAudioDecoderConfigurationResponse(struct soap *soap, const struct _trt__SetAudioDecoderConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__SetAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__SetAudioDecoderConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__SetAudioDecoderConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__SetAudioDecoderConfigurationResponse * SOAP_FMAC4 soap_in__trt__SetAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__SetAudioDecoderConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__SetAudioDecoderConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetAudioDecoderConfigurationResponse, sizeof(struct _trt__SetAudioDecoderConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__SetAudioDecoderConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__SetAudioDecoderConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetAudioDecoderConfigurationResponse, SOAP_TYPE__trt__SetAudioDecoderConfigurationResponse, sizeof(struct _trt__SetAudioDecoderConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__SetAudioDecoderConfigurationResponse * SOAP_FMAC4 soap_new__trt__SetAudioDecoderConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__SetAudioDecoderConfigurationResponse *p;
	struct _trt__SetAudioDecoderConfigurationResponse *a = (struct _trt__SetAudioDecoderConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__SetAudioDecoderConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__SetAudioDecoderConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__SetAudioDecoderConfigurationResponse(struct soap *soap, const struct _trt__SetAudioDecoderConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__SetAudioDecoderConfigurationResponse(soap, tag ? tag : "trt:SetAudioDecoderConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetAudioDecoderConfigurationResponse * SOAP_FMAC4 soap_get__trt__SetAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__SetAudioDecoderConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__SetAudioDecoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__SetAudioDecoderConfiguration(struct soap *soap, struct _trt__SetAudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
	soap_default_xsd__boolean(soap, &a->ForcePersistence);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__SetAudioDecoderConfiguration(struct soap *soap, const struct _trt__SetAudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AudioDecoderConfiguration(soap, &a->Configuration);
	soap_embedded(soap, &a->ForcePersistence, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__SetAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, const struct _trt__SetAudioDecoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__SetAudioDecoderConfiguration), type))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_nil(soap, "trt:Configuration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__AudioDecoderConfiguration(soap, "trt:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "trt:ForcePersistence", -1, &a->ForcePersistence, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__SetAudioDecoderConfiguration * SOAP_FMAC4 soap_in__trt__SetAudioDecoderConfiguration(struct soap *soap, const char *tag, struct _trt__SetAudioDecoderConfiguration *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	size_t soap_flag_ForcePersistence = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__SetAudioDecoderConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetAudioDecoderConfiguration, sizeof(struct _trt__SetAudioDecoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__SetAudioDecoderConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioDecoderConfiguration(soap, "trt:Configuration", &a->Configuration, "tt:AudioDecoderConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			if (soap_flag_ForcePersistence && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "trt:ForcePersistence", &a->ForcePersistence, "xsd:boolean"))
				{	soap_flag_ForcePersistence--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0 || soap_flag_ForcePersistence > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _trt__SetAudioDecoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetAudioDecoderConfiguration, SOAP_TYPE__trt__SetAudioDecoderConfiguration, sizeof(struct _trt__SetAudioDecoderConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__SetAudioDecoderConfiguration * SOAP_FMAC4 soap_new__trt__SetAudioDecoderConfiguration(struct soap *soap, int n)
{
	struct _trt__SetAudioDecoderConfiguration *p;
	struct _trt__SetAudioDecoderConfiguration *a = (struct _trt__SetAudioDecoderConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__SetAudioDecoderConfiguration));
	for (p = a; p && n--; p++)
		soap_default__trt__SetAudioDecoderConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__SetAudioDecoderConfiguration(struct soap *soap, const struct _trt__SetAudioDecoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__trt__SetAudioDecoderConfiguration(soap, tag ? tag : "trt:SetAudioDecoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetAudioDecoderConfiguration * SOAP_FMAC4 soap_get__trt__SetAudioDecoderConfiguration(struct soap *soap, struct _trt__SetAudioDecoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__SetAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trt__SetAudioOutputConfigurationResponse(struct soap *soap, struct _trt__SetAudioOutputConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trt__SetAudioOutputConfigurationResponse(struct soap *soap, const struct _trt__SetAudioOutputConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trt__SetAudioOutputConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trt__SetAudioOutputConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trt__SetAudioOutputConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trt__SetAudioOutputConfigurationResponse * SOAP_FMAC4 soap_in__trt__SetAudioOutputConfigurationResponse(struct soap *soap, const char *tag, struct _trt__SetAudioOutputConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trt__SetAudioOutputConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trt__SetAudioOutputConfigurationResponse, sizeof(struct _trt__SetAudioOutputConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trt__SetAudioOutputConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trt__SetAudioOutputConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trt__SetAudioOutputConfigurationResponse, SOAP_TYPE__trt__SetAudioOutputConfigurationResponse, sizeof(struct _trt__SetAudioOutputConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _trt__SetAudioOutputConfigurationResponse * SOAP_FMAC4 soap_new__trt__SetAudioOutputConfigurationResponse(struct soap *soap, int n)
{
	struct _trt__SetAudioOutputConfigurationResponse *p;
	struct _trt__SetAudioOutputConfigurationResponse *a = (struct _trt__SetAudioOutputConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _trt__SetAudioOutputConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__trt__SetAudioOutputConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trt__SetAudioOutputConfigurationResponse(struct soap *soap, const struct _trt__SetAudioOutputConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__trt__SetAudioOutputConfigurationResponse(soap, tag ? tag : "trt:SetAudioOutputConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetAudioOutputConfigurationResponse * SOAP_FMAC4 soap_get__trt__SetAudioOutputConfigurationResponse(struct soap *soap, struct _trt__SetAudioOutputConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trt__SetAudioOutputConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
