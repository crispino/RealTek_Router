/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:59 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioAnalyticsStreamExtension(struct soap *soap, struct tt__AudioAnalyticsStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioAnalyticsStreamExtension(struct soap *soap, const struct tt__AudioAnalyticsStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioAnalyticsStreamExtension(struct soap *soap, const char *tag, int id, const struct tt__AudioAnalyticsStreamExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioAnalyticsStreamExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioAnalyticsStreamExtension * SOAP_FMAC4 soap_in_tt__AudioAnalyticsStreamExtension(struct soap *soap, const char *tag, struct tt__AudioAnalyticsStreamExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AudioAnalyticsStreamExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioAnalyticsStreamExtension, sizeof(struct tt__AudioAnalyticsStreamExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioAnalyticsStreamExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AudioAnalyticsStreamExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioAnalyticsStreamExtension, SOAP_TYPE_tt__AudioAnalyticsStreamExtension, sizeof(struct tt__AudioAnalyticsStreamExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioAnalyticsStreamExtension * SOAP_FMAC4 soap_new_tt__AudioAnalyticsStreamExtension(struct soap *soap, int n)
{
	struct tt__AudioAnalyticsStreamExtension *p;
	struct tt__AudioAnalyticsStreamExtension *a = (struct tt__AudioAnalyticsStreamExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioAnalyticsStreamExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioAnalyticsStreamExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioAnalyticsStreamExtension(struct soap *soap, const struct tt__AudioAnalyticsStreamExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioAnalyticsStreamExtension(soap, tag ? tag : "tt:AudioAnalyticsStreamExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioAnalyticsStreamExtension * SOAP_FMAC4 soap_get_tt__AudioAnalyticsStreamExtension(struct soap *soap, struct tt__AudioAnalyticsStreamExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioAnalyticsStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioDescriptor(struct soap *soap, struct tt__AudioDescriptor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->UtcTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioDescriptor(struct soap *soap, const struct tt__AudioDescriptor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioDescriptor(struct soap *soap, const char *tag, int id, const struct tt__AudioDescriptor *a, const char *type)
{
	soap_set_attr(soap, "UtcTime", soap_dateTime2s(soap, a->UtcTime), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioDescriptor), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioDescriptor * SOAP_FMAC4 soap_in_tt__AudioDescriptor(struct soap *soap, const char *tag, struct tt__AudioDescriptor *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AudioDescriptor *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioDescriptor, sizeof(struct tt__AudioDescriptor), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioDescriptor(soap, a);
	if (soap_s2dateTime(soap, soap_attr_value(soap, "UtcTime", 1), &a->UtcTime))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AudioDescriptor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioDescriptor, SOAP_TYPE_tt__AudioDescriptor, sizeof(struct tt__AudioDescriptor), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioDescriptor * SOAP_FMAC4 soap_new_tt__AudioDescriptor(struct soap *soap, int n)
{
	struct tt__AudioDescriptor *p;
	struct tt__AudioDescriptor *a = (struct tt__AudioDescriptor*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioDescriptor));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioDescriptor(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioDescriptor(struct soap *soap, const struct tt__AudioDescriptor *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioDescriptor(soap, tag ? tag : "tt:AudioDescriptor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioDescriptor * SOAP_FMAC4 soap_get_tt__AudioDescriptor(struct soap *soap, struct tt__AudioDescriptor *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MetadataStreamExtension2(struct soap *soap, struct tt__MetadataStreamExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MetadataStreamExtension2(struct soap *soap, const struct tt__MetadataStreamExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataStreamExtension2(struct soap *soap, const char *tag, int id, const struct tt__MetadataStreamExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataStreamExtension2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MetadataStreamExtension2 * SOAP_FMAC4 soap_in_tt__MetadataStreamExtension2(struct soap *soap, const char *tag, struct tt__MetadataStreamExtension2 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MetadataStreamExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataStreamExtension2, sizeof(struct tt__MetadataStreamExtension2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MetadataStreamExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataStreamExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataStreamExtension2, SOAP_TYPE_tt__MetadataStreamExtension2, sizeof(struct tt__MetadataStreamExtension2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MetadataStreamExtension2 * SOAP_FMAC4 soap_new_tt__MetadataStreamExtension2(struct soap *soap, int n)
{
	struct tt__MetadataStreamExtension2 *p;
	struct tt__MetadataStreamExtension2 *a = (struct tt__MetadataStreamExtension2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MetadataStreamExtension2));
	for (p = a; p && n--; p++)
		soap_default_tt__MetadataStreamExtension2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MetadataStreamExtension2(struct soap *soap, const struct tt__MetadataStreamExtension2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__MetadataStreamExtension2(soap, tag ? tag : "tt:MetadataStreamExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataStreamExtension2 * SOAP_FMAC4 soap_get_tt__MetadataStreamExtension2(struct soap *soap, struct tt__MetadataStreamExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataStreamExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AudioAnalyticsStream(struct soap *soap, struct tt__AudioAnalyticsStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAudioDescriptor = 0;
	a->AudioDescriptor = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AudioAnalyticsStream(struct soap *soap, const struct tt__AudioAnalyticsStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->AudioDescriptor)
	{	int i;
		for (i = 0; i < (int)a->__sizeAudioDescriptor; i++)
		{
			soap_embedded(soap, a->AudioDescriptor + i, SOAP_TYPE_tt__AudioDescriptor);
			soap_serialize_tt__AudioDescriptor(soap, a->AudioDescriptor + i);
		}
	}
	soap_serialize_PointerTott__AudioAnalyticsStreamExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioAnalyticsStream(struct soap *soap, const char *tag, int id, const struct tt__AudioAnalyticsStream *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioAnalyticsStream), type))
		return soap->error;
	if (a->AudioDescriptor)
	{	int i;
		for (i = 0; i < (int)a->__sizeAudioDescriptor; i++)
			if (soap_out_tt__AudioDescriptor(soap, "tt:AudioDescriptor", -1, a->AudioDescriptor + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__AudioAnalyticsStreamExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AudioAnalyticsStream * SOAP_FMAC4 soap_in_tt__AudioAnalyticsStream(struct soap *soap, const char *tag, struct tt__AudioAnalyticsStream *a, const char *type)
{
	struct soap_blist *soap_blist_AudioDescriptor = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AudioAnalyticsStream *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioAnalyticsStream, sizeof(struct tt__AudioAnalyticsStream), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AudioAnalyticsStream(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AudioDescriptor", 1, NULL))
			{	if (a->AudioDescriptor == NULL)
				{	if (soap_blist_AudioDescriptor == NULL)
						soap_blist_AudioDescriptor = soap_alloc_block(soap);
					a->AudioDescriptor = (struct tt__AudioDescriptor *)soap_push_block_max(soap, soap_blist_AudioDescriptor, sizeof(struct tt__AudioDescriptor));
					if (a->AudioDescriptor == NULL)
						return NULL;
					soap_default_tt__AudioDescriptor(soap, a->AudioDescriptor);
				}
				soap_revert(soap);
				if (soap_in_tt__AudioDescriptor(soap, "tt:AudioDescriptor", a->AudioDescriptor, "tt:AudioDescriptor"))
				{	a->__sizeAudioDescriptor++;
					a->AudioDescriptor = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioAnalyticsStreamExtension(soap, "tt:Extension", &a->Extension, "tt:AudioAnalyticsStreamExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AudioDescriptor)
			soap_pop_block(soap, soap_blist_AudioDescriptor);
		if (a->__sizeAudioDescriptor)
		{	a->AudioDescriptor = (struct tt__AudioDescriptor *)soap_save_block(soap, soap_blist_AudioDescriptor, NULL, 1);
		}
		else
		{	a->AudioDescriptor = NULL;
			if (soap_blist_AudioDescriptor)
				soap_end_block(soap, soap_blist_AudioDescriptor);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AudioAnalyticsStream *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioAnalyticsStream, SOAP_TYPE_tt__AudioAnalyticsStream, sizeof(struct tt__AudioAnalyticsStream), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AudioAnalyticsStream * SOAP_FMAC4 soap_new_tt__AudioAnalyticsStream(struct soap *soap, int n)
{
	struct tt__AudioAnalyticsStream *p;
	struct tt__AudioAnalyticsStream *a = (struct tt__AudioAnalyticsStream*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AudioAnalyticsStream));
	for (p = a; p && n--; p++)
		soap_default_tt__AudioAnalyticsStream(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AudioAnalyticsStream(struct soap *soap, const struct tt__AudioAnalyticsStream *a, const char *tag, const char *type)
{
	if (soap_out_tt__AudioAnalyticsStream(soap, tag ? tag : "tt:AudioAnalyticsStream", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioAnalyticsStream * SOAP_FMAC4 soap_get_tt__AudioAnalyticsStream(struct soap *soap, struct tt__AudioAnalyticsStream *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioAnalyticsStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MetadataStreamExtension(struct soap *soap, struct tt__MetadataStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->AudioAnalyticsStream = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MetadataStreamExtension(struct soap *soap, const struct tt__MetadataStreamExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AudioAnalyticsStream(soap, &a->AudioAnalyticsStream);
	soap_serialize_PointerTott__MetadataStreamExtension2(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataStreamExtension(struct soap *soap, const char *tag, int id, const struct tt__MetadataStreamExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataStreamExtension), type))
		return soap->error;
	if (soap_out_PointerTott__AudioAnalyticsStream(soap, "tt:AudioAnalyticsStream", -1, &a->AudioAnalyticsStream, ""))
		return soap->error;
	if (soap_out_PointerTott__MetadataStreamExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MetadataStreamExtension * SOAP_FMAC4 soap_in_tt__MetadataStreamExtension(struct soap *soap, const char *tag, struct tt__MetadataStreamExtension *a, const char *type)
{
	size_t soap_flag_AudioAnalyticsStream = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MetadataStreamExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataStreamExtension, sizeof(struct tt__MetadataStreamExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MetadataStreamExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AudioAnalyticsStream && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioAnalyticsStream(soap, "tt:AudioAnalyticsStream", &a->AudioAnalyticsStream, "tt:AudioAnalyticsStream"))
				{	soap_flag_AudioAnalyticsStream--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MetadataStreamExtension2(soap, "tt:Extension", &a->Extension, "tt:MetadataStreamExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataStreamExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataStreamExtension, SOAP_TYPE_tt__MetadataStreamExtension, sizeof(struct tt__MetadataStreamExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MetadataStreamExtension * SOAP_FMAC4 soap_new_tt__MetadataStreamExtension(struct soap *soap, int n)
{
	struct tt__MetadataStreamExtension *p;
	struct tt__MetadataStreamExtension *a = (struct tt__MetadataStreamExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MetadataStreamExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__MetadataStreamExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MetadataStreamExtension(struct soap *soap, const struct tt__MetadataStreamExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__MetadataStreamExtension(soap, tag ? tag : "tt:MetadataStreamExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataStreamExtension * SOAP_FMAC4 soap_get_tt__MetadataStreamExtension(struct soap *soap, struct tt__MetadataStreamExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__EventStream(struct soap *soap, struct tt__EventStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_EventStream = 0;
	a->__union_EventStream = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__EventStream(struct soap *soap, const struct tt__EventStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_EventStream)
	{	int i;
		for (i = 0; i < (int)a->__size_EventStream; i++)
		{
			soap_serialize___tt__union_EventStream(soap, a->__union_EventStream + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EventStream(struct soap *soap, const char *tag, int id, const struct tt__EventStream *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EventStream), type))
		return soap->error;
	if (a->__union_EventStream)
	{	int i;
		for (i = 0; i < (int)a->__size_EventStream; i++)
			if (soap_out___tt__union_EventStream(soap, "-union-EventStream", -1, a->__union_EventStream + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__EventStream * SOAP_FMAC4 soap_in_tt__EventStream(struct soap *soap, const char *tag, struct tt__EventStream *a, const char *type)
{
	struct soap_blist *soap_blist___union_EventStream = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__EventStream *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EventStream, sizeof(struct tt__EventStream), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__EventStream(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_EventStream == NULL)
				{	if (soap_blist___union_EventStream == NULL)
						soap_blist___union_EventStream = soap_alloc_block(soap);
					a->__union_EventStream = (struct __tt__union_EventStream *)soap_push_block_max(soap, soap_blist___union_EventStream, sizeof(struct __tt__union_EventStream));
					if (a->__union_EventStream == NULL)
						return NULL;
					soap_default___tt__union_EventStream(soap, a->__union_EventStream);
				}
				if (soap_in___tt__union_EventStream(soap, "-union-EventStream", a->__union_EventStream, "-tt:union-EventStream"))
				{	a->__size_EventStream++;
					a->__union_EventStream = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_EventStream)
			soap_pop_block(soap, soap_blist___union_EventStream);
		if (a->__size_EventStream)
		{	a->__union_EventStream = (struct __tt__union_EventStream *)soap_save_block(soap, soap_blist___union_EventStream, NULL, 1);
		}
		else
		{	a->__union_EventStream = NULL;
			if (soap_blist___union_EventStream)
				soap_end_block(soap, soap_blist___union_EventStream);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__EventStream *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EventStream, SOAP_TYPE_tt__EventStream, sizeof(struct tt__EventStream), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__EventStream * SOAP_FMAC4 soap_new_tt__EventStream(struct soap *soap, int n)
{
	struct tt__EventStream *p;
	struct tt__EventStream *a = (struct tt__EventStream*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__EventStream));
	for (p = a; p && n--; p++)
		soap_default_tt__EventStream(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EventStream(struct soap *soap, const struct tt__EventStream *a, const char *tag, const char *type)
{
	if (soap_out_tt__EventStream(soap, tag ? tag : "tt:EventStream", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EventStream * SOAP_FMAC4 soap_get_tt__EventStream(struct soap *soap, struct tt__EventStream *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EventStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZStream(struct soap *soap, struct tt__PTZStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_PTZStream = 0;
	a->__union_PTZStream = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZStream(struct soap *soap, const struct tt__PTZStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_PTZStream)
	{	int i;
		for (i = 0; i < (int)a->__size_PTZStream; i++)
		{
			soap_serialize___tt__union_PTZStream(soap, a->__union_PTZStream + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZStream(struct soap *soap, const char *tag, int id, const struct tt__PTZStream *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZStream), type))
		return soap->error;
	if (a->__union_PTZStream)
	{	int i;
		for (i = 0; i < (int)a->__size_PTZStream; i++)
			if (soap_out___tt__union_PTZStream(soap, "-union-PTZStream", -1, a->__union_PTZStream + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZStream * SOAP_FMAC4 soap_in_tt__PTZStream(struct soap *soap, const char *tag, struct tt__PTZStream *a, const char *type)
{
	struct soap_blist *soap_blist___union_PTZStream = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZStream *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZStream, sizeof(struct tt__PTZStream), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZStream(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_PTZStream == NULL)
				{	if (soap_blist___union_PTZStream == NULL)
						soap_blist___union_PTZStream = soap_alloc_block(soap);
					a->__union_PTZStream = (struct __tt__union_PTZStream *)soap_push_block_max(soap, soap_blist___union_PTZStream, sizeof(struct __tt__union_PTZStream));
					if (a->__union_PTZStream == NULL)
						return NULL;
					soap_default___tt__union_PTZStream(soap, a->__union_PTZStream);
				}
				if (soap_in___tt__union_PTZStream(soap, "-union-PTZStream", a->__union_PTZStream, "-tt:union-PTZStream"))
				{	a->__size_PTZStream++;
					a->__union_PTZStream = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_PTZStream)
			soap_pop_block(soap, soap_blist___union_PTZStream);
		if (a->__size_PTZStream)
		{	a->__union_PTZStream = (struct __tt__union_PTZStream *)soap_save_block(soap, soap_blist___union_PTZStream, NULL, 1);
		}
		else
		{	a->__union_PTZStream = NULL;
			if (soap_blist___union_PTZStream)
				soap_end_block(soap, soap_blist___union_PTZStream);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZStream *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZStream, SOAP_TYPE_tt__PTZStream, sizeof(struct tt__PTZStream), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PTZStream * SOAP_FMAC4 soap_new_tt__PTZStream(struct soap *soap, int n)
{
	struct tt__PTZStream *p;
	struct tt__PTZStream *a = (struct tt__PTZStream*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PTZStream));
	for (p = a; p && n--; p++)
		soap_default_tt__PTZStream(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZStream(struct soap *soap, const struct tt__PTZStream *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZStream(soap, tag ? tag : "tt:PTZStream", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZStream * SOAP_FMAC4 soap_get_tt__PTZStream(struct soap *soap, struct tt__PTZStream *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoAnalyticsStream(struct soap *soap, struct tt__VideoAnalyticsStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_VideoAnalyticsStream = 0;
	a->__union_VideoAnalyticsStream = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoAnalyticsStream(struct soap *soap, const struct tt__VideoAnalyticsStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_VideoAnalyticsStream)
	{	int i;
		for (i = 0; i < (int)a->__size_VideoAnalyticsStream; i++)
		{
			soap_serialize___tt__union_VideoAnalyticsStream(soap, a->__union_VideoAnalyticsStream + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoAnalyticsStream(struct soap *soap, const char *tag, int id, const struct tt__VideoAnalyticsStream *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoAnalyticsStream), type))
		return soap->error;
	if (a->__union_VideoAnalyticsStream)
	{	int i;
		for (i = 0; i < (int)a->__size_VideoAnalyticsStream; i++)
			if (soap_out___tt__union_VideoAnalyticsStream(soap, "-union-VideoAnalyticsStream", -1, a->__union_VideoAnalyticsStream + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoAnalyticsStream * SOAP_FMAC4 soap_in_tt__VideoAnalyticsStream(struct soap *soap, const char *tag, struct tt__VideoAnalyticsStream *a, const char *type)
{
	struct soap_blist *soap_blist___union_VideoAnalyticsStream = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoAnalyticsStream *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoAnalyticsStream, sizeof(struct tt__VideoAnalyticsStream), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoAnalyticsStream(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_VideoAnalyticsStream == NULL)
				{	if (soap_blist___union_VideoAnalyticsStream == NULL)
						soap_blist___union_VideoAnalyticsStream = soap_alloc_block(soap);
					a->__union_VideoAnalyticsStream = (struct __tt__union_VideoAnalyticsStream *)soap_push_block_max(soap, soap_blist___union_VideoAnalyticsStream, sizeof(struct __tt__union_VideoAnalyticsStream));
					if (a->__union_VideoAnalyticsStream == NULL)
						return NULL;
					soap_default___tt__union_VideoAnalyticsStream(soap, a->__union_VideoAnalyticsStream);
				}
				if (soap_in___tt__union_VideoAnalyticsStream(soap, "-union-VideoAnalyticsStream", a->__union_VideoAnalyticsStream, "-tt:union-VideoAnalyticsStream"))
				{	a->__size_VideoAnalyticsStream++;
					a->__union_VideoAnalyticsStream = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_VideoAnalyticsStream)
			soap_pop_block(soap, soap_blist___union_VideoAnalyticsStream);
		if (a->__size_VideoAnalyticsStream)
		{	a->__union_VideoAnalyticsStream = (struct __tt__union_VideoAnalyticsStream *)soap_save_block(soap, soap_blist___union_VideoAnalyticsStream, NULL, 1);
		}
		else
		{	a->__union_VideoAnalyticsStream = NULL;
			if (soap_blist___union_VideoAnalyticsStream)
				soap_end_block(soap, soap_blist___union_VideoAnalyticsStream);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__VideoAnalyticsStream *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoAnalyticsStream, SOAP_TYPE_tt__VideoAnalyticsStream, sizeof(struct tt__VideoAnalyticsStream), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoAnalyticsStream * SOAP_FMAC4 soap_new_tt__VideoAnalyticsStream(struct soap *soap, int n)
{
	struct tt__VideoAnalyticsStream *p;
	struct tt__VideoAnalyticsStream *a = (struct tt__VideoAnalyticsStream*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoAnalyticsStream));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoAnalyticsStream(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoAnalyticsStream(struct soap *soap, const struct tt__VideoAnalyticsStream *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoAnalyticsStream(soap, tag ? tag : "tt:VideoAnalyticsStream", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoAnalyticsStream * SOAP_FMAC4 soap_get_tt__VideoAnalyticsStream(struct soap *soap, struct tt__VideoAnalyticsStream *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoAnalyticsStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tt__union_MetadataStream(struct soap *soap, struct __tt__union_MetadataStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__union_MetadataStream = -1;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tt__union_MetadataStream(struct soap *soap, const struct __tt__union_MetadataStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__tt__union_MetadataStream(soap, a->__union_MetadataStream, &a->union_MetadataStream);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tt__union_MetadataStream(struct soap *soap, const char *tag, int id, const struct __tt__union_MetadataStream *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out__tt__union_MetadataStream(soap, a->__union_MetadataStream, &a->union_MetadataStream))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tt__union_MetadataStream * SOAP_FMAC4 soap_in___tt__union_MetadataStream(struct soap *soap, const char *tag, struct __tt__union_MetadataStream *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tt__union_MetadataStream *)soap_id_enter(soap, "", a, SOAP_TYPE___tt__union_MetadataStream, sizeof(struct __tt__union_MetadataStream), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tt__union_MetadataStream(soap, a);
		if (!soap_in__tt__union_MetadataStream(soap, &a->__union_MetadataStream, &a->union_MetadataStream))
			return NULL;
	return a;
}

SOAP_FMAC3 struct __tt__union_MetadataStream * SOAP_FMAC4 soap_new___tt__union_MetadataStream(struct soap *soap, int n)
{
	struct __tt__union_MetadataStream *p;
	struct __tt__union_MetadataStream *a = (struct __tt__union_MetadataStream*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __tt__union_MetadataStream));
	for (p = a; p && n--; p++)
		soap_default___tt__union_MetadataStream(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tt__union_MetadataStream(struct soap *soap, const struct __tt__union_MetadataStream *a, const char *tag, const char *type)
{
	if (soap_out___tt__union_MetadataStream(soap, tag ? tag : "-tt:union-MetadataStream", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tt__union_MetadataStream * SOAP_FMAC4 soap_get___tt__union_MetadataStream(struct soap *soap, struct __tt__union_MetadataStream *p, const char *tag, const char *type)
{
	if ((p = soap_in___tt__union_MetadataStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MetadataStream(struct soap *soap, struct tt__MetadataStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_MetadataStream = 0;
	a->__union_MetadataStream = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MetadataStream(struct soap *soap, const struct tt__MetadataStream *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__union_MetadataStream)
	{	int i;
		for (i = 0; i < (int)a->__size_MetadataStream; i++)
		{
			soap_serialize___tt__union_MetadataStream(soap, a->__union_MetadataStream + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataStream(struct soap *soap, const char *tag, int id, const struct tt__MetadataStream *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataStream), type))
		return soap->error;
	if (a->__union_MetadataStream)
	{	int i;
		for (i = 0; i < (int)a->__size_MetadataStream; i++)
			if (soap_out___tt__union_MetadataStream(soap, "-union-MetadataStream", -1, a->__union_MetadataStream + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MetadataStream * SOAP_FMAC4 soap_in_tt__MetadataStream(struct soap *soap, const char *tag, struct tt__MetadataStream *a, const char *type)
{
	struct soap_blist *soap_blist___union_MetadataStream = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MetadataStream *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataStream, sizeof(struct tt__MetadataStream), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MetadataStream(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_MetadataStream == NULL)
				{	if (soap_blist___union_MetadataStream == NULL)
						soap_blist___union_MetadataStream = soap_alloc_block(soap);
					a->__union_MetadataStream = (struct __tt__union_MetadataStream *)soap_push_block_max(soap, soap_blist___union_MetadataStream, sizeof(struct __tt__union_MetadataStream));
					if (a->__union_MetadataStream == NULL)
						return NULL;
					soap_default___tt__union_MetadataStream(soap, a->__union_MetadataStream);
				}
				if (soap_in___tt__union_MetadataStream(soap, "-union-MetadataStream", a->__union_MetadataStream, "-tt:union-MetadataStream"))
				{	a->__size_MetadataStream++;
					a->__union_MetadataStream = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_MetadataStream)
			soap_pop_block(soap, soap_blist___union_MetadataStream);
		if (a->__size_MetadataStream)
		{	a->__union_MetadataStream = (struct __tt__union_MetadataStream *)soap_save_block(soap, soap_blist___union_MetadataStream, NULL, 1);
		}
		else
		{	a->__union_MetadataStream = NULL;
			if (soap_blist___union_MetadataStream)
				soap_end_block(soap, soap_blist___union_MetadataStream);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataStream *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataStream, SOAP_TYPE_tt__MetadataStream, sizeof(struct tt__MetadataStream), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MetadataStream * SOAP_FMAC4 soap_new_tt__MetadataStream(struct soap *soap, int n)
{
	struct tt__MetadataStream *p;
	struct tt__MetadataStream *a = (struct tt__MetadataStream*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MetadataStream));
	for (p = a; p && n--; p++)
		soap_default_tt__MetadataStream(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MetadataStream(struct soap *soap, const struct tt__MetadataStream *a, const char *tag, const char *type)
{
	if (soap_out_tt__MetadataStream(soap, tag ? tag : "tt:MetadataStream", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataStream * SOAP_FMAC4 soap_get_tt__MetadataStream(struct soap *soap, struct tt__MetadataStream *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__CellLayout(struct soap *soap, struct tt__CellLayout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transformation = NULL;
	soap_default_xsd__integer(soap, &a->Columns);
	soap_default_xsd__integer(soap, &a->Rows);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__CellLayout(struct soap *soap, const struct tt__CellLayout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Transformation(soap, &a->Transformation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CellLayout(struct soap *soap, const char *tag, int id, const struct tt__CellLayout *a, const char *type)
{
	if (a->Columns)
		soap_set_attr(soap, "Columns", soap_xsd__integer2s(soap, a->Columns), 1);
	if (a->Rows)
		soap_set_attr(soap, "Rows", soap_xsd__integer2s(soap, a->Rows), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CellLayout), type))
		return soap->error;
	if (!a->Transformation)
	{	if (soap_element_nil(soap, "tt:Transformation"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__Transformation(soap, "tt:Transformation", -1, &a->Transformation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__CellLayout * SOAP_FMAC4 soap_in_tt__CellLayout(struct soap *soap, const char *tag, struct tt__CellLayout *a, const char *type)
{
	size_t soap_flag_Transformation = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__CellLayout *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CellLayout, sizeof(struct tt__CellLayout), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__CellLayout(soap, a);
	if (soap_s2xsd__integer(soap, soap_attr_value(soap, "Columns", 1), &a->Columns))
		return NULL;
	if (soap_s2xsd__integer(soap, soap_attr_value(soap, "Rows", 1), &a->Rows))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transformation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Transformation(soap, "tt:Transformation", &a->Transformation, "tt:Transformation"))
				{	soap_flag_Transformation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Transformation > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__CellLayout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CellLayout, SOAP_TYPE_tt__CellLayout, sizeof(struct tt__CellLayout), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__CellLayout * SOAP_FMAC4 soap_new_tt__CellLayout(struct soap *soap, int n)
{
	struct tt__CellLayout *p;
	struct tt__CellLayout *a = (struct tt__CellLayout*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__CellLayout));
	for (p = a; p && n--; p++)
		soap_default_tt__CellLayout(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__CellLayout(struct soap *soap, const struct tt__CellLayout *a, const char *tag, const char *type)
{
	if (soap_out_tt__CellLayout(soap, tag ? tag : "tt:CellLayout", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CellLayout * SOAP_FMAC4 soap_get_tt__CellLayout(struct soap *soap, struct tt__CellLayout *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CellLayout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MotionExpressionConfiguration(struct soap *soap, struct tt__MotionExpressionConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MotionExpression = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MotionExpressionConfiguration(struct soap *soap, const struct tt__MotionExpressionConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__MotionExpression(soap, &a->MotionExpression);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MotionExpressionConfiguration(struct soap *soap, const char *tag, int id, const struct tt__MotionExpressionConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MotionExpressionConfiguration), type))
		return soap->error;
	if (!a->MotionExpression)
	{	if (soap_element_nil(soap, "tt:MotionExpression"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__MotionExpression(soap, "tt:MotionExpression", -1, &a->MotionExpression, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MotionExpressionConfiguration * SOAP_FMAC4 soap_in_tt__MotionExpressionConfiguration(struct soap *soap, const char *tag, struct tt__MotionExpressionConfiguration *a, const char *type)
{
	size_t soap_flag_MotionExpression = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MotionExpressionConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MotionExpressionConfiguration, sizeof(struct tt__MotionExpressionConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MotionExpressionConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MotionExpression && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MotionExpression(soap, "tt:MotionExpression", &a->MotionExpression, "tt:MotionExpression"))
				{	soap_flag_MotionExpression--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MotionExpression > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__MotionExpressionConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MotionExpressionConfiguration, SOAP_TYPE_tt__MotionExpressionConfiguration, sizeof(struct tt__MotionExpressionConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MotionExpressionConfiguration * SOAP_FMAC4 soap_new_tt__MotionExpressionConfiguration(struct soap *soap, int n)
{
	struct tt__MotionExpressionConfiguration *p;
	struct tt__MotionExpressionConfiguration *a = (struct tt__MotionExpressionConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MotionExpressionConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__MotionExpressionConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MotionExpressionConfiguration(struct soap *soap, const struct tt__MotionExpressionConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__MotionExpressionConfiguration(soap, tag ? tag : "tt:MotionExpressionConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MotionExpressionConfiguration * SOAP_FMAC4 soap_get_tt__MotionExpressionConfiguration(struct soap *soap, struct tt__MotionExpressionConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MotionExpressionConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MotionExpression(struct soap *soap, struct tt__MotionExpression *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Expression);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MotionExpression(struct soap *soap, const struct tt__MotionExpression *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Expression);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MotionExpression(struct soap *soap, const char *tag, int id, const struct tt__MotionExpression *a, const char *type)
{
	if (a->Type)
		soap_set_attr(soap, "Type", soap_string2s(soap, a->Type), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MotionExpression), type))
		return soap->error;
	if (!a->Expression)
	{	if (soap_element_nil(soap, "tt:Expression"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "tt:Expression", -1, (char*const*)&a->Expression, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MotionExpression * SOAP_FMAC4 soap_in_tt__MotionExpression(struct soap *soap, const char *tag, struct tt__MotionExpression *a, const char *type)
{
	size_t soap_flag_Expression = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MotionExpression *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MotionExpression, sizeof(struct tt__MotionExpression), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MotionExpression(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Expression && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Expression", (char**)&a->Expression, "xsd:string"))
				{	soap_flag_Expression--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Expression > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__MotionExpression *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MotionExpression, SOAP_TYPE_tt__MotionExpression, sizeof(struct tt__MotionExpression), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MotionExpression * SOAP_FMAC4 soap_new_tt__MotionExpression(struct soap *soap, int n)
{
	struct tt__MotionExpression *p;
	struct tt__MotionExpression *a = (struct tt__MotionExpression*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MotionExpression));
	for (p = a; p && n--; p++)
		soap_default_tt__MotionExpression(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MotionExpression(struct soap *soap, const struct tt__MotionExpression *a, const char *tag, const char *type)
{
	if (soap_out_tt__MotionExpression(soap, tag ? tag : "tt:MotionExpression", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MotionExpression * SOAP_FMAC4 soap_get_tt__MotionExpression(struct soap *soap, struct tt__MotionExpression *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MotionExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PolylineArrayConfiguration(struct soap *soap, struct tt__PolylineArrayConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PolylineArray = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PolylineArrayConfiguration(struct soap *soap, const struct tt__PolylineArrayConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PolylineArray(soap, &a->PolylineArray);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PolylineArrayConfiguration(struct soap *soap, const char *tag, int id, const struct tt__PolylineArrayConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PolylineArrayConfiguration), type))
		return soap->error;
	if (!a->PolylineArray)
	{	if (soap_element_nil(soap, "tt:PolylineArray"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__PolylineArray(soap, "tt:PolylineArray", -1, &a->PolylineArray, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PolylineArrayConfiguration * SOAP_FMAC4 soap_in_tt__PolylineArrayConfiguration(struct soap *soap, const char *tag, struct tt__PolylineArrayConfiguration *a, const char *type)
{
	size_t soap_flag_PolylineArray = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PolylineArrayConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PolylineArrayConfiguration, sizeof(struct tt__PolylineArrayConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PolylineArrayConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PolylineArray && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PolylineArray(soap, "tt:PolylineArray", &a->PolylineArray, "tt:PolylineArray"))
				{	soap_flag_PolylineArray--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PolylineArray > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PolylineArrayConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PolylineArrayConfiguration, SOAP_TYPE_tt__PolylineArrayConfiguration, sizeof(struct tt__PolylineArrayConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PolylineArrayConfiguration * SOAP_FMAC4 soap_new_tt__PolylineArrayConfiguration(struct soap *soap, int n)
{
	struct tt__PolylineArrayConfiguration *p;
	struct tt__PolylineArrayConfiguration *a = (struct tt__PolylineArrayConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PolylineArrayConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__PolylineArrayConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PolylineArrayConfiguration(struct soap *soap, const struct tt__PolylineArrayConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__PolylineArrayConfiguration(soap, tag ? tag : "tt:PolylineArrayConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PolylineArrayConfiguration * SOAP_FMAC4 soap_get_tt__PolylineArrayConfiguration(struct soap *soap, struct tt__PolylineArrayConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PolylineArrayConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PolylineArrayExtension(struct soap *soap, struct tt__PolylineArrayExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PolylineArrayExtension(struct soap *soap, const struct tt__PolylineArrayExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PolylineArrayExtension(struct soap *soap, const char *tag, int id, const struct tt__PolylineArrayExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PolylineArrayExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PolylineArrayExtension * SOAP_FMAC4 soap_in_tt__PolylineArrayExtension(struct soap *soap, const char *tag, struct tt__PolylineArrayExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PolylineArrayExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PolylineArrayExtension, sizeof(struct tt__PolylineArrayExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PolylineArrayExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PolylineArrayExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PolylineArrayExtension, SOAP_TYPE_tt__PolylineArrayExtension, sizeof(struct tt__PolylineArrayExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PolylineArrayExtension * SOAP_FMAC4 soap_new_tt__PolylineArrayExtension(struct soap *soap, int n)
{
	struct tt__PolylineArrayExtension *p;
	struct tt__PolylineArrayExtension *a = (struct tt__PolylineArrayExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PolylineArrayExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__PolylineArrayExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PolylineArrayExtension(struct soap *soap, const struct tt__PolylineArrayExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__PolylineArrayExtension(soap, tag ? tag : "tt:PolylineArrayExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PolylineArrayExtension * SOAP_FMAC4 soap_get_tt__PolylineArrayExtension(struct soap *soap, struct tt__PolylineArrayExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PolylineArrayExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PolylineArray(struct soap *soap, struct tt__PolylineArray *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeSegment = 0;
	a->Segment = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PolylineArray(struct soap *soap, const struct tt__PolylineArray *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Segment)
	{	int i;
		for (i = 0; i < (int)a->__sizeSegment; i++)
		{
			soap_embedded(soap, a->Segment + i, SOAP_TYPE_tt__Polyline);
			soap_serialize_tt__Polyline(soap, a->Segment + i);
		}
	}
	soap_serialize_PointerTott__PolylineArrayExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PolylineArray(struct soap *soap, const char *tag, int id, const struct tt__PolylineArray *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PolylineArray), type))
		return soap->error;
	if (a->Segment)
	{	int i;
		for (i = 0; i < (int)a->__sizeSegment; i++)
			if (soap_out_tt__Polyline(soap, "tt:Segment", -1, a->Segment + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__PolylineArrayExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PolylineArray * SOAP_FMAC4 soap_in_tt__PolylineArray(struct soap *soap, const char *tag, struct tt__PolylineArray *a, const char *type)
{
	struct soap_blist *soap_blist_Segment = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PolylineArray *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PolylineArray, sizeof(struct tt__PolylineArray), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PolylineArray(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Segment", 1, NULL))
			{	if (a->Segment == NULL)
				{	if (soap_blist_Segment == NULL)
						soap_blist_Segment = soap_alloc_block(soap);
					a->Segment = (struct tt__Polyline *)soap_push_block_max(soap, soap_blist_Segment, sizeof(struct tt__Polyline));
					if (a->Segment == NULL)
						return NULL;
					soap_default_tt__Polyline(soap, a->Segment);
				}
				soap_revert(soap);
				if (soap_in_tt__Polyline(soap, "tt:Segment", a->Segment, "tt:Polyline"))
				{	a->__sizeSegment++;
					a->Segment = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PolylineArrayExtension(soap, "tt:Extension", &a->Extension, "tt:PolylineArrayExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Segment)
			soap_pop_block(soap, soap_blist_Segment);
		if (a->__sizeSegment)
		{	a->Segment = (struct tt__Polyline *)soap_save_block(soap, soap_blist_Segment, NULL, 1);
		}
		else
		{	a->Segment = NULL;
			if (soap_blist_Segment)
				soap_end_block(soap, soap_blist_Segment);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeSegment < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PolylineArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PolylineArray, SOAP_TYPE_tt__PolylineArray, sizeof(struct tt__PolylineArray), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PolylineArray * SOAP_FMAC4 soap_new_tt__PolylineArray(struct soap *soap, int n)
{
	struct tt__PolylineArray *p;
	struct tt__PolylineArray *a = (struct tt__PolylineArray*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PolylineArray));
	for (p = a; p && n--; p++)
		soap_default_tt__PolylineArray(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PolylineArray(struct soap *soap, const struct tt__PolylineArray *a, const char *tag, const char *type)
{
	if (soap_out_tt__PolylineArray(soap, tag ? tag : "tt:PolylineArray", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PolylineArray * SOAP_FMAC4 soap_get_tt__PolylineArray(struct soap *soap, struct tt__PolylineArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PolylineArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PolygonConfiguration(struct soap *soap, struct tt__PolygonConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Polygon = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PolygonConfiguration(struct soap *soap, const struct tt__PolygonConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Polygon(soap, &a->Polygon);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PolygonConfiguration(struct soap *soap, const char *tag, int id, const struct tt__PolygonConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PolygonConfiguration), type))
		return soap->error;
	if (!a->Polygon)
	{	if (soap_element_nil(soap, "tt:Polygon"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__Polygon(soap, "tt:Polygon", -1, &a->Polygon, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PolygonConfiguration * SOAP_FMAC4 soap_in_tt__PolygonConfiguration(struct soap *soap, const char *tag, struct tt__PolygonConfiguration *a, const char *type)
{
	size_t soap_flag_Polygon = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PolygonConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PolygonConfiguration, sizeof(struct tt__PolygonConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PolygonConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Polygon && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Polygon(soap, "tt:Polygon", &a->Polygon, "tt:Polygon"))
				{	soap_flag_Polygon--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Polygon > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__PolygonConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PolygonConfiguration, SOAP_TYPE_tt__PolygonConfiguration, sizeof(struct tt__PolygonConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__PolygonConfiguration * SOAP_FMAC4 soap_new_tt__PolygonConfiguration(struct soap *soap, int n)
{
	struct tt__PolygonConfiguration *p;
	struct tt__PolygonConfiguration *a = (struct tt__PolygonConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__PolygonConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__PolygonConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PolygonConfiguration(struct soap *soap, const struct tt__PolygonConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__PolygonConfiguration(soap, tag ? tag : "tt:PolygonConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PolygonConfiguration * SOAP_FMAC4 soap_get_tt__PolygonConfiguration(struct soap *soap, struct tt__PolygonConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PolygonConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SupportedAnalyticsModulesExtension(struct soap *soap, struct tt__SupportedAnalyticsModulesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SupportedAnalyticsModulesExtension(struct soap *soap, const struct tt__SupportedAnalyticsModulesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SupportedAnalyticsModulesExtension(struct soap *soap, const char *tag, int id, const struct tt__SupportedAnalyticsModulesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SupportedAnalyticsModulesExtension * SOAP_FMAC4 soap_in_tt__SupportedAnalyticsModulesExtension(struct soap *soap, const char *tag, struct tt__SupportedAnalyticsModulesExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SupportedAnalyticsModulesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension, sizeof(struct tt__SupportedAnalyticsModulesExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SupportedAnalyticsModulesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SupportedAnalyticsModulesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension, sizeof(struct tt__SupportedAnalyticsModulesExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SupportedAnalyticsModulesExtension * SOAP_FMAC4 soap_new_tt__SupportedAnalyticsModulesExtension(struct soap *soap, int n)
{
	struct tt__SupportedAnalyticsModulesExtension *p;
	struct tt__SupportedAnalyticsModulesExtension *a = (struct tt__SupportedAnalyticsModulesExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SupportedAnalyticsModulesExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__SupportedAnalyticsModulesExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SupportedAnalyticsModulesExtension(struct soap *soap, const struct tt__SupportedAnalyticsModulesExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__SupportedAnalyticsModulesExtension(soap, tag ? tag : "tt:SupportedAnalyticsModulesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SupportedAnalyticsModulesExtension * SOAP_FMAC4 soap_get_tt__SupportedAnalyticsModulesExtension(struct soap *soap, struct tt__SupportedAnalyticsModulesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SupportedAnalyticsModulesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SupportedAnalyticsModules(struct soap *soap, struct tt__SupportedAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAnalyticsModuleContentSchemaLocation = 0;
	a->AnalyticsModuleContentSchemaLocation = NULL;
	a->__sizeAnalyticsModuleDescription = 0;
	a->AnalyticsModuleDescription = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SupportedAnalyticsModules(struct soap *soap, const struct tt__SupportedAnalyticsModules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->AnalyticsModuleContentSchemaLocation)
	{	int i;
		for (i = 0; i < (int)a->__sizeAnalyticsModuleContentSchemaLocation; i++)
		{
			soap_serialize_xsd__anyURI(soap, (char*const*)(a->AnalyticsModuleContentSchemaLocation + i));
		}
	}
	if (a->AnalyticsModuleDescription)
	{	int i;
		for (i = 0; i < (int)a->__sizeAnalyticsModuleDescription; i++)
		{
			soap_embedded(soap, a->AnalyticsModuleDescription + i, SOAP_TYPE_tt__ConfigDescription);
			soap_serialize_tt__ConfigDescription(soap, a->AnalyticsModuleDescription + i);
		}
	}
	soap_serialize_PointerTott__SupportedAnalyticsModulesExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SupportedAnalyticsModules(struct soap *soap, const char *tag, int id, const struct tt__SupportedAnalyticsModules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SupportedAnalyticsModules), type))
		return soap->error;
	if (a->AnalyticsModuleContentSchemaLocation)
	{	int i;
		for (i = 0; i < (int)a->__sizeAnalyticsModuleContentSchemaLocation; i++)
			soap_out_string(soap, "tt:AnalyticsModuleContentSchemaLocation", -1, (char*const*)(a->AnalyticsModuleContentSchemaLocation + i), "");
	}
	if (a->AnalyticsModuleDescription)
	{	int i;
		for (i = 0; i < (int)a->__sizeAnalyticsModuleDescription; i++)
			if (soap_out_tt__ConfigDescription(soap, "tt:AnalyticsModuleDescription", -1, a->AnalyticsModuleDescription + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__SupportedAnalyticsModulesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SupportedAnalyticsModules * SOAP_FMAC4 soap_in_tt__SupportedAnalyticsModules(struct soap *soap, const char *tag, struct tt__SupportedAnalyticsModules *a, const char *type)
{
	struct soap_blist *soap_blist_AnalyticsModuleContentSchemaLocation = NULL;
	struct soap_blist *soap_blist_AnalyticsModuleDescription = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SupportedAnalyticsModules *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SupportedAnalyticsModules, sizeof(struct tt__SupportedAnalyticsModules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SupportedAnalyticsModules(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AnalyticsModuleContentSchemaLocation", 1, NULL))
			{	if (a->AnalyticsModuleContentSchemaLocation == NULL)
				{	if (soap_blist_AnalyticsModuleContentSchemaLocation == NULL)
						soap_blist_AnalyticsModuleContentSchemaLocation = soap_alloc_block(soap);
					a->AnalyticsModuleContentSchemaLocation = (char **)soap_push_block_max(soap, soap_blist_AnalyticsModuleContentSchemaLocation, sizeof(char *));
					if (a->AnalyticsModuleContentSchemaLocation == NULL)
						return NULL;
					*a->AnalyticsModuleContentSchemaLocation = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "tt:AnalyticsModuleContentSchemaLocation", (char**)a->AnalyticsModuleContentSchemaLocation, "xsd:anyURI"))
				{	a->__sizeAnalyticsModuleContentSchemaLocation++;
					a->AnalyticsModuleContentSchemaLocation = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AnalyticsModuleDescription", 1, NULL))
			{	if (a->AnalyticsModuleDescription == NULL)
				{	if (soap_blist_AnalyticsModuleDescription == NULL)
						soap_blist_AnalyticsModuleDescription = soap_alloc_block(soap);
					a->AnalyticsModuleDescription = (struct tt__ConfigDescription *)soap_push_block_max(soap, soap_blist_AnalyticsModuleDescription, sizeof(struct tt__ConfigDescription));
					if (a->AnalyticsModuleDescription == NULL)
						return NULL;
					soap_default_tt__ConfigDescription(soap, a->AnalyticsModuleDescription);
				}
				soap_revert(soap);
				if (soap_in_tt__ConfigDescription(soap, "tt:AnalyticsModuleDescription", a->AnalyticsModuleDescription, "tt:ConfigDescription"))
				{	a->__sizeAnalyticsModuleDescription++;
					a->AnalyticsModuleDescription = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SupportedAnalyticsModulesExtension(soap, "tt:Extension", &a->Extension, "tt:SupportedAnalyticsModulesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AnalyticsModuleContentSchemaLocation)
			soap_pop_block(soap, soap_blist_AnalyticsModuleContentSchemaLocation);
		if (a->__sizeAnalyticsModuleContentSchemaLocation)
		{	a->AnalyticsModuleContentSchemaLocation = (char **)soap_save_block(soap, soap_blist_AnalyticsModuleContentSchemaLocation, NULL, 1);
		}
		else
		{	a->AnalyticsModuleContentSchemaLocation = NULL;
			if (soap_blist_AnalyticsModuleContentSchemaLocation)
				soap_end_block(soap, soap_blist_AnalyticsModuleContentSchemaLocation);
		}
		if (a->AnalyticsModuleDescription)
			soap_pop_block(soap, soap_blist_AnalyticsModuleDescription);
		if (a->__sizeAnalyticsModuleDescription)
		{	a->AnalyticsModuleDescription = (struct tt__ConfigDescription *)soap_save_block(soap, soap_blist_AnalyticsModuleDescription, NULL, 1);
		}
		else
		{	a->AnalyticsModuleDescription = NULL;
			if (soap_blist_AnalyticsModuleDescription)
				soap_end_block(soap, soap_blist_AnalyticsModuleDescription);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SupportedAnalyticsModules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SupportedAnalyticsModules, SOAP_TYPE_tt__SupportedAnalyticsModules, sizeof(struct tt__SupportedAnalyticsModules), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SupportedAnalyticsModules * SOAP_FMAC4 soap_new_tt__SupportedAnalyticsModules(struct soap *soap, int n)
{
	struct tt__SupportedAnalyticsModules *p;
	struct tt__SupportedAnalyticsModules *a = (struct tt__SupportedAnalyticsModules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SupportedAnalyticsModules));
	for (p = a; p && n--; p++)
		soap_default_tt__SupportedAnalyticsModules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SupportedAnalyticsModules(struct soap *soap, const struct tt__SupportedAnalyticsModules *a, const char *tag, const char *type)
{
	if (soap_out_tt__SupportedAnalyticsModules(soap, tag ? tag : "tt:SupportedAnalyticsModules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SupportedAnalyticsModules * SOAP_FMAC4 soap_get_tt__SupportedAnalyticsModules(struct soap *soap, struct tt__SupportedAnalyticsModules *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SupportedAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SupportedRulesExtension(struct soap *soap, struct tt__SupportedRulesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SupportedRulesExtension(struct soap *soap, const struct tt__SupportedRulesExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SupportedRulesExtension(struct soap *soap, const char *tag, int id, const struct tt__SupportedRulesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SupportedRulesExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SupportedRulesExtension * SOAP_FMAC4 soap_in_tt__SupportedRulesExtension(struct soap *soap, const char *tag, struct tt__SupportedRulesExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SupportedRulesExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SupportedRulesExtension, sizeof(struct tt__SupportedRulesExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SupportedRulesExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SupportedRulesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SupportedRulesExtension, SOAP_TYPE_tt__SupportedRulesExtension, sizeof(struct tt__SupportedRulesExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SupportedRulesExtension * SOAP_FMAC4 soap_new_tt__SupportedRulesExtension(struct soap *soap, int n)
{
	struct tt__SupportedRulesExtension *p;
	struct tt__SupportedRulesExtension *a = (struct tt__SupportedRulesExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SupportedRulesExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__SupportedRulesExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SupportedRulesExtension(struct soap *soap, const struct tt__SupportedRulesExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__SupportedRulesExtension(soap, tag ? tag : "tt:SupportedRulesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SupportedRulesExtension * SOAP_FMAC4 soap_get_tt__SupportedRulesExtension(struct soap *soap, struct tt__SupportedRulesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SupportedRulesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__SupportedRules(struct soap *soap, struct tt__SupportedRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeRuleContentSchemaLocation = 0;
	a->RuleContentSchemaLocation = NULL;
	a->__sizeRuleDescription = 0;
	a->RuleDescription = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__SupportedRules(struct soap *soap, const struct tt__SupportedRules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->RuleContentSchemaLocation)
	{	int i;
		for (i = 0; i < (int)a->__sizeRuleContentSchemaLocation; i++)
		{
			soap_serialize_xsd__anyURI(soap, (char*const*)(a->RuleContentSchemaLocation + i));
		}
	}
	if (a->RuleDescription)
	{	int i;
		for (i = 0; i < (int)a->__sizeRuleDescription; i++)
		{
			soap_embedded(soap, a->RuleDescription + i, SOAP_TYPE_tt__ConfigDescription);
			soap_serialize_tt__ConfigDescription(soap, a->RuleDescription + i);
		}
	}
	soap_serialize_PointerTott__SupportedRulesExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SupportedRules(struct soap *soap, const char *tag, int id, const struct tt__SupportedRules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SupportedRules), type))
		return soap->error;
	if (a->RuleContentSchemaLocation)
	{	int i;
		for (i = 0; i < (int)a->__sizeRuleContentSchemaLocation; i++)
			soap_out_string(soap, "tt:RuleContentSchemaLocation", -1, (char*const*)(a->RuleContentSchemaLocation + i), "");
	}
	if (a->RuleDescription)
	{	int i;
		for (i = 0; i < (int)a->__sizeRuleDescription; i++)
			if (soap_out_tt__ConfigDescription(soap, "tt:RuleDescription", -1, a->RuleDescription + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__SupportedRulesExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__SupportedRules * SOAP_FMAC4 soap_in_tt__SupportedRules(struct soap *soap, const char *tag, struct tt__SupportedRules *a, const char *type)
{
	struct soap_blist *soap_blist_RuleContentSchemaLocation = NULL;
	struct soap_blist *soap_blist_RuleDescription = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__SupportedRules *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SupportedRules, sizeof(struct tt__SupportedRules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__SupportedRules(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:RuleContentSchemaLocation", 1, NULL))
			{	if (a->RuleContentSchemaLocation == NULL)
				{	if (soap_blist_RuleContentSchemaLocation == NULL)
						soap_blist_RuleContentSchemaLocation = soap_alloc_block(soap);
					a->RuleContentSchemaLocation = (char **)soap_push_block_max(soap, soap_blist_RuleContentSchemaLocation, sizeof(char *));
					if (a->RuleContentSchemaLocation == NULL)
						return NULL;
					*a->RuleContentSchemaLocation = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "tt:RuleContentSchemaLocation", (char**)a->RuleContentSchemaLocation, "xsd:anyURI"))
				{	a->__sizeRuleContentSchemaLocation++;
					a->RuleContentSchemaLocation = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:RuleDescription", 1, NULL))
			{	if (a->RuleDescription == NULL)
				{	if (soap_blist_RuleDescription == NULL)
						soap_blist_RuleDescription = soap_alloc_block(soap);
					a->RuleDescription = (struct tt__ConfigDescription *)soap_push_block_max(soap, soap_blist_RuleDescription, sizeof(struct tt__ConfigDescription));
					if (a->RuleDescription == NULL)
						return NULL;
					soap_default_tt__ConfigDescription(soap, a->RuleDescription);
				}
				soap_revert(soap);
				if (soap_in_tt__ConfigDescription(soap, "tt:RuleDescription", a->RuleDescription, "tt:ConfigDescription"))
				{	a->__sizeRuleDescription++;
					a->RuleDescription = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SupportedRulesExtension(soap, "tt:Extension", &a->Extension, "tt:SupportedRulesExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->RuleContentSchemaLocation)
			soap_pop_block(soap, soap_blist_RuleContentSchemaLocation);
		if (a->__sizeRuleContentSchemaLocation)
		{	a->RuleContentSchemaLocation = (char **)soap_save_block(soap, soap_blist_RuleContentSchemaLocation, NULL, 1);
		}
		else
		{	a->RuleContentSchemaLocation = NULL;
			if (soap_blist_RuleContentSchemaLocation)
				soap_end_block(soap, soap_blist_RuleContentSchemaLocation);
		}
		if (a->RuleDescription)
			soap_pop_block(soap, soap_blist_RuleDescription);
		if (a->__sizeRuleDescription)
		{	a->RuleDescription = (struct tt__ConfigDescription *)soap_save_block(soap, soap_blist_RuleDescription, NULL, 1);
		}
		else
		{	a->RuleDescription = NULL;
			if (soap_blist_RuleDescription)
				soap_end_block(soap, soap_blist_RuleDescription);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__SupportedRules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SupportedRules, SOAP_TYPE_tt__SupportedRules, sizeof(struct tt__SupportedRules), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__SupportedRules * SOAP_FMAC4 soap_new_tt__SupportedRules(struct soap *soap, int n)
{
	struct tt__SupportedRules *p;
	struct tt__SupportedRules *a = (struct tt__SupportedRules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__SupportedRules));
	for (p = a; p && n--; p++)
		soap_default_tt__SupportedRules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__SupportedRules(struct soap *soap, const struct tt__SupportedRules *a, const char *tag, const char *type)
{
	if (soap_out_tt__SupportedRules(soap, tag ? tag : "tt:SupportedRules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SupportedRules * SOAP_FMAC4 soap_get_tt__SupportedRules(struct soap *soap, struct tt__SupportedRules *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SupportedRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ConfigDescriptionExtension(struct soap *soap, struct tt__ConfigDescriptionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ConfigDescriptionExtension(struct soap *soap, const struct tt__ConfigDescriptionExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ConfigDescriptionExtension(struct soap *soap, const char *tag, int id, const struct tt__ConfigDescriptionExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ConfigDescriptionExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ConfigDescriptionExtension * SOAP_FMAC4 soap_in_tt__ConfigDescriptionExtension(struct soap *soap, const char *tag, struct tt__ConfigDescriptionExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ConfigDescriptionExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ConfigDescriptionExtension, sizeof(struct tt__ConfigDescriptionExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ConfigDescriptionExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ConfigDescriptionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ConfigDescriptionExtension, SOAP_TYPE_tt__ConfigDescriptionExtension, sizeof(struct tt__ConfigDescriptionExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ConfigDescriptionExtension * SOAP_FMAC4 soap_new_tt__ConfigDescriptionExtension(struct soap *soap, int n)
{
	struct tt__ConfigDescriptionExtension *p;
	struct tt__ConfigDescriptionExtension *a = (struct tt__ConfigDescriptionExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ConfigDescriptionExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ConfigDescriptionExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ConfigDescriptionExtension(struct soap *soap, const struct tt__ConfigDescriptionExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ConfigDescriptionExtension(soap, tag ? tag : "tt:ConfigDescriptionExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ConfigDescriptionExtension * SOAP_FMAC4 soap_get_tt__ConfigDescriptionExtension(struct soap *soap, struct tt__ConfigDescriptionExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ConfigDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__ConfigDescription_Messages(struct soap *soap, struct _tt__ConfigDescription_Messages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Source = NULL;
	a->Key = NULL;
	a->Data = NULL;
	a->Extension = NULL;
	a->IsProperty = NULL;
	soap_default_string(soap, &a->ParentTopic);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__ConfigDescription_Messages(struct soap *soap, const struct _tt__ConfigDescription_Messages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ItemListDescription(soap, &a->Source);
	soap_serialize_PointerTott__ItemListDescription(soap, &a->Key);
	soap_serialize_PointerTott__ItemListDescription(soap, &a->Data);
	soap_serialize_PointerTott__MessageDescriptionExtension(soap, &a->Extension);
	soap_serialize_string(soap, (char*const*)&a->ParentTopic);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ConfigDescription_Messages(struct soap *soap, const char *tag, int id, const struct _tt__ConfigDescription_Messages *a, const char *type)
{
	if (a->IsProperty)
		soap_set_attr(soap, "IsProperty", soap_xsd__boolean2s(soap, *a->IsProperty), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ConfigDescription_Messages), type))
		return soap->error;
	if (soap_out_PointerTott__ItemListDescription(soap, "tt:Source", -1, &a->Source, ""))
		return soap->error;
	if (soap_out_PointerTott__ItemListDescription(soap, "tt:Key", -1, &a->Key, ""))
		return soap->error;
	if (soap_out_PointerTott__ItemListDescription(soap, "tt:Data", -1, &a->Data, ""))
		return soap->error;
	if (soap_out_PointerTott__MessageDescriptionExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	if (!a->ParentTopic)
	{	if (soap_element_nil(soap, "tt:ParentTopic"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "tt:ParentTopic", -1, (char*const*)&a->ParentTopic, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__ConfigDescription_Messages * SOAP_FMAC4 soap_in__tt__ConfigDescription_Messages(struct soap *soap, const char *tag, struct _tt__ConfigDescription_Messages *a, const char *type)
{
	size_t soap_flag_Source = 1;
	size_t soap_flag_Key = 1;
	size_t soap_flag_Data = 1;
	size_t soap_flag_Extension = 1;
	size_t soap_flag_ParentTopic = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tt__ConfigDescription_Messages *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ConfigDescription_Messages, sizeof(struct _tt__ConfigDescription_Messages), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__ConfigDescription_Messages(soap, a);
	{	const char *t = soap_attr_value(soap, "IsProperty", 0);
		if (t)
		{
			if (!(a->IsProperty = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->IsProperty))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Source && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemListDescription(soap, "tt:Source", &a->Source, "tt:ItemListDescription"))
				{	soap_flag_Source--;
					continue;
				}
			if (soap_flag_Key && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemListDescription(soap, "tt:Key", &a->Key, "tt:ItemListDescription"))
				{	soap_flag_Key--;
					continue;
				}
			if (soap_flag_Data && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemListDescription(soap, "tt:Data", &a->Data, "tt:ItemListDescription"))
				{	soap_flag_Data--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MessageDescriptionExtension(soap, "tt:Extension", &a->Extension, "tt:MessageDescriptionExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap_flag_ParentTopic && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:ParentTopic", (char**)&a->ParentTopic, "xsd:string"))
				{	soap_flag_ParentTopic--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ParentTopic > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tt__ConfigDescription_Messages *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ConfigDescription_Messages, SOAP_TYPE__tt__ConfigDescription_Messages, sizeof(struct _tt__ConfigDescription_Messages), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tt__ConfigDescription_Messages * SOAP_FMAC4 soap_new__tt__ConfigDescription_Messages(struct soap *soap, int n)
{
	struct _tt__ConfigDescription_Messages *p;
	struct _tt__ConfigDescription_Messages *a = (struct _tt__ConfigDescription_Messages*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tt__ConfigDescription_Messages));
	for (p = a; p && n--; p++)
		soap_default__tt__ConfigDescription_Messages(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__ConfigDescription_Messages(struct soap *soap, const struct _tt__ConfigDescription_Messages *a, const char *tag, const char *type)
{
	if (soap_out__tt__ConfigDescription_Messages(soap, tag ? tag : "tt:ConfigDescription-Messages", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ConfigDescription_Messages * SOAP_FMAC4 soap_get__tt__ConfigDescription_Messages(struct soap *soap, struct _tt__ConfigDescription_Messages *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ConfigDescription_Messages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ConfigDescription(struct soap *soap, struct tt__ConfigDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Parameters = NULL;
	a->__sizeMessages = 0;
	a->Messages = NULL;
	a->Extension = NULL;
	soap_default__QName(soap, &a->Name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ConfigDescription(struct soap *soap, const struct tt__ConfigDescription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ItemListDescription(soap, &a->Parameters);
	if (a->Messages)
	{	int i;
		for (i = 0; i < (int)a->__sizeMessages; i++)
		{
			soap_embedded(soap, a->Messages + i, SOAP_TYPE__tt__ConfigDescription_Messages);
			soap_serialize__tt__ConfigDescription_Messages(soap, a->Messages + i);
		}
	}
	soap_serialize_PointerTott__ConfigDescriptionExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ConfigDescription(struct soap *soap, const char *tag, int id, const struct tt__ConfigDescription *a, const char *type)
{
	if (a->Name)
		soap_set_attr(soap, "Name", soap__QName2s(soap, a->Name), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ConfigDescription), type))
		return soap->error;
	if (!a->Parameters)
	{	if (soap_element_nil(soap, "tt:Parameters"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__ItemListDescription(soap, "tt:Parameters", -1, &a->Parameters, ""))
		return soap->error;
	if (a->Messages)
	{	int i;
		for (i = 0; i < (int)a->__sizeMessages; i++)
			if (soap_out__tt__ConfigDescription_Messages(soap, "tt:Messages", -1, a->Messages + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ConfigDescriptionExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ConfigDescription * SOAP_FMAC4 soap_in_tt__ConfigDescription(struct soap *soap, const char *tag, struct tt__ConfigDescription *a, const char *type)
{
	size_t soap_flag_Parameters = 1;
	struct soap_blist *soap_blist_Messages = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ConfigDescription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ConfigDescription, sizeof(struct tt__ConfigDescription), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ConfigDescription(soap, a);
	if (soap_s2_QName(soap, soap_attr_value(soap, "Name", 1), &a->Name))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Parameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemListDescription(soap, "tt:Parameters", &a->Parameters, "tt:ItemListDescription"))
				{	soap_flag_Parameters--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Messages", 1, NULL))
			{	if (a->Messages == NULL)
				{	if (soap_blist_Messages == NULL)
						soap_blist_Messages = soap_alloc_block(soap);
					a->Messages = (struct _tt__ConfigDescription_Messages *)soap_push_block_max(soap, soap_blist_Messages, sizeof(struct _tt__ConfigDescription_Messages));
					if (a->Messages == NULL)
						return NULL;
					soap_default__tt__ConfigDescription_Messages(soap, a->Messages);
				}
				soap_revert(soap);
				if (soap_in__tt__ConfigDescription_Messages(soap, "tt:Messages", a->Messages, ""))
				{	a->__sizeMessages++;
					a->Messages = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ConfigDescriptionExtension(soap, "tt:Extension", &a->Extension, "tt:ConfigDescriptionExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Messages)
			soap_pop_block(soap, soap_blist_Messages);
		if (a->__sizeMessages)
		{	a->Messages = (struct _tt__ConfigDescription_Messages *)soap_save_block(soap, soap_blist_Messages, NULL, 1);
		}
		else
		{	a->Messages = NULL;
			if (soap_blist_Messages)
				soap_end_block(soap, soap_blist_Messages);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Parameters > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ConfigDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ConfigDescription, SOAP_TYPE_tt__ConfigDescription, sizeof(struct tt__ConfigDescription), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ConfigDescription * SOAP_FMAC4 soap_new_tt__ConfigDescription(struct soap *soap, int n)
{
	struct tt__ConfigDescription *p;
	struct tt__ConfigDescription *a = (struct tt__ConfigDescription*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ConfigDescription));
	for (p = a; p && n--; p++)
		soap_default_tt__ConfigDescription(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ConfigDescription(struct soap *soap, const struct tt__ConfigDescription *a, const char *tag, const char *type)
{
	if (soap_out_tt__ConfigDescription(soap, tag ? tag : "tt:ConfigDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ConfigDescription * SOAP_FMAC4 soap_get_tt__ConfigDescription(struct soap *soap, struct tt__ConfigDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ConfigDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RuleEngineConfigurationExtension(struct soap *soap, struct tt__RuleEngineConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RuleEngineConfigurationExtension(struct soap *soap, const struct tt__RuleEngineConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RuleEngineConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__RuleEngineConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RuleEngineConfigurationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RuleEngineConfigurationExtension * SOAP_FMAC4 soap_in_tt__RuleEngineConfigurationExtension(struct soap *soap, const char *tag, struct tt__RuleEngineConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RuleEngineConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RuleEngineConfigurationExtension, sizeof(struct tt__RuleEngineConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RuleEngineConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RuleEngineConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RuleEngineConfigurationExtension, SOAP_TYPE_tt__RuleEngineConfigurationExtension, sizeof(struct tt__RuleEngineConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RuleEngineConfigurationExtension * SOAP_FMAC4 soap_new_tt__RuleEngineConfigurationExtension(struct soap *soap, int n)
{
	struct tt__RuleEngineConfigurationExtension *p;
	struct tt__RuleEngineConfigurationExtension *a = (struct tt__RuleEngineConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RuleEngineConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__RuleEngineConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RuleEngineConfigurationExtension(struct soap *soap, const struct tt__RuleEngineConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__RuleEngineConfigurationExtension(soap, tag ? tag : "tt:RuleEngineConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RuleEngineConfigurationExtension * SOAP_FMAC4 soap_get_tt__RuleEngineConfigurationExtension(struct soap *soap, struct tt__RuleEngineConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RuleEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__RuleEngineConfiguration(struct soap *soap, struct tt__RuleEngineConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeRule = 0;
	a->Rule = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RuleEngineConfiguration(struct soap *soap, const struct tt__RuleEngineConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Rule)
	{	int i;
		for (i = 0; i < (int)a->__sizeRule; i++)
		{
			soap_embedded(soap, a->Rule + i, SOAP_TYPE_tt__Config);
			soap_serialize_tt__Config(soap, a->Rule + i);
		}
	}
	soap_serialize_PointerTott__RuleEngineConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RuleEngineConfiguration(struct soap *soap, const char *tag, int id, const struct tt__RuleEngineConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RuleEngineConfiguration), type))
		return soap->error;
	if (a->Rule)
	{	int i;
		for (i = 0; i < (int)a->__sizeRule; i++)
			if (soap_out_tt__Config(soap, "tt:Rule", -1, a->Rule + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__RuleEngineConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__RuleEngineConfiguration * SOAP_FMAC4 soap_in_tt__RuleEngineConfiguration(struct soap *soap, const char *tag, struct tt__RuleEngineConfiguration *a, const char *type)
{
	struct soap_blist *soap_blist_Rule = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__RuleEngineConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RuleEngineConfiguration, sizeof(struct tt__RuleEngineConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__RuleEngineConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Rule", 1, NULL))
			{	if (a->Rule == NULL)
				{	if (soap_blist_Rule == NULL)
						soap_blist_Rule = soap_alloc_block(soap);
					a->Rule = (struct tt__Config *)soap_push_block_max(soap, soap_blist_Rule, sizeof(struct tt__Config));
					if (a->Rule == NULL)
						return NULL;
					soap_default_tt__Config(soap, a->Rule);
				}
				soap_revert(soap);
				if (soap_in_tt__Config(soap, "tt:Rule", a->Rule, "tt:Config"))
				{	a->__sizeRule++;
					a->Rule = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RuleEngineConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:RuleEngineConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Rule)
			soap_pop_block(soap, soap_blist_Rule);
		if (a->__sizeRule)
		{	a->Rule = (struct tt__Config *)soap_save_block(soap, soap_blist_Rule, NULL, 1);
		}
		else
		{	a->Rule = NULL;
			if (soap_blist_Rule)
				soap_end_block(soap, soap_blist_Rule);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__RuleEngineConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RuleEngineConfiguration, SOAP_TYPE_tt__RuleEngineConfiguration, sizeof(struct tt__RuleEngineConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__RuleEngineConfiguration * SOAP_FMAC4 soap_new_tt__RuleEngineConfiguration(struct soap *soap, int n)
{
	struct tt__RuleEngineConfiguration *p;
	struct tt__RuleEngineConfiguration *a = (struct tt__RuleEngineConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__RuleEngineConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__RuleEngineConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RuleEngineConfiguration(struct soap *soap, const struct tt__RuleEngineConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__RuleEngineConfiguration(soap, tag ? tag : "tt:RuleEngineConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RuleEngineConfiguration * SOAP_FMAC4 soap_get_tt__RuleEngineConfiguration(struct soap *soap, struct tt__RuleEngineConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RuleEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, struct tt__AnalyticsEngineConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, const struct tt__AnalyticsEngineConfigurationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsEngineConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsEngineConfigurationExtension * SOAP_FMAC4 soap_in_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *tag, struct tt__AnalyticsEngineConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AnalyticsEngineConfigurationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, sizeof(struct tt__AnalyticsEngineConfigurationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsEngineConfigurationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, sizeof(struct tt__AnalyticsEngineConfigurationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnalyticsEngineConfigurationExtension * SOAP_FMAC4 soap_new_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, int n)
{
	struct tt__AnalyticsEngineConfigurationExtension *p;
	struct tt__AnalyticsEngineConfigurationExtension *a = (struct tt__AnalyticsEngineConfigurationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnalyticsEngineConfigurationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__AnalyticsEngineConfigurationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, const struct tt__AnalyticsEngineConfigurationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnalyticsEngineConfigurationExtension(soap, tag ? tag : "tt:AnalyticsEngineConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineConfigurationExtension * SOAP_FMAC4 soap_get_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, struct tt__AnalyticsEngineConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Config(struct soap *soap, struct tt__Config *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Parameters = NULL;
	soap_default_string(soap, &a->Name);
	soap_default__QName(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Config(struct soap *soap, const struct tt__Config *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ItemList(soap, &a->Parameters);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Config(struct soap *soap, const char *tag, int id, const struct tt__Config *a, const char *type)
{
	if (a->Name)
		soap_set_attr(soap, "Name", soap_string2s(soap, a->Name), 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap__QName2s(soap, a->Type), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Config), type))
		return soap->error;
	if (!a->Parameters)
	{	if (soap_element_nil(soap, "tt:Parameters"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__ItemList(soap, "tt:Parameters", -1, &a->Parameters, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Config * SOAP_FMAC4 soap_in_tt__Config(struct soap *soap, const char *tag, struct tt__Config *a, const char *type)
{
	size_t soap_flag_Parameters = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Config *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Config, sizeof(struct tt__Config), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Config(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Name", 1), &a->Name))
		return NULL;
	if (soap_s2_QName(soap, soap_attr_value(soap, "Type", 1), &a->Type))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Parameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ItemList(soap, "tt:Parameters", &a->Parameters, "tt:ItemList"))
				{	soap_flag_Parameters--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Parameters > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Config *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Config, SOAP_TYPE_tt__Config, sizeof(struct tt__Config), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Config * SOAP_FMAC4 soap_new_tt__Config(struct soap *soap, int n)
{
	struct tt__Config *p;
	struct tt__Config *a = (struct tt__Config*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Config));
	for (p = a; p && n--; p++)
		soap_default_tt__Config(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Config(struct soap *soap, const struct tt__Config *a, const char *tag, const char *type)
{
	if (soap_out_tt__Config(soap, tag ? tag : "tt:Config", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Config * SOAP_FMAC4 soap_get_tt__Config(struct soap *soap, struct tt__Config *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Config(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__AnalyticsEngineConfiguration(struct soap *soap, struct tt__AnalyticsEngineConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeAnalyticsModule = 0;
	a->AnalyticsModule = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AnalyticsEngineConfiguration(struct soap *soap, const struct tt__AnalyticsEngineConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->AnalyticsModule)
	{	int i;
		for (i = 0; i < (int)a->__sizeAnalyticsModule; i++)
		{
			soap_embedded(soap, a->AnalyticsModule + i, SOAP_TYPE_tt__Config);
			soap_serialize_tt__Config(soap, a->AnalyticsModule + i);
		}
	}
	soap_serialize_PointerTott__AnalyticsEngineConfigurationExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngineConfiguration(struct soap *soap, const char *tag, int id, const struct tt__AnalyticsEngineConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngineConfiguration), type))
		return soap->error;
	if (a->AnalyticsModule)
	{	int i;
		for (i = 0; i < (int)a->__sizeAnalyticsModule; i++)
			if (soap_out_tt__Config(soap, "tt:AnalyticsModule", -1, a->AnalyticsModule + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__AnalyticsEngineConfigurationExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__AnalyticsEngineConfiguration * SOAP_FMAC4 soap_in_tt__AnalyticsEngineConfiguration(struct soap *soap, const char *tag, struct tt__AnalyticsEngineConfiguration *a, const char *type)
{
	struct soap_blist *soap_blist_AnalyticsModule = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__AnalyticsEngineConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineConfiguration, sizeof(struct tt__AnalyticsEngineConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__AnalyticsEngineConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AnalyticsModule", 1, NULL))
			{	if (a->AnalyticsModule == NULL)
				{	if (soap_blist_AnalyticsModule == NULL)
						soap_blist_AnalyticsModule = soap_alloc_block(soap);
					a->AnalyticsModule = (struct tt__Config *)soap_push_block_max(soap, soap_blist_AnalyticsModule, sizeof(struct tt__Config));
					if (a->AnalyticsModule == NULL)
						return NULL;
					soap_default_tt__Config(soap, a->AnalyticsModule);
				}
				soap_revert(soap);
				if (soap_in_tt__Config(soap, "tt:AnalyticsModule", a->AnalyticsModule, "tt:Config"))
				{	a->__sizeAnalyticsModule++;
					a->AnalyticsModule = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AnalyticsEngineConfigurationExtension(soap, "tt:Extension", &a->Extension, "tt:AnalyticsEngineConfigurationExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AnalyticsModule)
			soap_pop_block(soap, soap_blist_AnalyticsModule);
		if (a->__sizeAnalyticsModule)
		{	a->AnalyticsModule = (struct tt__Config *)soap_save_block(soap, soap_blist_AnalyticsModule, NULL, 1);
		}
		else
		{	a->AnalyticsModule = NULL;
			if (soap_blist_AnalyticsModule)
				soap_end_block(soap, soap_blist_AnalyticsModule);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineConfiguration, SOAP_TYPE_tt__AnalyticsEngineConfiguration, sizeof(struct tt__AnalyticsEngineConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__AnalyticsEngineConfiguration * SOAP_FMAC4 soap_new_tt__AnalyticsEngineConfiguration(struct soap *soap, int n)
{
	struct tt__AnalyticsEngineConfiguration *p;
	struct tt__AnalyticsEngineConfiguration *a = (struct tt__AnalyticsEngineConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__AnalyticsEngineConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__AnalyticsEngineConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AnalyticsEngineConfiguration(struct soap *soap, const struct tt__AnalyticsEngineConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__AnalyticsEngineConfiguration(soap, tag ? tag : "tt:AnalyticsEngineConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineConfiguration * SOAP_FMAC4 soap_get_tt__AnalyticsEngineConfiguration(struct soap *soap, struct tt__AnalyticsEngineConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ObjectTreeExtension(struct soap *soap, struct tt__ObjectTreeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ObjectTreeExtension(struct soap *soap, const struct tt__ObjectTreeExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ObjectTreeExtension(struct soap *soap, const char *tag, int id, const struct tt__ObjectTreeExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ObjectTreeExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ObjectTreeExtension * SOAP_FMAC4 soap_in_tt__ObjectTreeExtension(struct soap *soap, const char *tag, struct tt__ObjectTreeExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ObjectTreeExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ObjectTreeExtension, sizeof(struct tt__ObjectTreeExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ObjectTreeExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ObjectTreeExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ObjectTreeExtension, SOAP_TYPE_tt__ObjectTreeExtension, sizeof(struct tt__ObjectTreeExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ObjectTreeExtension * SOAP_FMAC4 soap_new_tt__ObjectTreeExtension(struct soap *soap, int n)
{
	struct tt__ObjectTreeExtension *p;
	struct tt__ObjectTreeExtension *a = (struct tt__ObjectTreeExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ObjectTreeExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ObjectTreeExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ObjectTreeExtension(struct soap *soap, const struct tt__ObjectTreeExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ObjectTreeExtension(soap, tag ? tag : "tt:ObjectTreeExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ObjectTreeExtension * SOAP_FMAC4 soap_get_tt__ObjectTreeExtension(struct soap *soap, struct tt__ObjectTreeExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ObjectTreeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__BehaviourExtension(struct soap *soap, struct tt__BehaviourExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__BehaviourExtension(struct soap *soap, const struct tt__BehaviourExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BehaviourExtension(struct soap *soap, const char *tag, int id, const struct tt__BehaviourExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BehaviourExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__BehaviourExtension * SOAP_FMAC4 soap_in_tt__BehaviourExtension(struct soap *soap, const char *tag, struct tt__BehaviourExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__BehaviourExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BehaviourExtension, sizeof(struct tt__BehaviourExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__BehaviourExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__BehaviourExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BehaviourExtension, SOAP_TYPE_tt__BehaviourExtension, sizeof(struct tt__BehaviourExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__BehaviourExtension * SOAP_FMAC4 soap_new_tt__BehaviourExtension(struct soap *soap, int n)
{
	struct tt__BehaviourExtension *p;
	struct tt__BehaviourExtension *a = (struct tt__BehaviourExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__BehaviourExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__BehaviourExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__BehaviourExtension(struct soap *soap, const struct tt__BehaviourExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__BehaviourExtension(soap, tag ? tag : "tt:BehaviourExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BehaviourExtension * SOAP_FMAC4 soap_get_tt__BehaviourExtension(struct soap *soap, struct tt__BehaviourExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BehaviourExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__Behaviour_Idle(struct soap *soap, struct _tt__Behaviour_Idle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__Behaviour_Idle(struct soap *soap, const struct _tt__Behaviour_Idle *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__Behaviour_Idle(struct soap *soap, const char *tag, int id, const struct _tt__Behaviour_Idle *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__Behaviour_Idle), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__Behaviour_Idle * SOAP_FMAC4 soap_in__tt__Behaviour_Idle(struct soap *soap, const char *tag, struct _tt__Behaviour_Idle *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tt__Behaviour_Idle *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__Behaviour_Idle, sizeof(struct _tt__Behaviour_Idle), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__Behaviour_Idle(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tt__Behaviour_Idle *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__Behaviour_Idle, SOAP_TYPE__tt__Behaviour_Idle, sizeof(struct _tt__Behaviour_Idle), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tt__Behaviour_Idle * SOAP_FMAC4 soap_new__tt__Behaviour_Idle(struct soap *soap, int n)
{
	struct _tt__Behaviour_Idle *p;
	struct _tt__Behaviour_Idle *a = (struct _tt__Behaviour_Idle*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tt__Behaviour_Idle));
	for (p = a; p && n--; p++)
		soap_default__tt__Behaviour_Idle(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__Behaviour_Idle(struct soap *soap, const struct _tt__Behaviour_Idle *a, const char *tag, const char *type)
{
	if (soap_out__tt__Behaviour_Idle(soap, tag ? tag : "tt:Behaviour-Idle", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__Behaviour_Idle * SOAP_FMAC4 soap_get__tt__Behaviour_Idle(struct soap *soap, struct _tt__Behaviour_Idle *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__Behaviour_Idle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__Behaviour_Removed(struct soap *soap, struct _tt__Behaviour_Removed *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__Behaviour_Removed(struct soap *soap, const struct _tt__Behaviour_Removed *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__Behaviour_Removed(struct soap *soap, const char *tag, int id, const struct _tt__Behaviour_Removed *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__Behaviour_Removed), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__Behaviour_Removed * SOAP_FMAC4 soap_in__tt__Behaviour_Removed(struct soap *soap, const char *tag, struct _tt__Behaviour_Removed *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tt__Behaviour_Removed *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__Behaviour_Removed, sizeof(struct _tt__Behaviour_Removed), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__Behaviour_Removed(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tt__Behaviour_Removed *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__Behaviour_Removed, SOAP_TYPE__tt__Behaviour_Removed, sizeof(struct _tt__Behaviour_Removed), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tt__Behaviour_Removed * SOAP_FMAC4 soap_new__tt__Behaviour_Removed(struct soap *soap, int n)
{
	struct _tt__Behaviour_Removed *p;
	struct _tt__Behaviour_Removed *a = (struct _tt__Behaviour_Removed*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tt__Behaviour_Removed));
	for (p = a; p && n--; p++)
		soap_default__tt__Behaviour_Removed(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__Behaviour_Removed(struct soap *soap, const struct _tt__Behaviour_Removed *a, const char *tag, const char *type)
{
	if (soap_out__tt__Behaviour_Removed(soap, tag ? tag : "tt:Behaviour-Removed", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__Behaviour_Removed * SOAP_FMAC4 soap_get__tt__Behaviour_Removed(struct soap *soap, struct _tt__Behaviour_Removed *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__Behaviour_Removed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Behaviour(struct soap *soap, struct tt__Behaviour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Removed = NULL;
	a->Idle = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Behaviour(struct soap *soap, const struct tt__Behaviour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tt__Behaviour_Removed(soap, &a->Removed);
	soap_serialize_PointerTo_tt__Behaviour_Idle(soap, &a->Idle);
	soap_serialize_PointerTott__BehaviourExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Behaviour(struct soap *soap, const char *tag, int id, const struct tt__Behaviour *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Behaviour), type))
		return soap->error;
	if (soap_out_PointerTo_tt__Behaviour_Removed(soap, "tt:Removed", -1, &a->Removed, ""))
		return soap->error;
	if (soap_out_PointerTo_tt__Behaviour_Idle(soap, "tt:Idle", -1, &a->Idle, ""))
		return soap->error;
	if (soap_out_PointerTott__BehaviourExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Behaviour * SOAP_FMAC4 soap_in_tt__Behaviour(struct soap *soap, const char *tag, struct tt__Behaviour *a, const char *type)
{
	size_t soap_flag_Removed = 1;
	size_t soap_flag_Idle = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Behaviour *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Behaviour, sizeof(struct tt__Behaviour), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Behaviour(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Removed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tt__Behaviour_Removed(soap, "tt:Removed", &a->Removed, ""))
				{	soap_flag_Removed--;
					continue;
				}
			if (soap_flag_Idle && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tt__Behaviour_Idle(soap, "tt:Idle", &a->Idle, ""))
				{	soap_flag_Idle--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__BehaviourExtension(soap, "tt:Extension", &a->Extension, "tt:BehaviourExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Behaviour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Behaviour, SOAP_TYPE_tt__Behaviour, sizeof(struct tt__Behaviour), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Behaviour * SOAP_FMAC4 soap_new_tt__Behaviour(struct soap *soap, int n)
{
	struct tt__Behaviour *p;
	struct tt__Behaviour *a = (struct tt__Behaviour*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Behaviour));
	for (p = a; p && n--; p++)
		soap_default_tt__Behaviour(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Behaviour(struct soap *soap, const struct tt__Behaviour *a, const char *tag, const char *type)
{
	if (soap_out_tt__Behaviour(soap, tag ? tag : "tt:Behaviour", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Behaviour * SOAP_FMAC4 soap_get_tt__Behaviour(struct soap *soap, struct tt__Behaviour *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Behaviour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Rename(struct soap *soap, struct tt__Rename *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->from = NULL;
	a->to = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Rename(struct soap *soap, const struct tt__Rename *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ObjectId(soap, &a->from);
	soap_serialize_PointerTott__ObjectId(soap, &a->to);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Rename(struct soap *soap, const char *tag, int id, const struct tt__Rename *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Rename), type))
		return soap->error;
	if (!a->from)
	{	if (soap_element_nil(soap, "tt:from"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__ObjectId(soap, "tt:from", -1, &a->from, ""))
		return soap->error;
	if (!a->to)
	{	if (soap_element_nil(soap, "tt:to"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__ObjectId(soap, "tt:to", -1, &a->to, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Rename * SOAP_FMAC4 soap_in_tt__Rename(struct soap *soap, const char *tag, struct tt__Rename *a, const char *type)
{
	size_t soap_flag_from = 1;
	size_t soap_flag_to = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Rename *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Rename, sizeof(struct tt__Rename), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Rename(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_from && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ObjectId(soap, "tt:from", &a->from, "tt:ObjectId"))
				{	soap_flag_from--;
					continue;
				}
			if (soap_flag_to && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ObjectId(soap, "tt:to", &a->to, "tt:ObjectId"))
				{	soap_flag_to--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_from > 0 || soap_flag_to > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Rename *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Rename, SOAP_TYPE_tt__Rename, sizeof(struct tt__Rename), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Rename * SOAP_FMAC4 soap_new_tt__Rename(struct soap *soap, int n)
{
	struct tt__Rename *p;
	struct tt__Rename *a = (struct tt__Rename*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Rename));
	for (p = a; p && n--; p++)
		soap_default_tt__Rename(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Rename(struct soap *soap, const struct tt__Rename *a, const char *tag, const char *type)
{
	if (soap_out_tt__Rename(soap, tag ? tag : "tt:Rename", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Rename * SOAP_FMAC4 soap_get_tt__Rename(struct soap *soap, struct tt__Rename *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Rename(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Split(struct soap *soap, struct tt__Split *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->from = NULL;
	a->__sizeto = 0;
	a->to = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Split(struct soap *soap, const struct tt__Split *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ObjectId(soap, &a->from);
	if (a->to)
	{	int i;
		for (i = 0; i < (int)a->__sizeto; i++)
		{
			soap_embedded(soap, a->to + i, SOAP_TYPE_tt__ObjectId);
			soap_serialize_tt__ObjectId(soap, a->to + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Split(struct soap *soap, const char *tag, int id, const struct tt__Split *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Split), type))
		return soap->error;
	if (!a->from)
	{	if (soap_element_nil(soap, "tt:from"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__ObjectId(soap, "tt:from", -1, &a->from, ""))
		return soap->error;
	if (a->to)
	{	int i;
		for (i = 0; i < (int)a->__sizeto; i++)
			if (soap_out_tt__ObjectId(soap, "tt:to", -1, a->to + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Split * SOAP_FMAC4 soap_in_tt__Split(struct soap *soap, const char *tag, struct tt__Split *a, const char *type)
{
	size_t soap_flag_from = 1;
	struct soap_blist *soap_blist_to = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Split *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Split, sizeof(struct tt__Split), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Split(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_from && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ObjectId(soap, "tt:from", &a->from, "tt:ObjectId"))
				{	soap_flag_from--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:to", 1, NULL))
			{	if (a->to == NULL)
				{	if (soap_blist_to == NULL)
						soap_blist_to = soap_alloc_block(soap);
					a->to = (struct tt__ObjectId *)soap_push_block_max(soap, soap_blist_to, sizeof(struct tt__ObjectId));
					if (a->to == NULL)
						return NULL;
					soap_default_tt__ObjectId(soap, a->to);
				}
				soap_revert(soap);
				if (soap_in_tt__ObjectId(soap, "tt:to", a->to, "tt:ObjectId"))
				{	a->__sizeto++;
					a->to = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->to)
			soap_pop_block(soap, soap_blist_to);
		if (a->__sizeto)
		{	a->to = (struct tt__ObjectId *)soap_save_block(soap, soap_blist_to, NULL, 1);
		}
		else
		{	a->to = NULL;
			if (soap_blist_to)
				soap_end_block(soap, soap_blist_to);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_from > 0 || a->__sizeto < 2))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Split *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Split, SOAP_TYPE_tt__Split, sizeof(struct tt__Split), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Split * SOAP_FMAC4 soap_new_tt__Split(struct soap *soap, int n)
{
	struct tt__Split *p;
	struct tt__Split *a = (struct tt__Split*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Split));
	for (p = a; p && n--; p++)
		soap_default_tt__Split(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Split(struct soap *soap, const struct tt__Split *a, const char *tag, const char *type)
{
	if (soap_out_tt__Split(soap, tag ? tag : "tt:Split", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Split * SOAP_FMAC4 soap_get_tt__Split(struct soap *soap, struct tt__Split *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Split(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ObjectId(struct soap *soap, struct tt__ObjectId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__integer(soap, &a->ObjectId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ObjectId(struct soap *soap, const struct tt__ObjectId *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ObjectId(struct soap *soap, const char *tag, int id, const struct tt__ObjectId *a, const char *type)
{
	if (a->ObjectId)
		soap_set_attr(soap, "ObjectId", soap_xsd__integer2s(soap, a->ObjectId), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ObjectId), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ObjectId * SOAP_FMAC4 soap_in_tt__ObjectId(struct soap *soap, const char *tag, struct tt__ObjectId *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ObjectId *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ObjectId, sizeof(struct tt__ObjectId), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ObjectId(soap, a);
	if (soap_s2xsd__integer(soap, soap_attr_value(soap, "ObjectId", 0), &a->ObjectId))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ObjectId *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ObjectId, SOAP_TYPE_tt__ObjectId, sizeof(struct tt__ObjectId), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ObjectId * SOAP_FMAC4 soap_new_tt__ObjectId(struct soap *soap, int n)
{
	struct tt__ObjectId *p;
	struct tt__ObjectId *a = (struct tt__ObjectId*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ObjectId));
	for (p = a; p && n--; p++)
		soap_default_tt__ObjectId(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ObjectId(struct soap *soap, const struct tt__ObjectId *a, const char *tag, const char *type)
{
	if (soap_out_tt__ObjectId(soap, tag ? tag : "tt:ObjectId", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ObjectId * SOAP_FMAC4 soap_get_tt__ObjectId(struct soap *soap, struct tt__ObjectId *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ObjectId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Merge(struct soap *soap, struct tt__Merge *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizefrom = 0;
	a->from = NULL;
	a->to = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Merge(struct soap *soap, const struct tt__Merge *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->from)
	{	int i;
		for (i = 0; i < (int)a->__sizefrom; i++)
		{
			soap_embedded(soap, a->from + i, SOAP_TYPE_tt__ObjectId);
			soap_serialize_tt__ObjectId(soap, a->from + i);
		}
	}
	soap_serialize_PointerTott__ObjectId(soap, &a->to);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Merge(struct soap *soap, const char *tag, int id, const struct tt__Merge *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Merge), type))
		return soap->error;
	if (a->from)
	{	int i;
		for (i = 0; i < (int)a->__sizefrom; i++)
			if (soap_out_tt__ObjectId(soap, "tt:from", -1, a->from + i, ""))
				return soap->error;
	}
	if (!a->to)
	{	if (soap_element_nil(soap, "tt:to"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__ObjectId(soap, "tt:to", -1, &a->to, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Merge * SOAP_FMAC4 soap_in_tt__Merge(struct soap *soap, const char *tag, struct tt__Merge *a, const char *type)
{
	struct soap_blist *soap_blist_from = NULL;
	size_t soap_flag_to = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Merge *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Merge, sizeof(struct tt__Merge), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Merge(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:from", 1, NULL))
			{	if (a->from == NULL)
				{	if (soap_blist_from == NULL)
						soap_blist_from = soap_alloc_block(soap);
					a->from = (struct tt__ObjectId *)soap_push_block_max(soap, soap_blist_from, sizeof(struct tt__ObjectId));
					if (a->from == NULL)
						return NULL;
					soap_default_tt__ObjectId(soap, a->from);
				}
				soap_revert(soap);
				if (soap_in_tt__ObjectId(soap, "tt:from", a->from, "tt:ObjectId"))
				{	a->__sizefrom++;
					a->from = NULL;
					continue;
				}
			}
			if (soap_flag_to && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ObjectId(soap, "tt:to", &a->to, "tt:ObjectId"))
				{	soap_flag_to--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->from)
			soap_pop_block(soap, soap_blist_from);
		if (a->__sizefrom)
		{	a->from = (struct tt__ObjectId *)soap_save_block(soap, soap_blist_from, NULL, 1);
		}
		else
		{	a->from = NULL;
			if (soap_blist_from)
				soap_end_block(soap, soap_blist_from);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizefrom < 2 || soap_flag_to > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__Merge *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Merge, SOAP_TYPE_tt__Merge, sizeof(struct tt__Merge), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Merge * SOAP_FMAC4 soap_new_tt__Merge(struct soap *soap, int n)
{
	struct tt__Merge *p;
	struct tt__Merge *a = (struct tt__Merge*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Merge));
	for (p = a; p && n--; p++)
		soap_default_tt__Merge(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Merge(struct soap *soap, const struct tt__Merge *a, const char *tag, const char *type)
{
	if (soap_out_tt__Merge(soap, tag ? tag : "tt:Merge", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Merge * SOAP_FMAC4 soap_get_tt__Merge(struct soap *soap, struct tt__Merge *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Merge(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FrameExtension2(struct soap *soap, struct tt__FrameExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FrameExtension2(struct soap *soap, const struct tt__FrameExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FrameExtension2(struct soap *soap, const char *tag, int id, const struct tt__FrameExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FrameExtension2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FrameExtension2 * SOAP_FMAC4 soap_in_tt__FrameExtension2(struct soap *soap, const char *tag, struct tt__FrameExtension2 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FrameExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FrameExtension2, sizeof(struct tt__FrameExtension2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FrameExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__FrameExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FrameExtension2, SOAP_TYPE_tt__FrameExtension2, sizeof(struct tt__FrameExtension2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FrameExtension2 * SOAP_FMAC4 soap_new_tt__FrameExtension2(struct soap *soap, int n)
{
	struct tt__FrameExtension2 *p;
	struct tt__FrameExtension2 *a = (struct tt__FrameExtension2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FrameExtension2));
	for (p = a; p && n--; p++)
		soap_default_tt__FrameExtension2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FrameExtension2(struct soap *soap, const struct tt__FrameExtension2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__FrameExtension2(soap, tag ? tag : "tt:FrameExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FrameExtension2 * SOAP_FMAC4 soap_get_tt__FrameExtension2(struct soap *soap, struct tt__FrameExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FrameExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__MotionInCells(struct soap *soap, struct tt__MotionInCells *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__integer(soap, &a->Columns);
	soap_default_xsd__integer(soap, &a->Rows);
	soap_default_xsd__base64Binary(soap, &a->Cells);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__MotionInCells(struct soap *soap, const struct tt__MotionInCells *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MotionInCells(struct soap *soap, const char *tag, int id, const struct tt__MotionInCells *a, const char *type)
{
	if (a->Columns)
		soap_set_attr(soap, "Columns", soap_xsd__integer2s(soap, a->Columns), 1);
	if (a->Rows)
		soap_set_attr(soap, "Rows", soap_xsd__integer2s(soap, a->Rows), 1);
	soap_set_attr(soap, "Cells", soap_xsd__base64Binary2s(soap, a->Cells), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MotionInCells), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__MotionInCells * SOAP_FMAC4 soap_in_tt__MotionInCells(struct soap *soap, const char *tag, struct tt__MotionInCells *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__MotionInCells *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MotionInCells, sizeof(struct tt__MotionInCells), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__MotionInCells(soap, a);
	if (soap_s2xsd__integer(soap, soap_attr_value(soap, "Columns", 1), &a->Columns))
		return NULL;
	if (soap_s2xsd__integer(soap, soap_attr_value(soap, "Rows", 1), &a->Rows))
		return NULL;
	if (soap_s2xsd__base64Binary(soap, soap_attr_value(soap, "Cells", 1), &a->Cells))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__MotionInCells *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MotionInCells, SOAP_TYPE_tt__MotionInCells, sizeof(struct tt__MotionInCells), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__MotionInCells * SOAP_FMAC4 soap_new_tt__MotionInCells(struct soap *soap, int n)
{
	struct tt__MotionInCells *p;
	struct tt__MotionInCells *a = (struct tt__MotionInCells*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__MotionInCells));
	for (p = a; p && n--; p++)
		soap_default_tt__MotionInCells(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MotionInCells(struct soap *soap, const struct tt__MotionInCells *a, const char *tag, const char *type)
{
	if (soap_out_tt__MotionInCells(soap, tag ? tag : "tt:MotionInCells", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MotionInCells * SOAP_FMAC4 soap_get_tt__MotionInCells(struct soap *soap, struct tt__MotionInCells *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MotionInCells(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__FrameExtension(struct soap *soap, struct tt__FrameExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MotionInCells = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FrameExtension(struct soap *soap, const struct tt__FrameExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__MotionInCells(soap, &a->MotionInCells);
	soap_serialize_PointerTott__FrameExtension2(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FrameExtension(struct soap *soap, const char *tag, int id, const struct tt__FrameExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FrameExtension), type))
		return soap->error;
	if (soap_out_PointerTott__MotionInCells(soap, "tt:MotionInCells", -1, &a->MotionInCells, ""))
		return soap->error;
	if (soap_out_PointerTott__FrameExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__FrameExtension * SOAP_FMAC4 soap_in_tt__FrameExtension(struct soap *soap, const char *tag, struct tt__FrameExtension *a, const char *type)
{
	size_t soap_flag_MotionInCells = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__FrameExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FrameExtension, sizeof(struct tt__FrameExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__FrameExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MotionInCells && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MotionInCells(soap, "tt:MotionInCells", &a->MotionInCells, "tt:MotionInCells"))
				{	soap_flag_MotionInCells--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FrameExtension2(soap, "tt:Extension", &a->Extension, "tt:FrameExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__FrameExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FrameExtension, SOAP_TYPE_tt__FrameExtension, sizeof(struct tt__FrameExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__FrameExtension * SOAP_FMAC4 soap_new_tt__FrameExtension(struct soap *soap, int n)
{
	struct tt__FrameExtension *p;
	struct tt__FrameExtension *a = (struct tt__FrameExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__FrameExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__FrameExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FrameExtension(struct soap *soap, const struct tt__FrameExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__FrameExtension(soap, tag ? tag : "tt:FrameExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FrameExtension * SOAP_FMAC4 soap_get_tt__FrameExtension(struct soap *soap, struct tt__FrameExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FrameExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ObjectTree(struct soap *soap, struct tt__ObjectTree *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeRename = 0;
	a->Rename = NULL;
	a->__sizeSplit = 0;
	a->Split = NULL;
	a->__sizeMerge = 0;
	a->Merge = NULL;
	a->__sizeDelete = 0;
	a->Delete = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ObjectTree(struct soap *soap, const struct tt__ObjectTree *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Rename)
	{	int i;
		for (i = 0; i < (int)a->__sizeRename; i++)
		{
			soap_embedded(soap, a->Rename + i, SOAP_TYPE_tt__Rename);
			soap_serialize_tt__Rename(soap, a->Rename + i);
		}
	}
	if (a->Split)
	{	int i;
		for (i = 0; i < (int)a->__sizeSplit; i++)
		{
			soap_embedded(soap, a->Split + i, SOAP_TYPE_tt__Split);
			soap_serialize_tt__Split(soap, a->Split + i);
		}
	}
	if (a->Merge)
	{	int i;
		for (i = 0; i < (int)a->__sizeMerge; i++)
		{
			soap_embedded(soap, a->Merge + i, SOAP_TYPE_tt__Merge);
			soap_serialize_tt__Merge(soap, a->Merge + i);
		}
	}
	if (a->Delete)
	{	int i;
		for (i = 0; i < (int)a->__sizeDelete; i++)
		{
			soap_embedded(soap, a->Delete + i, SOAP_TYPE_tt__ObjectId);
			soap_serialize_tt__ObjectId(soap, a->Delete + i);
		}
	}
	soap_serialize_PointerTott__ObjectTreeExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ObjectTree(struct soap *soap, const char *tag, int id, const struct tt__ObjectTree *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ObjectTree), type))
		return soap->error;
	if (a->Rename)
	{	int i;
		for (i = 0; i < (int)a->__sizeRename; i++)
			if (soap_out_tt__Rename(soap, "tt:Rename", -1, a->Rename + i, ""))
				return soap->error;
	}
	if (a->Split)
	{	int i;
		for (i = 0; i < (int)a->__sizeSplit; i++)
			if (soap_out_tt__Split(soap, "tt:Split", -1, a->Split + i, ""))
				return soap->error;
	}
	if (a->Merge)
	{	int i;
		for (i = 0; i < (int)a->__sizeMerge; i++)
			if (soap_out_tt__Merge(soap, "tt:Merge", -1, a->Merge + i, ""))
				return soap->error;
	}
	if (a->Delete)
	{	int i;
		for (i = 0; i < (int)a->__sizeDelete; i++)
			if (soap_out_tt__ObjectId(soap, "tt:Delete", -1, a->Delete + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ObjectTreeExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ObjectTree * SOAP_FMAC4 soap_in_tt__ObjectTree(struct soap *soap, const char *tag, struct tt__ObjectTree *a, const char *type)
{
	struct soap_blist *soap_blist_Rename = NULL;
	struct soap_blist *soap_blist_Split = NULL;
	struct soap_blist *soap_blist_Merge = NULL;
	struct soap_blist *soap_blist_Delete = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ObjectTree *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ObjectTree, sizeof(struct tt__ObjectTree), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ObjectTree(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Rename", 1, NULL))
			{	if (a->Rename == NULL)
				{	if (soap_blist_Rename == NULL)
						soap_blist_Rename = soap_alloc_block(soap);
					a->Rename = (struct tt__Rename *)soap_push_block_max(soap, soap_blist_Rename, sizeof(struct tt__Rename));
					if (a->Rename == NULL)
						return NULL;
					soap_default_tt__Rename(soap, a->Rename);
				}
				soap_revert(soap);
				if (soap_in_tt__Rename(soap, "tt:Rename", a->Rename, "tt:Rename"))
				{	a->__sizeRename++;
					a->Rename = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Split", 1, NULL))
			{	if (a->Split == NULL)
				{	if (soap_blist_Split == NULL)
						soap_blist_Split = soap_alloc_block(soap);
					a->Split = (struct tt__Split *)soap_push_block_max(soap, soap_blist_Split, sizeof(struct tt__Split));
					if (a->Split == NULL)
						return NULL;
					soap_default_tt__Split(soap, a->Split);
				}
				soap_revert(soap);
				if (soap_in_tt__Split(soap, "tt:Split", a->Split, "tt:Split"))
				{	a->__sizeSplit++;
					a->Split = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Merge", 1, NULL))
			{	if (a->Merge == NULL)
				{	if (soap_blist_Merge == NULL)
						soap_blist_Merge = soap_alloc_block(soap);
					a->Merge = (struct tt__Merge *)soap_push_block_max(soap, soap_blist_Merge, sizeof(struct tt__Merge));
					if (a->Merge == NULL)
						return NULL;
					soap_default_tt__Merge(soap, a->Merge);
				}
				soap_revert(soap);
				if (soap_in_tt__Merge(soap, "tt:Merge", a->Merge, "tt:Merge"))
				{	a->__sizeMerge++;
					a->Merge = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Delete", 1, NULL))
			{	if (a->Delete == NULL)
				{	if (soap_blist_Delete == NULL)
						soap_blist_Delete = soap_alloc_block(soap);
					a->Delete = (struct tt__ObjectId *)soap_push_block_max(soap, soap_blist_Delete, sizeof(struct tt__ObjectId));
					if (a->Delete == NULL)
						return NULL;
					soap_default_tt__ObjectId(soap, a->Delete);
				}
				soap_revert(soap);
				if (soap_in_tt__ObjectId(soap, "tt:Delete", a->Delete, "tt:ObjectId"))
				{	a->__sizeDelete++;
					a->Delete = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ObjectTreeExtension(soap, "tt:Extension", &a->Extension, "tt:ObjectTreeExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Rename)
			soap_pop_block(soap, soap_blist_Rename);
		if (a->__sizeRename)
		{	a->Rename = (struct tt__Rename *)soap_save_block(soap, soap_blist_Rename, NULL, 1);
		}
		else
		{	a->Rename = NULL;
			if (soap_blist_Rename)
				soap_end_block(soap, soap_blist_Rename);
		}
		if (a->Split)
			soap_pop_block(soap, soap_blist_Split);
		if (a->__sizeSplit)
		{	a->Split = (struct tt__Split *)soap_save_block(soap, soap_blist_Split, NULL, 1);
		}
		else
		{	a->Split = NULL;
			if (soap_blist_Split)
				soap_end_block(soap, soap_blist_Split);
		}
		if (a->Merge)
			soap_pop_block(soap, soap_blist_Merge);
		if (a->__sizeMerge)
		{	a->Merge = (struct tt__Merge *)soap_save_block(soap, soap_blist_Merge, NULL, 1);
		}
		else
		{	a->Merge = NULL;
			if (soap_blist_Merge)
				soap_end_block(soap, soap_blist_Merge);
		}
		if (a->Delete)
			soap_pop_block(soap, soap_blist_Delete);
		if (a->__sizeDelete)
		{	a->Delete = (struct tt__ObjectId *)soap_save_block(soap, soap_blist_Delete, NULL, 1);
		}
		else
		{	a->Delete = NULL;
			if (soap_blist_Delete)
				soap_end_block(soap, soap_blist_Delete);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ObjectTree *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ObjectTree, SOAP_TYPE_tt__ObjectTree, sizeof(struct tt__ObjectTree), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ObjectTree * SOAP_FMAC4 soap_new_tt__ObjectTree(struct soap *soap, int n)
{
	struct tt__ObjectTree *p;
	struct tt__ObjectTree *a = (struct tt__ObjectTree*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ObjectTree));
	for (p = a; p && n--; p++)
		soap_default_tt__ObjectTree(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ObjectTree(struct soap *soap, const struct tt__ObjectTree *a, const char *tag, const char *type)
{
	if (soap_out_tt__ObjectTree(soap, tag ? tag : "tt:ObjectTree", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ObjectTree * SOAP_FMAC4 soap_get_tt__ObjectTree(struct soap *soap, struct tt__ObjectTree *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ObjectTree(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Object(struct soap *soap, struct tt__Object *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__integer(soap, &a->ObjectId);
	a->Appearance = NULL;
	a->Behaviour = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Object(struct soap *soap, const struct tt__Object *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Appearance(soap, &a->Appearance);
	soap_serialize_PointerTott__Behaviour(soap, &a->Behaviour);
	soap_serialize_PointerTott__ObjectExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Object(struct soap *soap, const char *tag, int id, const struct tt__Object *a, const char *type)
{
	if (a->ObjectId)
		soap_set_attr(soap, "ObjectId", soap_xsd__integer2s(soap, a->ObjectId), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Object), type))
		return soap->error;
	if (soap_out_PointerTott__Appearance(soap, "tt:Appearance", -1, &a->Appearance, ""))
		return soap->error;
	if (soap_out_PointerTott__Behaviour(soap, "tt:Behaviour", -1, &a->Behaviour, ""))
		return soap->error;
	if (soap_out_PointerTott__ObjectExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Object * SOAP_FMAC4 soap_in_tt__Object(struct soap *soap, const char *tag, struct tt__Object *a, const char *type)
{
	size_t soap_flag_Appearance = 1;
	size_t soap_flag_Behaviour = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Object *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Object, sizeof(struct tt__Object), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Object(soap, a);
	if (soap_s2xsd__integer(soap, soap_attr_value(soap, "ObjectId", 0), &a->ObjectId))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Appearance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Appearance(soap, "tt:Appearance", &a->Appearance, "tt:Appearance"))
				{	soap_flag_Appearance--;
					continue;
				}
			if (soap_flag_Behaviour && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Behaviour(soap, "tt:Behaviour", &a->Behaviour, "tt:Behaviour"))
				{	soap_flag_Behaviour--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ObjectExtension(soap, "tt:Extension", &a->Extension, "tt:ObjectExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Object *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Object, SOAP_TYPE_tt__Object, sizeof(struct tt__Object), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Object * SOAP_FMAC4 soap_new_tt__Object(struct soap *soap, int n)
{
	struct tt__Object *p;
	struct tt__Object *a = (struct tt__Object*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Object));
	for (p = a; p && n--; p++)
		soap_default_tt__Object(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Object(struct soap *soap, const struct tt__Object *a, const char *tag, const char *type)
{
	if (soap_out_tt__Object(soap, tag ? tag : "tt:Object", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Object * SOAP_FMAC4 soap_get_tt__Object(struct soap *soap, struct tt__Object *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Object(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__Frame(struct soap *soap, struct tt__Frame *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PTZStatus = NULL;
	a->Transformation = NULL;
	a->__sizeObject = 0;
	a->Object = NULL;
	a->ObjectTree = NULL;
	a->Extension = NULL;
	soap_default_dateTime(soap, &a->UtcTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Frame(struct soap *soap, const struct tt__Frame *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZStatus(soap, &a->PTZStatus);
	soap_serialize_PointerTott__Transformation(soap, &a->Transformation);
	if (a->Object)
	{	int i;
		for (i = 0; i < (int)a->__sizeObject; i++)
		{
			soap_embedded(soap, a->Object + i, SOAP_TYPE_tt__Object);
			soap_serialize_tt__Object(soap, a->Object + i);
		}
	}
	soap_serialize_PointerTott__ObjectTree(soap, &a->ObjectTree);
	soap_serialize_PointerTott__FrameExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Frame(struct soap *soap, const char *tag, int id, const struct tt__Frame *a, const char *type)
{
	soap_set_attr(soap, "UtcTime", soap_dateTime2s(soap, a->UtcTime), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Frame), type))
		return soap->error;
	if (soap_out_PointerTott__PTZStatus(soap, "tt:PTZStatus", -1, &a->PTZStatus, ""))
		return soap->error;
	if (soap_out_PointerTott__Transformation(soap, "tt:Transformation", -1, &a->Transformation, ""))
		return soap->error;
	if (a->Object)
	{	int i;
		for (i = 0; i < (int)a->__sizeObject; i++)
			if (soap_out_tt__Object(soap, "tt:Object", -1, a->Object + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ObjectTree(soap, "tt:ObjectTree", -1, &a->ObjectTree, ""))
		return soap->error;
	if (soap_out_PointerTott__FrameExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__Frame * SOAP_FMAC4 soap_in_tt__Frame(struct soap *soap, const char *tag, struct tt__Frame *a, const char *type)
{
	size_t soap_flag_PTZStatus = 1;
	size_t soap_flag_Transformation = 1;
	struct soap_blist *soap_blist_Object = NULL;
	size_t soap_flag_ObjectTree = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__Frame *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Frame, sizeof(struct tt__Frame), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__Frame(soap, a);
	if (soap_s2dateTime(soap, soap_attr_value(soap, "UtcTime", 1), &a->UtcTime))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZStatus(soap, "tt:PTZStatus", &a->PTZStatus, "tt:PTZStatus"))
				{	soap_flag_PTZStatus--;
					continue;
				}
			if (soap_flag_Transformation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Transformation(soap, "tt:Transformation", &a->Transformation, "tt:Transformation"))
				{	soap_flag_Transformation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Object", 1, NULL))
			{	if (a->Object == NULL)
				{	if (soap_blist_Object == NULL)
						soap_blist_Object = soap_alloc_block(soap);
					a->Object = (struct tt__Object *)soap_push_block_max(soap, soap_blist_Object, sizeof(struct tt__Object));
					if (a->Object == NULL)
						return NULL;
					soap_default_tt__Object(soap, a->Object);
				}
				soap_revert(soap);
				if (soap_in_tt__Object(soap, "tt:Object", a->Object, "tt:Object"))
				{	a->__sizeObject++;
					a->Object = NULL;
					continue;
				}
			}
			if (soap_flag_ObjectTree && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ObjectTree(soap, "tt:ObjectTree", &a->ObjectTree, "tt:ObjectTree"))
				{	soap_flag_ObjectTree--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FrameExtension(soap, "tt:Extension", &a->Extension, "tt:FrameExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Object)
			soap_pop_block(soap, soap_blist_Object);
		if (a->__sizeObject)
		{	a->Object = (struct tt__Object *)soap_save_block(soap, soap_blist_Object, NULL, 1);
		}
		else
		{	a->Object = NULL;
			if (soap_blist_Object)
				soap_end_block(soap, soap_blist_Object);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__Frame *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Frame, SOAP_TYPE_tt__Frame, sizeof(struct tt__Frame), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__Frame * SOAP_FMAC4 soap_new_tt__Frame(struct soap *soap, int n)
{
	struct tt__Frame *p;
	struct tt__Frame *a = (struct tt__Frame*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__Frame));
	for (p = a; p && n--; p++)
		soap_default_tt__Frame(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Frame(struct soap *soap, const struct tt__Frame *a, const char *tag, const char *type)
{
	if (soap_out_tt__Frame(soap, tag ? tag : "tt:Frame", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Frame * SOAP_FMAC4 soap_get_tt__Frame(struct soap *soap, struct tt__Frame *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Frame(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__TransformationExtension(struct soap *soap, struct tt__TransformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__TransformationExtension(struct soap *soap, const struct tt__TransformationExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TransformationExtension(struct soap *soap, const char *tag, int id, const struct tt__TransformationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TransformationExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__TransformationExtension * SOAP_FMAC4 soap_in_tt__TransformationExtension(struct soap *soap, const char *tag, struct tt__TransformationExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__TransformationExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TransformationExtension, sizeof(struct tt__TransformationExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__TransformationExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__TransformationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TransformationExtension, SOAP_TYPE_tt__TransformationExtension, sizeof(struct tt__TransformationExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__TransformationExtension * SOAP_FMAC4 soap_new_tt__TransformationExtension(struct soap *soap, int n)
{
	struct tt__TransformationExtension *p;
	struct tt__TransformationExtension *a = (struct tt__TransformationExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__TransformationExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__TransformationExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__TransformationExtension(struct soap *soap, const struct tt__TransformationExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__TransformationExtension(soap, tag ? tag : "tt:TransformationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TransformationExtension * SOAP_FMAC4 soap_get_tt__TransformationExtension(struct soap *soap, struct tt__TransformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TransformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ObjectExtension(struct soap *soap, struct tt__ObjectExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ObjectExtension(struct soap *soap, const struct tt__ObjectExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ObjectExtension(struct soap *soap, const char *tag, int id, const struct tt__ObjectExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ObjectExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ObjectExtension * SOAP_FMAC4 soap_in_tt__ObjectExtension(struct soap *soap, const char *tag, struct tt__ObjectExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ObjectExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ObjectExtension, sizeof(struct tt__ObjectExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ObjectExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ObjectExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ObjectExtension, SOAP_TYPE_tt__ObjectExtension, sizeof(struct tt__ObjectExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ObjectExtension * SOAP_FMAC4 soap_new_tt__ObjectExtension(struct soap *soap, int n)
{
	struct tt__ObjectExtension *p;
	struct tt__ObjectExtension *a = (struct tt__ObjectExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ObjectExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ObjectExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ObjectExtension(struct soap *soap, const struct tt__ObjectExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ObjectExtension(soap, tag ? tag : "tt:ObjectExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ObjectExtension * SOAP_FMAC4 soap_get_tt__ObjectExtension(struct soap *soap, struct tt__ObjectExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ObjectExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ClassDescriptorExtension2(struct soap *soap, struct tt__ClassDescriptorExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ClassDescriptorExtension2(struct soap *soap, const struct tt__ClassDescriptorExtension2 *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ClassDescriptorExtension2(struct soap *soap, const char *tag, int id, const struct tt__ClassDescriptorExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ClassDescriptorExtension2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ClassDescriptorExtension2 * SOAP_FMAC4 soap_in_tt__ClassDescriptorExtension2(struct soap *soap, const char *tag, struct tt__ClassDescriptorExtension2 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ClassDescriptorExtension2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ClassDescriptorExtension2, sizeof(struct tt__ClassDescriptorExtension2), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ClassDescriptorExtension2(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__ClassDescriptorExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ClassDescriptorExtension2, SOAP_TYPE_tt__ClassDescriptorExtension2, sizeof(struct tt__ClassDescriptorExtension2), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ClassDescriptorExtension2 * SOAP_FMAC4 soap_new_tt__ClassDescriptorExtension2(struct soap *soap, int n)
{
	struct tt__ClassDescriptorExtension2 *p;
	struct tt__ClassDescriptorExtension2 *a = (struct tt__ClassDescriptorExtension2*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ClassDescriptorExtension2));
	for (p = a; p && n--; p++)
		soap_default_tt__ClassDescriptorExtension2(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ClassDescriptorExtension2(struct soap *soap, const struct tt__ClassDescriptorExtension2 *a, const char *tag, const char *type)
{
	if (soap_out_tt__ClassDescriptorExtension2(soap, tag ? tag : "tt:ClassDescriptorExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ClassDescriptorExtension2 * SOAP_FMAC4 soap_get_tt__ClassDescriptorExtension2(struct soap *soap, struct tt__ClassDescriptorExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ClassDescriptorExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OtherType(struct soap *soap, struct tt__OtherType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Type);
	soap_default_float(soap, &a->Likelihood);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OtherType(struct soap *soap, const struct tt__OtherType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Type);
	soap_embedded(soap, &a->Likelihood, SOAP_TYPE_float);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OtherType(struct soap *soap, const char *tag, int id, const struct tt__OtherType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OtherType), type))
		return soap->error;
	if (!a->Type)
	{	if (soap_element_nil(soap, "tt:Type"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "tt:Type", -1, (char*const*)&a->Type, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Likelihood", -1, &a->Likelihood, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__OtherType * SOAP_FMAC4 soap_in_tt__OtherType(struct soap *soap, const char *tag, struct tt__OtherType *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_Likelihood = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__OtherType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OtherType, sizeof(struct tt__OtherType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__OtherType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tt:Type", (char**)&a->Type, "xsd:string"))
				{	soap_flag_Type--;
					continue;
				}
			if (soap_flag_Likelihood && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Likelihood", &a->Likelihood, "xsd:float"))
				{	soap_flag_Likelihood--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0 || soap_flag_Likelihood > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__OtherType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OtherType, SOAP_TYPE_tt__OtherType, sizeof(struct tt__OtherType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__OtherType * SOAP_FMAC4 soap_new_tt__OtherType(struct soap *soap, int n)
{
	struct tt__OtherType *p;
	struct tt__OtherType *a = (struct tt__OtherType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OtherType));
	for (p = a; p && n--; p++)
		soap_default_tt__OtherType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OtherType(struct soap *soap, const struct tt__OtherType *a, const char *tag, const char *type)
{
	if (soap_out_tt__OtherType(soap, tag ? tag : "tt:OtherType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OtherType * SOAP_FMAC4 soap_get_tt__OtherType(struct soap *soap, struct tt__OtherType *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OtherType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__ClassDescriptorExtension(struct soap *soap, struct tt__ClassDescriptorExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeOtherTypes = 0;
	a->OtherTypes = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ClassDescriptorExtension(struct soap *soap, const struct tt__ClassDescriptorExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->OtherTypes)
	{	int i;
		for (i = 0; i < (int)a->__sizeOtherTypes; i++)
		{
			soap_embedded(soap, a->OtherTypes + i, SOAP_TYPE_tt__OtherType);
			soap_serialize_tt__OtherType(soap, a->OtherTypes + i);
		}
	}
	soap_serialize_PointerTott__ClassDescriptorExtension2(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ClassDescriptorExtension(struct soap *soap, const char *tag, int id, const struct tt__ClassDescriptorExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ClassDescriptorExtension), type))
		return soap->error;
	if (a->OtherTypes)
	{	int i;
		for (i = 0; i < (int)a->__sizeOtherTypes; i++)
			if (soap_out_tt__OtherType(soap, "tt:OtherTypes", -1, a->OtherTypes + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ClassDescriptorExtension2(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__ClassDescriptorExtension * SOAP_FMAC4 soap_in_tt__ClassDescriptorExtension(struct soap *soap, const char *tag, struct tt__ClassDescriptorExtension *a, const char *type)
{
	struct soap_blist *soap_blist_OtherTypes = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__ClassDescriptorExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ClassDescriptorExtension, sizeof(struct tt__ClassDescriptorExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__ClassDescriptorExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:OtherTypes", 1, NULL))
			{	if (a->OtherTypes == NULL)
				{	if (soap_blist_OtherTypes == NULL)
						soap_blist_OtherTypes = soap_alloc_block(soap);
					a->OtherTypes = (struct tt__OtherType *)soap_push_block_max(soap, soap_blist_OtherTypes, sizeof(struct tt__OtherType));
					if (a->OtherTypes == NULL)
						return NULL;
					soap_default_tt__OtherType(soap, a->OtherTypes);
				}
				soap_revert(soap);
				if (soap_in_tt__OtherType(soap, "tt:OtherTypes", a->OtherTypes, "tt:OtherType"))
				{	a->__sizeOtherTypes++;
					a->OtherTypes = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ClassDescriptorExtension2(soap, "tt:Extension", &a->Extension, "tt:ClassDescriptorExtension2"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->OtherTypes)
			soap_pop_block(soap, soap_blist_OtherTypes);
		if (a->__sizeOtherTypes)
		{	a->OtherTypes = (struct tt__OtherType *)soap_save_block(soap, soap_blist_OtherTypes, NULL, 1);
		}
		else
		{	a->OtherTypes = NULL;
			if (soap_blist_OtherTypes)
				soap_end_block(soap, soap_blist_OtherTypes);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeOtherTypes < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__ClassDescriptorExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ClassDescriptorExtension, SOAP_TYPE_tt__ClassDescriptorExtension, sizeof(struct tt__ClassDescriptorExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__ClassDescriptorExtension * SOAP_FMAC4 soap_new_tt__ClassDescriptorExtension(struct soap *soap, int n)
{
	struct tt__ClassDescriptorExtension *p;
	struct tt__ClassDescriptorExtension *a = (struct tt__ClassDescriptorExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__ClassDescriptorExtension));
	for (p = a; p && n--; p++)
		soap_default_tt__ClassDescriptorExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ClassDescriptorExtension(struct soap *soap, const struct tt__ClassDescriptorExtension *a, const char *tag, const char *type)
{
	if (soap_out_tt__ClassDescriptorExtension(soap, tag ? tag : "tt:ClassDescriptorExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ClassDescriptorExtension * SOAP_FMAC4 soap_get_tt__ClassDescriptorExtension(struct soap *soap, struct tt__ClassDescriptorExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ClassDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tt__ClassDescriptor_ClassCandidate(struct soap *soap, struct _tt__ClassDescriptor_ClassCandidate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ClassType(soap, &a->Type);
	soap_default_float(soap, &a->Likelihood);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__ClassDescriptor_ClassCandidate(struct soap *soap, const struct _tt__ClassDescriptor_ClassCandidate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Likelihood, SOAP_TYPE_float);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__ClassDescriptor_ClassCandidate(struct soap *soap, const char *tag, int id, const struct _tt__ClassDescriptor_ClassCandidate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tt__ClassDescriptor_ClassCandidate), type))
		return soap->error;
	if (soap_out_tt__ClassType(soap, "tt:Type", -1, &a->Type, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Likelihood", -1, &a->Likelihood, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tt__ClassDescriptor_ClassCandidate * SOAP_FMAC4 soap_in__tt__ClassDescriptor_ClassCandidate(struct soap *soap, const char *tag, struct _tt__ClassDescriptor_ClassCandidate *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_Likelihood = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tt__ClassDescriptor_ClassCandidate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tt__ClassDescriptor_ClassCandidate, sizeof(struct _tt__ClassDescriptor_ClassCandidate), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tt__ClassDescriptor_ClassCandidate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__ClassType(soap, "tt:Type", &a->Type, "tt:ClassType"))
				{	soap_flag_Type--;
					continue;
				}
			if (soap_flag_Likelihood && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Likelihood", &a->Likelihood, "xsd:float"))
				{	soap_flag_Likelihood--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0 || soap_flag_Likelihood > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tt__ClassDescriptor_ClassCandidate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tt__ClassDescriptor_ClassCandidate, SOAP_TYPE__tt__ClassDescriptor_ClassCandidate, sizeof(struct _tt__ClassDescriptor_ClassCandidate), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tt__ClassDescriptor_ClassCandidate * SOAP_FMAC4 soap_new__tt__ClassDescriptor_ClassCandidate(struct soap *soap, int n)
{
	struct _tt__ClassDescriptor_ClassCandidate *p;
	struct _tt__ClassDescriptor_ClassCandidate *a = (struct _tt__ClassDescriptor_ClassCandidate*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tt__ClassDescriptor_ClassCandidate));
	for (p = a; p && n--; p++)
		soap_default__tt__ClassDescriptor_ClassCandidate(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tt__ClassDescriptor_ClassCandidate(struct soap *soap, const struct _tt__ClassDescriptor_ClassCandidate *a, const char *tag, const char *type)
{
	if (soap_out__tt__ClassDescriptor_ClassCandidate(soap, tag ? tag : "tt:ClassDescriptor-ClassCandidate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ClassDescriptor_ClassCandidate * SOAP_FMAC4 soap_get__tt__ClassDescriptor_ClassCandidate(struct soap *soap, struct _tt__ClassDescriptor_ClassCandidate *p, const char *tag, const char *type)
{
	if ((p = soap_in__tt__ClassDescriptor_ClassCandidate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
