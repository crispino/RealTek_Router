/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:58 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__FindRecordings(struct soap *soap, struct _tse__FindRecordings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Scope = NULL;
	a->MaxMatches = NULL;
	soap_default_xsd__duration(soap, &a->KeepAliveTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__FindRecordings(struct soap *soap, const struct _tse__FindRecordings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__SearchScope(soap, &a->Scope);
	soap_serialize_PointerToint(soap, &a->MaxMatches);
	soap_embedded(soap, &a->KeepAliveTime, SOAP_TYPE_xsd__duration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__FindRecordings(struct soap *soap, const char *tag, int id, const struct _tse__FindRecordings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__FindRecordings), type))
		return soap->error;
	if (!a->Scope)
	{	if (soap_element_nil(soap, "tse:Scope"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__SearchScope(soap, "tse:Scope", -1, &a->Scope, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MaxMatches", -1, &a->MaxMatches, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tse:KeepAliveTime", -1, &a->KeepAliveTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__FindRecordings * SOAP_FMAC4 soap_in__tse__FindRecordings(struct soap *soap, const char *tag, struct _tse__FindRecordings *a, const char *type)
{
	size_t soap_flag_Scope = 1;
	size_t soap_flag_MaxMatches = 1;
	size_t soap_flag_KeepAliveTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__FindRecordings *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__FindRecordings, sizeof(struct _tse__FindRecordings), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__FindRecordings(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Scope && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SearchScope(soap, "tse:Scope", &a->Scope, "tt:SearchScope"))
				{	soap_flag_Scope--;
					continue;
				}
			if (soap_flag_MaxMatches && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tse:MaxMatches", &a->MaxMatches, "xsd:int"))
				{	soap_flag_MaxMatches--;
					continue;
				}
			if (soap_flag_KeepAliveTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tse:KeepAliveTime", &a->KeepAliveTime, "xsd:duration"))
				{	soap_flag_KeepAliveTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Scope > 0 || soap_flag_KeepAliveTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__FindRecordings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__FindRecordings, SOAP_TYPE__tse__FindRecordings, sizeof(struct _tse__FindRecordings), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__FindRecordings * SOAP_FMAC4 soap_new__tse__FindRecordings(struct soap *soap, int n)
{
	struct _tse__FindRecordings *p;
	struct _tse__FindRecordings *a = (struct _tse__FindRecordings*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__FindRecordings));
	for (p = a; p && n--; p++)
		soap_default__tse__FindRecordings(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__FindRecordings(struct soap *soap, const struct _tse__FindRecordings *a, const char *tag, const char *type)
{
	if (soap_out__tse__FindRecordings(soap, tag ? tag : "tse:FindRecordings", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindRecordings * SOAP_FMAC4 soap_get__tse__FindRecordings(struct soap *soap, struct _tse__FindRecordings *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__FindRecordings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetMediaAttributesResponse(struct soap *soap, struct _tse__GetMediaAttributesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMediaAttributes = 0;
	a->MediaAttributes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetMediaAttributesResponse(struct soap *soap, const struct _tse__GetMediaAttributesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->MediaAttributes)
	{	int i;
		for (i = 0; i < (int)a->__sizeMediaAttributes; i++)
		{
			soap_embedded(soap, a->MediaAttributes + i, SOAP_TYPE_tt__MediaAttributes);
			soap_serialize_tt__MediaAttributes(soap, a->MediaAttributes + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetMediaAttributesResponse(struct soap *soap, const char *tag, int id, const struct _tse__GetMediaAttributesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetMediaAttributesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeMediaAttributes");
	if (a->MediaAttributes)
	{	int i;
		for (i = 0; i < (int)a->__sizeMediaAttributes; i++)
			if (soap_out_tt__MediaAttributes(soap, "tse:MediaAttributes", -1, a->MediaAttributes + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetMediaAttributesResponse * SOAP_FMAC4 soap_in__tse__GetMediaAttributesResponse(struct soap *soap, const char *tag, struct _tse__GetMediaAttributesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_MediaAttributes = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetMediaAttributesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetMediaAttributesResponse, sizeof(struct _tse__GetMediaAttributesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetMediaAttributesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tse:MediaAttributes", 1, NULL))
			{	if (a->MediaAttributes == NULL)
				{	if (soap_blist_MediaAttributes == NULL)
						soap_blist_MediaAttributes = soap_alloc_block(soap);
					a->MediaAttributes = (struct tt__MediaAttributes *)soap_push_block_max(soap, soap_blist_MediaAttributes, sizeof(struct tt__MediaAttributes));
					if (a->MediaAttributes == NULL)
						return NULL;
					soap_default_tt__MediaAttributes(soap, a->MediaAttributes);
				}
				soap_revert(soap);
				if (soap_in_tt__MediaAttributes(soap, "tse:MediaAttributes", a->MediaAttributes, "tt:MediaAttributes"))
				{	a->__sizeMediaAttributes++;
					a->MediaAttributes = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeMediaAttributes");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->MediaAttributes)
			soap_pop_block(soap, soap_blist_MediaAttributes);
		if (a->__sizeMediaAttributes)
		{	a->MediaAttributes = (struct tt__MediaAttributes *)soap_save_block(soap, soap_blist_MediaAttributes, NULL, 1);
		}
		else
		{	a->MediaAttributes = NULL;
			if (soap_blist_MediaAttributes)
				soap_end_block(soap, soap_blist_MediaAttributes);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tse__GetMediaAttributesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetMediaAttributesResponse, SOAP_TYPE__tse__GetMediaAttributesResponse, sizeof(struct _tse__GetMediaAttributesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetMediaAttributesResponse * SOAP_FMAC4 soap_new__tse__GetMediaAttributesResponse(struct soap *soap, int n)
{
	struct _tse__GetMediaAttributesResponse *p;
	struct _tse__GetMediaAttributesResponse *a = (struct _tse__GetMediaAttributesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetMediaAttributesResponse));
	for (p = a; p && n--; p++)
		soap_default__tse__GetMediaAttributesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetMediaAttributesResponse(struct soap *soap, const struct _tse__GetMediaAttributesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetMediaAttributesResponse(soap, tag ? tag : "tse:GetMediaAttributesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetMediaAttributesResponse * SOAP_FMAC4 soap_get__tse__GetMediaAttributesResponse(struct soap *soap, struct _tse__GetMediaAttributesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetMediaAttributesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetMediaAttributes(struct soap *soap, struct _tse__GetMediaAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeRecordingTokens = 0;
	a->RecordingTokens = NULL;
	soap_default_dateTime(soap, &a->Time);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetMediaAttributes(struct soap *soap, const struct _tse__GetMediaAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->RecordingTokens)
	{	int i;
		for (i = 0; i < (int)a->__sizeRecordingTokens; i++)
		{
			soap_serialize_tt__RecordingReference(soap, (char*const*)(a->RecordingTokens + i));
		}
	}
	soap_embedded(soap, &a->Time, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetMediaAttributes(struct soap *soap, const char *tag, int id, const struct _tse__GetMediaAttributes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetMediaAttributes), type))
		return soap->error;
	if (a->RecordingTokens)
	{	int i;
		for (i = 0; i < (int)a->__sizeRecordingTokens; i++)
			soap_out_string(soap, "tse:RecordingTokens", -1, (char*const*)(a->RecordingTokens + i), "");
	}
	if (soap_out_dateTime(soap, "tse:Time", -1, &a->Time, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetMediaAttributes * SOAP_FMAC4 soap_in__tse__GetMediaAttributes(struct soap *soap, const char *tag, struct _tse__GetMediaAttributes *a, const char *type)
{
	struct soap_blist *soap_blist_RecordingTokens = NULL;
	size_t soap_flag_Time = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetMediaAttributes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetMediaAttributes, sizeof(struct _tse__GetMediaAttributes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetMediaAttributes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tse:RecordingTokens", 1, NULL))
			{	if (a->RecordingTokens == NULL)
				{	if (soap_blist_RecordingTokens == NULL)
						soap_blist_RecordingTokens = soap_alloc_block(soap);
					a->RecordingTokens = (char **)soap_push_block_max(soap, soap_blist_RecordingTokens, sizeof(char *));
					if (a->RecordingTokens == NULL)
						return NULL;
					*a->RecordingTokens = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__RecordingReference(soap, "tse:RecordingTokens", (char**)a->RecordingTokens, "tt:RecordingReference"))
				{	a->__sizeRecordingTokens++;
					a->RecordingTokens = NULL;
					continue;
				}
			}
			if (soap_flag_Time && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "tse:Time", &a->Time, "xsd:dateTime"))
				{	soap_flag_Time--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->RecordingTokens)
			soap_pop_block(soap, soap_blist_RecordingTokens);
		if (a->__sizeRecordingTokens)
		{	a->RecordingTokens = (char **)soap_save_block(soap, soap_blist_RecordingTokens, NULL, 1);
		}
		else
		{	a->RecordingTokens = NULL;
			if (soap_blist_RecordingTokens)
				soap_end_block(soap, soap_blist_RecordingTokens);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Time > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__GetMediaAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetMediaAttributes, SOAP_TYPE__tse__GetMediaAttributes, sizeof(struct _tse__GetMediaAttributes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetMediaAttributes * SOAP_FMAC4 soap_new__tse__GetMediaAttributes(struct soap *soap, int n)
{
	struct _tse__GetMediaAttributes *p;
	struct _tse__GetMediaAttributes *a = (struct _tse__GetMediaAttributes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetMediaAttributes));
	for (p = a; p && n--; p++)
		soap_default__tse__GetMediaAttributes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetMediaAttributes(struct soap *soap, const struct _tse__GetMediaAttributes *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetMediaAttributes(soap, tag ? tag : "tse:GetMediaAttributes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetMediaAttributes * SOAP_FMAC4 soap_get__tse__GetMediaAttributes(struct soap *soap, struct _tse__GetMediaAttributes *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetMediaAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetRecordingInformationResponse(struct soap *soap, struct _tse__GetRecordingInformationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RecordingInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetRecordingInformationResponse(struct soap *soap, const struct _tse__GetRecordingInformationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RecordingInformation(soap, &a->RecordingInformation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetRecordingInformationResponse(struct soap *soap, const char *tag, int id, const struct _tse__GetRecordingInformationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetRecordingInformationResponse), type))
		return soap->error;
	if (a->RecordingInformation)
		soap_element_result(soap, "tse:RecordingInformation");
	if (!a->RecordingInformation)
	{	if (soap_element_nil(soap, "tse:RecordingInformation"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__RecordingInformation(soap, "tse:RecordingInformation", -1, &a->RecordingInformation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetRecordingInformationResponse * SOAP_FMAC4 soap_in__tse__GetRecordingInformationResponse(struct soap *soap, const char *tag, struct _tse__GetRecordingInformationResponse *a, const char *type)
{
	size_t soap_flag_RecordingInformation = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetRecordingInformationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetRecordingInformationResponse, sizeof(struct _tse__GetRecordingInformationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetRecordingInformationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingInformation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingInformation(soap, "tse:RecordingInformation", &a->RecordingInformation, "tt:RecordingInformation"))
				{	soap_flag_RecordingInformation--;
					continue;
				}
			soap_check_result(soap, "tse:RecordingInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingInformation > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingInformationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetRecordingInformationResponse, SOAP_TYPE__tse__GetRecordingInformationResponse, sizeof(struct _tse__GetRecordingInformationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetRecordingInformationResponse * SOAP_FMAC4 soap_new__tse__GetRecordingInformationResponse(struct soap *soap, int n)
{
	struct _tse__GetRecordingInformationResponse *p;
	struct _tse__GetRecordingInformationResponse *a = (struct _tse__GetRecordingInformationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetRecordingInformationResponse));
	for (p = a; p && n--; p++)
		soap_default__tse__GetRecordingInformationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetRecordingInformationResponse(struct soap *soap, const struct _tse__GetRecordingInformationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetRecordingInformationResponse(soap, tag ? tag : "tse:GetRecordingInformationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingInformationResponse * SOAP_FMAC4 soap_get__tse__GetRecordingInformationResponse(struct soap *soap, struct _tse__GetRecordingInformationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetRecordingInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetRecordingInformation(struct soap *soap, struct _tse__GetRecordingInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetRecordingInformation(struct soap *soap, const struct _tse__GetRecordingInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__RecordingReference(soap, (char*const*)&a->RecordingToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetRecordingInformation(struct soap *soap, const char *tag, int id, const struct _tse__GetRecordingInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetRecordingInformation), type))
		return soap->error;
	if (!a->RecordingToken)
	{	if (soap_element_nil(soap, "tse:RecordingToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__RecordingReference(soap, "tse:RecordingToken", -1, (char*const*)&a->RecordingToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetRecordingInformation * SOAP_FMAC4 soap_in__tse__GetRecordingInformation(struct soap *soap, const char *tag, struct _tse__GetRecordingInformation *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetRecordingInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetRecordingInformation, sizeof(struct _tse__GetRecordingInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetRecordingInformation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "tse:RecordingToken", (char**)&a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetRecordingInformation, SOAP_TYPE__tse__GetRecordingInformation, sizeof(struct _tse__GetRecordingInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetRecordingInformation * SOAP_FMAC4 soap_new__tse__GetRecordingInformation(struct soap *soap, int n)
{
	struct _tse__GetRecordingInformation *p;
	struct _tse__GetRecordingInformation *a = (struct _tse__GetRecordingInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetRecordingInformation));
	for (p = a; p && n--; p++)
		soap_default__tse__GetRecordingInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetRecordingInformation(struct soap *soap, const struct _tse__GetRecordingInformation *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetRecordingInformation(soap, tag ? tag : "tse:GetRecordingInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingInformation * SOAP_FMAC4 soap_get__tse__GetRecordingInformation(struct soap *soap, struct _tse__GetRecordingInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetRecordingInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetRecordingSummaryResponse(struct soap *soap, struct _tse__GetRecordingSummaryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Summary = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetRecordingSummaryResponse(struct soap *soap, const struct _tse__GetRecordingSummaryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RecordingSummary(soap, &a->Summary);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetRecordingSummaryResponse(struct soap *soap, const char *tag, int id, const struct _tse__GetRecordingSummaryResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetRecordingSummaryResponse), type))
		return soap->error;
	if (a->Summary)
		soap_element_result(soap, "tse:Summary");
	if (!a->Summary)
	{	if (soap_element_nil(soap, "tse:Summary"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__RecordingSummary(soap, "tse:Summary", -1, &a->Summary, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetRecordingSummaryResponse * SOAP_FMAC4 soap_in__tse__GetRecordingSummaryResponse(struct soap *soap, const char *tag, struct _tse__GetRecordingSummaryResponse *a, const char *type)
{
	size_t soap_flag_Summary = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetRecordingSummaryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetRecordingSummaryResponse, sizeof(struct _tse__GetRecordingSummaryResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetRecordingSummaryResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Summary && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingSummary(soap, "tse:Summary", &a->Summary, "tt:RecordingSummary"))
				{	soap_flag_Summary--;
					continue;
				}
			soap_check_result(soap, "tse:Summary");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Summary > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingSummaryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetRecordingSummaryResponse, SOAP_TYPE__tse__GetRecordingSummaryResponse, sizeof(struct _tse__GetRecordingSummaryResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetRecordingSummaryResponse * SOAP_FMAC4 soap_new__tse__GetRecordingSummaryResponse(struct soap *soap, int n)
{
	struct _tse__GetRecordingSummaryResponse *p;
	struct _tse__GetRecordingSummaryResponse *a = (struct _tse__GetRecordingSummaryResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetRecordingSummaryResponse));
	for (p = a; p && n--; p++)
		soap_default__tse__GetRecordingSummaryResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetRecordingSummaryResponse(struct soap *soap, const struct _tse__GetRecordingSummaryResponse *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetRecordingSummaryResponse(soap, tag ? tag : "tse:GetRecordingSummaryResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingSummaryResponse * SOAP_FMAC4 soap_get__tse__GetRecordingSummaryResponse(struct soap *soap, struct _tse__GetRecordingSummaryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetRecordingSummaryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetRecordingSummary(struct soap *soap, struct _tse__GetRecordingSummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetRecordingSummary(struct soap *soap, const struct _tse__GetRecordingSummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetRecordingSummary(struct soap *soap, const char *tag, int id, const struct _tse__GetRecordingSummary *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetRecordingSummary), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetRecordingSummary * SOAP_FMAC4 soap_in__tse__GetRecordingSummary(struct soap *soap, const char *tag, struct _tse__GetRecordingSummary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetRecordingSummary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetRecordingSummary, sizeof(struct _tse__GetRecordingSummary), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetRecordingSummary(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingSummary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetRecordingSummary, SOAP_TYPE__tse__GetRecordingSummary, sizeof(struct _tse__GetRecordingSummary), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetRecordingSummary * SOAP_FMAC4 soap_new__tse__GetRecordingSummary(struct soap *soap, int n)
{
	struct _tse__GetRecordingSummary *p;
	struct _tse__GetRecordingSummary *a = (struct _tse__GetRecordingSummary*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetRecordingSummary));
	for (p = a; p && n--; p++)
		soap_default__tse__GetRecordingSummary(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetRecordingSummary(struct soap *soap, const struct _tse__GetRecordingSummary *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetRecordingSummary(soap, tag ? tag : "tse:GetRecordingSummary", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingSummary * SOAP_FMAC4 soap_get__tse__GetRecordingSummary(struct soap *soap, struct _tse__GetRecordingSummary *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetRecordingSummary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetServiceCapabilitiesResponse(struct soap *soap, struct _tse__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tse__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotse__Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _tse__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tse:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_nil(soap, "tse:Capabilities"))
			return soap->error;
	}
	else
	if (soap_out_PointerTotse__Capabilities(soap, "tse:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__tse__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tse__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetServiceCapabilitiesResponse, sizeof(struct _tse__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotse__Capabilities(soap, "tse:Capabilities", &a->Capabilities, "tse:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			soap_check_result(soap, "tse:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetServiceCapabilitiesResponse, SOAP_TYPE__tse__GetServiceCapabilitiesResponse, sizeof(struct _tse__GetServiceCapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_new__tse__GetServiceCapabilitiesResponse(struct soap *soap, int n)
{
	struct _tse__GetServiceCapabilitiesResponse *p;
	struct _tse__GetServiceCapabilitiesResponse *a = (struct _tse__GetServiceCapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetServiceCapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__tse__GetServiceCapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tse__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetServiceCapabilitiesResponse(soap, tag ? tag : "tse:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__tse__GetServiceCapabilitiesResponse(struct soap *soap, struct _tse__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetServiceCapabilities(struct soap *soap, struct _tse__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetServiceCapabilities(struct soap *soap, const struct _tse__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _tse__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetServiceCapabilities * SOAP_FMAC4 soap_in__tse__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tse__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetServiceCapabilities, sizeof(struct _tse__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetServiceCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tse__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetServiceCapabilities, SOAP_TYPE__tse__GetServiceCapabilities, sizeof(struct _tse__GetServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetServiceCapabilities * SOAP_FMAC4 soap_new__tse__GetServiceCapabilities(struct soap *soap, int n)
{
	struct _tse__GetServiceCapabilities *p;
	struct _tse__GetServiceCapabilities *a = (struct _tse__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default__tse__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetServiceCapabilities(struct soap *soap, const struct _tse__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetServiceCapabilities(soap, tag ? tag : "tse:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetServiceCapabilities * SOAP_FMAC4 soap_get__tse__GetServiceCapabilities(struct soap *soap, struct _tse__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tse__Capabilities(struct soap *soap, struct tse__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MetadataSearch = NULL;
	a->GeneralStartEvents = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tse__Capabilities(struct soap *soap, const struct tse__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tse__Capabilities(struct soap *soap, const char *tag, int id, const struct tse__Capabilities *a, const char *type)
{
	if (a->MetadataSearch)
		soap_set_attr(soap, "MetadataSearch", soap_xsd__boolean2s(soap, *a->MetadataSearch), 1);
	if (a->GeneralStartEvents)
		soap_set_attr(soap, "GeneralStartEvents", soap_xsd__boolean2s(soap, *a->GeneralStartEvents), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tse__Capabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tse__Capabilities * SOAP_FMAC4 soap_in_tse__Capabilities(struct soap *soap, const char *tag, struct tse__Capabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tse__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tse__Capabilities, sizeof(struct tse__Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tse__Capabilities(soap, a);
	{	const char *t = soap_attr_value(soap, "MetadataSearch", 0);
		if (t)
		{
			if (!(a->MetadataSearch = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->MetadataSearch))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "GeneralStartEvents", 0);
		if (t)
		{
			if (!(a->GeneralStartEvents = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->GeneralStartEvents))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tse__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tse__Capabilities, SOAP_TYPE_tse__Capabilities, sizeof(struct tse__Capabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tse__Capabilities * SOAP_FMAC4 soap_new_tse__Capabilities(struct soap *soap, int n)
{
	struct tse__Capabilities *p;
	struct tse__Capabilities *a = (struct tse__Capabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tse__Capabilities));
	for (p = a; p && n--; p++)
		soap_default_tse__Capabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tse__Capabilities(struct soap *soap, const struct tse__Capabilities *a, const char *tag, const char *type)
{
	if (soap_out_tse__Capabilities(soap, tag ? tag : "tse:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tse__Capabilities * SOAP_FMAC4 soap_get_tse__Capabilities(struct soap *soap, struct tse__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tse__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns7__DeleteSpecialDayGroupResponse(struct soap *soap, struct _ns7__DeleteSpecialDayGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__DeleteSpecialDayGroupResponse(struct soap *soap, const struct _ns7__DeleteSpecialDayGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__DeleteSpecialDayGroupResponse(struct soap *soap, const char *tag, int id, const struct _ns7__DeleteSpecialDayGroupResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__DeleteSpecialDayGroupResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns7__DeleteSpecialDayGroupResponse * SOAP_FMAC4 soap_in__ns7__DeleteSpecialDayGroupResponse(struct soap *soap, const char *tag, struct _ns7__DeleteSpecialDayGroupResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns7__DeleteSpecialDayGroupResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__DeleteSpecialDayGroupResponse, sizeof(struct _ns7__DeleteSpecialDayGroupResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns7__DeleteSpecialDayGroupResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns7__DeleteSpecialDayGroupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__DeleteSpecialDayGroupResponse, SOAP_TYPE__ns7__DeleteSpecialDayGroupResponse, sizeof(struct _ns7__DeleteSpecialDayGroupResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns7__DeleteSpecialDayGroupResponse * SOAP_FMAC4 soap_new__ns7__DeleteSpecialDayGroupResponse(struct soap *soap, int n)
{
	struct _ns7__DeleteSpecialDayGroupResponse *p;
	struct _ns7__DeleteSpecialDayGroupResponse *a = (struct _ns7__DeleteSpecialDayGroupResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns7__DeleteSpecialDayGroupResponse));
	for (p = a; p && n--; p++)
		soap_default__ns7__DeleteSpecialDayGroupResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns7__DeleteSpecialDayGroupResponse(struct soap *soap, const struct _ns7__DeleteSpecialDayGroupResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns7__DeleteSpecialDayGroupResponse(soap, tag ? tag : "ns7:DeleteSpecialDayGroupResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns7__DeleteSpecialDayGroupResponse * SOAP_FMAC4 soap_get__ns7__DeleteSpecialDayGroupResponse(struct soap *soap, struct _ns7__DeleteSpecialDayGroupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__DeleteSpecialDayGroupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns7__DeleteSpecialDayGroup(struct soap *soap, struct _ns7__DeleteSpecialDayGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__DeleteSpecialDayGroup(struct soap *soap, const struct _ns7__DeleteSpecialDayGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__ReferenceToken(soap, (char*const*)&a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__DeleteSpecialDayGroup(struct soap *soap, const char *tag, int id, const struct _ns7__DeleteSpecialDayGroup *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__DeleteSpecialDayGroup), type))
		return soap->error;
	if (!a->Token)
	{	if (soap_element_nil(soap, "ns7:Token"))
			return soap->error;
	}
	else
	if (soap_out_ns2__ReferenceToken(soap, "ns7:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns7__DeleteSpecialDayGroup * SOAP_FMAC4 soap_in__ns7__DeleteSpecialDayGroup(struct soap *soap, const char *tag, struct _ns7__DeleteSpecialDayGroup *a, const char *type)
{
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns7__DeleteSpecialDayGroup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__DeleteSpecialDayGroup, sizeof(struct _ns7__DeleteSpecialDayGroup), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns7__DeleteSpecialDayGroup(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns7:Token", (char**)&a->Token, "ns2:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns7__DeleteSpecialDayGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__DeleteSpecialDayGroup, SOAP_TYPE__ns7__DeleteSpecialDayGroup, sizeof(struct _ns7__DeleteSpecialDayGroup), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns7__DeleteSpecialDayGroup * SOAP_FMAC4 soap_new__ns7__DeleteSpecialDayGroup(struct soap *soap, int n)
{
	struct _ns7__DeleteSpecialDayGroup *p;
	struct _ns7__DeleteSpecialDayGroup *a = (struct _ns7__DeleteSpecialDayGroup*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns7__DeleteSpecialDayGroup));
	for (p = a; p && n--; p++)
		soap_default__ns7__DeleteSpecialDayGroup(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns7__DeleteSpecialDayGroup(struct soap *soap, const struct _ns7__DeleteSpecialDayGroup *a, const char *tag, const char *type)
{
	if (soap_out__ns7__DeleteSpecialDayGroup(soap, tag ? tag : "ns7:DeleteSpecialDayGroup", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns7__DeleteSpecialDayGroup * SOAP_FMAC4 soap_get__ns7__DeleteSpecialDayGroup(struct soap *soap, struct _ns7__DeleteSpecialDayGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__DeleteSpecialDayGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns7__ModifySpecialDayGroupResponse(struct soap *soap, struct _ns7__ModifySpecialDayGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__ModifySpecialDayGroupResponse(struct soap *soap, const struct _ns7__ModifySpecialDayGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__ModifySpecialDayGroupResponse(struct soap *soap, const char *tag, int id, const struct _ns7__ModifySpecialDayGroupResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__ModifySpecialDayGroupResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns7__ModifySpecialDayGroupResponse * SOAP_FMAC4 soap_in__ns7__ModifySpecialDayGroupResponse(struct soap *soap, const char *tag, struct _ns7__ModifySpecialDayGroupResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns7__ModifySpecialDayGroupResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__ModifySpecialDayGroupResponse, sizeof(struct _ns7__ModifySpecialDayGroupResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns7__ModifySpecialDayGroupResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns7__ModifySpecialDayGroupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__ModifySpecialDayGroupResponse, SOAP_TYPE__ns7__ModifySpecialDayGroupResponse, sizeof(struct _ns7__ModifySpecialDayGroupResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns7__ModifySpecialDayGroupResponse * SOAP_FMAC4 soap_new__ns7__ModifySpecialDayGroupResponse(struct soap *soap, int n)
{
	struct _ns7__ModifySpecialDayGroupResponse *p;
	struct _ns7__ModifySpecialDayGroupResponse *a = (struct _ns7__ModifySpecialDayGroupResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns7__ModifySpecialDayGroupResponse));
	for (p = a; p && n--; p++)
		soap_default__ns7__ModifySpecialDayGroupResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns7__ModifySpecialDayGroupResponse(struct soap *soap, const struct _ns7__ModifySpecialDayGroupResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns7__ModifySpecialDayGroupResponse(soap, tag ? tag : "ns7:ModifySpecialDayGroupResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns7__ModifySpecialDayGroupResponse * SOAP_FMAC4 soap_get__ns7__ModifySpecialDayGroupResponse(struct soap *soap, struct _ns7__ModifySpecialDayGroupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__ModifySpecialDayGroupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns7__ModifySpecialDayGroup(struct soap *soap, struct _ns7__ModifySpecialDayGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SpecialDayGroup = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__ModifySpecialDayGroup(struct soap *soap, const struct _ns7__ModifySpecialDayGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons7__SpecialDayGroup(soap, &a->SpecialDayGroup);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__ModifySpecialDayGroup(struct soap *soap, const char *tag, int id, const struct _ns7__ModifySpecialDayGroup *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__ModifySpecialDayGroup), type))
		return soap->error;
	if (!a->SpecialDayGroup)
	{	if (soap_element_nil(soap, "ns7:SpecialDayGroup"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__SpecialDayGroup(soap, "ns7:SpecialDayGroup", -1, &a->SpecialDayGroup, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns7__ModifySpecialDayGroup * SOAP_FMAC4 soap_in__ns7__ModifySpecialDayGroup(struct soap *soap, const char *tag, struct _ns7__ModifySpecialDayGroup *a, const char *type)
{
	size_t soap_flag_SpecialDayGroup = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns7__ModifySpecialDayGroup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__ModifySpecialDayGroup, sizeof(struct _ns7__ModifySpecialDayGroup), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns7__ModifySpecialDayGroup(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SpecialDayGroup && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons7__SpecialDayGroup(soap, "ns7:SpecialDayGroup", &a->SpecialDayGroup, "ns7:SpecialDayGroup"))
				{	soap_flag_SpecialDayGroup--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SpecialDayGroup > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns7__ModifySpecialDayGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__ModifySpecialDayGroup, SOAP_TYPE__ns7__ModifySpecialDayGroup, sizeof(struct _ns7__ModifySpecialDayGroup), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns7__ModifySpecialDayGroup * SOAP_FMAC4 soap_new__ns7__ModifySpecialDayGroup(struct soap *soap, int n)
{
	struct _ns7__ModifySpecialDayGroup *p;
	struct _ns7__ModifySpecialDayGroup *a = (struct _ns7__ModifySpecialDayGroup*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns7__ModifySpecialDayGroup));
	for (p = a; p && n--; p++)
		soap_default__ns7__ModifySpecialDayGroup(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns7__ModifySpecialDayGroup(struct soap *soap, const struct _ns7__ModifySpecialDayGroup *a, const char *tag, const char *type)
{
	if (soap_out__ns7__ModifySpecialDayGroup(soap, tag ? tag : "ns7:ModifySpecialDayGroup", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns7__ModifySpecialDayGroup * SOAP_FMAC4 soap_get__ns7__ModifySpecialDayGroup(struct soap *soap, struct _ns7__ModifySpecialDayGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__ModifySpecialDayGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns7__CreateSpecialDayGroupResponse(struct soap *soap, struct _ns7__CreateSpecialDayGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__CreateSpecialDayGroupResponse(struct soap *soap, const struct _ns7__CreateSpecialDayGroupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__ReferenceToken(soap, (char*const*)&a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__CreateSpecialDayGroupResponse(struct soap *soap, const char *tag, int id, const struct _ns7__CreateSpecialDayGroupResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__CreateSpecialDayGroupResponse), type))
		return soap->error;
	if (a->Token)
		soap_element_result(soap, "ns7:Token");
	if (!a->Token)
	{	if (soap_element_nil(soap, "ns7:Token"))
			return soap->error;
	}
	else
	if (soap_out_ns2__ReferenceToken(soap, "ns7:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns7__CreateSpecialDayGroupResponse * SOAP_FMAC4 soap_in__ns7__CreateSpecialDayGroupResponse(struct soap *soap, const char *tag, struct _ns7__CreateSpecialDayGroupResponse *a, const char *type)
{
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns7__CreateSpecialDayGroupResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__CreateSpecialDayGroupResponse, sizeof(struct _ns7__CreateSpecialDayGroupResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns7__CreateSpecialDayGroupResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns7:Token", (char**)&a->Token, "ns2:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			soap_check_result(soap, "ns7:Token");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns7__CreateSpecialDayGroupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__CreateSpecialDayGroupResponse, SOAP_TYPE__ns7__CreateSpecialDayGroupResponse, sizeof(struct _ns7__CreateSpecialDayGroupResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns7__CreateSpecialDayGroupResponse * SOAP_FMAC4 soap_new__ns7__CreateSpecialDayGroupResponse(struct soap *soap, int n)
{
	struct _ns7__CreateSpecialDayGroupResponse *p;
	struct _ns7__CreateSpecialDayGroupResponse *a = (struct _ns7__CreateSpecialDayGroupResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns7__CreateSpecialDayGroupResponse));
	for (p = a; p && n--; p++)
		soap_default__ns7__CreateSpecialDayGroupResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns7__CreateSpecialDayGroupResponse(struct soap *soap, const struct _ns7__CreateSpecialDayGroupResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns7__CreateSpecialDayGroupResponse(soap, tag ? tag : "ns7:CreateSpecialDayGroupResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns7__CreateSpecialDayGroupResponse * SOAP_FMAC4 soap_get__ns7__CreateSpecialDayGroupResponse(struct soap *soap, struct _ns7__CreateSpecialDayGroupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__CreateSpecialDayGroupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns7__CreateSpecialDayGroup(struct soap *soap, struct _ns7__CreateSpecialDayGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SpecialDayGroup = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__CreateSpecialDayGroup(struct soap *soap, const struct _ns7__CreateSpecialDayGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons7__SpecialDayGroup(soap, &a->SpecialDayGroup);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__CreateSpecialDayGroup(struct soap *soap, const char *tag, int id, const struct _ns7__CreateSpecialDayGroup *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__CreateSpecialDayGroup), type))
		return soap->error;
	if (!a->SpecialDayGroup)
	{	if (soap_element_nil(soap, "ns7:SpecialDayGroup"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__SpecialDayGroup(soap, "ns7:SpecialDayGroup", -1, &a->SpecialDayGroup, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns7__CreateSpecialDayGroup * SOAP_FMAC4 soap_in__ns7__CreateSpecialDayGroup(struct soap *soap, const char *tag, struct _ns7__CreateSpecialDayGroup *a, const char *type)
{
	size_t soap_flag_SpecialDayGroup = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns7__CreateSpecialDayGroup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__CreateSpecialDayGroup, sizeof(struct _ns7__CreateSpecialDayGroup), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns7__CreateSpecialDayGroup(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SpecialDayGroup && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons7__SpecialDayGroup(soap, "ns7:SpecialDayGroup", &a->SpecialDayGroup, "ns7:SpecialDayGroup"))
				{	soap_flag_SpecialDayGroup--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SpecialDayGroup > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns7__CreateSpecialDayGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__CreateSpecialDayGroup, SOAP_TYPE__ns7__CreateSpecialDayGroup, sizeof(struct _ns7__CreateSpecialDayGroup), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns7__CreateSpecialDayGroup * SOAP_FMAC4 soap_new__ns7__CreateSpecialDayGroup(struct soap *soap, int n)
{
	struct _ns7__CreateSpecialDayGroup *p;
	struct _ns7__CreateSpecialDayGroup *a = (struct _ns7__CreateSpecialDayGroup*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns7__CreateSpecialDayGroup));
	for (p = a; p && n--; p++)
		soap_default__ns7__CreateSpecialDayGroup(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns7__CreateSpecialDayGroup(struct soap *soap, const struct _ns7__CreateSpecialDayGroup *a, const char *tag, const char *type)
{
	if (soap_out__ns7__CreateSpecialDayGroup(soap, tag ? tag : "ns7:CreateSpecialDayGroup", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns7__CreateSpecialDayGroup * SOAP_FMAC4 soap_get__ns7__CreateSpecialDayGroup(struct soap *soap, struct _ns7__CreateSpecialDayGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__CreateSpecialDayGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns7__GetSpecialDayGroupListResponse(struct soap *soap, struct _ns7__GetSpecialDayGroupListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->NextStartReference);
	a->__sizeSpecialDayGroup = 0;
	a->SpecialDayGroup = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__GetSpecialDayGroupListResponse(struct soap *soap, const struct _ns7__GetSpecialDayGroupListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->NextStartReference);
	if (a->SpecialDayGroup)
	{	int i;
		for (i = 0; i < (int)a->__sizeSpecialDayGroup; i++)
		{
			soap_embedded(soap, a->SpecialDayGroup + i, SOAP_TYPE_ns7__SpecialDayGroup);
			soap_serialize_ns7__SpecialDayGroup(soap, a->SpecialDayGroup + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__GetSpecialDayGroupListResponse(struct soap *soap, const char *tag, int id, const struct _ns7__GetSpecialDayGroupListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__GetSpecialDayGroupListResponse), type))
		return soap->error;
	if (a->NextStartReference)
		soap_element_result(soap, "ns7:NextStartReference");
	if (soap_out_string(soap, "ns7:NextStartReference", -1, (char*const*)&a->NextStartReference, ""))
		return soap->error;
	if (a->SpecialDayGroup)
	{	int i;
		for (i = 0; i < (int)a->__sizeSpecialDayGroup; i++)
			if (soap_out_ns7__SpecialDayGroup(soap, "ns7:SpecialDayGroup", -1, a->SpecialDayGroup + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns7__GetSpecialDayGroupListResponse * SOAP_FMAC4 soap_in__ns7__GetSpecialDayGroupListResponse(struct soap *soap, const char *tag, struct _ns7__GetSpecialDayGroupListResponse *a, const char *type)
{
	size_t soap_flag_NextStartReference = 1;
	struct soap_blist *soap_blist_SpecialDayGroup = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns7__GetSpecialDayGroupListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__GetSpecialDayGroupListResponse, sizeof(struct _ns7__GetSpecialDayGroupListResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns7__GetSpecialDayGroupListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NextStartReference && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns7:NextStartReference", (char**)&a->NextStartReference, "xsd:string"))
				{	soap_flag_NextStartReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:SpecialDayGroup", 1, NULL))
			{	if (a->SpecialDayGroup == NULL)
				{	if (soap_blist_SpecialDayGroup == NULL)
						soap_blist_SpecialDayGroup = soap_alloc_block(soap);
					a->SpecialDayGroup = (struct ns7__SpecialDayGroup *)soap_push_block_max(soap, soap_blist_SpecialDayGroup, sizeof(struct ns7__SpecialDayGroup));
					if (a->SpecialDayGroup == NULL)
						return NULL;
					soap_default_ns7__SpecialDayGroup(soap, a->SpecialDayGroup);
				}
				soap_revert(soap);
				if (soap_in_ns7__SpecialDayGroup(soap, "ns7:SpecialDayGroup", a->SpecialDayGroup, "ns7:SpecialDayGroup"))
				{	a->__sizeSpecialDayGroup++;
					a->SpecialDayGroup = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns7:NextStartReference");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SpecialDayGroup)
			soap_pop_block(soap, soap_blist_SpecialDayGroup);
		if (a->__sizeSpecialDayGroup)
		{	a->SpecialDayGroup = (struct ns7__SpecialDayGroup *)soap_save_block(soap, soap_blist_SpecialDayGroup, NULL, 1);
		}
		else
		{	a->SpecialDayGroup = NULL;
			if (soap_blist_SpecialDayGroup)
				soap_end_block(soap, soap_blist_SpecialDayGroup);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns7__GetSpecialDayGroupListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__GetSpecialDayGroupListResponse, SOAP_TYPE__ns7__GetSpecialDayGroupListResponse, sizeof(struct _ns7__GetSpecialDayGroupListResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns7__GetSpecialDayGroupListResponse * SOAP_FMAC4 soap_new__ns7__GetSpecialDayGroupListResponse(struct soap *soap, int n)
{
	struct _ns7__GetSpecialDayGroupListResponse *p;
	struct _ns7__GetSpecialDayGroupListResponse *a = (struct _ns7__GetSpecialDayGroupListResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns7__GetSpecialDayGroupListResponse));
	for (p = a; p && n--; p++)
		soap_default__ns7__GetSpecialDayGroupListResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns7__GetSpecialDayGroupListResponse(struct soap *soap, const struct _ns7__GetSpecialDayGroupListResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns7__GetSpecialDayGroupListResponse(soap, tag ? tag : "ns7:GetSpecialDayGroupListResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns7__GetSpecialDayGroupListResponse * SOAP_FMAC4 soap_get__ns7__GetSpecialDayGroupListResponse(struct soap *soap, struct _ns7__GetSpecialDayGroupListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__GetSpecialDayGroupListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns7__GetSpecialDayGroupList(struct soap *soap, struct _ns7__GetSpecialDayGroupList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Limit = NULL;
	soap_default_string(soap, &a->StartReference);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__GetSpecialDayGroupList(struct soap *soap, const struct _ns7__GetSpecialDayGroupList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->Limit);
	soap_serialize_string(soap, (char*const*)&a->StartReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__GetSpecialDayGroupList(struct soap *soap, const char *tag, int id, const struct _ns7__GetSpecialDayGroupList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__GetSpecialDayGroupList), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns7:Limit", -1, &a->Limit, ""))
		return soap->error;
	if (soap_out_string(soap, "ns7:StartReference", -1, (char*const*)&a->StartReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns7__GetSpecialDayGroupList * SOAP_FMAC4 soap_in__ns7__GetSpecialDayGroupList(struct soap *soap, const char *tag, struct _ns7__GetSpecialDayGroupList *a, const char *type)
{
	size_t soap_flag_Limit = 1;
	size_t soap_flag_StartReference = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns7__GetSpecialDayGroupList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__GetSpecialDayGroupList, sizeof(struct _ns7__GetSpecialDayGroupList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns7__GetSpecialDayGroupList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Limit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns7:Limit", &a->Limit, "xsd:int"))
				{	soap_flag_Limit--;
					continue;
				}
			if (soap_flag_StartReference && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns7:StartReference", (char**)&a->StartReference, "xsd:string"))
				{	soap_flag_StartReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns7__GetSpecialDayGroupList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__GetSpecialDayGroupList, SOAP_TYPE__ns7__GetSpecialDayGroupList, sizeof(struct _ns7__GetSpecialDayGroupList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns7__GetSpecialDayGroupList * SOAP_FMAC4 soap_new__ns7__GetSpecialDayGroupList(struct soap *soap, int n)
{
	struct _ns7__GetSpecialDayGroupList *p;
	struct _ns7__GetSpecialDayGroupList *a = (struct _ns7__GetSpecialDayGroupList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns7__GetSpecialDayGroupList));
	for (p = a; p && n--; p++)
		soap_default__ns7__GetSpecialDayGroupList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns7__GetSpecialDayGroupList(struct soap *soap, const struct _ns7__GetSpecialDayGroupList *a, const char *tag, const char *type)
{
	if (soap_out__ns7__GetSpecialDayGroupList(soap, tag ? tag : "ns7:GetSpecialDayGroupList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns7__GetSpecialDayGroupList * SOAP_FMAC4 soap_get__ns7__GetSpecialDayGroupList(struct soap *soap, struct _ns7__GetSpecialDayGroupList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__GetSpecialDayGroupList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns7__SpecialDayGroup(struct soap *soap, struct ns7__SpecialDayGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->token);
	soap_default_ns2__Name(soap, &a->Name);
	soap_default_ns2__Description(soap, &a->Description);
	soap_default_string(soap, &a->Days);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns7__SpecialDayGroup(struct soap *soap, const struct ns7__SpecialDayGroup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__Name(soap, (char*const*)&a->Name);
	soap_serialize_ns2__Description(soap, (char*const*)&a->Description);
	soap_serialize_string(soap, (char*const*)&a->Days);
	soap_serialize_PointerTons7__SpecialDayGroupExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__SpecialDayGroup(struct soap *soap, const char *tag, int id, const struct ns7__SpecialDayGroup *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_ns2__ReferenceToken2s(soap, a->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__SpecialDayGroup), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "ns7:Name"))
			return soap->error;
	}
	else
	if (soap_out_ns2__Name(soap, "ns7:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_ns2__Description(soap, "ns7:Description", -1, (char*const*)&a->Description, ""))
		return soap->error;
	if (soap_out_string(soap, "ns7:Days", -1, (char*const*)&a->Days, ""))
		return soap->error;
	if (soap_out_PointerTons7__SpecialDayGroupExtension(soap, "ns7:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns7__SpecialDayGroup * SOAP_FMAC4 soap_in_ns7__SpecialDayGroup(struct soap *soap, const char *tag, struct ns7__SpecialDayGroup *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_Description = 1;
	size_t soap_flag_Days = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns7__SpecialDayGroup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__SpecialDayGroup, sizeof(struct ns7__SpecialDayGroup), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns7__SpecialDayGroup(soap, a);
	if (soap_s2ns2__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Name(soap, "ns7:Name", (char**)&a->Name, "ns2:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Description(soap, "ns7:Description", (char**)&a->Description, "ns2:Description"))
				{	soap_flag_Description--;
					continue;
				}
			if (soap_flag_Days && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns7:Days", (char**)&a->Days, "xsd:string"))
				{	soap_flag_Days--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons7__SpecialDayGroupExtension(soap, "ns7:Extension", &a->Extension, "ns7:SpecialDayGroupExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns7__SpecialDayGroup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__SpecialDayGroup, SOAP_TYPE_ns7__SpecialDayGroup, sizeof(struct ns7__SpecialDayGroup), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns7__SpecialDayGroup * SOAP_FMAC4 soap_new_ns7__SpecialDayGroup(struct soap *soap, int n)
{
	struct ns7__SpecialDayGroup *p;
	struct ns7__SpecialDayGroup *a = (struct ns7__SpecialDayGroup*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns7__SpecialDayGroup));
	for (p = a; p && n--; p++)
		soap_default_ns7__SpecialDayGroup(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns7__SpecialDayGroup(struct soap *soap, const struct ns7__SpecialDayGroup *a, const char *tag, const char *type)
{
	if (soap_out_ns7__SpecialDayGroup(soap, tag ? tag : "ns7:SpecialDayGroup", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns7__SpecialDayGroup * SOAP_FMAC4 soap_get_ns7__SpecialDayGroup(struct soap *soap, struct ns7__SpecialDayGroup *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__SpecialDayGroup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns7__GetSpecialDayGroupsResponse(struct soap *soap, struct _ns7__GetSpecialDayGroupsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeSpecialDayGroup = 0;
	a->SpecialDayGroup = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__GetSpecialDayGroupsResponse(struct soap *soap, const struct _ns7__GetSpecialDayGroupsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->SpecialDayGroup)
	{	int i;
		for (i = 0; i < (int)a->__sizeSpecialDayGroup; i++)
		{
			soap_embedded(soap, a->SpecialDayGroup + i, SOAP_TYPE_ns7__SpecialDayGroup);
			soap_serialize_ns7__SpecialDayGroup(soap, a->SpecialDayGroup + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__GetSpecialDayGroupsResponse(struct soap *soap, const char *tag, int id, const struct _ns7__GetSpecialDayGroupsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__GetSpecialDayGroupsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeSpecialDayGroup");
	if (a->SpecialDayGroup)
	{	int i;
		for (i = 0; i < (int)a->__sizeSpecialDayGroup; i++)
			if (soap_out_ns7__SpecialDayGroup(soap, "ns7:SpecialDayGroup", -1, a->SpecialDayGroup + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns7__GetSpecialDayGroupsResponse * SOAP_FMAC4 soap_in__ns7__GetSpecialDayGroupsResponse(struct soap *soap, const char *tag, struct _ns7__GetSpecialDayGroupsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_SpecialDayGroup = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns7__GetSpecialDayGroupsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__GetSpecialDayGroupsResponse, sizeof(struct _ns7__GetSpecialDayGroupsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns7__GetSpecialDayGroupsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:SpecialDayGroup", 1, NULL))
			{	if (a->SpecialDayGroup == NULL)
				{	if (soap_blist_SpecialDayGroup == NULL)
						soap_blist_SpecialDayGroup = soap_alloc_block(soap);
					a->SpecialDayGroup = (struct ns7__SpecialDayGroup *)soap_push_block_max(soap, soap_blist_SpecialDayGroup, sizeof(struct ns7__SpecialDayGroup));
					if (a->SpecialDayGroup == NULL)
						return NULL;
					soap_default_ns7__SpecialDayGroup(soap, a->SpecialDayGroup);
				}
				soap_revert(soap);
				if (soap_in_ns7__SpecialDayGroup(soap, "ns7:SpecialDayGroup", a->SpecialDayGroup, "ns7:SpecialDayGroup"))
				{	a->__sizeSpecialDayGroup++;
					a->SpecialDayGroup = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeSpecialDayGroup");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SpecialDayGroup)
			soap_pop_block(soap, soap_blist_SpecialDayGroup);
		if (a->__sizeSpecialDayGroup)
		{	a->SpecialDayGroup = (struct ns7__SpecialDayGroup *)soap_save_block(soap, soap_blist_SpecialDayGroup, NULL, 1);
		}
		else
		{	a->SpecialDayGroup = NULL;
			if (soap_blist_SpecialDayGroup)
				soap_end_block(soap, soap_blist_SpecialDayGroup);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns7__GetSpecialDayGroupsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__GetSpecialDayGroupsResponse, SOAP_TYPE__ns7__GetSpecialDayGroupsResponse, sizeof(struct _ns7__GetSpecialDayGroupsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns7__GetSpecialDayGroupsResponse * SOAP_FMAC4 soap_new__ns7__GetSpecialDayGroupsResponse(struct soap *soap, int n)
{
	struct _ns7__GetSpecialDayGroupsResponse *p;
	struct _ns7__GetSpecialDayGroupsResponse *a = (struct _ns7__GetSpecialDayGroupsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns7__GetSpecialDayGroupsResponse));
	for (p = a; p && n--; p++)
		soap_default__ns7__GetSpecialDayGroupsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns7__GetSpecialDayGroupsResponse(struct soap *soap, const struct _ns7__GetSpecialDayGroupsResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns7__GetSpecialDayGroupsResponse(soap, tag ? tag : "ns7:GetSpecialDayGroupsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns7__GetSpecialDayGroupsResponse * SOAP_FMAC4 soap_get__ns7__GetSpecialDayGroupsResponse(struct soap *soap, struct _ns7__GetSpecialDayGroupsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__GetSpecialDayGroupsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns7__GetSpecialDayGroups(struct soap *soap, struct _ns7__GetSpecialDayGroups *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeToken = 0;
	a->Token = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__GetSpecialDayGroups(struct soap *soap, const struct _ns7__GetSpecialDayGroups *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Token)
	{	int i;
		for (i = 0; i < (int)a->__sizeToken; i++)
		{
			soap_serialize_ns2__ReferenceToken(soap, (char*const*)(a->Token + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__GetSpecialDayGroups(struct soap *soap, const char *tag, int id, const struct _ns7__GetSpecialDayGroups *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__GetSpecialDayGroups), type))
		return soap->error;
	if (a->Token)
	{	int i;
		for (i = 0; i < (int)a->__sizeToken; i++)
			soap_out_string(soap, "ns7:Token", -1, (char*const*)(a->Token + i), "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns7__GetSpecialDayGroups * SOAP_FMAC4 soap_in__ns7__GetSpecialDayGroups(struct soap *soap, const char *tag, struct _ns7__GetSpecialDayGroups *a, const char *type)
{
	struct soap_blist *soap_blist_Token = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns7__GetSpecialDayGroups *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__GetSpecialDayGroups, sizeof(struct _ns7__GetSpecialDayGroups), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns7__GetSpecialDayGroups(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:Token", 1, NULL))
			{	if (a->Token == NULL)
				{	if (soap_blist_Token == NULL)
						soap_blist_Token = soap_alloc_block(soap);
					a->Token = (char **)soap_push_block_max(soap, soap_blist_Token, sizeof(char *));
					if (a->Token == NULL)
						return NULL;
					*a->Token = NULL;
				}
				soap_revert(soap);
				if (soap_in_ns2__ReferenceToken(soap, "ns7:Token", (char**)a->Token, "ns2:ReferenceToken"))
				{	a->__sizeToken++;
					a->Token = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Token)
			soap_pop_block(soap, soap_blist_Token);
		if (a->__sizeToken)
		{	a->Token = (char **)soap_save_block(soap, soap_blist_Token, NULL, 1);
		}
		else
		{	a->Token = NULL;
			if (soap_blist_Token)
				soap_end_block(soap, soap_blist_Token);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeToken < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns7__GetSpecialDayGroups *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__GetSpecialDayGroups, SOAP_TYPE__ns7__GetSpecialDayGroups, sizeof(struct _ns7__GetSpecialDayGroups), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns7__GetSpecialDayGroups * SOAP_FMAC4 soap_new__ns7__GetSpecialDayGroups(struct soap *soap, int n)
{
	struct _ns7__GetSpecialDayGroups *p;
	struct _ns7__GetSpecialDayGroups *a = (struct _ns7__GetSpecialDayGroups*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns7__GetSpecialDayGroups));
	for (p = a; p && n--; p++)
		soap_default__ns7__GetSpecialDayGroups(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns7__GetSpecialDayGroups(struct soap *soap, const struct _ns7__GetSpecialDayGroups *a, const char *tag, const char *type)
{
	if (soap_out__ns7__GetSpecialDayGroups(soap, tag ? tag : "ns7:GetSpecialDayGroups", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns7__GetSpecialDayGroups * SOAP_FMAC4 soap_get__ns7__GetSpecialDayGroups(struct soap *soap, struct _ns7__GetSpecialDayGroups *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__GetSpecialDayGroups(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns7__GetSpecialDayGroupInfoListResponse(struct soap *soap, struct _ns7__GetSpecialDayGroupInfoListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->NextStartReference);
	a->__sizeSpecialDayGroupInfo = 0;
	a->SpecialDayGroupInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__GetSpecialDayGroupInfoListResponse(struct soap *soap, const struct _ns7__GetSpecialDayGroupInfoListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->NextStartReference);
	if (a->SpecialDayGroupInfo)
	{	int i;
		for (i = 0; i < (int)a->__sizeSpecialDayGroupInfo; i++)
		{
			soap_embedded(soap, a->SpecialDayGroupInfo + i, SOAP_TYPE_ns7__SpecialDayGroupInfo);
			soap_serialize_ns7__SpecialDayGroupInfo(soap, a->SpecialDayGroupInfo + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__GetSpecialDayGroupInfoListResponse(struct soap *soap, const char *tag, int id, const struct _ns7__GetSpecialDayGroupInfoListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__GetSpecialDayGroupInfoListResponse), type))
		return soap->error;
	if (a->NextStartReference)
		soap_element_result(soap, "ns7:NextStartReference");
	if (soap_out_string(soap, "ns7:NextStartReference", -1, (char*const*)&a->NextStartReference, ""))
		return soap->error;
	if (a->SpecialDayGroupInfo)
	{	int i;
		for (i = 0; i < (int)a->__sizeSpecialDayGroupInfo; i++)
			if (soap_out_ns7__SpecialDayGroupInfo(soap, "ns7:SpecialDayGroupInfo", -1, a->SpecialDayGroupInfo + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns7__GetSpecialDayGroupInfoListResponse * SOAP_FMAC4 soap_in__ns7__GetSpecialDayGroupInfoListResponse(struct soap *soap, const char *tag, struct _ns7__GetSpecialDayGroupInfoListResponse *a, const char *type)
{
	size_t soap_flag_NextStartReference = 1;
	struct soap_blist *soap_blist_SpecialDayGroupInfo = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns7__GetSpecialDayGroupInfoListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__GetSpecialDayGroupInfoListResponse, sizeof(struct _ns7__GetSpecialDayGroupInfoListResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns7__GetSpecialDayGroupInfoListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NextStartReference && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns7:NextStartReference", (char**)&a->NextStartReference, "xsd:string"))
				{	soap_flag_NextStartReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:SpecialDayGroupInfo", 1, NULL))
			{	if (a->SpecialDayGroupInfo == NULL)
				{	if (soap_blist_SpecialDayGroupInfo == NULL)
						soap_blist_SpecialDayGroupInfo = soap_alloc_block(soap);
					a->SpecialDayGroupInfo = (struct ns7__SpecialDayGroupInfo *)soap_push_block_max(soap, soap_blist_SpecialDayGroupInfo, sizeof(struct ns7__SpecialDayGroupInfo));
					if (a->SpecialDayGroupInfo == NULL)
						return NULL;
					soap_default_ns7__SpecialDayGroupInfo(soap, a->SpecialDayGroupInfo);
				}
				soap_revert(soap);
				if (soap_in_ns7__SpecialDayGroupInfo(soap, "ns7:SpecialDayGroupInfo", a->SpecialDayGroupInfo, "ns7:SpecialDayGroupInfo"))
				{	a->__sizeSpecialDayGroupInfo++;
					a->SpecialDayGroupInfo = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns7:NextStartReference");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SpecialDayGroupInfo)
			soap_pop_block(soap, soap_blist_SpecialDayGroupInfo);
		if (a->__sizeSpecialDayGroupInfo)
		{	a->SpecialDayGroupInfo = (struct ns7__SpecialDayGroupInfo *)soap_save_block(soap, soap_blist_SpecialDayGroupInfo, NULL, 1);
		}
		else
		{	a->SpecialDayGroupInfo = NULL;
			if (soap_blist_SpecialDayGroupInfo)
				soap_end_block(soap, soap_blist_SpecialDayGroupInfo);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns7__GetSpecialDayGroupInfoListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__GetSpecialDayGroupInfoListResponse, SOAP_TYPE__ns7__GetSpecialDayGroupInfoListResponse, sizeof(struct _ns7__GetSpecialDayGroupInfoListResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns7__GetSpecialDayGroupInfoListResponse * SOAP_FMAC4 soap_new__ns7__GetSpecialDayGroupInfoListResponse(struct soap *soap, int n)
{
	struct _ns7__GetSpecialDayGroupInfoListResponse *p;
	struct _ns7__GetSpecialDayGroupInfoListResponse *a = (struct _ns7__GetSpecialDayGroupInfoListResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns7__GetSpecialDayGroupInfoListResponse));
	for (p = a; p && n--; p++)
		soap_default__ns7__GetSpecialDayGroupInfoListResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns7__GetSpecialDayGroupInfoListResponse(struct soap *soap, const struct _ns7__GetSpecialDayGroupInfoListResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns7__GetSpecialDayGroupInfoListResponse(soap, tag ? tag : "ns7:GetSpecialDayGroupInfoListResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns7__GetSpecialDayGroupInfoListResponse * SOAP_FMAC4 soap_get__ns7__GetSpecialDayGroupInfoListResponse(struct soap *soap, struct _ns7__GetSpecialDayGroupInfoListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__GetSpecialDayGroupInfoListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns7__GetSpecialDayGroupInfoList(struct soap *soap, struct _ns7__GetSpecialDayGroupInfoList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Limit = NULL;
	soap_default_string(soap, &a->StartReference);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__GetSpecialDayGroupInfoList(struct soap *soap, const struct _ns7__GetSpecialDayGroupInfoList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->Limit);
	soap_serialize_string(soap, (char*const*)&a->StartReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__GetSpecialDayGroupInfoList(struct soap *soap, const char *tag, int id, const struct _ns7__GetSpecialDayGroupInfoList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__GetSpecialDayGroupInfoList), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns7:Limit", -1, &a->Limit, ""))
		return soap->error;
	if (soap_out_string(soap, "ns7:StartReference", -1, (char*const*)&a->StartReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns7__GetSpecialDayGroupInfoList * SOAP_FMAC4 soap_in__ns7__GetSpecialDayGroupInfoList(struct soap *soap, const char *tag, struct _ns7__GetSpecialDayGroupInfoList *a, const char *type)
{
	size_t soap_flag_Limit = 1;
	size_t soap_flag_StartReference = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns7__GetSpecialDayGroupInfoList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__GetSpecialDayGroupInfoList, sizeof(struct _ns7__GetSpecialDayGroupInfoList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns7__GetSpecialDayGroupInfoList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Limit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns7:Limit", &a->Limit, "xsd:int"))
				{	soap_flag_Limit--;
					continue;
				}
			if (soap_flag_StartReference && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns7:StartReference", (char**)&a->StartReference, "xsd:string"))
				{	soap_flag_StartReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns7__GetSpecialDayGroupInfoList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__GetSpecialDayGroupInfoList, SOAP_TYPE__ns7__GetSpecialDayGroupInfoList, sizeof(struct _ns7__GetSpecialDayGroupInfoList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns7__GetSpecialDayGroupInfoList * SOAP_FMAC4 soap_new__ns7__GetSpecialDayGroupInfoList(struct soap *soap, int n)
{
	struct _ns7__GetSpecialDayGroupInfoList *p;
	struct _ns7__GetSpecialDayGroupInfoList *a = (struct _ns7__GetSpecialDayGroupInfoList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns7__GetSpecialDayGroupInfoList));
	for (p = a; p && n--; p++)
		soap_default__ns7__GetSpecialDayGroupInfoList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns7__GetSpecialDayGroupInfoList(struct soap *soap, const struct _ns7__GetSpecialDayGroupInfoList *a, const char *tag, const char *type)
{
	if (soap_out__ns7__GetSpecialDayGroupInfoList(soap, tag ? tag : "ns7:GetSpecialDayGroupInfoList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns7__GetSpecialDayGroupInfoList * SOAP_FMAC4 soap_get__ns7__GetSpecialDayGroupInfoList(struct soap *soap, struct _ns7__GetSpecialDayGroupInfoList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__GetSpecialDayGroupInfoList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns7__SpecialDayGroupInfo(struct soap *soap, struct ns7__SpecialDayGroupInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->token);
	soap_default_ns2__Name(soap, &a->Name);
	soap_default_ns2__Description(soap, &a->Description);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns7__SpecialDayGroupInfo(struct soap *soap, const struct ns7__SpecialDayGroupInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__Name(soap, (char*const*)&a->Name);
	soap_serialize_ns2__Description(soap, (char*const*)&a->Description);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__SpecialDayGroupInfo(struct soap *soap, const char *tag, int id, const struct ns7__SpecialDayGroupInfo *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_ns2__ReferenceToken2s(soap, a->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__SpecialDayGroupInfo), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "ns7:Name"))
			return soap->error;
	}
	else
	if (soap_out_ns2__Name(soap, "ns7:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_ns2__Description(soap, "ns7:Description", -1, (char*const*)&a->Description, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns7__SpecialDayGroupInfo * SOAP_FMAC4 soap_in_ns7__SpecialDayGroupInfo(struct soap *soap, const char *tag, struct ns7__SpecialDayGroupInfo *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_Description = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns7__SpecialDayGroupInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__SpecialDayGroupInfo, sizeof(struct ns7__SpecialDayGroupInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns7__SpecialDayGroupInfo(soap, a);
	if (soap_s2ns2__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Name(soap, "ns7:Name", (char**)&a->Name, "ns2:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Description(soap, "ns7:Description", (char**)&a->Description, "ns2:Description"))
				{	soap_flag_Description--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns7__SpecialDayGroupInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__SpecialDayGroupInfo, SOAP_TYPE_ns7__SpecialDayGroupInfo, sizeof(struct ns7__SpecialDayGroupInfo), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns7__SpecialDayGroupInfo * SOAP_FMAC4 soap_new_ns7__SpecialDayGroupInfo(struct soap *soap, int n)
{
	struct ns7__SpecialDayGroupInfo *p;
	struct ns7__SpecialDayGroupInfo *a = (struct ns7__SpecialDayGroupInfo*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns7__SpecialDayGroupInfo));
	for (p = a; p && n--; p++)
		soap_default_ns7__SpecialDayGroupInfo(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns7__SpecialDayGroupInfo(struct soap *soap, const struct ns7__SpecialDayGroupInfo *a, const char *tag, const char *type)
{
	if (soap_out_ns7__SpecialDayGroupInfo(soap, tag ? tag : "ns7:SpecialDayGroupInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns7__SpecialDayGroupInfo * SOAP_FMAC4 soap_get_ns7__SpecialDayGroupInfo(struct soap *soap, struct ns7__SpecialDayGroupInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__SpecialDayGroupInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns7__GetSpecialDayGroupInfoResponse(struct soap *soap, struct _ns7__GetSpecialDayGroupInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeSpecialDayGroupInfo = 0;
	a->SpecialDayGroupInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__GetSpecialDayGroupInfoResponse(struct soap *soap, const struct _ns7__GetSpecialDayGroupInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->SpecialDayGroupInfo)
	{	int i;
		for (i = 0; i < (int)a->__sizeSpecialDayGroupInfo; i++)
		{
			soap_embedded(soap, a->SpecialDayGroupInfo + i, SOAP_TYPE_ns7__SpecialDayGroupInfo);
			soap_serialize_ns7__SpecialDayGroupInfo(soap, a->SpecialDayGroupInfo + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__GetSpecialDayGroupInfoResponse(struct soap *soap, const char *tag, int id, const struct _ns7__GetSpecialDayGroupInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__GetSpecialDayGroupInfoResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeSpecialDayGroupInfo");
	if (a->SpecialDayGroupInfo)
	{	int i;
		for (i = 0; i < (int)a->__sizeSpecialDayGroupInfo; i++)
			if (soap_out_ns7__SpecialDayGroupInfo(soap, "ns7:SpecialDayGroupInfo", -1, a->SpecialDayGroupInfo + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns7__GetSpecialDayGroupInfoResponse * SOAP_FMAC4 soap_in__ns7__GetSpecialDayGroupInfoResponse(struct soap *soap, const char *tag, struct _ns7__GetSpecialDayGroupInfoResponse *a, const char *type)
{
	struct soap_blist *soap_blist_SpecialDayGroupInfo = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns7__GetSpecialDayGroupInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__GetSpecialDayGroupInfoResponse, sizeof(struct _ns7__GetSpecialDayGroupInfoResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns7__GetSpecialDayGroupInfoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:SpecialDayGroupInfo", 1, NULL))
			{	if (a->SpecialDayGroupInfo == NULL)
				{	if (soap_blist_SpecialDayGroupInfo == NULL)
						soap_blist_SpecialDayGroupInfo = soap_alloc_block(soap);
					a->SpecialDayGroupInfo = (struct ns7__SpecialDayGroupInfo *)soap_push_block_max(soap, soap_blist_SpecialDayGroupInfo, sizeof(struct ns7__SpecialDayGroupInfo));
					if (a->SpecialDayGroupInfo == NULL)
						return NULL;
					soap_default_ns7__SpecialDayGroupInfo(soap, a->SpecialDayGroupInfo);
				}
				soap_revert(soap);
				if (soap_in_ns7__SpecialDayGroupInfo(soap, "ns7:SpecialDayGroupInfo", a->SpecialDayGroupInfo, "ns7:SpecialDayGroupInfo"))
				{	a->__sizeSpecialDayGroupInfo++;
					a->SpecialDayGroupInfo = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeSpecialDayGroupInfo");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SpecialDayGroupInfo)
			soap_pop_block(soap, soap_blist_SpecialDayGroupInfo);
		if (a->__sizeSpecialDayGroupInfo)
		{	a->SpecialDayGroupInfo = (struct ns7__SpecialDayGroupInfo *)soap_save_block(soap, soap_blist_SpecialDayGroupInfo, NULL, 1);
		}
		else
		{	a->SpecialDayGroupInfo = NULL;
			if (soap_blist_SpecialDayGroupInfo)
				soap_end_block(soap, soap_blist_SpecialDayGroupInfo);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns7__GetSpecialDayGroupInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__GetSpecialDayGroupInfoResponse, SOAP_TYPE__ns7__GetSpecialDayGroupInfoResponse, sizeof(struct _ns7__GetSpecialDayGroupInfoResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns7__GetSpecialDayGroupInfoResponse * SOAP_FMAC4 soap_new__ns7__GetSpecialDayGroupInfoResponse(struct soap *soap, int n)
{
	struct _ns7__GetSpecialDayGroupInfoResponse *p;
	struct _ns7__GetSpecialDayGroupInfoResponse *a = (struct _ns7__GetSpecialDayGroupInfoResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns7__GetSpecialDayGroupInfoResponse));
	for (p = a; p && n--; p++)
		soap_default__ns7__GetSpecialDayGroupInfoResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns7__GetSpecialDayGroupInfoResponse(struct soap *soap, const struct _ns7__GetSpecialDayGroupInfoResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns7__GetSpecialDayGroupInfoResponse(soap, tag ? tag : "ns7:GetSpecialDayGroupInfoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns7__GetSpecialDayGroupInfoResponse * SOAP_FMAC4 soap_get__ns7__GetSpecialDayGroupInfoResponse(struct soap *soap, struct _ns7__GetSpecialDayGroupInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__GetSpecialDayGroupInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns7__GetSpecialDayGroupInfo(struct soap *soap, struct _ns7__GetSpecialDayGroupInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeToken = 0;
	a->Token = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__GetSpecialDayGroupInfo(struct soap *soap, const struct _ns7__GetSpecialDayGroupInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Token)
	{	int i;
		for (i = 0; i < (int)a->__sizeToken; i++)
		{
			soap_serialize_ns2__ReferenceToken(soap, (char*const*)(a->Token + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__GetSpecialDayGroupInfo(struct soap *soap, const char *tag, int id, const struct _ns7__GetSpecialDayGroupInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__GetSpecialDayGroupInfo), type))
		return soap->error;
	if (a->Token)
	{	int i;
		for (i = 0; i < (int)a->__sizeToken; i++)
			soap_out_string(soap, "ns7:Token", -1, (char*const*)(a->Token + i), "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns7__GetSpecialDayGroupInfo * SOAP_FMAC4 soap_in__ns7__GetSpecialDayGroupInfo(struct soap *soap, const char *tag, struct _ns7__GetSpecialDayGroupInfo *a, const char *type)
{
	struct soap_blist *soap_blist_Token = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns7__GetSpecialDayGroupInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__GetSpecialDayGroupInfo, sizeof(struct _ns7__GetSpecialDayGroupInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns7__GetSpecialDayGroupInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:Token", 1, NULL))
			{	if (a->Token == NULL)
				{	if (soap_blist_Token == NULL)
						soap_blist_Token = soap_alloc_block(soap);
					a->Token = (char **)soap_push_block_max(soap, soap_blist_Token, sizeof(char *));
					if (a->Token == NULL)
						return NULL;
					*a->Token = NULL;
				}
				soap_revert(soap);
				if (soap_in_ns2__ReferenceToken(soap, "ns7:Token", (char**)a->Token, "ns2:ReferenceToken"))
				{	a->__sizeToken++;
					a->Token = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Token)
			soap_pop_block(soap, soap_blist_Token);
		if (a->__sizeToken)
		{	a->Token = (char **)soap_save_block(soap, soap_blist_Token, NULL, 1);
		}
		else
		{	a->Token = NULL;
			if (soap_blist_Token)
				soap_end_block(soap, soap_blist_Token);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeToken < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns7__GetSpecialDayGroupInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__GetSpecialDayGroupInfo, SOAP_TYPE__ns7__GetSpecialDayGroupInfo, sizeof(struct _ns7__GetSpecialDayGroupInfo), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns7__GetSpecialDayGroupInfo * SOAP_FMAC4 soap_new__ns7__GetSpecialDayGroupInfo(struct soap *soap, int n)
{
	struct _ns7__GetSpecialDayGroupInfo *p;
	struct _ns7__GetSpecialDayGroupInfo *a = (struct _ns7__GetSpecialDayGroupInfo*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns7__GetSpecialDayGroupInfo));
	for (p = a; p && n--; p++)
		soap_default__ns7__GetSpecialDayGroupInfo(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns7__GetSpecialDayGroupInfo(struct soap *soap, const struct _ns7__GetSpecialDayGroupInfo *a, const char *tag, const char *type)
{
	if (soap_out__ns7__GetSpecialDayGroupInfo(soap, tag ? tag : "ns7:GetSpecialDayGroupInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns7__GetSpecialDayGroupInfo * SOAP_FMAC4 soap_get__ns7__GetSpecialDayGroupInfo(struct soap *soap, struct _ns7__GetSpecialDayGroupInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__GetSpecialDayGroupInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns7__DeleteScheduleResponse(struct soap *soap, struct _ns7__DeleteScheduleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__DeleteScheduleResponse(struct soap *soap, const struct _ns7__DeleteScheduleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__DeleteScheduleResponse(struct soap *soap, const char *tag, int id, const struct _ns7__DeleteScheduleResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__DeleteScheduleResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns7__DeleteScheduleResponse * SOAP_FMAC4 soap_in__ns7__DeleteScheduleResponse(struct soap *soap, const char *tag, struct _ns7__DeleteScheduleResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns7__DeleteScheduleResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__DeleteScheduleResponse, sizeof(struct _ns7__DeleteScheduleResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns7__DeleteScheduleResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns7__DeleteScheduleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__DeleteScheduleResponse, SOAP_TYPE__ns7__DeleteScheduleResponse, sizeof(struct _ns7__DeleteScheduleResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns7__DeleteScheduleResponse * SOAP_FMAC4 soap_new__ns7__DeleteScheduleResponse(struct soap *soap, int n)
{
	struct _ns7__DeleteScheduleResponse *p;
	struct _ns7__DeleteScheduleResponse *a = (struct _ns7__DeleteScheduleResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns7__DeleteScheduleResponse));
	for (p = a; p && n--; p++)
		soap_default__ns7__DeleteScheduleResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns7__DeleteScheduleResponse(struct soap *soap, const struct _ns7__DeleteScheduleResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns7__DeleteScheduleResponse(soap, tag ? tag : "ns7:DeleteScheduleResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns7__DeleteScheduleResponse * SOAP_FMAC4 soap_get__ns7__DeleteScheduleResponse(struct soap *soap, struct _ns7__DeleteScheduleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__DeleteScheduleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns7__DeleteSchedule(struct soap *soap, struct _ns7__DeleteSchedule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__DeleteSchedule(struct soap *soap, const struct _ns7__DeleteSchedule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__ReferenceToken(soap, (char*const*)&a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__DeleteSchedule(struct soap *soap, const char *tag, int id, const struct _ns7__DeleteSchedule *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__DeleteSchedule), type))
		return soap->error;
	if (!a->Token)
	{	if (soap_element_nil(soap, "ns7:Token"))
			return soap->error;
	}
	else
	if (soap_out_ns2__ReferenceToken(soap, "ns7:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns7__DeleteSchedule * SOAP_FMAC4 soap_in__ns7__DeleteSchedule(struct soap *soap, const char *tag, struct _ns7__DeleteSchedule *a, const char *type)
{
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns7__DeleteSchedule *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__DeleteSchedule, sizeof(struct _ns7__DeleteSchedule), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns7__DeleteSchedule(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns7:Token", (char**)&a->Token, "ns2:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns7__DeleteSchedule *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__DeleteSchedule, SOAP_TYPE__ns7__DeleteSchedule, sizeof(struct _ns7__DeleteSchedule), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns7__DeleteSchedule * SOAP_FMAC4 soap_new__ns7__DeleteSchedule(struct soap *soap, int n)
{
	struct _ns7__DeleteSchedule *p;
	struct _ns7__DeleteSchedule *a = (struct _ns7__DeleteSchedule*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns7__DeleteSchedule));
	for (p = a; p && n--; p++)
		soap_default__ns7__DeleteSchedule(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns7__DeleteSchedule(struct soap *soap, const struct _ns7__DeleteSchedule *a, const char *tag, const char *type)
{
	if (soap_out__ns7__DeleteSchedule(soap, tag ? tag : "ns7:DeleteSchedule", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns7__DeleteSchedule * SOAP_FMAC4 soap_get__ns7__DeleteSchedule(struct soap *soap, struct _ns7__DeleteSchedule *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__DeleteSchedule(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns7__ModifyScheduleResponse(struct soap *soap, struct _ns7__ModifyScheduleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__ModifyScheduleResponse(struct soap *soap, const struct _ns7__ModifyScheduleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__ModifyScheduleResponse(struct soap *soap, const char *tag, int id, const struct _ns7__ModifyScheduleResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__ModifyScheduleResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns7__ModifyScheduleResponse * SOAP_FMAC4 soap_in__ns7__ModifyScheduleResponse(struct soap *soap, const char *tag, struct _ns7__ModifyScheduleResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns7__ModifyScheduleResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__ModifyScheduleResponse, sizeof(struct _ns7__ModifyScheduleResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns7__ModifyScheduleResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns7__ModifyScheduleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__ModifyScheduleResponse, SOAP_TYPE__ns7__ModifyScheduleResponse, sizeof(struct _ns7__ModifyScheduleResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns7__ModifyScheduleResponse * SOAP_FMAC4 soap_new__ns7__ModifyScheduleResponse(struct soap *soap, int n)
{
	struct _ns7__ModifyScheduleResponse *p;
	struct _ns7__ModifyScheduleResponse *a = (struct _ns7__ModifyScheduleResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns7__ModifyScheduleResponse));
	for (p = a; p && n--; p++)
		soap_default__ns7__ModifyScheduleResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns7__ModifyScheduleResponse(struct soap *soap, const struct _ns7__ModifyScheduleResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns7__ModifyScheduleResponse(soap, tag ? tag : "ns7:ModifyScheduleResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns7__ModifyScheduleResponse * SOAP_FMAC4 soap_get__ns7__ModifyScheduleResponse(struct soap *soap, struct _ns7__ModifyScheduleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__ModifyScheduleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns7__ModifySchedule(struct soap *soap, struct _ns7__ModifySchedule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Schedule = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__ModifySchedule(struct soap *soap, const struct _ns7__ModifySchedule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons7__Schedule(soap, &a->Schedule);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__ModifySchedule(struct soap *soap, const char *tag, int id, const struct _ns7__ModifySchedule *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__ModifySchedule), type))
		return soap->error;
	if (!a->Schedule)
	{	if (soap_element_nil(soap, "ns7:Schedule"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__Schedule(soap, "ns7:Schedule", -1, &a->Schedule, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns7__ModifySchedule * SOAP_FMAC4 soap_in__ns7__ModifySchedule(struct soap *soap, const char *tag, struct _ns7__ModifySchedule *a, const char *type)
{
	size_t soap_flag_Schedule = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns7__ModifySchedule *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__ModifySchedule, sizeof(struct _ns7__ModifySchedule), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns7__ModifySchedule(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Schedule && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons7__Schedule(soap, "ns7:Schedule", &a->Schedule, "ns7:Schedule"))
				{	soap_flag_Schedule--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Schedule > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns7__ModifySchedule *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__ModifySchedule, SOAP_TYPE__ns7__ModifySchedule, sizeof(struct _ns7__ModifySchedule), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns7__ModifySchedule * SOAP_FMAC4 soap_new__ns7__ModifySchedule(struct soap *soap, int n)
{
	struct _ns7__ModifySchedule *p;
	struct _ns7__ModifySchedule *a = (struct _ns7__ModifySchedule*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns7__ModifySchedule));
	for (p = a; p && n--; p++)
		soap_default__ns7__ModifySchedule(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns7__ModifySchedule(struct soap *soap, const struct _ns7__ModifySchedule *a, const char *tag, const char *type)
{
	if (soap_out__ns7__ModifySchedule(soap, tag ? tag : "ns7:ModifySchedule", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns7__ModifySchedule * SOAP_FMAC4 soap_get__ns7__ModifySchedule(struct soap *soap, struct _ns7__ModifySchedule *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__ModifySchedule(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns7__CreateScheduleResponse(struct soap *soap, struct _ns7__CreateScheduleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__CreateScheduleResponse(struct soap *soap, const struct _ns7__CreateScheduleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__ReferenceToken(soap, (char*const*)&a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__CreateScheduleResponse(struct soap *soap, const char *tag, int id, const struct _ns7__CreateScheduleResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__CreateScheduleResponse), type))
		return soap->error;
	if (a->Token)
		soap_element_result(soap, "ns7:Token");
	if (!a->Token)
	{	if (soap_element_nil(soap, "ns7:Token"))
			return soap->error;
	}
	else
	if (soap_out_ns2__ReferenceToken(soap, "ns7:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns7__CreateScheduleResponse * SOAP_FMAC4 soap_in__ns7__CreateScheduleResponse(struct soap *soap, const char *tag, struct _ns7__CreateScheduleResponse *a, const char *type)
{
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns7__CreateScheduleResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__CreateScheduleResponse, sizeof(struct _ns7__CreateScheduleResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns7__CreateScheduleResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns7:Token", (char**)&a->Token, "ns2:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			soap_check_result(soap, "ns7:Token");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns7__CreateScheduleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__CreateScheduleResponse, SOAP_TYPE__ns7__CreateScheduleResponse, sizeof(struct _ns7__CreateScheduleResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns7__CreateScheduleResponse * SOAP_FMAC4 soap_new__ns7__CreateScheduleResponse(struct soap *soap, int n)
{
	struct _ns7__CreateScheduleResponse *p;
	struct _ns7__CreateScheduleResponse *a = (struct _ns7__CreateScheduleResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns7__CreateScheduleResponse));
	for (p = a; p && n--; p++)
		soap_default__ns7__CreateScheduleResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns7__CreateScheduleResponse(struct soap *soap, const struct _ns7__CreateScheduleResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns7__CreateScheduleResponse(soap, tag ? tag : "ns7:CreateScheduleResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns7__CreateScheduleResponse * SOAP_FMAC4 soap_get__ns7__CreateScheduleResponse(struct soap *soap, struct _ns7__CreateScheduleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__CreateScheduleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns7__CreateSchedule(struct soap *soap, struct _ns7__CreateSchedule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Schedule = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__CreateSchedule(struct soap *soap, const struct _ns7__CreateSchedule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons7__Schedule(soap, &a->Schedule);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__CreateSchedule(struct soap *soap, const char *tag, int id, const struct _ns7__CreateSchedule *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__CreateSchedule), type))
		return soap->error;
	if (!a->Schedule)
	{	if (soap_element_nil(soap, "ns7:Schedule"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__Schedule(soap, "ns7:Schedule", -1, &a->Schedule, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns7__CreateSchedule * SOAP_FMAC4 soap_in__ns7__CreateSchedule(struct soap *soap, const char *tag, struct _ns7__CreateSchedule *a, const char *type)
{
	size_t soap_flag_Schedule = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns7__CreateSchedule *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__CreateSchedule, sizeof(struct _ns7__CreateSchedule), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns7__CreateSchedule(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Schedule && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons7__Schedule(soap, "ns7:Schedule", &a->Schedule, "ns7:Schedule"))
				{	soap_flag_Schedule--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Schedule > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns7__CreateSchedule *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__CreateSchedule, SOAP_TYPE__ns7__CreateSchedule, sizeof(struct _ns7__CreateSchedule), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns7__CreateSchedule * SOAP_FMAC4 soap_new__ns7__CreateSchedule(struct soap *soap, int n)
{
	struct _ns7__CreateSchedule *p;
	struct _ns7__CreateSchedule *a = (struct _ns7__CreateSchedule*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns7__CreateSchedule));
	for (p = a; p && n--; p++)
		soap_default__ns7__CreateSchedule(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns7__CreateSchedule(struct soap *soap, const struct _ns7__CreateSchedule *a, const char *tag, const char *type)
{
	if (soap_out__ns7__CreateSchedule(soap, tag ? tag : "ns7:CreateSchedule", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns7__CreateSchedule * SOAP_FMAC4 soap_get__ns7__CreateSchedule(struct soap *soap, struct _ns7__CreateSchedule *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__CreateSchedule(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns7__GetScheduleListResponse(struct soap *soap, struct _ns7__GetScheduleListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->NextStartReference);
	a->__sizeSchedule = 0;
	a->Schedule = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__GetScheduleListResponse(struct soap *soap, const struct _ns7__GetScheduleListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->NextStartReference);
	if (a->Schedule)
	{	int i;
		for (i = 0; i < (int)a->__sizeSchedule; i++)
		{
			soap_embedded(soap, a->Schedule + i, SOAP_TYPE_ns7__Schedule);
			soap_serialize_ns7__Schedule(soap, a->Schedule + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__GetScheduleListResponse(struct soap *soap, const char *tag, int id, const struct _ns7__GetScheduleListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__GetScheduleListResponse), type))
		return soap->error;
	if (a->NextStartReference)
		soap_element_result(soap, "ns7:NextStartReference");
	if (soap_out_string(soap, "ns7:NextStartReference", -1, (char*const*)&a->NextStartReference, ""))
		return soap->error;
	if (a->Schedule)
	{	int i;
		for (i = 0; i < (int)a->__sizeSchedule; i++)
			if (soap_out_ns7__Schedule(soap, "ns7:Schedule", -1, a->Schedule + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns7__GetScheduleListResponse * SOAP_FMAC4 soap_in__ns7__GetScheduleListResponse(struct soap *soap, const char *tag, struct _ns7__GetScheduleListResponse *a, const char *type)
{
	size_t soap_flag_NextStartReference = 1;
	struct soap_blist *soap_blist_Schedule = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns7__GetScheduleListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__GetScheduleListResponse, sizeof(struct _ns7__GetScheduleListResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns7__GetScheduleListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NextStartReference && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns7:NextStartReference", (char**)&a->NextStartReference, "xsd:string"))
				{	soap_flag_NextStartReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:Schedule", 1, NULL))
			{	if (a->Schedule == NULL)
				{	if (soap_blist_Schedule == NULL)
						soap_blist_Schedule = soap_alloc_block(soap);
					a->Schedule = (struct ns7__Schedule *)soap_push_block_max(soap, soap_blist_Schedule, sizeof(struct ns7__Schedule));
					if (a->Schedule == NULL)
						return NULL;
					soap_default_ns7__Schedule(soap, a->Schedule);
				}
				soap_revert(soap);
				if (soap_in_ns7__Schedule(soap, "ns7:Schedule", a->Schedule, "ns7:Schedule"))
				{	a->__sizeSchedule++;
					a->Schedule = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns7:NextStartReference");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Schedule)
			soap_pop_block(soap, soap_blist_Schedule);
		if (a->__sizeSchedule)
		{	a->Schedule = (struct ns7__Schedule *)soap_save_block(soap, soap_blist_Schedule, NULL, 1);
		}
		else
		{	a->Schedule = NULL;
			if (soap_blist_Schedule)
				soap_end_block(soap, soap_blist_Schedule);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns7__GetScheduleListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__GetScheduleListResponse, SOAP_TYPE__ns7__GetScheduleListResponse, sizeof(struct _ns7__GetScheduleListResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns7__GetScheduleListResponse * SOAP_FMAC4 soap_new__ns7__GetScheduleListResponse(struct soap *soap, int n)
{
	struct _ns7__GetScheduleListResponse *p;
	struct _ns7__GetScheduleListResponse *a = (struct _ns7__GetScheduleListResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns7__GetScheduleListResponse));
	for (p = a; p && n--; p++)
		soap_default__ns7__GetScheduleListResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns7__GetScheduleListResponse(struct soap *soap, const struct _ns7__GetScheduleListResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns7__GetScheduleListResponse(soap, tag ? tag : "ns7:GetScheduleListResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns7__GetScheduleListResponse * SOAP_FMAC4 soap_get__ns7__GetScheduleListResponse(struct soap *soap, struct _ns7__GetScheduleListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__GetScheduleListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns7__GetScheduleList(struct soap *soap, struct _ns7__GetScheduleList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Limit = NULL;
	soap_default_string(soap, &a->StartReference);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__GetScheduleList(struct soap *soap, const struct _ns7__GetScheduleList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->Limit);
	soap_serialize_string(soap, (char*const*)&a->StartReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__GetScheduleList(struct soap *soap, const char *tag, int id, const struct _ns7__GetScheduleList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__GetScheduleList), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns7:Limit", -1, &a->Limit, ""))
		return soap->error;
	if (soap_out_string(soap, "ns7:StartReference", -1, (char*const*)&a->StartReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns7__GetScheduleList * SOAP_FMAC4 soap_in__ns7__GetScheduleList(struct soap *soap, const char *tag, struct _ns7__GetScheduleList *a, const char *type)
{
	size_t soap_flag_Limit = 1;
	size_t soap_flag_StartReference = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns7__GetScheduleList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__GetScheduleList, sizeof(struct _ns7__GetScheduleList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns7__GetScheduleList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Limit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns7:Limit", &a->Limit, "xsd:int"))
				{	soap_flag_Limit--;
					continue;
				}
			if (soap_flag_StartReference && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns7:StartReference", (char**)&a->StartReference, "xsd:string"))
				{	soap_flag_StartReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns7__GetScheduleList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__GetScheduleList, SOAP_TYPE__ns7__GetScheduleList, sizeof(struct _ns7__GetScheduleList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns7__GetScheduleList * SOAP_FMAC4 soap_new__ns7__GetScheduleList(struct soap *soap, int n)
{
	struct _ns7__GetScheduleList *p;
	struct _ns7__GetScheduleList *a = (struct _ns7__GetScheduleList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns7__GetScheduleList));
	for (p = a; p && n--; p++)
		soap_default__ns7__GetScheduleList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns7__GetScheduleList(struct soap *soap, const struct _ns7__GetScheduleList *a, const char *tag, const char *type)
{
	if (soap_out__ns7__GetScheduleList(soap, tag ? tag : "ns7:GetScheduleList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns7__GetScheduleList * SOAP_FMAC4 soap_get__ns7__GetScheduleList(struct soap *soap, struct _ns7__GetScheduleList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__GetScheduleList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns7__Schedule(struct soap *soap, struct ns7__Schedule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->token);
	soap_default_ns2__Name(soap, &a->Name);
	soap_default_ns2__Description(soap, &a->Description);
	soap_default_string(soap, &a->Standard);
	a->__sizeSpecialDays = 0;
	a->SpecialDays = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns7__Schedule(struct soap *soap, const struct ns7__Schedule *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__Name(soap, (char*const*)&a->Name);
	soap_serialize_ns2__Description(soap, (char*const*)&a->Description);
	soap_serialize_string(soap, (char*const*)&a->Standard);
	if (a->SpecialDays)
	{	int i;
		for (i = 0; i < (int)a->__sizeSpecialDays; i++)
		{
			soap_embedded(soap, a->SpecialDays + i, SOAP_TYPE_ns7__SpecialDaysSchedule);
			soap_serialize_ns7__SpecialDaysSchedule(soap, a->SpecialDays + i);
		}
	}
	soap_serialize_PointerTons7__ScheduleExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__Schedule(struct soap *soap, const char *tag, int id, const struct ns7__Schedule *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_ns2__ReferenceToken2s(soap, a->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__Schedule), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "ns7:Name"))
			return soap->error;
	}
	else
	if (soap_out_ns2__Name(soap, "ns7:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_ns2__Description(soap, "ns7:Description", -1, (char*const*)&a->Description, ""))
		return soap->error;
	if (!a->Standard)
	{	if (soap_element_nil(soap, "ns7:Standard"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "ns7:Standard", -1, (char*const*)&a->Standard, ""))
		return soap->error;
	if (a->SpecialDays)
	{	int i;
		for (i = 0; i < (int)a->__sizeSpecialDays; i++)
			if (soap_out_ns7__SpecialDaysSchedule(soap, "ns7:SpecialDays", -1, a->SpecialDays + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons7__ScheduleExtension(soap, "ns7:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns7__Schedule * SOAP_FMAC4 soap_in_ns7__Schedule(struct soap *soap, const char *tag, struct ns7__Schedule *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_Description = 1;
	size_t soap_flag_Standard = 1;
	struct soap_blist *soap_blist_SpecialDays = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns7__Schedule *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__Schedule, sizeof(struct ns7__Schedule), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns7__Schedule(soap, a);
	if (soap_s2ns2__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Name(soap, "ns7:Name", (char**)&a->Name, "ns2:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Description(soap, "ns7:Description", (char**)&a->Description, "ns2:Description"))
				{	soap_flag_Description--;
					continue;
				}
			if (soap_flag_Standard && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns7:Standard", (char**)&a->Standard, "xsd:string"))
				{	soap_flag_Standard--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:SpecialDays", 1, NULL))
			{	if (a->SpecialDays == NULL)
				{	if (soap_blist_SpecialDays == NULL)
						soap_blist_SpecialDays = soap_alloc_block(soap);
					a->SpecialDays = (struct ns7__SpecialDaysSchedule *)soap_push_block_max(soap, soap_blist_SpecialDays, sizeof(struct ns7__SpecialDaysSchedule));
					if (a->SpecialDays == NULL)
						return NULL;
					soap_default_ns7__SpecialDaysSchedule(soap, a->SpecialDays);
				}
				soap_revert(soap);
				if (soap_in_ns7__SpecialDaysSchedule(soap, "ns7:SpecialDays", a->SpecialDays, "ns7:SpecialDaysSchedule"))
				{	a->__sizeSpecialDays++;
					a->SpecialDays = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons7__ScheduleExtension(soap, "ns7:Extension", &a->Extension, "ns7:ScheduleExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SpecialDays)
			soap_pop_block(soap, soap_blist_SpecialDays);
		if (a->__sizeSpecialDays)
		{	a->SpecialDays = (struct ns7__SpecialDaysSchedule *)soap_save_block(soap, soap_blist_SpecialDays, NULL, 1);
		}
		else
		{	a->SpecialDays = NULL;
			if (soap_blist_SpecialDays)
				soap_end_block(soap, soap_blist_SpecialDays);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_Standard > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns7__Schedule *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__Schedule, SOAP_TYPE_ns7__Schedule, sizeof(struct ns7__Schedule), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns7__Schedule * SOAP_FMAC4 soap_new_ns7__Schedule(struct soap *soap, int n)
{
	struct ns7__Schedule *p;
	struct ns7__Schedule *a = (struct ns7__Schedule*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns7__Schedule));
	for (p = a; p && n--; p++)
		soap_default_ns7__Schedule(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns7__Schedule(struct soap *soap, const struct ns7__Schedule *a, const char *tag, const char *type)
{
	if (soap_out_ns7__Schedule(soap, tag ? tag : "ns7:Schedule", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns7__Schedule * SOAP_FMAC4 soap_get_ns7__Schedule(struct soap *soap, struct ns7__Schedule *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__Schedule(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns7__GetSchedulesResponse(struct soap *soap, struct _ns7__GetSchedulesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeSchedule = 0;
	a->Schedule = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__GetSchedulesResponse(struct soap *soap, const struct _ns7__GetSchedulesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Schedule)
	{	int i;
		for (i = 0; i < (int)a->__sizeSchedule; i++)
		{
			soap_embedded(soap, a->Schedule + i, SOAP_TYPE_ns7__Schedule);
			soap_serialize_ns7__Schedule(soap, a->Schedule + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__GetSchedulesResponse(struct soap *soap, const char *tag, int id, const struct _ns7__GetSchedulesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__GetSchedulesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeSchedule");
	if (a->Schedule)
	{	int i;
		for (i = 0; i < (int)a->__sizeSchedule; i++)
			if (soap_out_ns7__Schedule(soap, "ns7:Schedule", -1, a->Schedule + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns7__GetSchedulesResponse * SOAP_FMAC4 soap_in__ns7__GetSchedulesResponse(struct soap *soap, const char *tag, struct _ns7__GetSchedulesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Schedule = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns7__GetSchedulesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__GetSchedulesResponse, sizeof(struct _ns7__GetSchedulesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns7__GetSchedulesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:Schedule", 1, NULL))
			{	if (a->Schedule == NULL)
				{	if (soap_blist_Schedule == NULL)
						soap_blist_Schedule = soap_alloc_block(soap);
					a->Schedule = (struct ns7__Schedule *)soap_push_block_max(soap, soap_blist_Schedule, sizeof(struct ns7__Schedule));
					if (a->Schedule == NULL)
						return NULL;
					soap_default_ns7__Schedule(soap, a->Schedule);
				}
				soap_revert(soap);
				if (soap_in_ns7__Schedule(soap, "ns7:Schedule", a->Schedule, "ns7:Schedule"))
				{	a->__sizeSchedule++;
					a->Schedule = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeSchedule");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Schedule)
			soap_pop_block(soap, soap_blist_Schedule);
		if (a->__sizeSchedule)
		{	a->Schedule = (struct ns7__Schedule *)soap_save_block(soap, soap_blist_Schedule, NULL, 1);
		}
		else
		{	a->Schedule = NULL;
			if (soap_blist_Schedule)
				soap_end_block(soap, soap_blist_Schedule);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns7__GetSchedulesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__GetSchedulesResponse, SOAP_TYPE__ns7__GetSchedulesResponse, sizeof(struct _ns7__GetSchedulesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns7__GetSchedulesResponse * SOAP_FMAC4 soap_new__ns7__GetSchedulesResponse(struct soap *soap, int n)
{
	struct _ns7__GetSchedulesResponse *p;
	struct _ns7__GetSchedulesResponse *a = (struct _ns7__GetSchedulesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns7__GetSchedulesResponse));
	for (p = a; p && n--; p++)
		soap_default__ns7__GetSchedulesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns7__GetSchedulesResponse(struct soap *soap, const struct _ns7__GetSchedulesResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns7__GetSchedulesResponse(soap, tag ? tag : "ns7:GetSchedulesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns7__GetSchedulesResponse * SOAP_FMAC4 soap_get__ns7__GetSchedulesResponse(struct soap *soap, struct _ns7__GetSchedulesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__GetSchedulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns7__GetSchedules(struct soap *soap, struct _ns7__GetSchedules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeToken = 0;
	a->Token = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__GetSchedules(struct soap *soap, const struct _ns7__GetSchedules *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Token)
	{	int i;
		for (i = 0; i < (int)a->__sizeToken; i++)
		{
			soap_serialize_ns2__ReferenceToken(soap, (char*const*)(a->Token + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__GetSchedules(struct soap *soap, const char *tag, int id, const struct _ns7__GetSchedules *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__GetSchedules), type))
		return soap->error;
	if (a->Token)
	{	int i;
		for (i = 0; i < (int)a->__sizeToken; i++)
			soap_out_string(soap, "ns7:Token", -1, (char*const*)(a->Token + i), "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns7__GetSchedules * SOAP_FMAC4 soap_in__ns7__GetSchedules(struct soap *soap, const char *tag, struct _ns7__GetSchedules *a, const char *type)
{
	struct soap_blist *soap_blist_Token = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns7__GetSchedules *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__GetSchedules, sizeof(struct _ns7__GetSchedules), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns7__GetSchedules(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:Token", 1, NULL))
			{	if (a->Token == NULL)
				{	if (soap_blist_Token == NULL)
						soap_blist_Token = soap_alloc_block(soap);
					a->Token = (char **)soap_push_block_max(soap, soap_blist_Token, sizeof(char *));
					if (a->Token == NULL)
						return NULL;
					*a->Token = NULL;
				}
				soap_revert(soap);
				if (soap_in_ns2__ReferenceToken(soap, "ns7:Token", (char**)a->Token, "ns2:ReferenceToken"))
				{	a->__sizeToken++;
					a->Token = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Token)
			soap_pop_block(soap, soap_blist_Token);
		if (a->__sizeToken)
		{	a->Token = (char **)soap_save_block(soap, soap_blist_Token, NULL, 1);
		}
		else
		{	a->Token = NULL;
			if (soap_blist_Token)
				soap_end_block(soap, soap_blist_Token);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeToken < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns7__GetSchedules *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__GetSchedules, SOAP_TYPE__ns7__GetSchedules, sizeof(struct _ns7__GetSchedules), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns7__GetSchedules * SOAP_FMAC4 soap_new__ns7__GetSchedules(struct soap *soap, int n)
{
	struct _ns7__GetSchedules *p;
	struct _ns7__GetSchedules *a = (struct _ns7__GetSchedules*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns7__GetSchedules));
	for (p = a; p && n--; p++)
		soap_default__ns7__GetSchedules(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns7__GetSchedules(struct soap *soap, const struct _ns7__GetSchedules *a, const char *tag, const char *type)
{
	if (soap_out__ns7__GetSchedules(soap, tag ? tag : "ns7:GetSchedules", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns7__GetSchedules * SOAP_FMAC4 soap_get__ns7__GetSchedules(struct soap *soap, struct _ns7__GetSchedules *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__GetSchedules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns7__GetScheduleInfoListResponse(struct soap *soap, struct _ns7__GetScheduleInfoListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->NextStartReference);
	a->__sizeScheduleInfo = 0;
	a->ScheduleInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__GetScheduleInfoListResponse(struct soap *soap, const struct _ns7__GetScheduleInfoListResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->NextStartReference);
	if (a->ScheduleInfo)
	{	int i;
		for (i = 0; i < (int)a->__sizeScheduleInfo; i++)
		{
			soap_embedded(soap, a->ScheduleInfo + i, SOAP_TYPE_ns7__ScheduleInfo);
			soap_serialize_ns7__ScheduleInfo(soap, a->ScheduleInfo + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__GetScheduleInfoListResponse(struct soap *soap, const char *tag, int id, const struct _ns7__GetScheduleInfoListResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__GetScheduleInfoListResponse), type))
		return soap->error;
	if (a->NextStartReference)
		soap_element_result(soap, "ns7:NextStartReference");
	if (soap_out_string(soap, "ns7:NextStartReference", -1, (char*const*)&a->NextStartReference, ""))
		return soap->error;
	if (a->ScheduleInfo)
	{	int i;
		for (i = 0; i < (int)a->__sizeScheduleInfo; i++)
			if (soap_out_ns7__ScheduleInfo(soap, "ns7:ScheduleInfo", -1, a->ScheduleInfo + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns7__GetScheduleInfoListResponse * SOAP_FMAC4 soap_in__ns7__GetScheduleInfoListResponse(struct soap *soap, const char *tag, struct _ns7__GetScheduleInfoListResponse *a, const char *type)
{
	size_t soap_flag_NextStartReference = 1;
	struct soap_blist *soap_blist_ScheduleInfo = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns7__GetScheduleInfoListResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__GetScheduleInfoListResponse, sizeof(struct _ns7__GetScheduleInfoListResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns7__GetScheduleInfoListResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NextStartReference && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns7:NextStartReference", (char**)&a->NextStartReference, "xsd:string"))
				{	soap_flag_NextStartReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:ScheduleInfo", 1, NULL))
			{	if (a->ScheduleInfo == NULL)
				{	if (soap_blist_ScheduleInfo == NULL)
						soap_blist_ScheduleInfo = soap_alloc_block(soap);
					a->ScheduleInfo = (struct ns7__ScheduleInfo *)soap_push_block_max(soap, soap_blist_ScheduleInfo, sizeof(struct ns7__ScheduleInfo));
					if (a->ScheduleInfo == NULL)
						return NULL;
					soap_default_ns7__ScheduleInfo(soap, a->ScheduleInfo);
				}
				soap_revert(soap);
				if (soap_in_ns7__ScheduleInfo(soap, "ns7:ScheduleInfo", a->ScheduleInfo, "ns7:ScheduleInfo"))
				{	a->__sizeScheduleInfo++;
					a->ScheduleInfo = NULL;
					continue;
				}
			}
			soap_check_result(soap, "ns7:NextStartReference");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ScheduleInfo)
			soap_pop_block(soap, soap_blist_ScheduleInfo);
		if (a->__sizeScheduleInfo)
		{	a->ScheduleInfo = (struct ns7__ScheduleInfo *)soap_save_block(soap, soap_blist_ScheduleInfo, NULL, 1);
		}
		else
		{	a->ScheduleInfo = NULL;
			if (soap_blist_ScheduleInfo)
				soap_end_block(soap, soap_blist_ScheduleInfo);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns7__GetScheduleInfoListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__GetScheduleInfoListResponse, SOAP_TYPE__ns7__GetScheduleInfoListResponse, sizeof(struct _ns7__GetScheduleInfoListResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns7__GetScheduleInfoListResponse * SOAP_FMAC4 soap_new__ns7__GetScheduleInfoListResponse(struct soap *soap, int n)
{
	struct _ns7__GetScheduleInfoListResponse *p;
	struct _ns7__GetScheduleInfoListResponse *a = (struct _ns7__GetScheduleInfoListResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns7__GetScheduleInfoListResponse));
	for (p = a; p && n--; p++)
		soap_default__ns7__GetScheduleInfoListResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns7__GetScheduleInfoListResponse(struct soap *soap, const struct _ns7__GetScheduleInfoListResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns7__GetScheduleInfoListResponse(soap, tag ? tag : "ns7:GetScheduleInfoListResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns7__GetScheduleInfoListResponse * SOAP_FMAC4 soap_get__ns7__GetScheduleInfoListResponse(struct soap *soap, struct _ns7__GetScheduleInfoListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__GetScheduleInfoListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns7__GetScheduleInfoList(struct soap *soap, struct _ns7__GetScheduleInfoList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Limit = NULL;
	soap_default_string(soap, &a->StartReference);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__GetScheduleInfoList(struct soap *soap, const struct _ns7__GetScheduleInfoList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->Limit);
	soap_serialize_string(soap, (char*const*)&a->StartReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__GetScheduleInfoList(struct soap *soap, const char *tag, int id, const struct _ns7__GetScheduleInfoList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__GetScheduleInfoList), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ns7:Limit", -1, &a->Limit, ""))
		return soap->error;
	if (soap_out_string(soap, "ns7:StartReference", -1, (char*const*)&a->StartReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns7__GetScheduleInfoList * SOAP_FMAC4 soap_in__ns7__GetScheduleInfoList(struct soap *soap, const char *tag, struct _ns7__GetScheduleInfoList *a, const char *type)
{
	size_t soap_flag_Limit = 1;
	size_t soap_flag_StartReference = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns7__GetScheduleInfoList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__GetScheduleInfoList, sizeof(struct _ns7__GetScheduleInfoList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns7__GetScheduleInfoList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Limit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ns7:Limit", &a->Limit, "xsd:int"))
				{	soap_flag_Limit--;
					continue;
				}
			if (soap_flag_StartReference && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ns7:StartReference", (char**)&a->StartReference, "xsd:string"))
				{	soap_flag_StartReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns7__GetScheduleInfoList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__GetScheduleInfoList, SOAP_TYPE__ns7__GetScheduleInfoList, sizeof(struct _ns7__GetScheduleInfoList), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns7__GetScheduleInfoList * SOAP_FMAC4 soap_new__ns7__GetScheduleInfoList(struct soap *soap, int n)
{
	struct _ns7__GetScheduleInfoList *p;
	struct _ns7__GetScheduleInfoList *a = (struct _ns7__GetScheduleInfoList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns7__GetScheduleInfoList));
	for (p = a; p && n--; p++)
		soap_default__ns7__GetScheduleInfoList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns7__GetScheduleInfoList(struct soap *soap, const struct _ns7__GetScheduleInfoList *a, const char *tag, const char *type)
{
	if (soap_out__ns7__GetScheduleInfoList(soap, tag ? tag : "ns7:GetScheduleInfoList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns7__GetScheduleInfoList * SOAP_FMAC4 soap_get__ns7__GetScheduleInfoList(struct soap *soap, struct _ns7__GetScheduleInfoList *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__GetScheduleInfoList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns7__ScheduleInfo(struct soap *soap, struct ns7__ScheduleInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->token);
	soap_default_ns2__Name(soap, &a->Name);
	soap_default_ns2__Description(soap, &a->Description);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns7__ScheduleInfo(struct soap *soap, const struct ns7__ScheduleInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__Name(soap, (char*const*)&a->Name);
	soap_serialize_ns2__Description(soap, (char*const*)&a->Description);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__ScheduleInfo(struct soap *soap, const char *tag, int id, const struct ns7__ScheduleInfo *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_ns2__ReferenceToken2s(soap, a->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__ScheduleInfo), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "ns7:Name"))
			return soap->error;
	}
	else
	if (soap_out_ns2__Name(soap, "ns7:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_ns2__Description(soap, "ns7:Description", -1, (char*const*)&a->Description, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns7__ScheduleInfo * SOAP_FMAC4 soap_in_ns7__ScheduleInfo(struct soap *soap, const char *tag, struct ns7__ScheduleInfo *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_Description = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns7__ScheduleInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__ScheduleInfo, sizeof(struct ns7__ScheduleInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns7__ScheduleInfo(soap, a);
	if (soap_s2ns2__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Name(soap, "ns7:Name", (char**)&a->Name, "ns2:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Description(soap, "ns7:Description", (char**)&a->Description, "ns2:Description"))
				{	soap_flag_Description--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns7__ScheduleInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__ScheduleInfo, SOAP_TYPE_ns7__ScheduleInfo, sizeof(struct ns7__ScheduleInfo), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns7__ScheduleInfo * SOAP_FMAC4 soap_new_ns7__ScheduleInfo(struct soap *soap, int n)
{
	struct ns7__ScheduleInfo *p;
	struct ns7__ScheduleInfo *a = (struct ns7__ScheduleInfo*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns7__ScheduleInfo));
	for (p = a; p && n--; p++)
		soap_default_ns7__ScheduleInfo(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns7__ScheduleInfo(struct soap *soap, const struct ns7__ScheduleInfo *a, const char *tag, const char *type)
{
	if (soap_out_ns7__ScheduleInfo(soap, tag ? tag : "ns7:ScheduleInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns7__ScheduleInfo * SOAP_FMAC4 soap_get_ns7__ScheduleInfo(struct soap *soap, struct ns7__ScheduleInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__ScheduleInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns7__GetScheduleInfoResponse(struct soap *soap, struct _ns7__GetScheduleInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeScheduleInfo = 0;
	a->ScheduleInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__GetScheduleInfoResponse(struct soap *soap, const struct _ns7__GetScheduleInfoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ScheduleInfo)
	{	int i;
		for (i = 0; i < (int)a->__sizeScheduleInfo; i++)
		{
			soap_embedded(soap, a->ScheduleInfo + i, SOAP_TYPE_ns7__ScheduleInfo);
			soap_serialize_ns7__ScheduleInfo(soap, a->ScheduleInfo + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__GetScheduleInfoResponse(struct soap *soap, const char *tag, int id, const struct _ns7__GetScheduleInfoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__GetScheduleInfoResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeScheduleInfo");
	if (a->ScheduleInfo)
	{	int i;
		for (i = 0; i < (int)a->__sizeScheduleInfo; i++)
			if (soap_out_ns7__ScheduleInfo(soap, "ns7:ScheduleInfo", -1, a->ScheduleInfo + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns7__GetScheduleInfoResponse * SOAP_FMAC4 soap_in__ns7__GetScheduleInfoResponse(struct soap *soap, const char *tag, struct _ns7__GetScheduleInfoResponse *a, const char *type)
{
	struct soap_blist *soap_blist_ScheduleInfo = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns7__GetScheduleInfoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__GetScheduleInfoResponse, sizeof(struct _ns7__GetScheduleInfoResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns7__GetScheduleInfoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:ScheduleInfo", 1, NULL))
			{	if (a->ScheduleInfo == NULL)
				{	if (soap_blist_ScheduleInfo == NULL)
						soap_blist_ScheduleInfo = soap_alloc_block(soap);
					a->ScheduleInfo = (struct ns7__ScheduleInfo *)soap_push_block_max(soap, soap_blist_ScheduleInfo, sizeof(struct ns7__ScheduleInfo));
					if (a->ScheduleInfo == NULL)
						return NULL;
					soap_default_ns7__ScheduleInfo(soap, a->ScheduleInfo);
				}
				soap_revert(soap);
				if (soap_in_ns7__ScheduleInfo(soap, "ns7:ScheduleInfo", a->ScheduleInfo, "ns7:ScheduleInfo"))
				{	a->__sizeScheduleInfo++;
					a->ScheduleInfo = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeScheduleInfo");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ScheduleInfo)
			soap_pop_block(soap, soap_blist_ScheduleInfo);
		if (a->__sizeScheduleInfo)
		{	a->ScheduleInfo = (struct ns7__ScheduleInfo *)soap_save_block(soap, soap_blist_ScheduleInfo, NULL, 1);
		}
		else
		{	a->ScheduleInfo = NULL;
			if (soap_blist_ScheduleInfo)
				soap_end_block(soap, soap_blist_ScheduleInfo);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns7__GetScheduleInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__GetScheduleInfoResponse, SOAP_TYPE__ns7__GetScheduleInfoResponse, sizeof(struct _ns7__GetScheduleInfoResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns7__GetScheduleInfoResponse * SOAP_FMAC4 soap_new__ns7__GetScheduleInfoResponse(struct soap *soap, int n)
{
	struct _ns7__GetScheduleInfoResponse *p;
	struct _ns7__GetScheduleInfoResponse *a = (struct _ns7__GetScheduleInfoResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns7__GetScheduleInfoResponse));
	for (p = a; p && n--; p++)
		soap_default__ns7__GetScheduleInfoResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns7__GetScheduleInfoResponse(struct soap *soap, const struct _ns7__GetScheduleInfoResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns7__GetScheduleInfoResponse(soap, tag ? tag : "ns7:GetScheduleInfoResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns7__GetScheduleInfoResponse * SOAP_FMAC4 soap_get__ns7__GetScheduleInfoResponse(struct soap *soap, struct _ns7__GetScheduleInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__GetScheduleInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns7__GetScheduleInfo(struct soap *soap, struct _ns7__GetScheduleInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeToken = 0;
	a->Token = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__GetScheduleInfo(struct soap *soap, const struct _ns7__GetScheduleInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Token)
	{	int i;
		for (i = 0; i < (int)a->__sizeToken; i++)
		{
			soap_serialize_ns2__ReferenceToken(soap, (char*const*)(a->Token + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__GetScheduleInfo(struct soap *soap, const char *tag, int id, const struct _ns7__GetScheduleInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__GetScheduleInfo), type))
		return soap->error;
	if (a->Token)
	{	int i;
		for (i = 0; i < (int)a->__sizeToken; i++)
			soap_out_string(soap, "ns7:Token", -1, (char*const*)(a->Token + i), "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns7__GetScheduleInfo * SOAP_FMAC4 soap_in__ns7__GetScheduleInfo(struct soap *soap, const char *tag, struct _ns7__GetScheduleInfo *a, const char *type)
{
	struct soap_blist *soap_blist_Token = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns7__GetScheduleInfo *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__GetScheduleInfo, sizeof(struct _ns7__GetScheduleInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns7__GetScheduleInfo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns7:Token", 1, NULL))
			{	if (a->Token == NULL)
				{	if (soap_blist_Token == NULL)
						soap_blist_Token = soap_alloc_block(soap);
					a->Token = (char **)soap_push_block_max(soap, soap_blist_Token, sizeof(char *));
					if (a->Token == NULL)
						return NULL;
					*a->Token = NULL;
				}
				soap_revert(soap);
				if (soap_in_ns2__ReferenceToken(soap, "ns7:Token", (char**)a->Token, "ns2:ReferenceToken"))
				{	a->__sizeToken++;
					a->Token = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Token)
			soap_pop_block(soap, soap_blist_Token);
		if (a->__sizeToken)
		{	a->Token = (char **)soap_save_block(soap, soap_blist_Token, NULL, 1);
		}
		else
		{	a->Token = NULL;
			if (soap_blist_Token)
				soap_end_block(soap, soap_blist_Token);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeToken < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns7__GetScheduleInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__GetScheduleInfo, SOAP_TYPE__ns7__GetScheduleInfo, sizeof(struct _ns7__GetScheduleInfo), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns7__GetScheduleInfo * SOAP_FMAC4 soap_new__ns7__GetScheduleInfo(struct soap *soap, int n)
{
	struct _ns7__GetScheduleInfo *p;
	struct _ns7__GetScheduleInfo *a = (struct _ns7__GetScheduleInfo*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns7__GetScheduleInfo));
	for (p = a; p && n--; p++)
		soap_default__ns7__GetScheduleInfo(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns7__GetScheduleInfo(struct soap *soap, const struct _ns7__GetScheduleInfo *a, const char *tag, const char *type)
{
	if (soap_out__ns7__GetScheduleInfo(soap, tag ? tag : "ns7:GetScheduleInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns7__GetScheduleInfo * SOAP_FMAC4 soap_get__ns7__GetScheduleInfo(struct soap *soap, struct _ns7__GetScheduleInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__GetScheduleInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns7__GetScheduleStateResponse(struct soap *soap, struct _ns7__GetScheduleStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ScheduleState = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__GetScheduleStateResponse(struct soap *soap, const struct _ns7__GetScheduleStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons7__ScheduleState(soap, &a->ScheduleState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__GetScheduleStateResponse(struct soap *soap, const char *tag, int id, const struct _ns7__GetScheduleStateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__GetScheduleStateResponse), type))
		return soap->error;
	if (a->ScheduleState)
		soap_element_result(soap, "ns7:ScheduleState");
	if (!a->ScheduleState)
	{	if (soap_element_nil(soap, "ns7:ScheduleState"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__ScheduleState(soap, "ns7:ScheduleState", -1, &a->ScheduleState, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns7__GetScheduleStateResponse * SOAP_FMAC4 soap_in__ns7__GetScheduleStateResponse(struct soap *soap, const char *tag, struct _ns7__GetScheduleStateResponse *a, const char *type)
{
	size_t soap_flag_ScheduleState = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns7__GetScheduleStateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__GetScheduleStateResponse, sizeof(struct _ns7__GetScheduleStateResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns7__GetScheduleStateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ScheduleState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons7__ScheduleState(soap, "ns7:ScheduleState", &a->ScheduleState, "ns7:ScheduleState"))
				{	soap_flag_ScheduleState--;
					continue;
				}
			soap_check_result(soap, "ns7:ScheduleState");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ScheduleState > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns7__GetScheduleStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__GetScheduleStateResponse, SOAP_TYPE__ns7__GetScheduleStateResponse, sizeof(struct _ns7__GetScheduleStateResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns7__GetScheduleStateResponse * SOAP_FMAC4 soap_new__ns7__GetScheduleStateResponse(struct soap *soap, int n)
{
	struct _ns7__GetScheduleStateResponse *p;
	struct _ns7__GetScheduleStateResponse *a = (struct _ns7__GetScheduleStateResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns7__GetScheduleStateResponse));
	for (p = a; p && n--; p++)
		soap_default__ns7__GetScheduleStateResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns7__GetScheduleStateResponse(struct soap *soap, const struct _ns7__GetScheduleStateResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns7__GetScheduleStateResponse(soap, tag ? tag : "ns7:GetScheduleStateResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns7__GetScheduleStateResponse * SOAP_FMAC4 soap_get__ns7__GetScheduleStateResponse(struct soap *soap, struct _ns7__GetScheduleStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__GetScheduleStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns7__GetScheduleState(struct soap *soap, struct _ns7__GetScheduleState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->Token);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__GetScheduleState(struct soap *soap, const struct _ns7__GetScheduleState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__ReferenceToken(soap, (char*const*)&a->Token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__GetScheduleState(struct soap *soap, const char *tag, int id, const struct _ns7__GetScheduleState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__GetScheduleState), type))
		return soap->error;
	if (!a->Token)
	{	if (soap_element_nil(soap, "ns7:Token"))
			return soap->error;
	}
	else
	if (soap_out_ns2__ReferenceToken(soap, "ns7:Token", -1, (char*const*)&a->Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns7__GetScheduleState * SOAP_FMAC4 soap_in__ns7__GetScheduleState(struct soap *soap, const char *tag, struct _ns7__GetScheduleState *a, const char *type)
{
	size_t soap_flag_Token = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns7__GetScheduleState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__GetScheduleState, sizeof(struct _ns7__GetScheduleState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns7__GetScheduleState(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns7:Token", (char**)&a->Token, "ns2:ReferenceToken"))
				{	soap_flag_Token--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Token > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns7__GetScheduleState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__GetScheduleState, SOAP_TYPE__ns7__GetScheduleState, sizeof(struct _ns7__GetScheduleState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns7__GetScheduleState * SOAP_FMAC4 soap_new__ns7__GetScheduleState(struct soap *soap, int n)
{
	struct _ns7__GetScheduleState *p;
	struct _ns7__GetScheduleState *a = (struct _ns7__GetScheduleState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns7__GetScheduleState));
	for (p = a; p && n--; p++)
		soap_default__ns7__GetScheduleState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns7__GetScheduleState(struct soap *soap, const struct _ns7__GetScheduleState *a, const char *tag, const char *type)
{
	if (soap_out__ns7__GetScheduleState(soap, tag ? tag : "ns7:GetScheduleState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns7__GetScheduleState * SOAP_FMAC4 soap_get__ns7__GetScheduleState(struct soap *soap, struct _ns7__GetScheduleState *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__GetScheduleState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns7__GetServiceCapabilitiesResponse(struct soap *soap, struct _ns7__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__GetServiceCapabilitiesResponse(struct soap *soap, const struct _ns7__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons7__ServiceCapabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _ns7__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "ns7:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_nil(soap, "ns7:Capabilities"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons7__ServiceCapabilities(soap, "ns7:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns7__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__ns7__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _ns7__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns7__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__GetServiceCapabilitiesResponse, sizeof(struct _ns7__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns7__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons7__ServiceCapabilities(soap, "ns7:Capabilities", &a->Capabilities, "ns7:ServiceCapabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			soap_check_result(soap, "ns7:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns7__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__GetServiceCapabilitiesResponse, SOAP_TYPE__ns7__GetServiceCapabilitiesResponse, sizeof(struct _ns7__GetServiceCapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns7__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_new__ns7__GetServiceCapabilitiesResponse(struct soap *soap, int n)
{
	struct _ns7__GetServiceCapabilitiesResponse *p;
	struct _ns7__GetServiceCapabilitiesResponse *a = (struct _ns7__GetServiceCapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns7__GetServiceCapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__ns7__GetServiceCapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns7__GetServiceCapabilitiesResponse(struct soap *soap, const struct _ns7__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns7__GetServiceCapabilitiesResponse(soap, tag ? tag : "ns7:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns7__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__ns7__GetServiceCapabilitiesResponse(struct soap *soap, struct _ns7__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns7__GetServiceCapabilities(struct soap *soap, struct _ns7__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns7__GetServiceCapabilities(struct soap *soap, const struct _ns7__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns7__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _ns7__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns7__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns7__GetServiceCapabilities * SOAP_FMAC4 soap_in__ns7__GetServiceCapabilities(struct soap *soap, const char *tag, struct _ns7__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns7__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns7__GetServiceCapabilities, sizeof(struct _ns7__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns7__GetServiceCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns7__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns7__GetServiceCapabilities, SOAP_TYPE__ns7__GetServiceCapabilities, sizeof(struct _ns7__GetServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns7__GetServiceCapabilities * SOAP_FMAC4 soap_new__ns7__GetServiceCapabilities(struct soap *soap, int n)
{
	struct _ns7__GetServiceCapabilities *p;
	struct _ns7__GetServiceCapabilities *a = (struct _ns7__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns7__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default__ns7__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns7__GetServiceCapabilities(struct soap *soap, const struct _ns7__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__ns7__GetServiceCapabilities(soap, tag ? tag : "ns7:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns7__GetServiceCapabilities * SOAP_FMAC4 soap_get__ns7__GetServiceCapabilities(struct soap *soap, struct _ns7__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns7__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns7__SpecialDayGroupExtension(struct soap *soap, struct ns7__SpecialDayGroupExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns7__SpecialDayGroupExtension(struct soap *soap, const struct ns7__SpecialDayGroupExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__SpecialDayGroupExtension(struct soap *soap, const char *tag, int id, const struct ns7__SpecialDayGroupExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__SpecialDayGroupExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns7__SpecialDayGroupExtension * SOAP_FMAC4 soap_in_ns7__SpecialDayGroupExtension(struct soap *soap, const char *tag, struct ns7__SpecialDayGroupExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns7__SpecialDayGroupExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__SpecialDayGroupExtension, sizeof(struct ns7__SpecialDayGroupExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns7__SpecialDayGroupExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns7__SpecialDayGroupExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__SpecialDayGroupExtension, SOAP_TYPE_ns7__SpecialDayGroupExtension, sizeof(struct ns7__SpecialDayGroupExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns7__SpecialDayGroupExtension * SOAP_FMAC4 soap_new_ns7__SpecialDayGroupExtension(struct soap *soap, int n)
{
	struct ns7__SpecialDayGroupExtension *p;
	struct ns7__SpecialDayGroupExtension *a = (struct ns7__SpecialDayGroupExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns7__SpecialDayGroupExtension));
	for (p = a; p && n--; p++)
		soap_default_ns7__SpecialDayGroupExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns7__SpecialDayGroupExtension(struct soap *soap, const struct ns7__SpecialDayGroupExtension *a, const char *tag, const char *type)
{
	if (soap_out_ns7__SpecialDayGroupExtension(soap, tag ? tag : "ns7:SpecialDayGroupExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns7__SpecialDayGroupExtension * SOAP_FMAC4 soap_get_ns7__SpecialDayGroupExtension(struct soap *soap, struct ns7__SpecialDayGroupExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__SpecialDayGroupExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns7__TimePeriodExtension(struct soap *soap, struct ns7__TimePeriodExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns7__TimePeriodExtension(struct soap *soap, const struct ns7__TimePeriodExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__TimePeriodExtension(struct soap *soap, const char *tag, int id, const struct ns7__TimePeriodExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__TimePeriodExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns7__TimePeriodExtension * SOAP_FMAC4 soap_in_ns7__TimePeriodExtension(struct soap *soap, const char *tag, struct ns7__TimePeriodExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns7__TimePeriodExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__TimePeriodExtension, sizeof(struct ns7__TimePeriodExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns7__TimePeriodExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns7__TimePeriodExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__TimePeriodExtension, SOAP_TYPE_ns7__TimePeriodExtension, sizeof(struct ns7__TimePeriodExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns7__TimePeriodExtension * SOAP_FMAC4 soap_new_ns7__TimePeriodExtension(struct soap *soap, int n)
{
	struct ns7__TimePeriodExtension *p;
	struct ns7__TimePeriodExtension *a = (struct ns7__TimePeriodExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns7__TimePeriodExtension));
	for (p = a; p && n--; p++)
		soap_default_ns7__TimePeriodExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns7__TimePeriodExtension(struct soap *soap, const struct ns7__TimePeriodExtension *a, const char *tag, const char *type)
{
	if (soap_out_ns7__TimePeriodExtension(soap, tag ? tag : "ns7:TimePeriodExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns7__TimePeriodExtension * SOAP_FMAC4 soap_get_ns7__TimePeriodExtension(struct soap *soap, struct ns7__TimePeriodExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__TimePeriodExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns7__ScheduleStateExtension(struct soap *soap, struct ns7__ScheduleStateExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns7__ScheduleStateExtension(struct soap *soap, const struct ns7__ScheduleStateExtension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__ScheduleStateExtension(struct soap *soap, const char *tag, int id, const struct ns7__ScheduleStateExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__ScheduleStateExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns7__ScheduleStateExtension * SOAP_FMAC4 soap_in_ns7__ScheduleStateExtension(struct soap *soap, const char *tag, struct ns7__ScheduleStateExtension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns7__ScheduleStateExtension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__ScheduleStateExtension, sizeof(struct ns7__ScheduleStateExtension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns7__ScheduleStateExtension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns7__ScheduleStateExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__ScheduleStateExtension, SOAP_TYPE_ns7__ScheduleStateExtension, sizeof(struct ns7__ScheduleStateExtension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns7__ScheduleStateExtension * SOAP_FMAC4 soap_new_ns7__ScheduleStateExtension(struct soap *soap, int n)
{
	struct ns7__ScheduleStateExtension *p;
	struct ns7__ScheduleStateExtension *a = (struct ns7__ScheduleStateExtension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns7__ScheduleStateExtension));
	for (p = a; p && n--; p++)
		soap_default_ns7__ScheduleStateExtension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns7__ScheduleStateExtension(struct soap *soap, const struct ns7__ScheduleStateExtension *a, const char *tag, const char *type)
{
	if (soap_out_ns7__ScheduleStateExtension(soap, tag ? tag : "ns7:ScheduleStateExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns7__ScheduleStateExtension * SOAP_FMAC4 soap_get_ns7__ScheduleStateExtension(struct soap *soap, struct ns7__ScheduleStateExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__ScheduleStateExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns7__ScheduleState(struct soap *soap, struct ns7__ScheduleState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->Active);
	a->SpecialDay = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns7__ScheduleState(struct soap *soap, const struct ns7__ScheduleState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Active, SOAP_TYPE_xsd__boolean);
	soap_serialize_PointerToxsd__boolean(soap, &a->SpecialDay);
	soap_serialize_PointerTons7__ScheduleStateExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns7__ScheduleState(struct soap *soap, const char *tag, int id, const struct ns7__ScheduleState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns7__ScheduleState), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns7:Active", -1, &a->Active, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns7:SpecialDay", -1, &a->SpecialDay, ""))
		return soap->error;
	if (soap_out_PointerTons7__ScheduleStateExtension(soap, "ns7:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns7__ScheduleState * SOAP_FMAC4 soap_in_ns7__ScheduleState(struct soap *soap, const char *tag, struct ns7__ScheduleState *a, const char *type)
{
	size_t soap_flag_Active = 1;
	size_t soap_flag_SpecialDay = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns7__ScheduleState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns7__ScheduleState, sizeof(struct ns7__ScheduleState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns7__ScheduleState(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Active && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns7:Active", &a->Active, "xsd:boolean"))
				{	soap_flag_Active--;
					continue;
				}
			if (soap_flag_SpecialDay && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns7:SpecialDay", &a->SpecialDay, "xsd:boolean"))
				{	soap_flag_SpecialDay--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons7__ScheduleStateExtension(soap, "ns7:Extension", &a->Extension, "ns7:ScheduleStateExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Active > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns7__ScheduleState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns7__ScheduleState, SOAP_TYPE_ns7__ScheduleState, sizeof(struct ns7__ScheduleState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns7__ScheduleState * SOAP_FMAC4 soap_new_ns7__ScheduleState(struct soap *soap, int n)
{
	struct ns7__ScheduleState *p;
	struct ns7__ScheduleState *a = (struct ns7__ScheduleState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns7__ScheduleState));
	for (p = a; p && n--; p++)
		soap_default_ns7__ScheduleState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns7__ScheduleState(struct soap *soap, const struct ns7__ScheduleState *a, const char *tag, const char *type)
{
	if (soap_out_ns7__ScheduleState(soap, tag ? tag : "ns7:ScheduleState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns7__ScheduleState * SOAP_FMAC4 soap_get_ns7__ScheduleState(struct soap *soap, struct ns7__ScheduleState *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns7__ScheduleState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
