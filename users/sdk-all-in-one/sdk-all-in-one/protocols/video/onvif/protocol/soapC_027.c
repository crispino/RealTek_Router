/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:59 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDPAddresses(struct soap *soap, struct _tds__SetDPAddresses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeDPAddress = 0;
	a->DPAddress = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDPAddresses(struct soap *soap, const struct _tds__SetDPAddresses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->DPAddress)
	{	int i;
		for (i = 0; i < (int)a->__sizeDPAddress; i++)
		{
			soap_embedded(soap, a->DPAddress + i, SOAP_TYPE_tt__NetworkHost);
			soap_serialize_tt__NetworkHost(soap, a->DPAddress + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDPAddresses(struct soap *soap, const char *tag, int id, const struct _tds__SetDPAddresses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDPAddresses), type))
		return soap->error;
	if (a->DPAddress)
	{	int i;
		for (i = 0; i < (int)a->__sizeDPAddress; i++)
			if (soap_out_tt__NetworkHost(soap, "tds:DPAddress", -1, a->DPAddress + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDPAddresses * SOAP_FMAC4 soap_in__tds__SetDPAddresses(struct soap *soap, const char *tag, struct _tds__SetDPAddresses *a, const char *type)
{
	struct soap_blist *soap_blist_DPAddress = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetDPAddresses *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDPAddresses, sizeof(struct _tds__SetDPAddresses), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetDPAddresses(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:DPAddress", 1, NULL))
			{	if (a->DPAddress == NULL)
				{	if (soap_blist_DPAddress == NULL)
						soap_blist_DPAddress = soap_alloc_block(soap);
					a->DPAddress = (struct tt__NetworkHost *)soap_push_block_max(soap, soap_blist_DPAddress, sizeof(struct tt__NetworkHost));
					if (a->DPAddress == NULL)
						return NULL;
					soap_default_tt__NetworkHost(soap, a->DPAddress);
				}
				soap_revert(soap);
				if (soap_in_tt__NetworkHost(soap, "tds:DPAddress", a->DPAddress, "tt:NetworkHost"))
				{	a->__sizeDPAddress++;
					a->DPAddress = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->DPAddress)
			soap_pop_block(soap, soap_blist_DPAddress);
		if (a->__sizeDPAddress)
		{	a->DPAddress = (struct tt__NetworkHost *)soap_save_block(soap, soap_blist_DPAddress, NULL, 1);
		}
		else
		{	a->DPAddress = NULL;
			if (soap_blist_DPAddress)
				soap_end_block(soap, soap_blist_DPAddress);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDPAddresses *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDPAddresses, SOAP_TYPE__tds__SetDPAddresses, sizeof(struct _tds__SetDPAddresses), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetDPAddresses * SOAP_FMAC4 soap_new__tds__SetDPAddresses(struct soap *soap, int n)
{
	struct _tds__SetDPAddresses *p;
	struct _tds__SetDPAddresses *a = (struct _tds__SetDPAddresses*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetDPAddresses));
	for (p = a; p && n--; p++)
		soap_default__tds__SetDPAddresses(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDPAddresses(struct soap *soap, const struct _tds__SetDPAddresses *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetDPAddresses(soap, tag ? tag : "tds:SetDPAddresses", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDPAddresses * SOAP_FMAC4 soap_get__tds__SetDPAddresses(struct soap *soap, struct _tds__SetDPAddresses *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDPAddresses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDPAddressesResponse(struct soap *soap, struct _tds__GetDPAddressesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeDPAddress = 0;
	a->DPAddress = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDPAddressesResponse(struct soap *soap, const struct _tds__GetDPAddressesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->DPAddress)
	{	int i;
		for (i = 0; i < (int)a->__sizeDPAddress; i++)
		{
			soap_embedded(soap, a->DPAddress + i, SOAP_TYPE_tt__NetworkHost);
			soap_serialize_tt__NetworkHost(soap, a->DPAddress + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDPAddressesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDPAddressesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDPAddressesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeDPAddress");
	if (a->DPAddress)
	{	int i;
		for (i = 0; i < (int)a->__sizeDPAddress; i++)
			if (soap_out_tt__NetworkHost(soap, "tds:DPAddress", -1, a->DPAddress + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDPAddressesResponse * SOAP_FMAC4 soap_in__tds__GetDPAddressesResponse(struct soap *soap, const char *tag, struct _tds__GetDPAddressesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_DPAddress = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDPAddressesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDPAddressesResponse, sizeof(struct _tds__GetDPAddressesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDPAddressesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:DPAddress", 1, NULL))
			{	if (a->DPAddress == NULL)
				{	if (soap_blist_DPAddress == NULL)
						soap_blist_DPAddress = soap_alloc_block(soap);
					a->DPAddress = (struct tt__NetworkHost *)soap_push_block_max(soap, soap_blist_DPAddress, sizeof(struct tt__NetworkHost));
					if (a->DPAddress == NULL)
						return NULL;
					soap_default_tt__NetworkHost(soap, a->DPAddress);
				}
				soap_revert(soap);
				if (soap_in_tt__NetworkHost(soap, "tds:DPAddress", a->DPAddress, "tt:NetworkHost"))
				{	a->__sizeDPAddress++;
					a->DPAddress = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeDPAddress");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->DPAddress)
			soap_pop_block(soap, soap_blist_DPAddress);
		if (a->__sizeDPAddress)
		{	a->DPAddress = (struct tt__NetworkHost *)soap_save_block(soap, soap_blist_DPAddress, NULL, 1);
		}
		else
		{	a->DPAddress = NULL;
			if (soap_blist_DPAddress)
				soap_end_block(soap, soap_blist_DPAddress);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDPAddressesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDPAddressesResponse, SOAP_TYPE__tds__GetDPAddressesResponse, sizeof(struct _tds__GetDPAddressesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDPAddressesResponse * SOAP_FMAC4 soap_new__tds__GetDPAddressesResponse(struct soap *soap, int n)
{
	struct _tds__GetDPAddressesResponse *p;
	struct _tds__GetDPAddressesResponse *a = (struct _tds__GetDPAddressesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDPAddressesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDPAddressesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDPAddressesResponse(struct soap *soap, const struct _tds__GetDPAddressesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDPAddressesResponse(soap, tag ? tag : "tds:GetDPAddressesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDPAddressesResponse * SOAP_FMAC4 soap_get__tds__GetDPAddressesResponse(struct soap *soap, struct _tds__GetDPAddressesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDPAddressesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDPAddresses(struct soap *soap, struct _tds__GetDPAddresses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDPAddresses(struct soap *soap, const struct _tds__GetDPAddresses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDPAddresses(struct soap *soap, const char *tag, int id, const struct _tds__GetDPAddresses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDPAddresses), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDPAddresses * SOAP_FMAC4 soap_in__tds__GetDPAddresses(struct soap *soap, const char *tag, struct _tds__GetDPAddresses *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDPAddresses *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDPAddresses, sizeof(struct _tds__GetDPAddresses), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDPAddresses(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDPAddresses *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDPAddresses, SOAP_TYPE__tds__GetDPAddresses, sizeof(struct _tds__GetDPAddresses), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDPAddresses * SOAP_FMAC4 soap_new__tds__GetDPAddresses(struct soap *soap, int n)
{
	struct _tds__GetDPAddresses *p;
	struct _tds__GetDPAddresses *a = (struct _tds__GetDPAddresses*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDPAddresses));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDPAddresses(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDPAddresses(struct soap *soap, const struct _tds__GetDPAddresses *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDPAddresses(soap, tag ? tag : "tds:GetDPAddresses", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDPAddresses * SOAP_FMAC4 soap_get__tds__GetDPAddresses(struct soap *soap, struct _tds__GetDPAddresses *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDPAddresses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, struct _tds__SetRemoteDiscoveryModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, const struct _tds__SetRemoteDiscoveryModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetRemoteDiscoveryModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRemoteDiscoveryModeResponse * SOAP_FMAC4 soap_in__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, struct _tds__SetRemoteDiscoveryModeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetRemoteDiscoveryModeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse, sizeof(struct _tds__SetRemoteDiscoveryModeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetRemoteDiscoveryModeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRemoteDiscoveryModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse, sizeof(struct _tds__SetRemoteDiscoveryModeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetRemoteDiscoveryModeResponse * SOAP_FMAC4 soap_new__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, int n)
{
	struct _tds__SetRemoteDiscoveryModeResponse *p;
	struct _tds__SetRemoteDiscoveryModeResponse *a = (struct _tds__SetRemoteDiscoveryModeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetRemoteDiscoveryModeResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetRemoteDiscoveryModeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, const struct _tds__SetRemoteDiscoveryModeResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetRemoteDiscoveryModeResponse(soap, tag ? tag : "tds:SetRemoteDiscoveryModeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRemoteDiscoveryModeResponse * SOAP_FMAC4 soap_get__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, struct _tds__SetRemoteDiscoveryModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRemoteDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRemoteDiscoveryMode(struct soap *soap, struct _tds__SetRemoteDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__DiscoveryMode(soap, &a->RemoteDiscoveryMode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRemoteDiscoveryMode(struct soap *soap, const struct _tds__SetRemoteDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRemoteDiscoveryMode(struct soap *soap, const char *tag, int id, const struct _tds__SetRemoteDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRemoteDiscoveryMode), type))
		return soap->error;
	if (soap_out_tt__DiscoveryMode(soap, "tds:RemoteDiscoveryMode", -1, &a->RemoteDiscoveryMode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRemoteDiscoveryMode * SOAP_FMAC4 soap_in__tds__SetRemoteDiscoveryMode(struct soap *soap, const char *tag, struct _tds__SetRemoteDiscoveryMode *a, const char *type)
{
	size_t soap_flag_RemoteDiscoveryMode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetRemoteDiscoveryMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRemoteDiscoveryMode, sizeof(struct _tds__SetRemoteDiscoveryMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetRemoteDiscoveryMode(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RemoteDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__DiscoveryMode(soap, "tds:RemoteDiscoveryMode", &a->RemoteDiscoveryMode, "tt:DiscoveryMode"))
				{	soap_flag_RemoteDiscoveryMode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RemoteDiscoveryMode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetRemoteDiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRemoteDiscoveryMode, SOAP_TYPE__tds__SetRemoteDiscoveryMode, sizeof(struct _tds__SetRemoteDiscoveryMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetRemoteDiscoveryMode * SOAP_FMAC4 soap_new__tds__SetRemoteDiscoveryMode(struct soap *soap, int n)
{
	struct _tds__SetRemoteDiscoveryMode *p;
	struct _tds__SetRemoteDiscoveryMode *a = (struct _tds__SetRemoteDiscoveryMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetRemoteDiscoveryMode));
	for (p = a; p && n--; p++)
		soap_default__tds__SetRemoteDiscoveryMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRemoteDiscoveryMode(struct soap *soap, const struct _tds__SetRemoteDiscoveryMode *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetRemoteDiscoveryMode(soap, tag ? tag : "tds:SetRemoteDiscoveryMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRemoteDiscoveryMode * SOAP_FMAC4 soap_get__tds__SetRemoteDiscoveryMode(struct soap *soap, struct _tds__SetRemoteDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRemoteDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, struct _tds__GetRemoteDiscoveryModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__DiscoveryMode(soap, &a->RemoteDiscoveryMode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, const struct _tds__GetRemoteDiscoveryModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetRemoteDiscoveryModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:RemoteDiscoveryMode");
	if (soap_out_tt__DiscoveryMode(soap, "tds:RemoteDiscoveryMode", -1, &a->RemoteDiscoveryMode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetRemoteDiscoveryModeResponse * SOAP_FMAC4 soap_in__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, struct _tds__GetRemoteDiscoveryModeResponse *a, const char *type)
{
	size_t soap_flag_RemoteDiscoveryMode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetRemoteDiscoveryModeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse, sizeof(struct _tds__GetRemoteDiscoveryModeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetRemoteDiscoveryModeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RemoteDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__DiscoveryMode(soap, "tds:RemoteDiscoveryMode", &a->RemoteDiscoveryMode, "tt:DiscoveryMode"))
				{	soap_flag_RemoteDiscoveryMode--;
					continue;
				}
			soap_check_result(soap, "tds:RemoteDiscoveryMode");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RemoteDiscoveryMode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetRemoteDiscoveryModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse, sizeof(struct _tds__GetRemoteDiscoveryModeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetRemoteDiscoveryModeResponse * SOAP_FMAC4 soap_new__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, int n)
{
	struct _tds__GetRemoteDiscoveryModeResponse *p;
	struct _tds__GetRemoteDiscoveryModeResponse *a = (struct _tds__GetRemoteDiscoveryModeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetRemoteDiscoveryModeResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetRemoteDiscoveryModeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, const struct _tds__GetRemoteDiscoveryModeResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetRemoteDiscoveryModeResponse(soap, tag ? tag : "tds:GetRemoteDiscoveryModeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRemoteDiscoveryModeResponse * SOAP_FMAC4 soap_get__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, struct _tds__GetRemoteDiscoveryModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRemoteDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetRemoteDiscoveryMode(struct soap *soap, struct _tds__GetRemoteDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetRemoteDiscoveryMode(struct soap *soap, const struct _tds__GetRemoteDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRemoteDiscoveryMode(struct soap *soap, const char *tag, int id, const struct _tds__GetRemoteDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRemoteDiscoveryMode), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetRemoteDiscoveryMode * SOAP_FMAC4 soap_in__tds__GetRemoteDiscoveryMode(struct soap *soap, const char *tag, struct _tds__GetRemoteDiscoveryMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetRemoteDiscoveryMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRemoteDiscoveryMode, sizeof(struct _tds__GetRemoteDiscoveryMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetRemoteDiscoveryMode(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetRemoteDiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRemoteDiscoveryMode, SOAP_TYPE__tds__GetRemoteDiscoveryMode, sizeof(struct _tds__GetRemoteDiscoveryMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetRemoteDiscoveryMode * SOAP_FMAC4 soap_new__tds__GetRemoteDiscoveryMode(struct soap *soap, int n)
{
	struct _tds__GetRemoteDiscoveryMode *p;
	struct _tds__GetRemoteDiscoveryMode *a = (struct _tds__GetRemoteDiscoveryMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetRemoteDiscoveryMode));
	for (p = a; p && n--; p++)
		soap_default__tds__GetRemoteDiscoveryMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetRemoteDiscoveryMode(struct soap *soap, const struct _tds__GetRemoteDiscoveryMode *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetRemoteDiscoveryMode(soap, tag ? tag : "tds:GetRemoteDiscoveryMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRemoteDiscoveryMode * SOAP_FMAC4 soap_get__tds__GetRemoteDiscoveryMode(struct soap *soap, struct _tds__GetRemoteDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRemoteDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDiscoveryModeResponse(struct soap *soap, struct _tds__SetDiscoveryModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDiscoveryModeResponse(struct soap *soap, const struct _tds__SetDiscoveryModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDiscoveryModeResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetDiscoveryModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDiscoveryModeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDiscoveryModeResponse * SOAP_FMAC4 soap_in__tds__SetDiscoveryModeResponse(struct soap *soap, const char *tag, struct _tds__SetDiscoveryModeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetDiscoveryModeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDiscoveryModeResponse, sizeof(struct _tds__SetDiscoveryModeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetDiscoveryModeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDiscoveryModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDiscoveryModeResponse, SOAP_TYPE__tds__SetDiscoveryModeResponse, sizeof(struct _tds__SetDiscoveryModeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetDiscoveryModeResponse * SOAP_FMAC4 soap_new__tds__SetDiscoveryModeResponse(struct soap *soap, int n)
{
	struct _tds__SetDiscoveryModeResponse *p;
	struct _tds__SetDiscoveryModeResponse *a = (struct _tds__SetDiscoveryModeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetDiscoveryModeResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetDiscoveryModeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDiscoveryModeResponse(struct soap *soap, const struct _tds__SetDiscoveryModeResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetDiscoveryModeResponse(soap, tag ? tag : "tds:SetDiscoveryModeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDiscoveryModeResponse * SOAP_FMAC4 soap_get__tds__SetDiscoveryModeResponse(struct soap *soap, struct _tds__SetDiscoveryModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDiscoveryMode(struct soap *soap, struct _tds__SetDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__DiscoveryMode(soap, &a->DiscoveryMode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDiscoveryMode(struct soap *soap, const struct _tds__SetDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDiscoveryMode(struct soap *soap, const char *tag, int id, const struct _tds__SetDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDiscoveryMode), type))
		return soap->error;
	if (soap_out_tt__DiscoveryMode(soap, "tds:DiscoveryMode", -1, &a->DiscoveryMode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDiscoveryMode * SOAP_FMAC4 soap_in__tds__SetDiscoveryMode(struct soap *soap, const char *tag, struct _tds__SetDiscoveryMode *a, const char *type)
{
	size_t soap_flag_DiscoveryMode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetDiscoveryMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDiscoveryMode, sizeof(struct _tds__SetDiscoveryMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetDiscoveryMode(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__DiscoveryMode(soap, "tds:DiscoveryMode", &a->DiscoveryMode, "tt:DiscoveryMode"))
				{	soap_flag_DiscoveryMode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DiscoveryMode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetDiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDiscoveryMode, SOAP_TYPE__tds__SetDiscoveryMode, sizeof(struct _tds__SetDiscoveryMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetDiscoveryMode * SOAP_FMAC4 soap_new__tds__SetDiscoveryMode(struct soap *soap, int n)
{
	struct _tds__SetDiscoveryMode *p;
	struct _tds__SetDiscoveryMode *a = (struct _tds__SetDiscoveryMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetDiscoveryMode));
	for (p = a; p && n--; p++)
		soap_default__tds__SetDiscoveryMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDiscoveryMode(struct soap *soap, const struct _tds__SetDiscoveryMode *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetDiscoveryMode(soap, tag ? tag : "tds:SetDiscoveryMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDiscoveryMode * SOAP_FMAC4 soap_get__tds__SetDiscoveryMode(struct soap *soap, struct _tds__SetDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDiscoveryModeResponse(struct soap *soap, struct _tds__GetDiscoveryModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__DiscoveryMode(soap, &a->DiscoveryMode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDiscoveryModeResponse(struct soap *soap, const struct _tds__GetDiscoveryModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDiscoveryModeResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDiscoveryModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDiscoveryModeResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:DiscoveryMode");
	if (soap_out_tt__DiscoveryMode(soap, "tds:DiscoveryMode", -1, &a->DiscoveryMode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDiscoveryModeResponse * SOAP_FMAC4 soap_in__tds__GetDiscoveryModeResponse(struct soap *soap, const char *tag, struct _tds__GetDiscoveryModeResponse *a, const char *type)
{
	size_t soap_flag_DiscoveryMode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDiscoveryModeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDiscoveryModeResponse, sizeof(struct _tds__GetDiscoveryModeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDiscoveryModeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__DiscoveryMode(soap, "tds:DiscoveryMode", &a->DiscoveryMode, "tt:DiscoveryMode"))
				{	soap_flag_DiscoveryMode--;
					continue;
				}
			soap_check_result(soap, "tds:DiscoveryMode");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DiscoveryMode > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetDiscoveryModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDiscoveryModeResponse, SOAP_TYPE__tds__GetDiscoveryModeResponse, sizeof(struct _tds__GetDiscoveryModeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDiscoveryModeResponse * SOAP_FMAC4 soap_new__tds__GetDiscoveryModeResponse(struct soap *soap, int n)
{
	struct _tds__GetDiscoveryModeResponse *p;
	struct _tds__GetDiscoveryModeResponse *a = (struct _tds__GetDiscoveryModeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDiscoveryModeResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDiscoveryModeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDiscoveryModeResponse(struct soap *soap, const struct _tds__GetDiscoveryModeResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDiscoveryModeResponse(soap, tag ? tag : "tds:GetDiscoveryModeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDiscoveryModeResponse * SOAP_FMAC4 soap_get__tds__GetDiscoveryModeResponse(struct soap *soap, struct _tds__GetDiscoveryModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDiscoveryMode(struct soap *soap, struct _tds__GetDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDiscoveryMode(struct soap *soap, const struct _tds__GetDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDiscoveryMode(struct soap *soap, const char *tag, int id, const struct _tds__GetDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDiscoveryMode), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDiscoveryMode * SOAP_FMAC4 soap_in__tds__GetDiscoveryMode(struct soap *soap, const char *tag, struct _tds__GetDiscoveryMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDiscoveryMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDiscoveryMode, sizeof(struct _tds__GetDiscoveryMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDiscoveryMode(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDiscoveryMode, SOAP_TYPE__tds__GetDiscoveryMode, sizeof(struct _tds__GetDiscoveryMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDiscoveryMode * SOAP_FMAC4 soap_new__tds__GetDiscoveryMode(struct soap *soap, int n)
{
	struct _tds__GetDiscoveryMode *p;
	struct _tds__GetDiscoveryMode *a = (struct _tds__GetDiscoveryMode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDiscoveryMode));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDiscoveryMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDiscoveryMode(struct soap *soap, const struct _tds__GetDiscoveryMode *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDiscoveryMode(soap, tag ? tag : "tds:GetDiscoveryMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDiscoveryMode * SOAP_FMAC4 soap_get__tds__GetDiscoveryMode(struct soap *soap, struct _tds__GetDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__RemoveScopesResponse(struct soap *soap, struct _tds__RemoveScopesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeScopeItem = 0;
	a->ScopeItem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__RemoveScopesResponse(struct soap *soap, const struct _tds__RemoveScopesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ScopeItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeScopeItem; i++)
		{
			soap_serialize_xsd__anyURI(soap, (char*const*)(a->ScopeItem + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RemoveScopesResponse(struct soap *soap, const char *tag, int id, const struct _tds__RemoveScopesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RemoveScopesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeScopeItem");
	if (a->ScopeItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeScopeItem; i++)
			soap_out_string(soap, "tds:ScopeItem", -1, (char*const*)(a->ScopeItem + i), "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__RemoveScopesResponse * SOAP_FMAC4 soap_in__tds__RemoveScopesResponse(struct soap *soap, const char *tag, struct _tds__RemoveScopesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_ScopeItem = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__RemoveScopesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RemoveScopesResponse, sizeof(struct _tds__RemoveScopesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__RemoveScopesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:ScopeItem", 1, NULL))
			{	if (a->ScopeItem == NULL)
				{	if (soap_blist_ScopeItem == NULL)
						soap_blist_ScopeItem = soap_alloc_block(soap);
					a->ScopeItem = (char **)soap_push_block_max(soap, soap_blist_ScopeItem, sizeof(char *));
					if (a->ScopeItem == NULL)
						return NULL;
					*a->ScopeItem = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "tds:ScopeItem", (char**)a->ScopeItem, "xsd:anyURI"))
				{	a->__sizeScopeItem++;
					a->ScopeItem = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeScopeItem");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ScopeItem)
			soap_pop_block(soap, soap_blist_ScopeItem);
		if (a->__sizeScopeItem)
		{	a->ScopeItem = (char **)soap_save_block(soap, soap_blist_ScopeItem, NULL, 1);
		}
		else
		{	a->ScopeItem = NULL;
			if (soap_blist_ScopeItem)
				soap_end_block(soap, soap_blist_ScopeItem);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__RemoveScopesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RemoveScopesResponse, SOAP_TYPE__tds__RemoveScopesResponse, sizeof(struct _tds__RemoveScopesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__RemoveScopesResponse * SOAP_FMAC4 soap_new__tds__RemoveScopesResponse(struct soap *soap, int n)
{
	struct _tds__RemoveScopesResponse *p;
	struct _tds__RemoveScopesResponse *a = (struct _tds__RemoveScopesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__RemoveScopesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__RemoveScopesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__RemoveScopesResponse(struct soap *soap, const struct _tds__RemoveScopesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__RemoveScopesResponse(soap, tag ? tag : "tds:RemoveScopesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RemoveScopesResponse * SOAP_FMAC4 soap_get__tds__RemoveScopesResponse(struct soap *soap, struct _tds__RemoveScopesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RemoveScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__RemoveScopes(struct soap *soap, struct _tds__RemoveScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeScopeItem = 0;
	a->ScopeItem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__RemoveScopes(struct soap *soap, const struct _tds__RemoveScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ScopeItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeScopeItem; i++)
		{
			soap_serialize_xsd__anyURI(soap, (char*const*)(a->ScopeItem + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RemoveScopes(struct soap *soap, const char *tag, int id, const struct _tds__RemoveScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RemoveScopes), type))
		return soap->error;
	if (a->ScopeItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeScopeItem; i++)
			soap_out_string(soap, "tds:ScopeItem", -1, (char*const*)(a->ScopeItem + i), "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__RemoveScopes * SOAP_FMAC4 soap_in__tds__RemoveScopes(struct soap *soap, const char *tag, struct _tds__RemoveScopes *a, const char *type)
{
	struct soap_blist *soap_blist_ScopeItem = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__RemoveScopes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RemoveScopes, sizeof(struct _tds__RemoveScopes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__RemoveScopes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:ScopeItem", 1, NULL))
			{	if (a->ScopeItem == NULL)
				{	if (soap_blist_ScopeItem == NULL)
						soap_blist_ScopeItem = soap_alloc_block(soap);
					a->ScopeItem = (char **)soap_push_block_max(soap, soap_blist_ScopeItem, sizeof(char *));
					if (a->ScopeItem == NULL)
						return NULL;
					*a->ScopeItem = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "tds:ScopeItem", (char**)a->ScopeItem, "xsd:anyURI"))
				{	a->__sizeScopeItem++;
					a->ScopeItem = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ScopeItem)
			soap_pop_block(soap, soap_blist_ScopeItem);
		if (a->__sizeScopeItem)
		{	a->ScopeItem = (char **)soap_save_block(soap, soap_blist_ScopeItem, NULL, 1);
		}
		else
		{	a->ScopeItem = NULL;
			if (soap_blist_ScopeItem)
				soap_end_block(soap, soap_blist_ScopeItem);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeScopeItem < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__RemoveScopes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RemoveScopes, SOAP_TYPE__tds__RemoveScopes, sizeof(struct _tds__RemoveScopes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__RemoveScopes * SOAP_FMAC4 soap_new__tds__RemoveScopes(struct soap *soap, int n)
{
	struct _tds__RemoveScopes *p;
	struct _tds__RemoveScopes *a = (struct _tds__RemoveScopes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__RemoveScopes));
	for (p = a; p && n--; p++)
		soap_default__tds__RemoveScopes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__RemoveScopes(struct soap *soap, const struct _tds__RemoveScopes *a, const char *tag, const char *type)
{
	if (soap_out__tds__RemoveScopes(soap, tag ? tag : "tds:RemoveScopes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RemoveScopes * SOAP_FMAC4 soap_get__tds__RemoveScopes(struct soap *soap, struct _tds__RemoveScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RemoveScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__AddScopesResponse(struct soap *soap, struct _tds__AddScopesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__AddScopesResponse(struct soap *soap, const struct _tds__AddScopesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__AddScopesResponse(struct soap *soap, const char *tag, int id, const struct _tds__AddScopesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__AddScopesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__AddScopesResponse * SOAP_FMAC4 soap_in__tds__AddScopesResponse(struct soap *soap, const char *tag, struct _tds__AddScopesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__AddScopesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__AddScopesResponse, sizeof(struct _tds__AddScopesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__AddScopesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__AddScopesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__AddScopesResponse, SOAP_TYPE__tds__AddScopesResponse, sizeof(struct _tds__AddScopesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__AddScopesResponse * SOAP_FMAC4 soap_new__tds__AddScopesResponse(struct soap *soap, int n)
{
	struct _tds__AddScopesResponse *p;
	struct _tds__AddScopesResponse *a = (struct _tds__AddScopesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__AddScopesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__AddScopesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__AddScopesResponse(struct soap *soap, const struct _tds__AddScopesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__AddScopesResponse(soap, tag ? tag : "tds:AddScopesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__AddScopesResponse * SOAP_FMAC4 soap_get__tds__AddScopesResponse(struct soap *soap, struct _tds__AddScopesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__AddScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__AddScopes(struct soap *soap, struct _tds__AddScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeScopeItem = 0;
	a->ScopeItem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__AddScopes(struct soap *soap, const struct _tds__AddScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ScopeItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeScopeItem; i++)
		{
			soap_serialize_xsd__anyURI(soap, (char*const*)(a->ScopeItem + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__AddScopes(struct soap *soap, const char *tag, int id, const struct _tds__AddScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__AddScopes), type))
		return soap->error;
	if (a->ScopeItem)
	{	int i;
		for (i = 0; i < (int)a->__sizeScopeItem; i++)
			soap_out_string(soap, "tds:ScopeItem", -1, (char*const*)(a->ScopeItem + i), "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__AddScopes * SOAP_FMAC4 soap_in__tds__AddScopes(struct soap *soap, const char *tag, struct _tds__AddScopes *a, const char *type)
{
	struct soap_blist *soap_blist_ScopeItem = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__AddScopes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__AddScopes, sizeof(struct _tds__AddScopes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__AddScopes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:ScopeItem", 1, NULL))
			{	if (a->ScopeItem == NULL)
				{	if (soap_blist_ScopeItem == NULL)
						soap_blist_ScopeItem = soap_alloc_block(soap);
					a->ScopeItem = (char **)soap_push_block_max(soap, soap_blist_ScopeItem, sizeof(char *));
					if (a->ScopeItem == NULL)
						return NULL;
					*a->ScopeItem = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "tds:ScopeItem", (char**)a->ScopeItem, "xsd:anyURI"))
				{	a->__sizeScopeItem++;
					a->ScopeItem = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ScopeItem)
			soap_pop_block(soap, soap_blist_ScopeItem);
		if (a->__sizeScopeItem)
		{	a->ScopeItem = (char **)soap_save_block(soap, soap_blist_ScopeItem, NULL, 1);
		}
		else
		{	a->ScopeItem = NULL;
			if (soap_blist_ScopeItem)
				soap_end_block(soap, soap_blist_ScopeItem);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeScopeItem < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__AddScopes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__AddScopes, SOAP_TYPE__tds__AddScopes, sizeof(struct _tds__AddScopes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__AddScopes * SOAP_FMAC4 soap_new__tds__AddScopes(struct soap *soap, int n)
{
	struct _tds__AddScopes *p;
	struct _tds__AddScopes *a = (struct _tds__AddScopes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__AddScopes));
	for (p = a; p && n--; p++)
		soap_default__tds__AddScopes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__AddScopes(struct soap *soap, const struct _tds__AddScopes *a, const char *tag, const char *type)
{
	if (soap_out__tds__AddScopes(soap, tag ? tag : "tds:AddScopes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__AddScopes * SOAP_FMAC4 soap_get__tds__AddScopes(struct soap *soap, struct _tds__AddScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__AddScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetScopesResponse(struct soap *soap, struct _tds__SetScopesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetScopesResponse(struct soap *soap, const struct _tds__SetScopesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetScopesResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetScopesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetScopesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetScopesResponse * SOAP_FMAC4 soap_in__tds__SetScopesResponse(struct soap *soap, const char *tag, struct _tds__SetScopesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetScopesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetScopesResponse, sizeof(struct _tds__SetScopesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetScopesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetScopesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetScopesResponse, SOAP_TYPE__tds__SetScopesResponse, sizeof(struct _tds__SetScopesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetScopesResponse * SOAP_FMAC4 soap_new__tds__SetScopesResponse(struct soap *soap, int n)
{
	struct _tds__SetScopesResponse *p;
	struct _tds__SetScopesResponse *a = (struct _tds__SetScopesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetScopesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetScopesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetScopesResponse(struct soap *soap, const struct _tds__SetScopesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetScopesResponse(soap, tag ? tag : "tds:SetScopesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetScopesResponse * SOAP_FMAC4 soap_get__tds__SetScopesResponse(struct soap *soap, struct _tds__SetScopesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetScopes(struct soap *soap, struct _tds__SetScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeScopes = 0;
	a->Scopes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetScopes(struct soap *soap, const struct _tds__SetScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Scopes)
	{	int i;
		for (i = 0; i < (int)a->__sizeScopes; i++)
		{
			soap_serialize_xsd__anyURI(soap, (char*const*)(a->Scopes + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetScopes(struct soap *soap, const char *tag, int id, const struct _tds__SetScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetScopes), type))
		return soap->error;
	if (a->Scopes)
	{	int i;
		for (i = 0; i < (int)a->__sizeScopes; i++)
			soap_out_string(soap, "tds:Scopes", -1, (char*const*)(a->Scopes + i), "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetScopes * SOAP_FMAC4 soap_in__tds__SetScopes(struct soap *soap, const char *tag, struct _tds__SetScopes *a, const char *type)
{
	struct soap_blist *soap_blist_Scopes = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetScopes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetScopes, sizeof(struct _tds__SetScopes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetScopes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Scopes", 1, NULL))
			{	if (a->Scopes == NULL)
				{	if (soap_blist_Scopes == NULL)
						soap_blist_Scopes = soap_alloc_block(soap);
					a->Scopes = (char **)soap_push_block_max(soap, soap_blist_Scopes, sizeof(char *));
					if (a->Scopes == NULL)
						return NULL;
					*a->Scopes = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "tds:Scopes", (char**)a->Scopes, "xsd:anyURI"))
				{	a->__sizeScopes++;
					a->Scopes = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Scopes)
			soap_pop_block(soap, soap_blist_Scopes);
		if (a->__sizeScopes)
		{	a->Scopes = (char **)soap_save_block(soap, soap_blist_Scopes, NULL, 1);
		}
		else
		{	a->Scopes = NULL;
			if (soap_blist_Scopes)
				soap_end_block(soap, soap_blist_Scopes);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeScopes < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetScopes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetScopes, SOAP_TYPE__tds__SetScopes, sizeof(struct _tds__SetScopes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetScopes * SOAP_FMAC4 soap_new__tds__SetScopes(struct soap *soap, int n)
{
	struct _tds__SetScopes *p;
	struct _tds__SetScopes *a = (struct _tds__SetScopes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetScopes));
	for (p = a; p && n--; p++)
		soap_default__tds__SetScopes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetScopes(struct soap *soap, const struct _tds__SetScopes *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetScopes(soap, tag ? tag : "tds:SetScopes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetScopes * SOAP_FMAC4 soap_get__tds__SetScopes(struct soap *soap, struct _tds__SetScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetScopesResponse(struct soap *soap, struct _tds__GetScopesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeScopes = 0;
	a->Scopes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetScopesResponse(struct soap *soap, const struct _tds__GetScopesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Scopes)
	{	int i;
		for (i = 0; i < (int)a->__sizeScopes; i++)
		{
			soap_embedded(soap, a->Scopes + i, SOAP_TYPE_tt__Scope);
			soap_serialize_tt__Scope(soap, a->Scopes + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetScopesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetScopesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetScopesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeScopes");
	if (a->Scopes)
	{	int i;
		for (i = 0; i < (int)a->__sizeScopes; i++)
			if (soap_out_tt__Scope(soap, "tds:Scopes", -1, a->Scopes + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetScopesResponse * SOAP_FMAC4 soap_in__tds__GetScopesResponse(struct soap *soap, const char *tag, struct _tds__GetScopesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Scopes = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetScopesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetScopesResponse, sizeof(struct _tds__GetScopesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetScopesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Scopes", 1, NULL))
			{	if (a->Scopes == NULL)
				{	if (soap_blist_Scopes == NULL)
						soap_blist_Scopes = soap_alloc_block(soap);
					a->Scopes = (struct tt__Scope *)soap_push_block_max(soap, soap_blist_Scopes, sizeof(struct tt__Scope));
					if (a->Scopes == NULL)
						return NULL;
					soap_default_tt__Scope(soap, a->Scopes);
				}
				soap_revert(soap);
				if (soap_in_tt__Scope(soap, "tds:Scopes", a->Scopes, "tt:Scope"))
				{	a->__sizeScopes++;
					a->Scopes = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeScopes");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Scopes)
			soap_pop_block(soap, soap_blist_Scopes);
		if (a->__sizeScopes)
		{	a->Scopes = (struct tt__Scope *)soap_save_block(soap, soap_blist_Scopes, NULL, 1);
		}
		else
		{	a->Scopes = NULL;
			if (soap_blist_Scopes)
				soap_end_block(soap, soap_blist_Scopes);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeScopes < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetScopesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetScopesResponse, SOAP_TYPE__tds__GetScopesResponse, sizeof(struct _tds__GetScopesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetScopesResponse * SOAP_FMAC4 soap_new__tds__GetScopesResponse(struct soap *soap, int n)
{
	struct _tds__GetScopesResponse *p;
	struct _tds__GetScopesResponse *a = (struct _tds__GetScopesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetScopesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetScopesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetScopesResponse(struct soap *soap, const struct _tds__GetScopesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetScopesResponse(soap, tag ? tag : "tds:GetScopesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetScopesResponse * SOAP_FMAC4 soap_get__tds__GetScopesResponse(struct soap *soap, struct _tds__GetScopesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetScopes(struct soap *soap, struct _tds__GetScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetScopes(struct soap *soap, const struct _tds__GetScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetScopes(struct soap *soap, const char *tag, int id, const struct _tds__GetScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetScopes), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetScopes * SOAP_FMAC4 soap_in__tds__GetScopes(struct soap *soap, const char *tag, struct _tds__GetScopes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetScopes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetScopes, sizeof(struct _tds__GetScopes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetScopes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetScopes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetScopes, SOAP_TYPE__tds__GetScopes, sizeof(struct _tds__GetScopes), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetScopes * SOAP_FMAC4 soap_new__tds__GetScopes(struct soap *soap, int n)
{
	struct _tds__GetScopes *p;
	struct _tds__GetScopes *a = (struct _tds__GetScopes*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetScopes));
	for (p = a; p && n--; p++)
		soap_default__tds__GetScopes(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetScopes(struct soap *soap, const struct _tds__GetScopes *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetScopes(soap, tag ? tag : "tds:GetScopes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetScopes * SOAP_FMAC4 soap_get__tds__GetScopes(struct soap *soap, struct _tds__GetScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemLogResponse(struct soap *soap, struct _tds__GetSystemLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SystemLog = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemLogResponse(struct soap *soap, const struct _tds__GetSystemLogResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__SystemLog(soap, &a->SystemLog);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemLogResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemLogResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemLogResponse), type))
		return soap->error;
	if (a->SystemLog)
		soap_element_result(soap, "tds:SystemLog");
	if (!a->SystemLog)
	{	if (soap_element_nil(soap, "tds:SystemLog"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__SystemLog(soap, "tds:SystemLog", -1, &a->SystemLog, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemLogResponse * SOAP_FMAC4 soap_in__tds__GetSystemLogResponse(struct soap *soap, const char *tag, struct _tds__GetSystemLogResponse *a, const char *type)
{
	size_t soap_flag_SystemLog = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetSystemLogResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemLogResponse, sizeof(struct _tds__GetSystemLogResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemLogResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SystemLog && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SystemLog(soap, "tds:SystemLog", &a->SystemLog, "tt:SystemLog"))
				{	soap_flag_SystemLog--;
					continue;
				}
			soap_check_result(soap, "tds:SystemLog");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SystemLog > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetSystemLogResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemLogResponse, SOAP_TYPE__tds__GetSystemLogResponse, sizeof(struct _tds__GetSystemLogResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetSystemLogResponse * SOAP_FMAC4 soap_new__tds__GetSystemLogResponse(struct soap *soap, int n)
{
	struct _tds__GetSystemLogResponse *p;
	struct _tds__GetSystemLogResponse *a = (struct _tds__GetSystemLogResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetSystemLogResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetSystemLogResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemLogResponse(struct soap *soap, const struct _tds__GetSystemLogResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetSystemLogResponse(soap, tag ? tag : "tds:GetSystemLogResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemLogResponse * SOAP_FMAC4 soap_get__tds__GetSystemLogResponse(struct soap *soap, struct _tds__GetSystemLogResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemLog(struct soap *soap, struct _tds__GetSystemLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__SystemLogType(soap, &a->LogType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemLog(struct soap *soap, const struct _tds__GetSystemLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemLog(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemLog), type))
		return soap->error;
	if (soap_out_tt__SystemLogType(soap, "tds:LogType", -1, &a->LogType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemLog * SOAP_FMAC4 soap_in__tds__GetSystemLog(struct soap *soap, const char *tag, struct _tds__GetSystemLog *a, const char *type)
{
	size_t soap_flag_LogType = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetSystemLog *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemLog, sizeof(struct _tds__GetSystemLog), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemLog(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LogType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__SystemLogType(soap, "tds:LogType", &a->LogType, "tt:SystemLogType"))
				{	soap_flag_LogType--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_LogType > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetSystemLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemLog, SOAP_TYPE__tds__GetSystemLog, sizeof(struct _tds__GetSystemLog), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetSystemLog * SOAP_FMAC4 soap_new__tds__GetSystemLog(struct soap *soap, int n)
{
	struct _tds__GetSystemLog *p;
	struct _tds__GetSystemLog *a = (struct _tds__GetSystemLog*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetSystemLog));
	for (p = a; p && n--; p++)
		soap_default__tds__GetSystemLog(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemLog(struct soap *soap, const struct _tds__GetSystemLog *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetSystemLog(soap, tag ? tag : "tds:GetSystemLog", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemLog * SOAP_FMAC4 soap_get__tds__GetSystemLog(struct soap *soap, struct _tds__GetSystemLog *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemSupportInformationResponse(struct soap *soap, struct _tds__GetSystemSupportInformationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SupportInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemSupportInformationResponse(struct soap *soap, const struct _tds__GetSystemSupportInformationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__SupportInformation(soap, &a->SupportInformation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemSupportInformationResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemSupportInformationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemSupportInformationResponse), type))
		return soap->error;
	if (a->SupportInformation)
		soap_element_result(soap, "tds:SupportInformation");
	if (!a->SupportInformation)
	{	if (soap_element_nil(soap, "tds:SupportInformation"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__SupportInformation(soap, "tds:SupportInformation", -1, &a->SupportInformation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemSupportInformationResponse * SOAP_FMAC4 soap_in__tds__GetSystemSupportInformationResponse(struct soap *soap, const char *tag, struct _tds__GetSystemSupportInformationResponse *a, const char *type)
{
	size_t soap_flag_SupportInformation = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetSystemSupportInformationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemSupportInformationResponse, sizeof(struct _tds__GetSystemSupportInformationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemSupportInformationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SupportInformation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SupportInformation(soap, "tds:SupportInformation", &a->SupportInformation, "tt:SupportInformation"))
				{	soap_flag_SupportInformation--;
					continue;
				}
			soap_check_result(soap, "tds:SupportInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SupportInformation > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetSystemSupportInformationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemSupportInformationResponse, SOAP_TYPE__tds__GetSystemSupportInformationResponse, sizeof(struct _tds__GetSystemSupportInformationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetSystemSupportInformationResponse * SOAP_FMAC4 soap_new__tds__GetSystemSupportInformationResponse(struct soap *soap, int n)
{
	struct _tds__GetSystemSupportInformationResponse *p;
	struct _tds__GetSystemSupportInformationResponse *a = (struct _tds__GetSystemSupportInformationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetSystemSupportInformationResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetSystemSupportInformationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemSupportInformationResponse(struct soap *soap, const struct _tds__GetSystemSupportInformationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetSystemSupportInformationResponse(soap, tag ? tag : "tds:GetSystemSupportInformationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemSupportInformationResponse * SOAP_FMAC4 soap_get__tds__GetSystemSupportInformationResponse(struct soap *soap, struct _tds__GetSystemSupportInformationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemSupportInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemSupportInformation(struct soap *soap, struct _tds__GetSystemSupportInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemSupportInformation(struct soap *soap, const struct _tds__GetSystemSupportInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemSupportInformation(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemSupportInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemSupportInformation), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemSupportInformation * SOAP_FMAC4 soap_in__tds__GetSystemSupportInformation(struct soap *soap, const char *tag, struct _tds__GetSystemSupportInformation *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetSystemSupportInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemSupportInformation, sizeof(struct _tds__GetSystemSupportInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemSupportInformation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemSupportInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemSupportInformation, SOAP_TYPE__tds__GetSystemSupportInformation, sizeof(struct _tds__GetSystemSupportInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetSystemSupportInformation * SOAP_FMAC4 soap_new__tds__GetSystemSupportInformation(struct soap *soap, int n)
{
	struct _tds__GetSystemSupportInformation *p;
	struct _tds__GetSystemSupportInformation *a = (struct _tds__GetSystemSupportInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetSystemSupportInformation));
	for (p = a; p && n--; p++)
		soap_default__tds__GetSystemSupportInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemSupportInformation(struct soap *soap, const struct _tds__GetSystemSupportInformation *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetSystemSupportInformation(soap, tag ? tag : "tds:GetSystemSupportInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemSupportInformation * SOAP_FMAC4 soap_get__tds__GetSystemSupportInformation(struct soap *soap, struct _tds__GetSystemSupportInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemSupportInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemBackupResponse(struct soap *soap, struct _tds__GetSystemBackupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeBackupFiles = 0;
	a->BackupFiles = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemBackupResponse(struct soap *soap, const struct _tds__GetSystemBackupResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->BackupFiles)
	{	int i;
		for (i = 0; i < (int)a->__sizeBackupFiles; i++)
		{
			soap_embedded(soap, a->BackupFiles + i, SOAP_TYPE_tt__BackupFile);
			soap_serialize_tt__BackupFile(soap, a->BackupFiles + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemBackupResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemBackupResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemBackupResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeBackupFiles");
	if (a->BackupFiles)
	{	int i;
		for (i = 0; i < (int)a->__sizeBackupFiles; i++)
			if (soap_out_tt__BackupFile(soap, "tds:BackupFiles", -1, a->BackupFiles + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemBackupResponse * SOAP_FMAC4 soap_in__tds__GetSystemBackupResponse(struct soap *soap, const char *tag, struct _tds__GetSystemBackupResponse *a, const char *type)
{
	struct soap_blist *soap_blist_BackupFiles = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetSystemBackupResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemBackupResponse, sizeof(struct _tds__GetSystemBackupResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemBackupResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:BackupFiles", 1, NULL))
			{	if (a->BackupFiles == NULL)
				{	if (soap_blist_BackupFiles == NULL)
						soap_blist_BackupFiles = soap_alloc_block(soap);
					a->BackupFiles = (struct tt__BackupFile *)soap_push_block_max(soap, soap_blist_BackupFiles, sizeof(struct tt__BackupFile));
					if (a->BackupFiles == NULL)
						return NULL;
					soap_default_tt__BackupFile(soap, a->BackupFiles);
				}
				soap_revert(soap);
				if (soap_in_tt__BackupFile(soap, "tds:BackupFiles", a->BackupFiles, "tt:BackupFile"))
				{	a->__sizeBackupFiles++;
					a->BackupFiles = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeBackupFiles");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->BackupFiles)
			soap_pop_block(soap, soap_blist_BackupFiles);
		if (a->__sizeBackupFiles)
		{	a->BackupFiles = (struct tt__BackupFile *)soap_save_block(soap, soap_blist_BackupFiles, NULL, 1);
		}
		else
		{	a->BackupFiles = NULL;
			if (soap_blist_BackupFiles)
				soap_end_block(soap, soap_blist_BackupFiles);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeBackupFiles < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetSystemBackupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemBackupResponse, SOAP_TYPE__tds__GetSystemBackupResponse, sizeof(struct _tds__GetSystemBackupResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetSystemBackupResponse * SOAP_FMAC4 soap_new__tds__GetSystemBackupResponse(struct soap *soap, int n)
{
	struct _tds__GetSystemBackupResponse *p;
	struct _tds__GetSystemBackupResponse *a = (struct _tds__GetSystemBackupResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetSystemBackupResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetSystemBackupResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemBackupResponse(struct soap *soap, const struct _tds__GetSystemBackupResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetSystemBackupResponse(soap, tag ? tag : "tds:GetSystemBackupResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemBackupResponse * SOAP_FMAC4 soap_get__tds__GetSystemBackupResponse(struct soap *soap, struct _tds__GetSystemBackupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemBackupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemBackup(struct soap *soap, struct _tds__GetSystemBackup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemBackup(struct soap *soap, const struct _tds__GetSystemBackup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemBackup(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemBackup *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemBackup), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemBackup * SOAP_FMAC4 soap_in__tds__GetSystemBackup(struct soap *soap, const char *tag, struct _tds__GetSystemBackup *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetSystemBackup *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemBackup, sizeof(struct _tds__GetSystemBackup), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemBackup(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemBackup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemBackup, SOAP_TYPE__tds__GetSystemBackup, sizeof(struct _tds__GetSystemBackup), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetSystemBackup * SOAP_FMAC4 soap_new__tds__GetSystemBackup(struct soap *soap, int n)
{
	struct _tds__GetSystemBackup *p;
	struct _tds__GetSystemBackup *a = (struct _tds__GetSystemBackup*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetSystemBackup));
	for (p = a; p && n--; p++)
		soap_default__tds__GetSystemBackup(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemBackup(struct soap *soap, const struct _tds__GetSystemBackup *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetSystemBackup(soap, tag ? tag : "tds:GetSystemBackup", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemBackup * SOAP_FMAC4 soap_get__tds__GetSystemBackup(struct soap *soap, struct _tds__GetSystemBackup *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemBackup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__RestoreSystemResponse(struct soap *soap, struct _tds__RestoreSystemResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__RestoreSystemResponse(struct soap *soap, const struct _tds__RestoreSystemResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RestoreSystemResponse(struct soap *soap, const char *tag, int id, const struct _tds__RestoreSystemResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RestoreSystemResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__RestoreSystemResponse * SOAP_FMAC4 soap_in__tds__RestoreSystemResponse(struct soap *soap, const char *tag, struct _tds__RestoreSystemResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__RestoreSystemResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RestoreSystemResponse, sizeof(struct _tds__RestoreSystemResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__RestoreSystemResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__RestoreSystemResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RestoreSystemResponse, SOAP_TYPE__tds__RestoreSystemResponse, sizeof(struct _tds__RestoreSystemResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__RestoreSystemResponse * SOAP_FMAC4 soap_new__tds__RestoreSystemResponse(struct soap *soap, int n)
{
	struct _tds__RestoreSystemResponse *p;
	struct _tds__RestoreSystemResponse *a = (struct _tds__RestoreSystemResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__RestoreSystemResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__RestoreSystemResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__RestoreSystemResponse(struct soap *soap, const struct _tds__RestoreSystemResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__RestoreSystemResponse(soap, tag ? tag : "tds:RestoreSystemResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RestoreSystemResponse * SOAP_FMAC4 soap_get__tds__RestoreSystemResponse(struct soap *soap, struct _tds__RestoreSystemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RestoreSystemResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__RestoreSystem(struct soap *soap, struct _tds__RestoreSystem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeBackupFiles = 0;
	a->BackupFiles = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__RestoreSystem(struct soap *soap, const struct _tds__RestoreSystem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->BackupFiles)
	{	int i;
		for (i = 0; i < (int)a->__sizeBackupFiles; i++)
		{
			soap_embedded(soap, a->BackupFiles + i, SOAP_TYPE_tt__BackupFile);
			soap_serialize_tt__BackupFile(soap, a->BackupFiles + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RestoreSystem(struct soap *soap, const char *tag, int id, const struct _tds__RestoreSystem *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RestoreSystem), type))
		return soap->error;
	if (a->BackupFiles)
	{	int i;
		for (i = 0; i < (int)a->__sizeBackupFiles; i++)
			if (soap_out_tt__BackupFile(soap, "tds:BackupFiles", -1, a->BackupFiles + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__RestoreSystem * SOAP_FMAC4 soap_in__tds__RestoreSystem(struct soap *soap, const char *tag, struct _tds__RestoreSystem *a, const char *type)
{
	struct soap_blist *soap_blist_BackupFiles = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__RestoreSystem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RestoreSystem, sizeof(struct _tds__RestoreSystem), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__RestoreSystem(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:BackupFiles", 1, NULL))
			{	if (a->BackupFiles == NULL)
				{	if (soap_blist_BackupFiles == NULL)
						soap_blist_BackupFiles = soap_alloc_block(soap);
					a->BackupFiles = (struct tt__BackupFile *)soap_push_block_max(soap, soap_blist_BackupFiles, sizeof(struct tt__BackupFile));
					if (a->BackupFiles == NULL)
						return NULL;
					soap_default_tt__BackupFile(soap, a->BackupFiles);
				}
				soap_revert(soap);
				if (soap_in_tt__BackupFile(soap, "tds:BackupFiles", a->BackupFiles, "tt:BackupFile"))
				{	a->__sizeBackupFiles++;
					a->BackupFiles = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->BackupFiles)
			soap_pop_block(soap, soap_blist_BackupFiles);
		if (a->__sizeBackupFiles)
		{	a->BackupFiles = (struct tt__BackupFile *)soap_save_block(soap, soap_blist_BackupFiles, NULL, 1);
		}
		else
		{	a->BackupFiles = NULL;
			if (soap_blist_BackupFiles)
				soap_end_block(soap, soap_blist_BackupFiles);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeBackupFiles < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__RestoreSystem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RestoreSystem, SOAP_TYPE__tds__RestoreSystem, sizeof(struct _tds__RestoreSystem), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__RestoreSystem * SOAP_FMAC4 soap_new__tds__RestoreSystem(struct soap *soap, int n)
{
	struct _tds__RestoreSystem *p;
	struct _tds__RestoreSystem *a = (struct _tds__RestoreSystem*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__RestoreSystem));
	for (p = a; p && n--; p++)
		soap_default__tds__RestoreSystem(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__RestoreSystem(struct soap *soap, const struct _tds__RestoreSystem *a, const char *tag, const char *type)
{
	if (soap_out__tds__RestoreSystem(soap, tag ? tag : "tds:RestoreSystem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RestoreSystem * SOAP_FMAC4 soap_get__tds__RestoreSystem(struct soap *soap, struct _tds__RestoreSystem *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RestoreSystem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SystemRebootResponse(struct soap *soap, struct _tds__SystemRebootResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SystemRebootResponse(struct soap *soap, const struct _tds__SystemRebootResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Message);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SystemRebootResponse(struct soap *soap, const char *tag, int id, const struct _tds__SystemRebootResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SystemRebootResponse), type))
		return soap->error;
	if (a->Message)
		soap_element_result(soap, "tds:Message");
	if (!a->Message)
	{	if (soap_element_nil(soap, "tds:Message"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "tds:Message", -1, (char*const*)&a->Message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SystemRebootResponse * SOAP_FMAC4 soap_in__tds__SystemRebootResponse(struct soap *soap, const char *tag, struct _tds__SystemRebootResponse *a, const char *type)
{
	size_t soap_flag_Message = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SystemRebootResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SystemRebootResponse, sizeof(struct _tds__SystemRebootResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SystemRebootResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:Message", (char**)&a->Message, "xsd:string"))
				{	soap_flag_Message--;
					continue;
				}
			soap_check_result(soap, "tds:Message");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Message > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SystemRebootResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SystemRebootResponse, SOAP_TYPE__tds__SystemRebootResponse, sizeof(struct _tds__SystemRebootResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SystemRebootResponse * SOAP_FMAC4 soap_new__tds__SystemRebootResponse(struct soap *soap, int n)
{
	struct _tds__SystemRebootResponse *p;
	struct _tds__SystemRebootResponse *a = (struct _tds__SystemRebootResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SystemRebootResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SystemRebootResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SystemRebootResponse(struct soap *soap, const struct _tds__SystemRebootResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SystemRebootResponse(soap, tag ? tag : "tds:SystemRebootResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SystemRebootResponse * SOAP_FMAC4 soap_get__tds__SystemRebootResponse(struct soap *soap, struct _tds__SystemRebootResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SystemRebootResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SystemReboot(struct soap *soap, struct _tds__SystemReboot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SystemReboot(struct soap *soap, const struct _tds__SystemReboot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SystemReboot(struct soap *soap, const char *tag, int id, const struct _tds__SystemReboot *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SystemReboot), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SystemReboot * SOAP_FMAC4 soap_in__tds__SystemReboot(struct soap *soap, const char *tag, struct _tds__SystemReboot *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SystemReboot *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SystemReboot, sizeof(struct _tds__SystemReboot), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SystemReboot(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SystemReboot *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SystemReboot, SOAP_TYPE__tds__SystemReboot, sizeof(struct _tds__SystemReboot), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SystemReboot * SOAP_FMAC4 soap_new__tds__SystemReboot(struct soap *soap, int n)
{
	struct _tds__SystemReboot *p;
	struct _tds__SystemReboot *a = (struct _tds__SystemReboot*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SystemReboot));
	for (p = a; p && n--; p++)
		soap_default__tds__SystemReboot(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SystemReboot(struct soap *soap, const struct _tds__SystemReboot *a, const char *tag, const char *type)
{
	if (soap_out__tds__SystemReboot(soap, tag ? tag : "tds:SystemReboot", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SystemReboot * SOAP_FMAC4 soap_get__tds__SystemReboot(struct soap *soap, struct _tds__SystemReboot *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SystemReboot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__UpgradeSystemFirmwareResponse(struct soap *soap, struct _tds__UpgradeSystemFirmwareResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Message);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__UpgradeSystemFirmwareResponse(struct soap *soap, const struct _tds__UpgradeSystemFirmwareResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Message);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__UpgradeSystemFirmwareResponse(struct soap *soap, const char *tag, int id, const struct _tds__UpgradeSystemFirmwareResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse), type))
		return soap->error;
	if (a->Message)
		soap_element_result(soap, "tds:Message");
	if (soap_out_string(soap, "tds:Message", -1, (char*const*)&a->Message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__UpgradeSystemFirmwareResponse * SOAP_FMAC4 soap_in__tds__UpgradeSystemFirmwareResponse(struct soap *soap, const char *tag, struct _tds__UpgradeSystemFirmwareResponse *a, const char *type)
{
	size_t soap_flag_Message = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__UpgradeSystemFirmwareResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse, sizeof(struct _tds__UpgradeSystemFirmwareResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__UpgradeSystemFirmwareResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Message && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:Message", (char**)&a->Message, "xsd:string"))
				{	soap_flag_Message--;
					continue;
				}
			soap_check_result(soap, "tds:Message");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__UpgradeSystemFirmwareResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse, sizeof(struct _tds__UpgradeSystemFirmwareResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__UpgradeSystemFirmwareResponse * SOAP_FMAC4 soap_new__tds__UpgradeSystemFirmwareResponse(struct soap *soap, int n)
{
	struct _tds__UpgradeSystemFirmwareResponse *p;
	struct _tds__UpgradeSystemFirmwareResponse *a = (struct _tds__UpgradeSystemFirmwareResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__UpgradeSystemFirmwareResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__UpgradeSystemFirmwareResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__UpgradeSystemFirmwareResponse(struct soap *soap, const struct _tds__UpgradeSystemFirmwareResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__UpgradeSystemFirmwareResponse(soap, tag ? tag : "tds:UpgradeSystemFirmwareResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__UpgradeSystemFirmwareResponse * SOAP_FMAC4 soap_get__tds__UpgradeSystemFirmwareResponse(struct soap *soap, struct _tds__UpgradeSystemFirmwareResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__UpgradeSystemFirmwareResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__UpgradeSystemFirmware(struct soap *soap, struct _tds__UpgradeSystemFirmware *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Firmware = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__UpgradeSystemFirmware(struct soap *soap, const struct _tds__UpgradeSystemFirmware *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AttachmentData(soap, &a->Firmware);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__UpgradeSystemFirmware(struct soap *soap, const char *tag, int id, const struct _tds__UpgradeSystemFirmware *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__UpgradeSystemFirmware), type))
		return soap->error;
	if (!a->Firmware)
	{	if (soap_element_nil(soap, "tds:Firmware"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__AttachmentData(soap, "tds:Firmware", -1, &a->Firmware, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__UpgradeSystemFirmware * SOAP_FMAC4 soap_in__tds__UpgradeSystemFirmware(struct soap *soap, const char *tag, struct _tds__UpgradeSystemFirmware *a, const char *type)
{
	size_t soap_flag_Firmware = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__UpgradeSystemFirmware *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__UpgradeSystemFirmware, sizeof(struct _tds__UpgradeSystemFirmware), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__UpgradeSystemFirmware(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Firmware && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AttachmentData(soap, "tds:Firmware", &a->Firmware, "tt:AttachmentData"))
				{	soap_flag_Firmware--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Firmware > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__UpgradeSystemFirmware *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__UpgradeSystemFirmware, SOAP_TYPE__tds__UpgradeSystemFirmware, sizeof(struct _tds__UpgradeSystemFirmware), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__UpgradeSystemFirmware * SOAP_FMAC4 soap_new__tds__UpgradeSystemFirmware(struct soap *soap, int n)
{
	struct _tds__UpgradeSystemFirmware *p;
	struct _tds__UpgradeSystemFirmware *a = (struct _tds__UpgradeSystemFirmware*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__UpgradeSystemFirmware));
	for (p = a; p && n--; p++)
		soap_default__tds__UpgradeSystemFirmware(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__UpgradeSystemFirmware(struct soap *soap, const struct _tds__UpgradeSystemFirmware *a, const char *tag, const char *type)
{
	if (soap_out__tds__UpgradeSystemFirmware(soap, tag ? tag : "tds:UpgradeSystemFirmware", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__UpgradeSystemFirmware * SOAP_FMAC4 soap_get__tds__UpgradeSystemFirmware(struct soap *soap, struct _tds__UpgradeSystemFirmware *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__UpgradeSystemFirmware(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetSystemFactoryDefaultResponse(struct soap *soap, struct _tds__SetSystemFactoryDefaultResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetSystemFactoryDefaultResponse(struct soap *soap, const struct _tds__SetSystemFactoryDefaultResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetSystemFactoryDefaultResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetSystemFactoryDefaultResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefaultResponse * SOAP_FMAC4 soap_in__tds__SetSystemFactoryDefaultResponse(struct soap *soap, const char *tag, struct _tds__SetSystemFactoryDefaultResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetSystemFactoryDefaultResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse, sizeof(struct _tds__SetSystemFactoryDefaultResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetSystemFactoryDefaultResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetSystemFactoryDefaultResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse, sizeof(struct _tds__SetSystemFactoryDefaultResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefaultResponse * SOAP_FMAC4 soap_new__tds__SetSystemFactoryDefaultResponse(struct soap *soap, int n)
{
	struct _tds__SetSystemFactoryDefaultResponse *p;
	struct _tds__SetSystemFactoryDefaultResponse *a = (struct _tds__SetSystemFactoryDefaultResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetSystemFactoryDefaultResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetSystemFactoryDefaultResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetSystemFactoryDefaultResponse(struct soap *soap, const struct _tds__SetSystemFactoryDefaultResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetSystemFactoryDefaultResponse(soap, tag ? tag : "tds:SetSystemFactoryDefaultResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefaultResponse * SOAP_FMAC4 soap_get__tds__SetSystemFactoryDefaultResponse(struct soap *soap, struct _tds__SetSystemFactoryDefaultResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetSystemFactoryDefaultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetSystemFactoryDefault(struct soap *soap, struct _tds__SetSystemFactoryDefault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__FactoryDefaultType(soap, &a->FactoryDefault);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetSystemFactoryDefault(struct soap *soap, const struct _tds__SetSystemFactoryDefault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, int id, const struct _tds__SetSystemFactoryDefault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetSystemFactoryDefault), type))
		return soap->error;
	if (soap_out_tt__FactoryDefaultType(soap, "tds:FactoryDefault", -1, &a->FactoryDefault, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefault * SOAP_FMAC4 soap_in__tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, struct _tds__SetSystemFactoryDefault *a, const char *type)
{
	size_t soap_flag_FactoryDefault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetSystemFactoryDefault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetSystemFactoryDefault, sizeof(struct _tds__SetSystemFactoryDefault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetSystemFactoryDefault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FactoryDefault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__FactoryDefaultType(soap, "tds:FactoryDefault", &a->FactoryDefault, "tt:FactoryDefaultType"))
				{	soap_flag_FactoryDefault--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FactoryDefault > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetSystemFactoryDefault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetSystemFactoryDefault, SOAP_TYPE__tds__SetSystemFactoryDefault, sizeof(struct _tds__SetSystemFactoryDefault), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefault * SOAP_FMAC4 soap_new__tds__SetSystemFactoryDefault(struct soap *soap, int n)
{
	struct _tds__SetSystemFactoryDefault *p;
	struct _tds__SetSystemFactoryDefault *a = (struct _tds__SetSystemFactoryDefault*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetSystemFactoryDefault));
	for (p = a; p && n--; p++)
		soap_default__tds__SetSystemFactoryDefault(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetSystemFactoryDefault(struct soap *soap, const struct _tds__SetSystemFactoryDefault *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetSystemFactoryDefault(soap, tag ? tag : "tds:SetSystemFactoryDefault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefault * SOAP_FMAC4 soap_get__tds__SetSystemFactoryDefault(struct soap *soap, struct _tds__SetSystemFactoryDefault *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetSystemFactoryDefault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemDateAndTimeResponse(struct soap *soap, struct _tds__GetSystemDateAndTimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SystemDateAndTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemDateAndTimeResponse(struct soap *soap, const struct _tds__GetSystemDateAndTimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__SystemDateTime(soap, &a->SystemDateAndTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemDateAndTimeResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemDateAndTimeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemDateAndTimeResponse), type))
		return soap->error;
	if (a->SystemDateAndTime)
		soap_element_result(soap, "tds:SystemDateAndTime");
	if (!a->SystemDateAndTime)
	{	if (soap_element_nil(soap, "tds:SystemDateAndTime"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__SystemDateTime(soap, "tds:SystemDateAndTime", -1, &a->SystemDateAndTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTimeResponse * SOAP_FMAC4 soap_in__tds__GetSystemDateAndTimeResponse(struct soap *soap, const char *tag, struct _tds__GetSystemDateAndTimeResponse *a, const char *type)
{
	size_t soap_flag_SystemDateAndTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetSystemDateAndTimeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemDateAndTimeResponse, sizeof(struct _tds__GetSystemDateAndTimeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemDateAndTimeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SystemDateAndTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SystemDateTime(soap, "tds:SystemDateAndTime", &a->SystemDateAndTime, "tt:SystemDateTime"))
				{	soap_flag_SystemDateAndTime--;
					continue;
				}
			soap_check_result(soap, "tds:SystemDateAndTime");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SystemDateAndTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetSystemDateAndTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemDateAndTimeResponse, SOAP_TYPE__tds__GetSystemDateAndTimeResponse, sizeof(struct _tds__GetSystemDateAndTimeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTimeResponse * SOAP_FMAC4 soap_new__tds__GetSystemDateAndTimeResponse(struct soap *soap, int n)
{
	struct _tds__GetSystemDateAndTimeResponse *p;
	struct _tds__GetSystemDateAndTimeResponse *a = (struct _tds__GetSystemDateAndTimeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetSystemDateAndTimeResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetSystemDateAndTimeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemDateAndTimeResponse(struct soap *soap, const struct _tds__GetSystemDateAndTimeResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetSystemDateAndTimeResponse(soap, tag ? tag : "tds:GetSystemDateAndTimeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTimeResponse * SOAP_FMAC4 soap_get__tds__GetSystemDateAndTimeResponse(struct soap *soap, struct _tds__GetSystemDateAndTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemDateAndTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemDateAndTime(struct soap *soap, struct _tds__GetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemDateAndTime(struct soap *soap, const struct _tds__GetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemDateAndTime(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemDateAndTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemDateAndTime), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTime * SOAP_FMAC4 soap_in__tds__GetSystemDateAndTime(struct soap *soap, const char *tag, struct _tds__GetSystemDateAndTime *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetSystemDateAndTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemDateAndTime, sizeof(struct _tds__GetSystemDateAndTime), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemDateAndTime(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemDateAndTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemDateAndTime, SOAP_TYPE__tds__GetSystemDateAndTime, sizeof(struct _tds__GetSystemDateAndTime), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTime * SOAP_FMAC4 soap_new__tds__GetSystemDateAndTime(struct soap *soap, int n)
{
	struct _tds__GetSystemDateAndTime *p;
	struct _tds__GetSystemDateAndTime *a = (struct _tds__GetSystemDateAndTime*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetSystemDateAndTime));
	for (p = a; p && n--; p++)
		soap_default__tds__GetSystemDateAndTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemDateAndTime(struct soap *soap, const struct _tds__GetSystemDateAndTime *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetSystemDateAndTime(soap, tag ? tag : "tds:GetSystemDateAndTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTime * SOAP_FMAC4 soap_get__tds__GetSystemDateAndTime(struct soap *soap, struct _tds__GetSystemDateAndTime *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetSystemDateAndTimeResponse(struct soap *soap, struct _tds__SetSystemDateAndTimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetSystemDateAndTimeResponse(struct soap *soap, const struct _tds__SetSystemDateAndTimeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetSystemDateAndTimeResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetSystemDateAndTimeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetSystemDateAndTimeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTimeResponse * SOAP_FMAC4 soap_in__tds__SetSystemDateAndTimeResponse(struct soap *soap, const char *tag, struct _tds__SetSystemDateAndTimeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetSystemDateAndTimeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetSystemDateAndTimeResponse, sizeof(struct _tds__SetSystemDateAndTimeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetSystemDateAndTimeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetSystemDateAndTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetSystemDateAndTimeResponse, SOAP_TYPE__tds__SetSystemDateAndTimeResponse, sizeof(struct _tds__SetSystemDateAndTimeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTimeResponse * SOAP_FMAC4 soap_new__tds__SetSystemDateAndTimeResponse(struct soap *soap, int n)
{
	struct _tds__SetSystemDateAndTimeResponse *p;
	struct _tds__SetSystemDateAndTimeResponse *a = (struct _tds__SetSystemDateAndTimeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetSystemDateAndTimeResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetSystemDateAndTimeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetSystemDateAndTimeResponse(struct soap *soap, const struct _tds__SetSystemDateAndTimeResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetSystemDateAndTimeResponse(soap, tag ? tag : "tds:SetSystemDateAndTimeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTimeResponse * SOAP_FMAC4 soap_get__tds__SetSystemDateAndTimeResponse(struct soap *soap, struct _tds__SetSystemDateAndTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetSystemDateAndTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetSystemDateAndTime(struct soap *soap, struct _tds__SetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__SetDateTimeType(soap, &a->DateTimeType);
	soap_default_xsd__boolean(soap, &a->DaylightSavings);
	a->TimeZone = NULL;
	a->UTCDateTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetSystemDateAndTime(struct soap *soap, const struct _tds__SetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->DaylightSavings, SOAP_TYPE_xsd__boolean);
	soap_serialize_PointerTott__TimeZone(soap, &a->TimeZone);
	soap_serialize_PointerTott__DateTime(soap, &a->UTCDateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetSystemDateAndTime(struct soap *soap, const char *tag, int id, const struct _tds__SetSystemDateAndTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetSystemDateAndTime), type))
		return soap->error;
	if (soap_out_tt__SetDateTimeType(soap, "tds:DateTimeType", -1, &a->DateTimeType, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tds:DaylightSavings", -1, &a->DaylightSavings, ""))
		return soap->error;
	if (soap_out_PointerTott__TimeZone(soap, "tds:TimeZone", -1, &a->TimeZone, ""))
		return soap->error;
	if (soap_out_PointerTott__DateTime(soap, "tds:UTCDateTime", -1, &a->UTCDateTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTime * SOAP_FMAC4 soap_in__tds__SetSystemDateAndTime(struct soap *soap, const char *tag, struct _tds__SetSystemDateAndTime *a, const char *type)
{
	size_t soap_flag_DateTimeType = 1;
	size_t soap_flag_DaylightSavings = 1;
	size_t soap_flag_TimeZone = 1;
	size_t soap_flag_UTCDateTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetSystemDateAndTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetSystemDateAndTime, sizeof(struct _tds__SetSystemDateAndTime), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetSystemDateAndTime(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DateTimeType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__SetDateTimeType(soap, "tds:DateTimeType", &a->DateTimeType, "tt:SetDateTimeType"))
				{	soap_flag_DateTimeType--;
					continue;
				}
			if (soap_flag_DaylightSavings && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tds:DaylightSavings", &a->DaylightSavings, "xsd:boolean"))
				{	soap_flag_DaylightSavings--;
					continue;
				}
			if (soap_flag_TimeZone && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__TimeZone(soap, "tds:TimeZone", &a->TimeZone, "tt:TimeZone"))
				{	soap_flag_TimeZone--;
					continue;
				}
			if (soap_flag_UTCDateTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DateTime(soap, "tds:UTCDateTime", &a->UTCDateTime, "tt:DateTime"))
				{	soap_flag_UTCDateTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DateTimeType > 0 || soap_flag_DaylightSavings > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetSystemDateAndTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetSystemDateAndTime, SOAP_TYPE__tds__SetSystemDateAndTime, sizeof(struct _tds__SetSystemDateAndTime), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTime * SOAP_FMAC4 soap_new__tds__SetSystemDateAndTime(struct soap *soap, int n)
{
	struct _tds__SetSystemDateAndTime *p;
	struct _tds__SetSystemDateAndTime *a = (struct _tds__SetSystemDateAndTime*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetSystemDateAndTime));
	for (p = a; p && n--; p++)
		soap_default__tds__SetSystemDateAndTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetSystemDateAndTime(struct soap *soap, const struct _tds__SetSystemDateAndTime *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetSystemDateAndTime(soap, tag ? tag : "tds:SetSystemDateAndTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTime * SOAP_FMAC4 soap_get__tds__SetSystemDateAndTime(struct soap *soap, struct _tds__SetSystemDateAndTime *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDeviceInformationResponse(struct soap *soap, struct _tds__GetDeviceInformationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Manufacturer);
	soap_default_string(soap, &a->Model);
	soap_default_string(soap, &a->FirmwareVersion);
	soap_default_string(soap, &a->SerialNumber);
	soap_default_string(soap, &a->HardwareId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDeviceInformationResponse(struct soap *soap, const struct _tds__GetDeviceInformationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Manufacturer);
	soap_serialize_string(soap, (char*const*)&a->Model);
	soap_serialize_string(soap, (char*const*)&a->FirmwareVersion);
	soap_serialize_string(soap, (char*const*)&a->SerialNumber);
	soap_serialize_string(soap, (char*const*)&a->HardwareId);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDeviceInformationResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDeviceInformationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDeviceInformationResponse), type))
		return soap->error;
	if (a->Manufacturer)
		soap_element_result(soap, "tds:Manufacturer");
	if (!a->Manufacturer)
	{	if (soap_element_nil(soap, "tds:Manufacturer"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "tds:Manufacturer", -1, (char*const*)&a->Manufacturer, ""))
		return soap->error;
	if (!a->Model)
	{	if (soap_element_nil(soap, "tds:Model"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "tds:Model", -1, (char*const*)&a->Model, ""))
		return soap->error;
	if (!a->FirmwareVersion)
	{	if (soap_element_nil(soap, "tds:FirmwareVersion"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "tds:FirmwareVersion", -1, (char*const*)&a->FirmwareVersion, ""))
		return soap->error;
	if (!a->SerialNumber)
	{	if (soap_element_nil(soap, "tds:SerialNumber"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "tds:SerialNumber", -1, (char*const*)&a->SerialNumber, ""))
		return soap->error;
	if (!a->HardwareId)
	{	if (soap_element_nil(soap, "tds:HardwareId"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "tds:HardwareId", -1, (char*const*)&a->HardwareId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDeviceInformationResponse * SOAP_FMAC4 soap_in__tds__GetDeviceInformationResponse(struct soap *soap, const char *tag, struct _tds__GetDeviceInformationResponse *a, const char *type)
{
	size_t soap_flag_Manufacturer = 1;
	size_t soap_flag_Model = 1;
	size_t soap_flag_FirmwareVersion = 1;
	size_t soap_flag_SerialNumber = 1;
	size_t soap_flag_HardwareId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDeviceInformationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDeviceInformationResponse, sizeof(struct _tds__GetDeviceInformationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDeviceInformationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Manufacturer && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:Manufacturer", (char**)&a->Manufacturer, "xsd:string"))
				{	soap_flag_Manufacturer--;
					continue;
				}
			if (soap_flag_Model && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:Model", (char**)&a->Model, "xsd:string"))
				{	soap_flag_Model--;
					continue;
				}
			if (soap_flag_FirmwareVersion && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:FirmwareVersion", (char**)&a->FirmwareVersion, "xsd:string"))
				{	soap_flag_FirmwareVersion--;
					continue;
				}
			if (soap_flag_SerialNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:SerialNumber", (char**)&a->SerialNumber, "xsd:string"))
				{	soap_flag_SerialNumber--;
					continue;
				}
			if (soap_flag_HardwareId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:HardwareId", (char**)&a->HardwareId, "xsd:string"))
				{	soap_flag_HardwareId--;
					continue;
				}
			soap_check_result(soap, "tds:Manufacturer");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Manufacturer > 0 || soap_flag_Model > 0 || soap_flag_FirmwareVersion > 0 || soap_flag_SerialNumber > 0 || soap_flag_HardwareId > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetDeviceInformationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDeviceInformationResponse, SOAP_TYPE__tds__GetDeviceInformationResponse, sizeof(struct _tds__GetDeviceInformationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDeviceInformationResponse * SOAP_FMAC4 soap_new__tds__GetDeviceInformationResponse(struct soap *soap, int n)
{
	struct _tds__GetDeviceInformationResponse *p;
	struct _tds__GetDeviceInformationResponse *a = (struct _tds__GetDeviceInformationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDeviceInformationResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDeviceInformationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDeviceInformationResponse(struct soap *soap, const struct _tds__GetDeviceInformationResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDeviceInformationResponse(soap, tag ? tag : "tds:GetDeviceInformationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDeviceInformationResponse * SOAP_FMAC4 soap_get__tds__GetDeviceInformationResponse(struct soap *soap, struct _tds__GetDeviceInformationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDeviceInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDeviceInformation(struct soap *soap, struct _tds__GetDeviceInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDeviceInformation(struct soap *soap, const struct _tds__GetDeviceInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDeviceInformation(struct soap *soap, const char *tag, int id, const struct _tds__GetDeviceInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDeviceInformation), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDeviceInformation * SOAP_FMAC4 soap_in__tds__GetDeviceInformation(struct soap *soap, const char *tag, struct _tds__GetDeviceInformation *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDeviceInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDeviceInformation, sizeof(struct _tds__GetDeviceInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDeviceInformation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDeviceInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDeviceInformation, SOAP_TYPE__tds__GetDeviceInformation, sizeof(struct _tds__GetDeviceInformation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDeviceInformation * SOAP_FMAC4 soap_new__tds__GetDeviceInformation(struct soap *soap, int n)
{
	struct _tds__GetDeviceInformation *p;
	struct _tds__GetDeviceInformation *a = (struct _tds__GetDeviceInformation*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDeviceInformation));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDeviceInformation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDeviceInformation(struct soap *soap, const struct _tds__GetDeviceInformation *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDeviceInformation(soap, tag ? tag : "tds:GetDeviceInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDeviceInformation * SOAP_FMAC4 soap_get__tds__GetDeviceInformation(struct soap *soap, struct _tds__GetDeviceInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDeviceInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetServiceCapabilitiesResponse(struct soap *soap, struct _tds__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tds__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotds__DeviceServiceCapabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tds:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_nil(soap, "tds:Capabilities"))
			return soap->error;
	}
	else
	if (soap_out_PointerTotds__DeviceServiceCapabilities(soap, "tds:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__tds__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tds__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetServiceCapabilitiesResponse, sizeof(struct _tds__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotds__DeviceServiceCapabilities(soap, "tds:Capabilities", &a->Capabilities, "tds:DeviceServiceCapabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			soap_check_result(soap, "tds:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetServiceCapabilitiesResponse, SOAP_TYPE__tds__GetServiceCapabilitiesResponse, sizeof(struct _tds__GetServiceCapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_new__tds__GetServiceCapabilitiesResponse(struct soap *soap, int n)
{
	struct _tds__GetServiceCapabilitiesResponse *p;
	struct _tds__GetServiceCapabilitiesResponse *a = (struct _tds__GetServiceCapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetServiceCapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetServiceCapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tds__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetServiceCapabilitiesResponse(soap, tag ? tag : "tds:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__tds__GetServiceCapabilitiesResponse(struct soap *soap, struct _tds__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetServiceCapabilities(struct soap *soap, struct _tds__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetServiceCapabilities(struct soap *soap, const struct _tds__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _tds__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetServiceCapabilities * SOAP_FMAC4 soap_in__tds__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tds__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetServiceCapabilities, sizeof(struct _tds__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetServiceCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetServiceCapabilities, SOAP_TYPE__tds__GetServiceCapabilities, sizeof(struct _tds__GetServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetServiceCapabilities * SOAP_FMAC4 soap_new__tds__GetServiceCapabilities(struct soap *soap, int n)
{
	struct _tds__GetServiceCapabilities *p;
	struct _tds__GetServiceCapabilities *a = (struct _tds__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default__tds__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetServiceCapabilities(struct soap *soap, const struct _tds__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetServiceCapabilities(soap, tag ? tag : "tds:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetServiceCapabilities * SOAP_FMAC4 soap_get__tds__GetServiceCapabilities(struct soap *soap, struct _tds__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetServicesResponse(struct soap *soap, struct _tds__GetServicesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeService = 0;
	a->Service = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetServicesResponse(struct soap *soap, const struct _tds__GetServicesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Service)
	{	int i;
		for (i = 0; i < (int)a->__sizeService; i++)
		{
			soap_embedded(soap, a->Service + i, SOAP_TYPE_tds__Service);
			soap_serialize_tds__Service(soap, a->Service + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetServicesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetServicesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetServicesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeService");
	if (a->Service)
	{	int i;
		for (i = 0; i < (int)a->__sizeService; i++)
			if (soap_out_tds__Service(soap, "tds:Service", -1, a->Service + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetServicesResponse * SOAP_FMAC4 soap_in__tds__GetServicesResponse(struct soap *soap, const char *tag, struct _tds__GetServicesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Service = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetServicesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetServicesResponse, sizeof(struct _tds__GetServicesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetServicesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Service", 1, NULL))
			{	if (a->Service == NULL)
				{	if (soap_blist_Service == NULL)
						soap_blist_Service = soap_alloc_block(soap);
					a->Service = (struct tds__Service *)soap_push_block_max(soap, soap_blist_Service, sizeof(struct tds__Service));
					if (a->Service == NULL)
						return NULL;
					soap_default_tds__Service(soap, a->Service);
				}
				soap_revert(soap);
				if (soap_in_tds__Service(soap, "tds:Service", a->Service, "tds:Service"))
				{	a->__sizeService++;
					a->Service = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeService");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Service)
			soap_pop_block(soap, soap_blist_Service);
		if (a->__sizeService)
		{	a->Service = (struct tds__Service *)soap_save_block(soap, soap_blist_Service, NULL, 1);
		}
		else
		{	a->Service = NULL;
			if (soap_blist_Service)
				soap_end_block(soap, soap_blist_Service);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeService < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetServicesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetServicesResponse, SOAP_TYPE__tds__GetServicesResponse, sizeof(struct _tds__GetServicesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetServicesResponse * SOAP_FMAC4 soap_new__tds__GetServicesResponse(struct soap *soap, int n)
{
	struct _tds__GetServicesResponse *p;
	struct _tds__GetServicesResponse *a = (struct _tds__GetServicesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetServicesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetServicesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetServicesResponse(struct soap *soap, const struct _tds__GetServicesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetServicesResponse(soap, tag ? tag : "tds:GetServicesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetServicesResponse * SOAP_FMAC4 soap_get__tds__GetServicesResponse(struct soap *soap, struct _tds__GetServicesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetServicesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetServices(struct soap *soap, struct _tds__GetServices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->IncludeCapability);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetServices(struct soap *soap, const struct _tds__GetServices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->IncludeCapability, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetServices(struct soap *soap, const char *tag, int id, const struct _tds__GetServices *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetServices), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tds:IncludeCapability", -1, &a->IncludeCapability, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetServices * SOAP_FMAC4 soap_in__tds__GetServices(struct soap *soap, const char *tag, struct _tds__GetServices *a, const char *type)
{
	size_t soap_flag_IncludeCapability = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetServices *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetServices, sizeof(struct _tds__GetServices), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetServices(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IncludeCapability && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tds:IncludeCapability", &a->IncludeCapability, "xsd:boolean"))
				{	soap_flag_IncludeCapability--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_IncludeCapability > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetServices *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetServices, SOAP_TYPE__tds__GetServices, sizeof(struct _tds__GetServices), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetServices * SOAP_FMAC4 soap_new__tds__GetServices(struct soap *soap, int n)
{
	struct _tds__GetServices *p;
	struct _tds__GetServices *a = (struct _tds__GetServices*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetServices));
	for (p = a; p && n--; p++)
		soap_default__tds__GetServices(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetServices(struct soap *soap, const struct _tds__GetServices *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetServices(soap, tag ? tag : "tds:GetServices", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetServices * SOAP_FMAC4 soap_get__tds__GetServices(struct soap *soap, struct _tds__GetServices *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetServices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__StorageConfigurationData_Extension(struct soap *soap, struct _tds__StorageConfigurationData_Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__StorageConfigurationData_Extension(struct soap *soap, const struct _tds__StorageConfigurationData_Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StorageConfigurationData_Extension(struct soap *soap, const char *tag, int id, const struct _tds__StorageConfigurationData_Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StorageConfigurationData_Extension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__StorageConfigurationData_Extension * SOAP_FMAC4 soap_in__tds__StorageConfigurationData_Extension(struct soap *soap, const char *tag, struct _tds__StorageConfigurationData_Extension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__StorageConfigurationData_Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StorageConfigurationData_Extension, sizeof(struct _tds__StorageConfigurationData_Extension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__StorageConfigurationData_Extension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__StorageConfigurationData_Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StorageConfigurationData_Extension, SOAP_TYPE__tds__StorageConfigurationData_Extension, sizeof(struct _tds__StorageConfigurationData_Extension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__StorageConfigurationData_Extension * SOAP_FMAC4 soap_new__tds__StorageConfigurationData_Extension(struct soap *soap, int n)
{
	struct _tds__StorageConfigurationData_Extension *p;
	struct _tds__StorageConfigurationData_Extension *a = (struct _tds__StorageConfigurationData_Extension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__StorageConfigurationData_Extension));
	for (p = a; p && n--; p++)
		soap_default__tds__StorageConfigurationData_Extension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__StorageConfigurationData_Extension(struct soap *soap, const struct _tds__StorageConfigurationData_Extension *a, const char *tag, const char *type)
{
	if (soap_out__tds__StorageConfigurationData_Extension(soap, tag ? tag : "tds:StorageConfigurationData-Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__StorageConfigurationData_Extension * SOAP_FMAC4 soap_get__tds__StorageConfigurationData_Extension(struct soap *soap, struct _tds__StorageConfigurationData_Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StorageConfigurationData_Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tds__StorageConfigurationData(struct soap *soap, struct tds__StorageConfigurationData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->LocalPath);
	soap_default_xsd__anyURI(soap, &a->StorageUri);
	a->User = NULL;
	a->Extension = NULL;
	soap_default_string(soap, &a->type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tds__StorageConfigurationData(struct soap *soap, const struct tds__StorageConfigurationData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->LocalPath);
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->StorageUri);
	soap_serialize_PointerTotds__UserCredential(soap, &a->User);
	soap_serialize_PointerTo_tds__StorageConfigurationData_Extension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__StorageConfigurationData(struct soap *soap, const char *tag, int id, const struct tds__StorageConfigurationData *a, const char *type)
{
	if (a->type)
		soap_set_attr(soap, "type", soap_string2s(soap, a->type), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__StorageConfigurationData), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tds:LocalPath", -1, (char*const*)&a->LocalPath, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tds:StorageUri", -1, (char*const*)&a->StorageUri, ""))
		return soap->error;
	if (soap_out_PointerTotds__UserCredential(soap, "tds:User", -1, &a->User, ""))
		return soap->error;
	if (soap_out_PointerTo_tds__StorageConfigurationData_Extension(soap, "tds:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tds__StorageConfigurationData * SOAP_FMAC4 soap_in_tds__StorageConfigurationData(struct soap *soap, const char *tag, struct tds__StorageConfigurationData *a, const char *type)
{
	size_t soap_flag_LocalPath = 1;
	size_t soap_flag_StorageUri = 1;
	size_t soap_flag_User = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tds__StorageConfigurationData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__StorageConfigurationData, sizeof(struct tds__StorageConfigurationData), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tds__StorageConfigurationData(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "type", 1), &a->type))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LocalPath && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tds:LocalPath", (char**)&a->LocalPath, "xsd:anyURI"))
				{	soap_flag_LocalPath--;
					continue;
				}
			if (soap_flag_StorageUri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tds:StorageUri", (char**)&a->StorageUri, "xsd:anyURI"))
				{	soap_flag_StorageUri--;
					continue;
				}
			if (soap_flag_User && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotds__UserCredential(soap, "tds:User", &a->User, "tds:UserCredential"))
				{	soap_flag_User--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__StorageConfigurationData_Extension(soap, "tds:Extension", &a->Extension, ""))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tds__StorageConfigurationData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__StorageConfigurationData, SOAP_TYPE_tds__StorageConfigurationData, sizeof(struct tds__StorageConfigurationData), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tds__StorageConfigurationData * SOAP_FMAC4 soap_new_tds__StorageConfigurationData(struct soap *soap, int n)
{
	struct tds__StorageConfigurationData *p;
	struct tds__StorageConfigurationData *a = (struct tds__StorageConfigurationData*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tds__StorageConfigurationData));
	for (p = a; p && n--; p++)
		soap_default_tds__StorageConfigurationData(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tds__StorageConfigurationData(struct soap *soap, const struct tds__StorageConfigurationData *a, const char *tag, const char *type)
{
	if (soap_out_tds__StorageConfigurationData(soap, tag ? tag : "tds:StorageConfigurationData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__StorageConfigurationData * SOAP_FMAC4 soap_get_tds__StorageConfigurationData(struct soap *soap, struct tds__StorageConfigurationData *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__StorageConfigurationData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__UserCredential_Extension(struct soap *soap, struct _tds__UserCredential_Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__UserCredential_Extension(struct soap *soap, const struct _tds__UserCredential_Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__UserCredential_Extension(struct soap *soap, const char *tag, int id, const struct _tds__UserCredential_Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__UserCredential_Extension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__UserCredential_Extension * SOAP_FMAC4 soap_in__tds__UserCredential_Extension(struct soap *soap, const char *tag, struct _tds__UserCredential_Extension *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__UserCredential_Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__UserCredential_Extension, sizeof(struct _tds__UserCredential_Extension), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__UserCredential_Extension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__UserCredential_Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__UserCredential_Extension, SOAP_TYPE__tds__UserCredential_Extension, sizeof(struct _tds__UserCredential_Extension), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__UserCredential_Extension * SOAP_FMAC4 soap_new__tds__UserCredential_Extension(struct soap *soap, int n)
{
	struct _tds__UserCredential_Extension *p;
	struct _tds__UserCredential_Extension *a = (struct _tds__UserCredential_Extension*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__UserCredential_Extension));
	for (p = a; p && n--; p++)
		soap_default__tds__UserCredential_Extension(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__UserCredential_Extension(struct soap *soap, const struct _tds__UserCredential_Extension *a, const char *tag, const char *type)
{
	if (soap_out__tds__UserCredential_Extension(soap, tag ? tag : "tds:UserCredential-Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__UserCredential_Extension * SOAP_FMAC4 soap_get__tds__UserCredential_Extension(struct soap *soap, struct _tds__UserCredential_Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__UserCredential_Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tds__UserCredential(struct soap *soap, struct tds__UserCredential *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->UserName);
	soap_default_string(soap, &a->Password);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tds__UserCredential(struct soap *soap, const struct tds__UserCredential *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->UserName);
	soap_serialize_string(soap, (char*const*)&a->Password);
	soap_serialize_PointerTo_tds__UserCredential_Extension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__UserCredential(struct soap *soap, const char *tag, int id, const struct tds__UserCredential *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__UserCredential), type))
		return soap->error;
	if (!a->UserName)
	{	if (soap_element_nil(soap, "tds:UserName"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "tds:UserName", -1, (char*const*)&a->UserName, ""))
		return soap->error;
	if (soap_out_string(soap, "tds:Password", -1, (char*const*)&a->Password, ""))
		return soap->error;
	if (soap_out_PointerTo_tds__UserCredential_Extension(soap, "tds:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tds__UserCredential * SOAP_FMAC4 soap_in_tds__UserCredential(struct soap *soap, const char *tag, struct tds__UserCredential *a, const char *type)
{
	size_t soap_flag_UserName = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tds__UserCredential *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__UserCredential, sizeof(struct tds__UserCredential), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tds__UserCredential(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UserName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:UserName", (char**)&a->UserName, "xsd:string"))
				{	soap_flag_UserName--;
					continue;
				}
			if (soap_flag_Password && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:Password", (char**)&a->Password, "xsd:string"))
				{	soap_flag_Password--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__UserCredential_Extension(soap, "tds:Extension", &a->Extension, ""))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_UserName > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tds__UserCredential *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__UserCredential, SOAP_TYPE_tds__UserCredential, sizeof(struct tds__UserCredential), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tds__UserCredential * SOAP_FMAC4 soap_new_tds__UserCredential(struct soap *soap, int n)
{
	struct tds__UserCredential *p;
	struct tds__UserCredential *a = (struct tds__UserCredential*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tds__UserCredential));
	for (p = a; p && n--; p++)
		soap_default_tds__UserCredential(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tds__UserCredential(struct soap *soap, const struct tds__UserCredential *a, const char *tag, const char *type)
{
	if (soap_out_tds__UserCredential(soap, tag ? tag : "tds:UserCredential", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__UserCredential * SOAP_FMAC4 soap_get_tds__UserCredential(struct soap *soap, struct tds__UserCredential *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__UserCredential(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tds__MiscCapabilities(struct soap *soap, struct tds__MiscCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__StringAttrList(soap, &a->AuxiliaryCommands);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tds__MiscCapabilities(struct soap *soap, const struct tds__MiscCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__MiscCapabilities(struct soap *soap, const char *tag, int id, const struct tds__MiscCapabilities *a, const char *type)
{
	if (a->AuxiliaryCommands)
		soap_set_attr(soap, "AuxiliaryCommands", soap_tt__StringAttrList2s(soap, a->AuxiliaryCommands), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__MiscCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tds__MiscCapabilities * SOAP_FMAC4 soap_in_tds__MiscCapabilities(struct soap *soap, const char *tag, struct tds__MiscCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tds__MiscCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__MiscCapabilities, sizeof(struct tds__MiscCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tds__MiscCapabilities(soap, a);
	if (soap_s2tt__StringAttrList(soap, soap_attr_value(soap, "AuxiliaryCommands", 0), &a->AuxiliaryCommands))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tds__MiscCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__MiscCapabilities, SOAP_TYPE_tds__MiscCapabilities, sizeof(struct tds__MiscCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tds__MiscCapabilities * SOAP_FMAC4 soap_new_tds__MiscCapabilities(struct soap *soap, int n)
{
	struct tds__MiscCapabilities *p;
	struct tds__MiscCapabilities *a = (struct tds__MiscCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tds__MiscCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tds__MiscCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tds__MiscCapabilities(struct soap *soap, const struct tds__MiscCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tds__MiscCapabilities(soap, tag ? tag : "tds:MiscCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__MiscCapabilities * SOAP_FMAC4 soap_get_tds__MiscCapabilities(struct soap *soap, struct tds__MiscCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__MiscCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tds__SystemCapabilities(struct soap *soap, struct tds__SystemCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DiscoveryResolve = NULL;
	a->DiscoveryBye = NULL;
	a->RemoteDiscovery = NULL;
	a->SystemBackup = NULL;
	a->SystemLogging = NULL;
	a->FirmwareUpgrade = NULL;
	a->HttpFirmwareUpgrade = NULL;
	a->HttpSystemBackup = NULL;
	a->HttpSystemLogging = NULL;
	a->HttpSupportInformation = NULL;
	a->StorageConfiguration = NULL;
	a->MaxStorageConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tds__SystemCapabilities(struct soap *soap, const struct tds__SystemCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__SystemCapabilities(struct soap *soap, const char *tag, int id, const struct tds__SystemCapabilities *a, const char *type)
{
	if (a->DiscoveryResolve)
		soap_set_attr(soap, "DiscoveryResolve", soap_xsd__boolean2s(soap, *a->DiscoveryResolve), 1);
	if (a->DiscoveryBye)
		soap_set_attr(soap, "DiscoveryBye", soap_xsd__boolean2s(soap, *a->DiscoveryBye), 1);
	if (a->RemoteDiscovery)
		soap_set_attr(soap, "RemoteDiscovery", soap_xsd__boolean2s(soap, *a->RemoteDiscovery), 1);
	if (a->SystemBackup)
		soap_set_attr(soap, "SystemBackup", soap_xsd__boolean2s(soap, *a->SystemBackup), 1);
	if (a->SystemLogging)
		soap_set_attr(soap, "SystemLogging", soap_xsd__boolean2s(soap, *a->SystemLogging), 1);
	if (a->FirmwareUpgrade)
		soap_set_attr(soap, "FirmwareUpgrade", soap_xsd__boolean2s(soap, *a->FirmwareUpgrade), 1);
	if (a->HttpFirmwareUpgrade)
		soap_set_attr(soap, "HttpFirmwareUpgrade", soap_xsd__boolean2s(soap, *a->HttpFirmwareUpgrade), 1);
	if (a->HttpSystemBackup)
		soap_set_attr(soap, "HttpSystemBackup", soap_xsd__boolean2s(soap, *a->HttpSystemBackup), 1);
	if (a->HttpSystemLogging)
		soap_set_attr(soap, "HttpSystemLogging", soap_xsd__boolean2s(soap, *a->HttpSystemLogging), 1);
	if (a->HttpSupportInformation)
		soap_set_attr(soap, "HttpSupportInformation", soap_xsd__boolean2s(soap, *a->HttpSupportInformation), 1);
	if (a->StorageConfiguration)
		soap_set_attr(soap, "StorageConfiguration", soap_xsd__boolean2s(soap, *a->StorageConfiguration), 1);
	if (a->MaxStorageConfigurations)
		soap_set_attr(soap, "MaxStorageConfigurations", soap_int2s(soap, *a->MaxStorageConfigurations), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__SystemCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tds__SystemCapabilities * SOAP_FMAC4 soap_in_tds__SystemCapabilities(struct soap *soap, const char *tag, struct tds__SystemCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tds__SystemCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__SystemCapabilities, sizeof(struct tds__SystemCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tds__SystemCapabilities(soap, a);
	{	const char *t = soap_attr_value(soap, "DiscoveryResolve", 0);
		if (t)
		{
			if (!(a->DiscoveryResolve = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->DiscoveryResolve))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "DiscoveryBye", 0);
		if (t)
		{
			if (!(a->DiscoveryBye = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->DiscoveryBye))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "RemoteDiscovery", 0);
		if (t)
		{
			if (!(a->RemoteDiscovery = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->RemoteDiscovery))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "SystemBackup", 0);
		if (t)
		{
			if (!(a->SystemBackup = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->SystemBackup))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "SystemLogging", 0);
		if (t)
		{
			if (!(a->SystemLogging = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->SystemLogging))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "FirmwareUpgrade", 0);
		if (t)
		{
			if (!(a->FirmwareUpgrade = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->FirmwareUpgrade))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "HttpFirmwareUpgrade", 0);
		if (t)
		{
			if (!(a->HttpFirmwareUpgrade = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->HttpFirmwareUpgrade))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "HttpSystemBackup", 0);
		if (t)
		{
			if (!(a->HttpSystemBackup = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->HttpSystemBackup))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "HttpSystemLogging", 0);
		if (t)
		{
			if (!(a->HttpSystemLogging = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->HttpSystemLogging))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "HttpSupportInformation", 0);
		if (t)
		{
			if (!(a->HttpSupportInformation = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->HttpSupportInformation))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "StorageConfiguration", 0);
		if (t)
		{
			if (!(a->StorageConfiguration = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->StorageConfiguration))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "MaxStorageConfigurations", 0);
		if (t)
		{
			if (!(a->MaxStorageConfigurations = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->MaxStorageConfigurations))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tds__SystemCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__SystemCapabilities, SOAP_TYPE_tds__SystemCapabilities, sizeof(struct tds__SystemCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tds__SystemCapabilities * SOAP_FMAC4 soap_new_tds__SystemCapabilities(struct soap *soap, int n)
{
	struct tds__SystemCapabilities *p;
	struct tds__SystemCapabilities *a = (struct tds__SystemCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tds__SystemCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tds__SystemCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tds__SystemCapabilities(struct soap *soap, const struct tds__SystemCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tds__SystemCapabilities(soap, tag ? tag : "tds:SystemCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__SystemCapabilities * SOAP_FMAC4 soap_get_tds__SystemCapabilities(struct soap *soap, struct tds__SystemCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__SystemCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tds__SecurityCapabilities(struct soap *soap, struct tds__SecurityCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->TLS1_x002e0 = NULL;
	a->TLS1_x002e1 = NULL;
	a->TLS1_x002e2 = NULL;
	a->OnboardKeyGeneration = NULL;
	a->AccessPolicyConfig = NULL;
	a->DefaultAccessPolicy = NULL;
	a->Dot1X = NULL;
	a->RemoteUserHandling = NULL;
	a->X_x002e509Token = NULL;
	a->SAMLToken = NULL;
	a->KerberosToken = NULL;
	a->UsernameToken = NULL;
	a->HttpDigest = NULL;
	a->RELToken = NULL;
	soap_default_tds__EAPMethodTypes(soap, &a->SupportedEAPMethods);
	a->MaxUsers = NULL;
	a->MaxUserNameLength = NULL;
	a->MaxPasswordLength = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tds__SecurityCapabilities(struct soap *soap, const struct tds__SecurityCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__SecurityCapabilities(struct soap *soap, const char *tag, int id, const struct tds__SecurityCapabilities *a, const char *type)
{
	if (a->TLS1_x002e0)
		soap_set_attr(soap, "TLS1.0", soap_xsd__boolean2s(soap, *a->TLS1_x002e0), 1);
	if (a->TLS1_x002e1)
		soap_set_attr(soap, "TLS1.1", soap_xsd__boolean2s(soap, *a->TLS1_x002e1), 1);
	if (a->TLS1_x002e2)
		soap_set_attr(soap, "TLS1.2", soap_xsd__boolean2s(soap, *a->TLS1_x002e2), 1);
	if (a->OnboardKeyGeneration)
		soap_set_attr(soap, "OnboardKeyGeneration", soap_xsd__boolean2s(soap, *a->OnboardKeyGeneration), 1);
	if (a->AccessPolicyConfig)
		soap_set_attr(soap, "AccessPolicyConfig", soap_xsd__boolean2s(soap, *a->AccessPolicyConfig), 1);
	if (a->DefaultAccessPolicy)
		soap_set_attr(soap, "DefaultAccessPolicy", soap_xsd__boolean2s(soap, *a->DefaultAccessPolicy), 1);
	if (a->Dot1X)
		soap_set_attr(soap, "Dot1X", soap_xsd__boolean2s(soap, *a->Dot1X), 1);
	if (a->RemoteUserHandling)
		soap_set_attr(soap, "RemoteUserHandling", soap_xsd__boolean2s(soap, *a->RemoteUserHandling), 1);
	if (a->X_x002e509Token)
		soap_set_attr(soap, "X.509Token", soap_xsd__boolean2s(soap, *a->X_x002e509Token), 1);
	if (a->SAMLToken)
		soap_set_attr(soap, "SAMLToken", soap_xsd__boolean2s(soap, *a->SAMLToken), 1);
	if (a->KerberosToken)
		soap_set_attr(soap, "KerberosToken", soap_xsd__boolean2s(soap, *a->KerberosToken), 1);
	if (a->UsernameToken)
		soap_set_attr(soap, "UsernameToken", soap_xsd__boolean2s(soap, *a->UsernameToken), 1);
	if (a->HttpDigest)
		soap_set_attr(soap, "HttpDigest", soap_xsd__boolean2s(soap, *a->HttpDigest), 1);
	if (a->RELToken)
		soap_set_attr(soap, "RELToken", soap_xsd__boolean2s(soap, *a->RELToken), 1);
	if (a->SupportedEAPMethods)
		soap_set_attr(soap, "SupportedEAPMethods", soap_tds__EAPMethodTypes2s(soap, a->SupportedEAPMethods), 1);
	if (a->MaxUsers)
		soap_set_attr(soap, "MaxUsers", soap_int2s(soap, *a->MaxUsers), 1);
	if (a->MaxUserNameLength)
		soap_set_attr(soap, "MaxUserNameLength", soap_int2s(soap, *a->MaxUserNameLength), 1);
	if (a->MaxPasswordLength)
		soap_set_attr(soap, "MaxPasswordLength", soap_int2s(soap, *a->MaxPasswordLength), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__SecurityCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tds__SecurityCapabilities * SOAP_FMAC4 soap_in_tds__SecurityCapabilities(struct soap *soap, const char *tag, struct tds__SecurityCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tds__SecurityCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__SecurityCapabilities, sizeof(struct tds__SecurityCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tds__SecurityCapabilities(soap, a);
	{	const char *t = soap_attr_value(soap, "TLS1.0", 0);
		if (t)
		{
			if (!(a->TLS1_x002e0 = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->TLS1_x002e0))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "TLS1.1", 0);
		if (t)
		{
			if (!(a->TLS1_x002e1 = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->TLS1_x002e1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "TLS1.2", 0);
		if (t)
		{
			if (!(a->TLS1_x002e2 = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->TLS1_x002e2))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "OnboardKeyGeneration", 0);
		if (t)
		{
			if (!(a->OnboardKeyGeneration = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->OnboardKeyGeneration))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "AccessPolicyConfig", 0);
		if (t)
		{
			if (!(a->AccessPolicyConfig = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->AccessPolicyConfig))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "DefaultAccessPolicy", 0);
		if (t)
		{
			if (!(a->DefaultAccessPolicy = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->DefaultAccessPolicy))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Dot1X", 0);
		if (t)
		{
			if (!(a->Dot1X = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->Dot1X))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "RemoteUserHandling", 0);
		if (t)
		{
			if (!(a->RemoteUserHandling = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->RemoteUserHandling))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "X.509Token", 0);
		if (t)
		{
			if (!(a->X_x002e509Token = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->X_x002e509Token))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "SAMLToken", 0);
		if (t)
		{
			if (!(a->SAMLToken = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->SAMLToken))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "KerberosToken", 0);
		if (t)
		{
			if (!(a->KerberosToken = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->KerberosToken))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "UsernameToken", 0);
		if (t)
		{
			if (!(a->UsernameToken = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->UsernameToken))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "HttpDigest", 0);
		if (t)
		{
			if (!(a->HttpDigest = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->HttpDigest))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "RELToken", 0);
		if (t)
		{
			if (!(a->RELToken = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->RELToken))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2tds__EAPMethodTypes(soap, soap_attr_value(soap, "SupportedEAPMethods", 0), &a->SupportedEAPMethods))
		return NULL;
	{	const char *t = soap_attr_value(soap, "MaxUsers", 0);
		if (t)
		{
			if (!(a->MaxUsers = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->MaxUsers))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "MaxUserNameLength", 0);
		if (t)
		{
			if (!(a->MaxUserNameLength = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->MaxUserNameLength))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "MaxPasswordLength", 0);
		if (t)
		{
			if (!(a->MaxPasswordLength = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->MaxPasswordLength))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tds__SecurityCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__SecurityCapabilities, SOAP_TYPE_tds__SecurityCapabilities, sizeof(struct tds__SecurityCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tds__SecurityCapabilities * SOAP_FMAC4 soap_new_tds__SecurityCapabilities(struct soap *soap, int n)
{
	struct tds__SecurityCapabilities *p;
	struct tds__SecurityCapabilities *a = (struct tds__SecurityCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tds__SecurityCapabilities));
	for (p = a; p && n--; p++)
		soap_default_tds__SecurityCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tds__SecurityCapabilities(struct soap *soap, const struct tds__SecurityCapabilities *a, const char *tag, const char *type)
{
	if (soap_out_tds__SecurityCapabilities(soap, tag ? tag : "tds:SecurityCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__SecurityCapabilities * SOAP_FMAC4 soap_get_tds__SecurityCapabilities(struct soap *soap, struct tds__SecurityCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__SecurityCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
