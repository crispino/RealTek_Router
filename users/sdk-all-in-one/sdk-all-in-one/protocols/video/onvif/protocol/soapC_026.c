/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:59 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, struct _tds__SetNetworkDefaultGatewayResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, const struct _tds__SetNetworkDefaultGatewayResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetNetworkDefaultGatewayResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_in__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, struct _tds__SetNetworkDefaultGatewayResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetNetworkDefaultGatewayResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse, sizeof(struct _tds__SetNetworkDefaultGatewayResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetNetworkDefaultGatewayResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetNetworkDefaultGatewayResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse, sizeof(struct _tds__SetNetworkDefaultGatewayResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_new__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, int n)
{
	struct _tds__SetNetworkDefaultGatewayResponse *p;
	struct _tds__SetNetworkDefaultGatewayResponse *a = (struct _tds__SetNetworkDefaultGatewayResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetNetworkDefaultGatewayResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetNetworkDefaultGatewayResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, const struct _tds__SetNetworkDefaultGatewayResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetNetworkDefaultGatewayResponse(soap, tag ? tag : "tds:SetNetworkDefaultGatewayResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_get__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, struct _tds__SetNetworkDefaultGatewayResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkDefaultGatewayResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetNetworkDefaultGateway(struct soap *soap, struct _tds__SetNetworkDefaultGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeIPv4Address = 0;
	a->IPv4Address = NULL;
	a->__sizeIPv6Address = 0;
	a->IPv6Address = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetNetworkDefaultGateway(struct soap *soap, const struct _tds__SetNetworkDefaultGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->IPv4Address)
	{	int i;
		for (i = 0; i < (int)a->__sizeIPv4Address; i++)
		{
			soap_serialize_tt__IPv4Address(soap, (char*const*)(a->IPv4Address + i));
		}
	}
	if (a->IPv6Address)
	{	int i;
		for (i = 0; i < (int)a->__sizeIPv6Address; i++)
		{
			soap_serialize_tt__IPv6Address(soap, (char*const*)(a->IPv6Address + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, const struct _tds__SetNetworkDefaultGateway *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkDefaultGateway), type))
		return soap->error;
	if (a->IPv4Address)
	{	int i;
		for (i = 0; i < (int)a->__sizeIPv4Address; i++)
			soap_out_string(soap, "tds:IPv4Address", -1, (char*const*)(a->IPv4Address + i), "");
	}
	if (a->IPv6Address)
	{	int i;
		for (i = 0; i < (int)a->__sizeIPv6Address; i++)
			soap_out_string(soap, "tds:IPv6Address", -1, (char*const*)(a->IPv6Address + i), "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetNetworkDefaultGateway * SOAP_FMAC4 soap_in__tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, struct _tds__SetNetworkDefaultGateway *a, const char *type)
{
	struct soap_blist *soap_blist_IPv4Address = NULL;
	struct soap_blist *soap_blist_IPv6Address = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetNetworkDefaultGateway *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkDefaultGateway, sizeof(struct _tds__SetNetworkDefaultGateway), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetNetworkDefaultGateway(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:IPv4Address", 1, NULL))
			{	if (a->IPv4Address == NULL)
				{	if (soap_blist_IPv4Address == NULL)
						soap_blist_IPv4Address = soap_alloc_block(soap);
					a->IPv4Address = (char **)soap_push_block_max(soap, soap_blist_IPv4Address, sizeof(char *));
					if (a->IPv4Address == NULL)
						return NULL;
					*a->IPv4Address = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__IPv4Address(soap, "tds:IPv4Address", (char**)a->IPv4Address, "tt:IPv4Address"))
				{	a->__sizeIPv4Address++;
					a->IPv4Address = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:IPv6Address", 1, NULL))
			{	if (a->IPv6Address == NULL)
				{	if (soap_blist_IPv6Address == NULL)
						soap_blist_IPv6Address = soap_alloc_block(soap);
					a->IPv6Address = (char **)soap_push_block_max(soap, soap_blist_IPv6Address, sizeof(char *));
					if (a->IPv6Address == NULL)
						return NULL;
					*a->IPv6Address = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__IPv6Address(soap, "tds:IPv6Address", (char**)a->IPv6Address, "tt:IPv6Address"))
				{	a->__sizeIPv6Address++;
					a->IPv6Address = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->IPv4Address)
			soap_pop_block(soap, soap_blist_IPv4Address);
		if (a->__sizeIPv4Address)
		{	a->IPv4Address = (char **)soap_save_block(soap, soap_blist_IPv4Address, NULL, 1);
		}
		else
		{	a->IPv4Address = NULL;
			if (soap_blist_IPv4Address)
				soap_end_block(soap, soap_blist_IPv4Address);
		}
		if (a->IPv6Address)
			soap_pop_block(soap, soap_blist_IPv6Address);
		if (a->__sizeIPv6Address)
		{	a->IPv6Address = (char **)soap_save_block(soap, soap_blist_IPv6Address, NULL, 1);
		}
		else
		{	a->IPv6Address = NULL;
			if (soap_blist_IPv6Address)
				soap_end_block(soap, soap_blist_IPv6Address);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetNetworkDefaultGateway *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkDefaultGateway, SOAP_TYPE__tds__SetNetworkDefaultGateway, sizeof(struct _tds__SetNetworkDefaultGateway), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetNetworkDefaultGateway * SOAP_FMAC4 soap_new__tds__SetNetworkDefaultGateway(struct soap *soap, int n)
{
	struct _tds__SetNetworkDefaultGateway *p;
	struct _tds__SetNetworkDefaultGateway *a = (struct _tds__SetNetworkDefaultGateway*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetNetworkDefaultGateway));
	for (p = a; p && n--; p++)
		soap_default__tds__SetNetworkDefaultGateway(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetNetworkDefaultGateway(struct soap *soap, const struct _tds__SetNetworkDefaultGateway *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetNetworkDefaultGateway(soap, tag ? tag : "tds:SetNetworkDefaultGateway", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkDefaultGateway * SOAP_FMAC4 soap_get__tds__SetNetworkDefaultGateway(struct soap *soap, struct _tds__SetNetworkDefaultGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, struct _tds__GetNetworkDefaultGatewayResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->NetworkGateway = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, const struct _tds__GetNetworkDefaultGatewayResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__NetworkGateway(soap, &a->NetworkGateway);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetNetworkDefaultGatewayResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse), type))
		return soap->error;
	if (a->NetworkGateway)
		soap_element_result(soap, "tds:NetworkGateway");
	if (!a->NetworkGateway)
	{	if (soap_element_nil(soap, "tds:NetworkGateway"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__NetworkGateway(soap, "tds:NetworkGateway", -1, &a->NetworkGateway, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_in__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, struct _tds__GetNetworkDefaultGatewayResponse *a, const char *type)
{
	size_t soap_flag_NetworkGateway = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetNetworkDefaultGatewayResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse, sizeof(struct _tds__GetNetworkDefaultGatewayResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetNetworkDefaultGatewayResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NetworkGateway && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkGateway(soap, "tds:NetworkGateway", &a->NetworkGateway, "tt:NetworkGateway"))
				{	soap_flag_NetworkGateway--;
					continue;
				}
			soap_check_result(soap, "tds:NetworkGateway");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_NetworkGateway > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetNetworkDefaultGatewayResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse, sizeof(struct _tds__GetNetworkDefaultGatewayResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_new__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, int n)
{
	struct _tds__GetNetworkDefaultGatewayResponse *p;
	struct _tds__GetNetworkDefaultGatewayResponse *a = (struct _tds__GetNetworkDefaultGatewayResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetNetworkDefaultGatewayResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetNetworkDefaultGatewayResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, const struct _tds__GetNetworkDefaultGatewayResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetNetworkDefaultGatewayResponse(soap, tag ? tag : "tds:GetNetworkDefaultGatewayResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_get__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, struct _tds__GetNetworkDefaultGatewayResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkDefaultGatewayResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetNetworkDefaultGateway(struct soap *soap, struct _tds__GetNetworkDefaultGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetNetworkDefaultGateway(struct soap *soap, const struct _tds__GetNetworkDefaultGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, const struct _tds__GetNetworkDefaultGateway *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkDefaultGateway), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetNetworkDefaultGateway * SOAP_FMAC4 soap_in__tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, struct _tds__GetNetworkDefaultGateway *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetNetworkDefaultGateway *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkDefaultGateway, sizeof(struct _tds__GetNetworkDefaultGateway), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetNetworkDefaultGateway(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetNetworkDefaultGateway *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkDefaultGateway, SOAP_TYPE__tds__GetNetworkDefaultGateway, sizeof(struct _tds__GetNetworkDefaultGateway), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetNetworkDefaultGateway * SOAP_FMAC4 soap_new__tds__GetNetworkDefaultGateway(struct soap *soap, int n)
{
	struct _tds__GetNetworkDefaultGateway *p;
	struct _tds__GetNetworkDefaultGateway *a = (struct _tds__GetNetworkDefaultGateway*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetNetworkDefaultGateway));
	for (p = a; p && n--; p++)
		soap_default__tds__GetNetworkDefaultGateway(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetNetworkDefaultGateway(struct soap *soap, const struct _tds__GetNetworkDefaultGateway *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetNetworkDefaultGateway(soap, tag ? tag : "tds:GetNetworkDefaultGateway", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkDefaultGateway * SOAP_FMAC4 soap_get__tds__GetNetworkDefaultGateway(struct soap *soap, struct _tds__GetNetworkDefaultGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetNetworkProtocolsResponse(struct soap *soap, struct _tds__SetNetworkProtocolsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetNetworkProtocolsResponse(struct soap *soap, const struct _tds__SetNetworkProtocolsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkProtocolsResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetNetworkProtocolsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkProtocolsResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetNetworkProtocolsResponse * SOAP_FMAC4 soap_in__tds__SetNetworkProtocolsResponse(struct soap *soap, const char *tag, struct _tds__SetNetworkProtocolsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetNetworkProtocolsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkProtocolsResponse, sizeof(struct _tds__SetNetworkProtocolsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetNetworkProtocolsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetNetworkProtocolsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkProtocolsResponse, SOAP_TYPE__tds__SetNetworkProtocolsResponse, sizeof(struct _tds__SetNetworkProtocolsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetNetworkProtocolsResponse * SOAP_FMAC4 soap_new__tds__SetNetworkProtocolsResponse(struct soap *soap, int n)
{
	struct _tds__SetNetworkProtocolsResponse *p;
	struct _tds__SetNetworkProtocolsResponse *a = (struct _tds__SetNetworkProtocolsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetNetworkProtocolsResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetNetworkProtocolsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetNetworkProtocolsResponse(struct soap *soap, const struct _tds__SetNetworkProtocolsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetNetworkProtocolsResponse(soap, tag ? tag : "tds:SetNetworkProtocolsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkProtocolsResponse * SOAP_FMAC4 soap_get__tds__SetNetworkProtocolsResponse(struct soap *soap, struct _tds__SetNetworkProtocolsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkProtocolsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetNetworkProtocols(struct soap *soap, struct _tds__SetNetworkProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNetworkProtocols = 0;
	a->NetworkProtocols = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetNetworkProtocols(struct soap *soap, const struct _tds__SetNetworkProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->NetworkProtocols)
	{	int i;
		for (i = 0; i < (int)a->__sizeNetworkProtocols; i++)
		{
			soap_embedded(soap, a->NetworkProtocols + i, SOAP_TYPE_tt__NetworkProtocol);
			soap_serialize_tt__NetworkProtocol(soap, a->NetworkProtocols + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkProtocols(struct soap *soap, const char *tag, int id, const struct _tds__SetNetworkProtocols *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkProtocols), type))
		return soap->error;
	if (a->NetworkProtocols)
	{	int i;
		for (i = 0; i < (int)a->__sizeNetworkProtocols; i++)
			if (soap_out_tt__NetworkProtocol(soap, "tds:NetworkProtocols", -1, a->NetworkProtocols + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetNetworkProtocols * SOAP_FMAC4 soap_in__tds__SetNetworkProtocols(struct soap *soap, const char *tag, struct _tds__SetNetworkProtocols *a, const char *type)
{
	struct soap_blist *soap_blist_NetworkProtocols = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetNetworkProtocols *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkProtocols, sizeof(struct _tds__SetNetworkProtocols), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetNetworkProtocols(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:NetworkProtocols", 1, NULL))
			{	if (a->NetworkProtocols == NULL)
				{	if (soap_blist_NetworkProtocols == NULL)
						soap_blist_NetworkProtocols = soap_alloc_block(soap);
					a->NetworkProtocols = (struct tt__NetworkProtocol *)soap_push_block_max(soap, soap_blist_NetworkProtocols, sizeof(struct tt__NetworkProtocol));
					if (a->NetworkProtocols == NULL)
						return NULL;
					soap_default_tt__NetworkProtocol(soap, a->NetworkProtocols);
				}
				soap_revert(soap);
				if (soap_in_tt__NetworkProtocol(soap, "tds:NetworkProtocols", a->NetworkProtocols, "tt:NetworkProtocol"))
				{	a->__sizeNetworkProtocols++;
					a->NetworkProtocols = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NetworkProtocols)
			soap_pop_block(soap, soap_blist_NetworkProtocols);
		if (a->__sizeNetworkProtocols)
		{	a->NetworkProtocols = (struct tt__NetworkProtocol *)soap_save_block(soap, soap_blist_NetworkProtocols, NULL, 1);
		}
		else
		{	a->NetworkProtocols = NULL;
			if (soap_blist_NetworkProtocols)
				soap_end_block(soap, soap_blist_NetworkProtocols);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeNetworkProtocols < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetNetworkProtocols *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkProtocols, SOAP_TYPE__tds__SetNetworkProtocols, sizeof(struct _tds__SetNetworkProtocols), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetNetworkProtocols * SOAP_FMAC4 soap_new__tds__SetNetworkProtocols(struct soap *soap, int n)
{
	struct _tds__SetNetworkProtocols *p;
	struct _tds__SetNetworkProtocols *a = (struct _tds__SetNetworkProtocols*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetNetworkProtocols));
	for (p = a; p && n--; p++)
		soap_default__tds__SetNetworkProtocols(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetNetworkProtocols(struct soap *soap, const struct _tds__SetNetworkProtocols *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetNetworkProtocols(soap, tag ? tag : "tds:SetNetworkProtocols", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkProtocols * SOAP_FMAC4 soap_get__tds__SetNetworkProtocols(struct soap *soap, struct _tds__SetNetworkProtocols *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetNetworkProtocolsResponse(struct soap *soap, struct _tds__GetNetworkProtocolsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNetworkProtocols = 0;
	a->NetworkProtocols = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetNetworkProtocolsResponse(struct soap *soap, const struct _tds__GetNetworkProtocolsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->NetworkProtocols)
	{	int i;
		for (i = 0; i < (int)a->__sizeNetworkProtocols; i++)
		{
			soap_embedded(soap, a->NetworkProtocols + i, SOAP_TYPE_tt__NetworkProtocol);
			soap_serialize_tt__NetworkProtocol(soap, a->NetworkProtocols + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkProtocolsResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetNetworkProtocolsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkProtocolsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeNetworkProtocols");
	if (a->NetworkProtocols)
	{	int i;
		for (i = 0; i < (int)a->__sizeNetworkProtocols; i++)
			if (soap_out_tt__NetworkProtocol(soap, "tds:NetworkProtocols", -1, a->NetworkProtocols + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetNetworkProtocolsResponse * SOAP_FMAC4 soap_in__tds__GetNetworkProtocolsResponse(struct soap *soap, const char *tag, struct _tds__GetNetworkProtocolsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_NetworkProtocols = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetNetworkProtocolsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkProtocolsResponse, sizeof(struct _tds__GetNetworkProtocolsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetNetworkProtocolsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:NetworkProtocols", 1, NULL))
			{	if (a->NetworkProtocols == NULL)
				{	if (soap_blist_NetworkProtocols == NULL)
						soap_blist_NetworkProtocols = soap_alloc_block(soap);
					a->NetworkProtocols = (struct tt__NetworkProtocol *)soap_push_block_max(soap, soap_blist_NetworkProtocols, sizeof(struct tt__NetworkProtocol));
					if (a->NetworkProtocols == NULL)
						return NULL;
					soap_default_tt__NetworkProtocol(soap, a->NetworkProtocols);
				}
				soap_revert(soap);
				if (soap_in_tt__NetworkProtocol(soap, "tds:NetworkProtocols", a->NetworkProtocols, "tt:NetworkProtocol"))
				{	a->__sizeNetworkProtocols++;
					a->NetworkProtocols = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeNetworkProtocols");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NetworkProtocols)
			soap_pop_block(soap, soap_blist_NetworkProtocols);
		if (a->__sizeNetworkProtocols)
		{	a->NetworkProtocols = (struct tt__NetworkProtocol *)soap_save_block(soap, soap_blist_NetworkProtocols, NULL, 1);
		}
		else
		{	a->NetworkProtocols = NULL;
			if (soap_blist_NetworkProtocols)
				soap_end_block(soap, soap_blist_NetworkProtocols);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetNetworkProtocolsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkProtocolsResponse, SOAP_TYPE__tds__GetNetworkProtocolsResponse, sizeof(struct _tds__GetNetworkProtocolsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetNetworkProtocolsResponse * SOAP_FMAC4 soap_new__tds__GetNetworkProtocolsResponse(struct soap *soap, int n)
{
	struct _tds__GetNetworkProtocolsResponse *p;
	struct _tds__GetNetworkProtocolsResponse *a = (struct _tds__GetNetworkProtocolsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetNetworkProtocolsResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetNetworkProtocolsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetNetworkProtocolsResponse(struct soap *soap, const struct _tds__GetNetworkProtocolsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetNetworkProtocolsResponse(soap, tag ? tag : "tds:GetNetworkProtocolsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkProtocolsResponse * SOAP_FMAC4 soap_get__tds__GetNetworkProtocolsResponse(struct soap *soap, struct _tds__GetNetworkProtocolsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkProtocolsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetNetworkProtocols(struct soap *soap, struct _tds__GetNetworkProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetNetworkProtocols(struct soap *soap, const struct _tds__GetNetworkProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkProtocols(struct soap *soap, const char *tag, int id, const struct _tds__GetNetworkProtocols *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkProtocols), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetNetworkProtocols * SOAP_FMAC4 soap_in__tds__GetNetworkProtocols(struct soap *soap, const char *tag, struct _tds__GetNetworkProtocols *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetNetworkProtocols *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkProtocols, sizeof(struct _tds__GetNetworkProtocols), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetNetworkProtocols(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetNetworkProtocols *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkProtocols, SOAP_TYPE__tds__GetNetworkProtocols, sizeof(struct _tds__GetNetworkProtocols), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetNetworkProtocols * SOAP_FMAC4 soap_new__tds__GetNetworkProtocols(struct soap *soap, int n)
{
	struct _tds__GetNetworkProtocols *p;
	struct _tds__GetNetworkProtocols *a = (struct _tds__GetNetworkProtocols*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetNetworkProtocols));
	for (p = a; p && n--; p++)
		soap_default__tds__GetNetworkProtocols(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetNetworkProtocols(struct soap *soap, const struct _tds__GetNetworkProtocols *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetNetworkProtocols(soap, tag ? tag : "tds:GetNetworkProtocols", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkProtocols * SOAP_FMAC4 soap_get__tds__GetNetworkProtocols(struct soap *soap, struct _tds__GetNetworkProtocols *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetNetworkInterfacesResponse(struct soap *soap, struct _tds__SetNetworkInterfacesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->RebootNeeded);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetNetworkInterfacesResponse(struct soap *soap, const struct _tds__SetNetworkInterfacesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->RebootNeeded, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkInterfacesResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetNetworkInterfacesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkInterfacesResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:RebootNeeded");
	if (soap_out_xsd__boolean(soap, "tds:RebootNeeded", -1, &a->RebootNeeded, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetNetworkInterfacesResponse * SOAP_FMAC4 soap_in__tds__SetNetworkInterfacesResponse(struct soap *soap, const char *tag, struct _tds__SetNetworkInterfacesResponse *a, const char *type)
{
	size_t soap_flag_RebootNeeded = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetNetworkInterfacesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkInterfacesResponse, sizeof(struct _tds__SetNetworkInterfacesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetNetworkInterfacesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RebootNeeded && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tds:RebootNeeded", &a->RebootNeeded, "xsd:boolean"))
				{	soap_flag_RebootNeeded--;
					continue;
				}
			soap_check_result(soap, "tds:RebootNeeded");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RebootNeeded > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetNetworkInterfacesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkInterfacesResponse, SOAP_TYPE__tds__SetNetworkInterfacesResponse, sizeof(struct _tds__SetNetworkInterfacesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetNetworkInterfacesResponse * SOAP_FMAC4 soap_new__tds__SetNetworkInterfacesResponse(struct soap *soap, int n)
{
	struct _tds__SetNetworkInterfacesResponse *p;
	struct _tds__SetNetworkInterfacesResponse *a = (struct _tds__SetNetworkInterfacesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetNetworkInterfacesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetNetworkInterfacesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetNetworkInterfacesResponse(struct soap *soap, const struct _tds__SetNetworkInterfacesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetNetworkInterfacesResponse(soap, tag ? tag : "tds:SetNetworkInterfacesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkInterfacesResponse * SOAP_FMAC4 soap_get__tds__SetNetworkInterfacesResponse(struct soap *soap, struct _tds__SetNetworkInterfacesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkInterfacesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetNetworkInterfaces(struct soap *soap, struct _tds__SetNetworkInterfaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->InterfaceToken);
	a->NetworkInterface = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetNetworkInterfaces(struct soap *soap, const struct _tds__SetNetworkInterfaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->InterfaceToken);
	soap_serialize_PointerTott__NetworkInterfaceSetConfiguration(soap, &a->NetworkInterface);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkInterfaces(struct soap *soap, const char *tag, int id, const struct _tds__SetNetworkInterfaces *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkInterfaces), type))
		return soap->error;
	if (!a->InterfaceToken)
	{	if (soap_element_nil(soap, "tds:InterfaceToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tds:InterfaceToken", -1, (char*const*)&a->InterfaceToken, ""))
		return soap->error;
	if (!a->NetworkInterface)
	{	if (soap_element_nil(soap, "tds:NetworkInterface"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__NetworkInterfaceSetConfiguration(soap, "tds:NetworkInterface", -1, &a->NetworkInterface, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetNetworkInterfaces * SOAP_FMAC4 soap_in__tds__SetNetworkInterfaces(struct soap *soap, const char *tag, struct _tds__SetNetworkInterfaces *a, const char *type)
{
	size_t soap_flag_InterfaceToken = 1;
	size_t soap_flag_NetworkInterface = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetNetworkInterfaces *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkInterfaces, sizeof(struct _tds__SetNetworkInterfaces), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetNetworkInterfaces(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tds:InterfaceToken", (char**)&a->InterfaceToken, "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken--;
					continue;
				}
			if (soap_flag_NetworkInterface && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkInterfaceSetConfiguration(soap, "tds:NetworkInterface", &a->NetworkInterface, "tt:NetworkInterfaceSetConfiguration"))
				{	soap_flag_NetworkInterface--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InterfaceToken > 0 || soap_flag_NetworkInterface > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetNetworkInterfaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkInterfaces, SOAP_TYPE__tds__SetNetworkInterfaces, sizeof(struct _tds__SetNetworkInterfaces), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetNetworkInterfaces * SOAP_FMAC4 soap_new__tds__SetNetworkInterfaces(struct soap *soap, int n)
{
	struct _tds__SetNetworkInterfaces *p;
	struct _tds__SetNetworkInterfaces *a = (struct _tds__SetNetworkInterfaces*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetNetworkInterfaces));
	for (p = a; p && n--; p++)
		soap_default__tds__SetNetworkInterfaces(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetNetworkInterfaces(struct soap *soap, const struct _tds__SetNetworkInterfaces *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetNetworkInterfaces(soap, tag ? tag : "tds:SetNetworkInterfaces", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkInterfaces * SOAP_FMAC4 soap_get__tds__SetNetworkInterfaces(struct soap *soap, struct _tds__SetNetworkInterfaces *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__NetworkInterface(struct soap *soap, struct tt__NetworkInterface *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_xsd__boolean(soap, &a->Enabled);
	a->Info = NULL;
	a->Link = NULL;
	a->IPv4 = NULL;
	a->IPv6 = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkInterface(struct soap *soap, const struct tt__NetworkInterface *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Enabled, SOAP_TYPE_xsd__boolean);
	soap_serialize_PointerTott__NetworkInterfaceInfo(soap, &a->Info);
	soap_serialize_PointerTott__NetworkInterfaceLink(soap, &a->Link);
	soap_serialize_PointerTott__IPv4NetworkInterface(soap, &a->IPv4);
	soap_serialize_PointerTott__IPv6NetworkInterface(soap, &a->IPv6);
	soap_serialize_PointerTott__NetworkInterfaceExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterface(struct soap *soap, const char *tag, int id, const struct tt__NetworkInterface *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, a->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterface), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceInfo(soap, "tt:Info", -1, &a->Info, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceLink(soap, "tt:Link", -1, &a->Link, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv4NetworkInterface(soap, "tt:IPv4", -1, &a->IPv4, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6NetworkInterface(soap, "tt:IPv6", -1, &a->IPv6, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__NetworkInterface * SOAP_FMAC4 soap_in_tt__NetworkInterface(struct soap *soap, const char *tag, struct tt__NetworkInterface *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	size_t soap_flag_Info = 1;
	size_t soap_flag_Link = 1;
	size_t soap_flag_IPv4 = 1;
	size_t soap_flag_IPv6 = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__NetworkInterface *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterface, sizeof(struct tt__NetworkInterface), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__NetworkInterface(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap_flag_Info && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkInterfaceInfo(soap, "tt:Info", &a->Info, "tt:NetworkInterfaceInfo"))
				{	soap_flag_Info--;
					continue;
				}
			if (soap_flag_Link && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkInterfaceLink(soap, "tt:Link", &a->Link, "tt:NetworkInterfaceLink"))
				{	soap_flag_Link--;
					continue;
				}
			if (soap_flag_IPv4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPv4NetworkInterface(soap, "tt:IPv4", &a->IPv4, "tt:IPv4NetworkInterface"))
				{	soap_flag_IPv4--;
					continue;
				}
			if (soap_flag_IPv6 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPv6NetworkInterface(soap, "tt:IPv6", &a->IPv6, "tt:IPv6NetworkInterface"))
				{	soap_flag_IPv6--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkInterfaceExtension(soap, "tt:Extension", &a->Extension, "tt:NetworkInterfaceExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__NetworkInterface *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterface, SOAP_TYPE_tt__NetworkInterface, sizeof(struct tt__NetworkInterface), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__NetworkInterface * SOAP_FMAC4 soap_new_tt__NetworkInterface(struct soap *soap, int n)
{
	struct tt__NetworkInterface *p;
	struct tt__NetworkInterface *a = (struct tt__NetworkInterface*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__NetworkInterface));
	for (p = a; p && n--; p++)
		soap_default_tt__NetworkInterface(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkInterface(struct soap *soap, const struct tt__NetworkInterface *a, const char *tag, const char *type)
{
	if (soap_out_tt__NetworkInterface(soap, tag ? tag : "tt:NetworkInterface", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterface * SOAP_FMAC4 soap_get_tt__NetworkInterface(struct soap *soap, struct tt__NetworkInterface *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetNetworkInterfacesResponse(struct soap *soap, struct _tds__GetNetworkInterfacesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNetworkInterfaces = 0;
	a->NetworkInterfaces = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetNetworkInterfacesResponse(struct soap *soap, const struct _tds__GetNetworkInterfacesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->NetworkInterfaces)
	{	int i;
		for (i = 0; i < (int)a->__sizeNetworkInterfaces; i++)
		{
			soap_embedded(soap, a->NetworkInterfaces + i, SOAP_TYPE_tt__NetworkInterface);
			soap_serialize_tt__NetworkInterface(soap, a->NetworkInterfaces + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkInterfacesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetNetworkInterfacesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkInterfacesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeNetworkInterfaces");
	if (a->NetworkInterfaces)
	{	int i;
		for (i = 0; i < (int)a->__sizeNetworkInterfaces; i++)
			if (soap_out_tt__NetworkInterface(soap, "tds:NetworkInterfaces", -1, a->NetworkInterfaces + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetNetworkInterfacesResponse * SOAP_FMAC4 soap_in__tds__GetNetworkInterfacesResponse(struct soap *soap, const char *tag, struct _tds__GetNetworkInterfacesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_NetworkInterfaces = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetNetworkInterfacesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkInterfacesResponse, sizeof(struct _tds__GetNetworkInterfacesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetNetworkInterfacesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:NetworkInterfaces", 1, NULL))
			{	if (a->NetworkInterfaces == NULL)
				{	if (soap_blist_NetworkInterfaces == NULL)
						soap_blist_NetworkInterfaces = soap_alloc_block(soap);
					a->NetworkInterfaces = (struct tt__NetworkInterface *)soap_push_block_max(soap, soap_blist_NetworkInterfaces, sizeof(struct tt__NetworkInterface));
					if (a->NetworkInterfaces == NULL)
						return NULL;
					soap_default_tt__NetworkInterface(soap, a->NetworkInterfaces);
				}
				soap_revert(soap);
				if (soap_in_tt__NetworkInterface(soap, "tds:NetworkInterfaces", a->NetworkInterfaces, "tt:NetworkInterface"))
				{	a->__sizeNetworkInterfaces++;
					a->NetworkInterfaces = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeNetworkInterfaces");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NetworkInterfaces)
			soap_pop_block(soap, soap_blist_NetworkInterfaces);
		if (a->__sizeNetworkInterfaces)
		{	a->NetworkInterfaces = (struct tt__NetworkInterface *)soap_save_block(soap, soap_blist_NetworkInterfaces, NULL, 1);
		}
		else
		{	a->NetworkInterfaces = NULL;
			if (soap_blist_NetworkInterfaces)
				soap_end_block(soap, soap_blist_NetworkInterfaces);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeNetworkInterfaces < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetNetworkInterfacesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkInterfacesResponse, SOAP_TYPE__tds__GetNetworkInterfacesResponse, sizeof(struct _tds__GetNetworkInterfacesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetNetworkInterfacesResponse * SOAP_FMAC4 soap_new__tds__GetNetworkInterfacesResponse(struct soap *soap, int n)
{
	struct _tds__GetNetworkInterfacesResponse *p;
	struct _tds__GetNetworkInterfacesResponse *a = (struct _tds__GetNetworkInterfacesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetNetworkInterfacesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetNetworkInterfacesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetNetworkInterfacesResponse(struct soap *soap, const struct _tds__GetNetworkInterfacesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetNetworkInterfacesResponse(soap, tag ? tag : "tds:GetNetworkInterfacesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkInterfacesResponse * SOAP_FMAC4 soap_get__tds__GetNetworkInterfacesResponse(struct soap *soap, struct _tds__GetNetworkInterfacesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkInterfacesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetNetworkInterfaces(struct soap *soap, struct _tds__GetNetworkInterfaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetNetworkInterfaces(struct soap *soap, const struct _tds__GetNetworkInterfaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkInterfaces(struct soap *soap, const char *tag, int id, const struct _tds__GetNetworkInterfaces *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkInterfaces), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetNetworkInterfaces * SOAP_FMAC4 soap_in__tds__GetNetworkInterfaces(struct soap *soap, const char *tag, struct _tds__GetNetworkInterfaces *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetNetworkInterfaces *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkInterfaces, sizeof(struct _tds__GetNetworkInterfaces), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetNetworkInterfaces(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetNetworkInterfaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkInterfaces, SOAP_TYPE__tds__GetNetworkInterfaces, sizeof(struct _tds__GetNetworkInterfaces), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetNetworkInterfaces * SOAP_FMAC4 soap_new__tds__GetNetworkInterfaces(struct soap *soap, int n)
{
	struct _tds__GetNetworkInterfaces *p;
	struct _tds__GetNetworkInterfaces *a = (struct _tds__GetNetworkInterfaces*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetNetworkInterfaces));
	for (p = a; p && n--; p++)
		soap_default__tds__GetNetworkInterfaces(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetNetworkInterfaces(struct soap *soap, const struct _tds__GetNetworkInterfaces *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetNetworkInterfaces(soap, tag ? tag : "tds:GetNetworkInterfaces", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkInterfaces * SOAP_FMAC4 soap_get__tds__GetNetworkInterfaces(struct soap *soap, struct _tds__GetNetworkInterfaces *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDynamicDNSResponse(struct soap *soap, struct _tds__SetDynamicDNSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDynamicDNSResponse(struct soap *soap, const struct _tds__SetDynamicDNSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDynamicDNSResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetDynamicDNSResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDynamicDNSResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDynamicDNSResponse * SOAP_FMAC4 soap_in__tds__SetDynamicDNSResponse(struct soap *soap, const char *tag, struct _tds__SetDynamicDNSResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetDynamicDNSResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDynamicDNSResponse, sizeof(struct _tds__SetDynamicDNSResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetDynamicDNSResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDynamicDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDynamicDNSResponse, SOAP_TYPE__tds__SetDynamicDNSResponse, sizeof(struct _tds__SetDynamicDNSResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetDynamicDNSResponse * SOAP_FMAC4 soap_new__tds__SetDynamicDNSResponse(struct soap *soap, int n)
{
	struct _tds__SetDynamicDNSResponse *p;
	struct _tds__SetDynamicDNSResponse *a = (struct _tds__SetDynamicDNSResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetDynamicDNSResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetDynamicDNSResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDynamicDNSResponse(struct soap *soap, const struct _tds__SetDynamicDNSResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetDynamicDNSResponse(soap, tag ? tag : "tds:SetDynamicDNSResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDynamicDNSResponse * SOAP_FMAC4 soap_get__tds__SetDynamicDNSResponse(struct soap *soap, struct _tds__SetDynamicDNSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDynamicDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDynamicDNS(struct soap *soap, struct _tds__SetDynamicDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__DynamicDNSType(soap, &a->Type);
	soap_default_tt__DNSName(soap, &a->Name);
	a->TTL = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDynamicDNS(struct soap *soap, const struct _tds__SetDynamicDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__DNSName(soap, (char*const*)&a->Name);
	soap_serialize_PointerToxsd__duration(soap, &a->TTL);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDynamicDNS(struct soap *soap, const char *tag, int id, const struct _tds__SetDynamicDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDynamicDNS), type))
		return soap->error;
	if (soap_out_tt__DynamicDNSType(soap, "tds:Type", -1, &a->Type, ""))
		return soap->error;
	if (soap_out_tt__DNSName(soap, "tds:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tds:TTL", -1, &a->TTL, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDynamicDNS * SOAP_FMAC4 soap_in__tds__SetDynamicDNS(struct soap *soap, const char *tag, struct _tds__SetDynamicDNS *a, const char *type)
{
	size_t soap_flag_Type = 1;
	size_t soap_flag_Name = 1;
	size_t soap_flag_TTL = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetDynamicDNS *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDynamicDNS, sizeof(struct _tds__SetDynamicDNS), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetDynamicDNS(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__DynamicDNSType(soap, "tds:Type", &a->Type, "tt:DynamicDNSType"))
				{	soap_flag_Type--;
					continue;
				}
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__DNSName(soap, "tds:Name", (char**)&a->Name, "tt:DNSName"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_TTL && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__duration(soap, "tds:TTL", &a->TTL, "xsd:duration"))
				{	soap_flag_TTL--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetDynamicDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDynamicDNS, SOAP_TYPE__tds__SetDynamicDNS, sizeof(struct _tds__SetDynamicDNS), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetDynamicDNS * SOAP_FMAC4 soap_new__tds__SetDynamicDNS(struct soap *soap, int n)
{
	struct _tds__SetDynamicDNS *p;
	struct _tds__SetDynamicDNS *a = (struct _tds__SetDynamicDNS*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetDynamicDNS));
	for (p = a; p && n--; p++)
		soap_default__tds__SetDynamicDNS(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDynamicDNS(struct soap *soap, const struct _tds__SetDynamicDNS *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetDynamicDNS(soap, tag ? tag : "tds:SetDynamicDNS", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDynamicDNS * SOAP_FMAC4 soap_get__tds__SetDynamicDNS(struct soap *soap, struct _tds__SetDynamicDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDynamicDNSResponse(struct soap *soap, struct _tds__GetDynamicDNSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DynamicDNSInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDynamicDNSResponse(struct soap *soap, const struct _tds__GetDynamicDNSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__DynamicDNSInformation(soap, &a->DynamicDNSInformation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDynamicDNSResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDynamicDNSResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDynamicDNSResponse), type))
		return soap->error;
	if (a->DynamicDNSInformation)
		soap_element_result(soap, "tds:DynamicDNSInformation");
	if (!a->DynamicDNSInformation)
	{	if (soap_element_nil(soap, "tds:DynamicDNSInformation"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__DynamicDNSInformation(soap, "tds:DynamicDNSInformation", -1, &a->DynamicDNSInformation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDynamicDNSResponse * SOAP_FMAC4 soap_in__tds__GetDynamicDNSResponse(struct soap *soap, const char *tag, struct _tds__GetDynamicDNSResponse *a, const char *type)
{
	size_t soap_flag_DynamicDNSInformation = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDynamicDNSResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDynamicDNSResponse, sizeof(struct _tds__GetDynamicDNSResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDynamicDNSResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DynamicDNSInformation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DynamicDNSInformation(soap, "tds:DynamicDNSInformation", &a->DynamicDNSInformation, "tt:DynamicDNSInformation"))
				{	soap_flag_DynamicDNSInformation--;
					continue;
				}
			soap_check_result(soap, "tds:DynamicDNSInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DynamicDNSInformation > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetDynamicDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDynamicDNSResponse, SOAP_TYPE__tds__GetDynamicDNSResponse, sizeof(struct _tds__GetDynamicDNSResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDynamicDNSResponse * SOAP_FMAC4 soap_new__tds__GetDynamicDNSResponse(struct soap *soap, int n)
{
	struct _tds__GetDynamicDNSResponse *p;
	struct _tds__GetDynamicDNSResponse *a = (struct _tds__GetDynamicDNSResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDynamicDNSResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDynamicDNSResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDynamicDNSResponse(struct soap *soap, const struct _tds__GetDynamicDNSResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDynamicDNSResponse(soap, tag ? tag : "tds:GetDynamicDNSResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDynamicDNSResponse * SOAP_FMAC4 soap_get__tds__GetDynamicDNSResponse(struct soap *soap, struct _tds__GetDynamicDNSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDynamicDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDynamicDNS(struct soap *soap, struct _tds__GetDynamicDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDynamicDNS(struct soap *soap, const struct _tds__GetDynamicDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDynamicDNS(struct soap *soap, const char *tag, int id, const struct _tds__GetDynamicDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDynamicDNS), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDynamicDNS * SOAP_FMAC4 soap_in__tds__GetDynamicDNS(struct soap *soap, const char *tag, struct _tds__GetDynamicDNS *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDynamicDNS *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDynamicDNS, sizeof(struct _tds__GetDynamicDNS), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDynamicDNS(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDynamicDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDynamicDNS, SOAP_TYPE__tds__GetDynamicDNS, sizeof(struct _tds__GetDynamicDNS), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDynamicDNS * SOAP_FMAC4 soap_new__tds__GetDynamicDNS(struct soap *soap, int n)
{
	struct _tds__GetDynamicDNS *p;
	struct _tds__GetDynamicDNS *a = (struct _tds__GetDynamicDNS*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDynamicDNS));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDynamicDNS(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDynamicDNS(struct soap *soap, const struct _tds__GetDynamicDNS *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDynamicDNS(soap, tag ? tag : "tds:GetDynamicDNS", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDynamicDNS * SOAP_FMAC4 soap_get__tds__GetDynamicDNS(struct soap *soap, struct _tds__GetDynamicDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetNTPResponse(struct soap *soap, struct _tds__SetNTPResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetNTPResponse(struct soap *soap, const struct _tds__SetNTPResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNTPResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetNTPResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNTPResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetNTPResponse * SOAP_FMAC4 soap_in__tds__SetNTPResponse(struct soap *soap, const char *tag, struct _tds__SetNTPResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetNTPResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNTPResponse, sizeof(struct _tds__SetNTPResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetNTPResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetNTPResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNTPResponse, SOAP_TYPE__tds__SetNTPResponse, sizeof(struct _tds__SetNTPResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetNTPResponse * SOAP_FMAC4 soap_new__tds__SetNTPResponse(struct soap *soap, int n)
{
	struct _tds__SetNTPResponse *p;
	struct _tds__SetNTPResponse *a = (struct _tds__SetNTPResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetNTPResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetNTPResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetNTPResponse(struct soap *soap, const struct _tds__SetNTPResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetNTPResponse(soap, tag ? tag : "tds:SetNTPResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNTPResponse * SOAP_FMAC4 soap_get__tds__SetNTPResponse(struct soap *soap, struct _tds__SetNTPResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNTPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetNTP(struct soap *soap, struct _tds__SetNTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->FromDHCP);
	a->__sizeNTPManual = 0;
	a->NTPManual = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetNTP(struct soap *soap, const struct _tds__SetNTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->FromDHCP, SOAP_TYPE_xsd__boolean);
	if (a->NTPManual)
	{	int i;
		for (i = 0; i < (int)a->__sizeNTPManual; i++)
		{
			soap_embedded(soap, a->NTPManual + i, SOAP_TYPE_tt__NetworkHost);
			soap_serialize_tt__NetworkHost(soap, a->NTPManual + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNTP(struct soap *soap, const char *tag, int id, const struct _tds__SetNTP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNTP), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tds:FromDHCP", -1, &a->FromDHCP, ""))
		return soap->error;
	if (a->NTPManual)
	{	int i;
		for (i = 0; i < (int)a->__sizeNTPManual; i++)
			if (soap_out_tt__NetworkHost(soap, "tds:NTPManual", -1, a->NTPManual + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetNTP * SOAP_FMAC4 soap_in__tds__SetNTP(struct soap *soap, const char *tag, struct _tds__SetNTP *a, const char *type)
{
	size_t soap_flag_FromDHCP = 1;
	struct soap_blist *soap_blist_NTPManual = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetNTP *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNTP, sizeof(struct _tds__SetNTP), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetNTP(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tds:FromDHCP", &a->FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:NTPManual", 1, NULL))
			{	if (a->NTPManual == NULL)
				{	if (soap_blist_NTPManual == NULL)
						soap_blist_NTPManual = soap_alloc_block(soap);
					a->NTPManual = (struct tt__NetworkHost *)soap_push_block_max(soap, soap_blist_NTPManual, sizeof(struct tt__NetworkHost));
					if (a->NTPManual == NULL)
						return NULL;
					soap_default_tt__NetworkHost(soap, a->NTPManual);
				}
				soap_revert(soap);
				if (soap_in_tt__NetworkHost(soap, "tds:NTPManual", a->NTPManual, "tt:NetworkHost"))
				{	a->__sizeNTPManual++;
					a->NTPManual = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NTPManual)
			soap_pop_block(soap, soap_blist_NTPManual);
		if (a->__sizeNTPManual)
		{	a->NTPManual = (struct tt__NetworkHost *)soap_save_block(soap, soap_blist_NTPManual, NULL, 1);
		}
		else
		{	a->NTPManual = NULL;
			if (soap_blist_NTPManual)
				soap_end_block(soap, soap_blist_NTPManual);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetNTP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNTP, SOAP_TYPE__tds__SetNTP, sizeof(struct _tds__SetNTP), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetNTP * SOAP_FMAC4 soap_new__tds__SetNTP(struct soap *soap, int n)
{
	struct _tds__SetNTP *p;
	struct _tds__SetNTP *a = (struct _tds__SetNTP*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetNTP));
	for (p = a; p && n--; p++)
		soap_default__tds__SetNTP(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetNTP(struct soap *soap, const struct _tds__SetNTP *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetNTP(soap, tag ? tag : "tds:SetNTP", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNTP * SOAP_FMAC4 soap_get__tds__SetNTP(struct soap *soap, struct _tds__SetNTP *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetNTPResponse(struct soap *soap, struct _tds__GetNTPResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->NTPInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetNTPResponse(struct soap *soap, const struct _tds__GetNTPResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__NTPInformation(soap, &a->NTPInformation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNTPResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetNTPResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNTPResponse), type))
		return soap->error;
	if (a->NTPInformation)
		soap_element_result(soap, "tds:NTPInformation");
	if (!a->NTPInformation)
	{	if (soap_element_nil(soap, "tds:NTPInformation"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__NTPInformation(soap, "tds:NTPInformation", -1, &a->NTPInformation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetNTPResponse * SOAP_FMAC4 soap_in__tds__GetNTPResponse(struct soap *soap, const char *tag, struct _tds__GetNTPResponse *a, const char *type)
{
	size_t soap_flag_NTPInformation = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetNTPResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNTPResponse, sizeof(struct _tds__GetNTPResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetNTPResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NTPInformation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NTPInformation(soap, "tds:NTPInformation", &a->NTPInformation, "tt:NTPInformation"))
				{	soap_flag_NTPInformation--;
					continue;
				}
			soap_check_result(soap, "tds:NTPInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_NTPInformation > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetNTPResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNTPResponse, SOAP_TYPE__tds__GetNTPResponse, sizeof(struct _tds__GetNTPResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetNTPResponse * SOAP_FMAC4 soap_new__tds__GetNTPResponse(struct soap *soap, int n)
{
	struct _tds__GetNTPResponse *p;
	struct _tds__GetNTPResponse *a = (struct _tds__GetNTPResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetNTPResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetNTPResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetNTPResponse(struct soap *soap, const struct _tds__GetNTPResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetNTPResponse(soap, tag ? tag : "tds:GetNTPResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNTPResponse * SOAP_FMAC4 soap_get__tds__GetNTPResponse(struct soap *soap, struct _tds__GetNTPResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNTPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetNTP(struct soap *soap, struct _tds__GetNTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetNTP(struct soap *soap, const struct _tds__GetNTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNTP(struct soap *soap, const char *tag, int id, const struct _tds__GetNTP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNTP), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetNTP * SOAP_FMAC4 soap_in__tds__GetNTP(struct soap *soap, const char *tag, struct _tds__GetNTP *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetNTP *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNTP, sizeof(struct _tds__GetNTP), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetNTP(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetNTP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNTP, SOAP_TYPE__tds__GetNTP, sizeof(struct _tds__GetNTP), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetNTP * SOAP_FMAC4 soap_new__tds__GetNTP(struct soap *soap, int n)
{
	struct _tds__GetNTP *p;
	struct _tds__GetNTP *a = (struct _tds__GetNTP*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetNTP));
	for (p = a; p && n--; p++)
		soap_default__tds__GetNTP(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetNTP(struct soap *soap, const struct _tds__GetNTP *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetNTP(soap, tag ? tag : "tds:GetNTP", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNTP * SOAP_FMAC4 soap_get__tds__GetNTP(struct soap *soap, struct _tds__GetNTP *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDNSResponse(struct soap *soap, struct _tds__SetDNSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDNSResponse(struct soap *soap, const struct _tds__SetDNSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDNSResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetDNSResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDNSResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDNSResponse * SOAP_FMAC4 soap_in__tds__SetDNSResponse(struct soap *soap, const char *tag, struct _tds__SetDNSResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetDNSResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDNSResponse, sizeof(struct _tds__SetDNSResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetDNSResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDNSResponse, SOAP_TYPE__tds__SetDNSResponse, sizeof(struct _tds__SetDNSResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetDNSResponse * SOAP_FMAC4 soap_new__tds__SetDNSResponse(struct soap *soap, int n)
{
	struct _tds__SetDNSResponse *p;
	struct _tds__SetDNSResponse *a = (struct _tds__SetDNSResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetDNSResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetDNSResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDNSResponse(struct soap *soap, const struct _tds__SetDNSResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetDNSResponse(soap, tag ? tag : "tds:SetDNSResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDNSResponse * SOAP_FMAC4 soap_get__tds__SetDNSResponse(struct soap *soap, struct _tds__SetDNSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDNS(struct soap *soap, struct _tds__SetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->FromDHCP);
	a->__sizeSearchDomain = 0;
	a->SearchDomain = NULL;
	a->__sizeDNSManual = 0;
	a->DNSManual = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDNS(struct soap *soap, const struct _tds__SetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->FromDHCP, SOAP_TYPE_xsd__boolean);
	if (a->SearchDomain)
	{	int i;
		for (i = 0; i < (int)a->__sizeSearchDomain; i++)
		{
			soap_serialize_xsd__token(soap, (char*const*)(a->SearchDomain + i));
		}
	}
	if (a->DNSManual)
	{	int i;
		for (i = 0; i < (int)a->__sizeDNSManual; i++)
		{
			soap_embedded(soap, a->DNSManual + i, SOAP_TYPE_tt__IPAddress);
			soap_serialize_tt__IPAddress(soap, a->DNSManual + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDNS(struct soap *soap, const char *tag, int id, const struct _tds__SetDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDNS), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tds:FromDHCP", -1, &a->FromDHCP, ""))
		return soap->error;
	if (a->SearchDomain)
	{	int i;
		for (i = 0; i < (int)a->__sizeSearchDomain; i++)
			soap_out_string(soap, "tds:SearchDomain", -1, (char*const*)(a->SearchDomain + i), "");
	}
	if (a->DNSManual)
	{	int i;
		for (i = 0; i < (int)a->__sizeDNSManual; i++)
			if (soap_out_tt__IPAddress(soap, "tds:DNSManual", -1, a->DNSManual + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDNS * SOAP_FMAC4 soap_in__tds__SetDNS(struct soap *soap, const char *tag, struct _tds__SetDNS *a, const char *type)
{
	size_t soap_flag_FromDHCP = 1;
	struct soap_blist *soap_blist_SearchDomain = NULL;
	struct soap_blist *soap_blist_DNSManual = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetDNS *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDNS, sizeof(struct _tds__SetDNS), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetDNS(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tds:FromDHCP", &a->FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:SearchDomain", 1, NULL))
			{	if (a->SearchDomain == NULL)
				{	if (soap_blist_SearchDomain == NULL)
						soap_blist_SearchDomain = soap_alloc_block(soap);
					a->SearchDomain = (char **)soap_push_block_max(soap, soap_blist_SearchDomain, sizeof(char *));
					if (a->SearchDomain == NULL)
						return NULL;
					*a->SearchDomain = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__token(soap, "tds:SearchDomain", (char**)a->SearchDomain, "xsd:token"))
				{	a->__sizeSearchDomain++;
					a->SearchDomain = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:DNSManual", 1, NULL))
			{	if (a->DNSManual == NULL)
				{	if (soap_blist_DNSManual == NULL)
						soap_blist_DNSManual = soap_alloc_block(soap);
					a->DNSManual = (struct tt__IPAddress *)soap_push_block_max(soap, soap_blist_DNSManual, sizeof(struct tt__IPAddress));
					if (a->DNSManual == NULL)
						return NULL;
					soap_default_tt__IPAddress(soap, a->DNSManual);
				}
				soap_revert(soap);
				if (soap_in_tt__IPAddress(soap, "tds:DNSManual", a->DNSManual, "tt:IPAddress"))
				{	a->__sizeDNSManual++;
					a->DNSManual = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->SearchDomain)
			soap_pop_block(soap, soap_blist_SearchDomain);
		if (a->__sizeSearchDomain)
		{	a->SearchDomain = (char **)soap_save_block(soap, soap_blist_SearchDomain, NULL, 1);
		}
		else
		{	a->SearchDomain = NULL;
			if (soap_blist_SearchDomain)
				soap_end_block(soap, soap_blist_SearchDomain);
		}
		if (a->DNSManual)
			soap_pop_block(soap, soap_blist_DNSManual);
		if (a->__sizeDNSManual)
		{	a->DNSManual = (struct tt__IPAddress *)soap_save_block(soap, soap_blist_DNSManual, NULL, 1);
		}
		else
		{	a->DNSManual = NULL;
			if (soap_blist_DNSManual)
				soap_end_block(soap, soap_blist_DNSManual);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDNS, SOAP_TYPE__tds__SetDNS, sizeof(struct _tds__SetDNS), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetDNS * SOAP_FMAC4 soap_new__tds__SetDNS(struct soap *soap, int n)
{
	struct _tds__SetDNS *p;
	struct _tds__SetDNS *a = (struct _tds__SetDNS*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetDNS));
	for (p = a; p && n--; p++)
		soap_default__tds__SetDNS(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDNS(struct soap *soap, const struct _tds__SetDNS *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetDNS(soap, tag ? tag : "tds:SetDNS", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDNS * SOAP_FMAC4 soap_get__tds__SetDNS(struct soap *soap, struct _tds__SetDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDNSResponse(struct soap *soap, struct _tds__GetDNSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DNSInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDNSResponse(struct soap *soap, const struct _tds__GetDNSResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__DNSInformation(soap, &a->DNSInformation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDNSResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDNSResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDNSResponse), type))
		return soap->error;
	if (a->DNSInformation)
		soap_element_result(soap, "tds:DNSInformation");
	if (!a->DNSInformation)
	{	if (soap_element_nil(soap, "tds:DNSInformation"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__DNSInformation(soap, "tds:DNSInformation", -1, &a->DNSInformation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDNSResponse * SOAP_FMAC4 soap_in__tds__GetDNSResponse(struct soap *soap, const char *tag, struct _tds__GetDNSResponse *a, const char *type)
{
	size_t soap_flag_DNSInformation = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDNSResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDNSResponse, sizeof(struct _tds__GetDNSResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDNSResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DNSInformation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DNSInformation(soap, "tds:DNSInformation", &a->DNSInformation, "tt:DNSInformation"))
				{	soap_flag_DNSInformation--;
					continue;
				}
			soap_check_result(soap, "tds:DNSInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DNSInformation > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDNSResponse, SOAP_TYPE__tds__GetDNSResponse, sizeof(struct _tds__GetDNSResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDNSResponse * SOAP_FMAC4 soap_new__tds__GetDNSResponse(struct soap *soap, int n)
{
	struct _tds__GetDNSResponse *p;
	struct _tds__GetDNSResponse *a = (struct _tds__GetDNSResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDNSResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDNSResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDNSResponse(struct soap *soap, const struct _tds__GetDNSResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDNSResponse(soap, tag ? tag : "tds:GetDNSResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDNSResponse * SOAP_FMAC4 soap_get__tds__GetDNSResponse(struct soap *soap, struct _tds__GetDNSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDNS(struct soap *soap, struct _tds__GetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDNS(struct soap *soap, const struct _tds__GetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDNS(struct soap *soap, const char *tag, int id, const struct _tds__GetDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDNS), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDNS * SOAP_FMAC4 soap_in__tds__GetDNS(struct soap *soap, const char *tag, struct _tds__GetDNS *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDNS *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDNS, sizeof(struct _tds__GetDNS), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDNS(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDNS, SOAP_TYPE__tds__GetDNS, sizeof(struct _tds__GetDNS), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetDNS * SOAP_FMAC4 soap_new__tds__GetDNS(struct soap *soap, int n)
{
	struct _tds__GetDNS *p;
	struct _tds__GetDNS *a = (struct _tds__GetDNS*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetDNS));
	for (p = a; p && n--; p++)
		soap_default__tds__GetDNS(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDNS(struct soap *soap, const struct _tds__GetDNS *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetDNS(soap, tag ? tag : "tds:GetDNS", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDNS * SOAP_FMAC4 soap_get__tds__GetDNS(struct soap *soap, struct _tds__GetDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetHostnameFromDHCPResponse(struct soap *soap, struct _tds__SetHostnameFromDHCPResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->RebootNeeded);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetHostnameFromDHCPResponse(struct soap *soap, const struct _tds__SetHostnameFromDHCPResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->RebootNeeded, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHostnameFromDHCPResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetHostnameFromDHCPResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHostnameFromDHCPResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:RebootNeeded");
	if (soap_out_xsd__boolean(soap, "tds:RebootNeeded", -1, &a->RebootNeeded, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetHostnameFromDHCPResponse * SOAP_FMAC4 soap_in__tds__SetHostnameFromDHCPResponse(struct soap *soap, const char *tag, struct _tds__SetHostnameFromDHCPResponse *a, const char *type)
{
	size_t soap_flag_RebootNeeded = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetHostnameFromDHCPResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostnameFromDHCPResponse, sizeof(struct _tds__SetHostnameFromDHCPResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetHostnameFromDHCPResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RebootNeeded && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tds:RebootNeeded", &a->RebootNeeded, "xsd:boolean"))
				{	soap_flag_RebootNeeded--;
					continue;
				}
			soap_check_result(soap, "tds:RebootNeeded");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RebootNeeded > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetHostnameFromDHCPResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostnameFromDHCPResponse, SOAP_TYPE__tds__SetHostnameFromDHCPResponse, sizeof(struct _tds__SetHostnameFromDHCPResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetHostnameFromDHCPResponse * SOAP_FMAC4 soap_new__tds__SetHostnameFromDHCPResponse(struct soap *soap, int n)
{
	struct _tds__SetHostnameFromDHCPResponse *p;
	struct _tds__SetHostnameFromDHCPResponse *a = (struct _tds__SetHostnameFromDHCPResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetHostnameFromDHCPResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetHostnameFromDHCPResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetHostnameFromDHCPResponse(struct soap *soap, const struct _tds__SetHostnameFromDHCPResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetHostnameFromDHCPResponse(soap, tag ? tag : "tds:SetHostnameFromDHCPResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetHostnameFromDHCPResponse * SOAP_FMAC4 soap_get__tds__SetHostnameFromDHCPResponse(struct soap *soap, struct _tds__SetHostnameFromDHCPResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHostnameFromDHCPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetHostnameFromDHCP(struct soap *soap, struct _tds__SetHostnameFromDHCP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->FromDHCP);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetHostnameFromDHCP(struct soap *soap, const struct _tds__SetHostnameFromDHCP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->FromDHCP, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, int id, const struct _tds__SetHostnameFromDHCP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHostnameFromDHCP), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tds:FromDHCP", -1, &a->FromDHCP, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetHostnameFromDHCP * SOAP_FMAC4 soap_in__tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, struct _tds__SetHostnameFromDHCP *a, const char *type)
{
	size_t soap_flag_FromDHCP = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetHostnameFromDHCP *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostnameFromDHCP, sizeof(struct _tds__SetHostnameFromDHCP), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetHostnameFromDHCP(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tds:FromDHCP", &a->FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetHostnameFromDHCP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostnameFromDHCP, SOAP_TYPE__tds__SetHostnameFromDHCP, sizeof(struct _tds__SetHostnameFromDHCP), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetHostnameFromDHCP * SOAP_FMAC4 soap_new__tds__SetHostnameFromDHCP(struct soap *soap, int n)
{
	struct _tds__SetHostnameFromDHCP *p;
	struct _tds__SetHostnameFromDHCP *a = (struct _tds__SetHostnameFromDHCP*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetHostnameFromDHCP));
	for (p = a; p && n--; p++)
		soap_default__tds__SetHostnameFromDHCP(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetHostnameFromDHCP(struct soap *soap, const struct _tds__SetHostnameFromDHCP *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetHostnameFromDHCP(soap, tag ? tag : "tds:SetHostnameFromDHCP", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetHostnameFromDHCP * SOAP_FMAC4 soap_get__tds__SetHostnameFromDHCP(struct soap *soap, struct _tds__SetHostnameFromDHCP *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHostnameFromDHCP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetHostnameResponse(struct soap *soap, struct _tds__SetHostnameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetHostnameResponse(struct soap *soap, const struct _tds__SetHostnameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHostnameResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetHostnameResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHostnameResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetHostnameResponse * SOAP_FMAC4 soap_in__tds__SetHostnameResponse(struct soap *soap, const char *tag, struct _tds__SetHostnameResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetHostnameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostnameResponse, sizeof(struct _tds__SetHostnameResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetHostnameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetHostnameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostnameResponse, SOAP_TYPE__tds__SetHostnameResponse, sizeof(struct _tds__SetHostnameResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetHostnameResponse * SOAP_FMAC4 soap_new__tds__SetHostnameResponse(struct soap *soap, int n)
{
	struct _tds__SetHostnameResponse *p;
	struct _tds__SetHostnameResponse *a = (struct _tds__SetHostnameResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetHostnameResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetHostnameResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetHostnameResponse(struct soap *soap, const struct _tds__SetHostnameResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetHostnameResponse(soap, tag ? tag : "tds:SetHostnameResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetHostnameResponse * SOAP_FMAC4 soap_get__tds__SetHostnameResponse(struct soap *soap, struct _tds__SetHostnameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHostnameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetHostname(struct soap *soap, struct _tds__SetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->Name);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetHostname(struct soap *soap, const struct _tds__SetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__token(soap, (char*const*)&a->Name);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHostname(struct soap *soap, const char *tag, int id, const struct _tds__SetHostname *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHostname), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "tds:Name"))
			return soap->error;
	}
	else
	if (soap_out_xsd__token(soap, "tds:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetHostname * SOAP_FMAC4 soap_in__tds__SetHostname(struct soap *soap, const char *tag, struct _tds__SetHostname *a, const char *type)
{
	size_t soap_flag_Name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetHostname *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostname, sizeof(struct _tds__SetHostname), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetHostname(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tds:Name", (char**)&a->Name, "xsd:token"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetHostname *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostname, SOAP_TYPE__tds__SetHostname, sizeof(struct _tds__SetHostname), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetHostname * SOAP_FMAC4 soap_new__tds__SetHostname(struct soap *soap, int n)
{
	struct _tds__SetHostname *p;
	struct _tds__SetHostname *a = (struct _tds__SetHostname*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetHostname));
	for (p = a; p && n--; p++)
		soap_default__tds__SetHostname(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetHostname(struct soap *soap, const struct _tds__SetHostname *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetHostname(soap, tag ? tag : "tds:SetHostname", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetHostname * SOAP_FMAC4 soap_get__tds__SetHostname(struct soap *soap, struct _tds__SetHostname *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetHostnameResponse(struct soap *soap, struct _tds__GetHostnameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->HostnameInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetHostnameResponse(struct soap *soap, const struct _tds__GetHostnameResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__HostnameInformation(soap, &a->HostnameInformation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetHostnameResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetHostnameResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetHostnameResponse), type))
		return soap->error;
	if (a->HostnameInformation)
		soap_element_result(soap, "tds:HostnameInformation");
	if (!a->HostnameInformation)
	{	if (soap_element_nil(soap, "tds:HostnameInformation"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__HostnameInformation(soap, "tds:HostnameInformation", -1, &a->HostnameInformation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetHostnameResponse * SOAP_FMAC4 soap_in__tds__GetHostnameResponse(struct soap *soap, const char *tag, struct _tds__GetHostnameResponse *a, const char *type)
{
	size_t soap_flag_HostnameInformation = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetHostnameResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetHostnameResponse, sizeof(struct _tds__GetHostnameResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetHostnameResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HostnameInformation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__HostnameInformation(soap, "tds:HostnameInformation", &a->HostnameInformation, "tt:HostnameInformation"))
				{	soap_flag_HostnameInformation--;
					continue;
				}
			soap_check_result(soap, "tds:HostnameInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_HostnameInformation > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetHostnameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetHostnameResponse, SOAP_TYPE__tds__GetHostnameResponse, sizeof(struct _tds__GetHostnameResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetHostnameResponse * SOAP_FMAC4 soap_new__tds__GetHostnameResponse(struct soap *soap, int n)
{
	struct _tds__GetHostnameResponse *p;
	struct _tds__GetHostnameResponse *a = (struct _tds__GetHostnameResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetHostnameResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetHostnameResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetHostnameResponse(struct soap *soap, const struct _tds__GetHostnameResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetHostnameResponse(soap, tag ? tag : "tds:GetHostnameResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetHostnameResponse * SOAP_FMAC4 soap_get__tds__GetHostnameResponse(struct soap *soap, struct _tds__GetHostnameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetHostnameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetHostname(struct soap *soap, struct _tds__GetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetHostname(struct soap *soap, const struct _tds__GetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetHostname(struct soap *soap, const char *tag, int id, const struct _tds__GetHostname *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetHostname), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetHostname * SOAP_FMAC4 soap_in__tds__GetHostname(struct soap *soap, const char *tag, struct _tds__GetHostname *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetHostname *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetHostname, sizeof(struct _tds__GetHostname), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetHostname(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetHostname *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetHostname, SOAP_TYPE__tds__GetHostname, sizeof(struct _tds__GetHostname), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetHostname * SOAP_FMAC4 soap_new__tds__GetHostname(struct soap *soap, int n)
{
	struct _tds__GetHostname *p;
	struct _tds__GetHostname *a = (struct _tds__GetHostname*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetHostname));
	for (p = a; p && n--; p++)
		soap_default__tds__GetHostname(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetHostname(struct soap *soap, const struct _tds__GetHostname *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetHostname(soap, tag ? tag : "tds:GetHostname", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetHostname * SOAP_FMAC4 soap_get__tds__GetHostname(struct soap *soap, struct _tds__GetHostname *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCapabilitiesResponse(struct soap *soap, struct _tds__GetCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCapabilitiesResponse(struct soap *soap, const struct _tds__GetCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tds:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_nil(soap, "tds:Capabilities"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__Capabilities(soap, "tds:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCapabilitiesResponse * SOAP_FMAC4 soap_in__tds__GetCapabilitiesResponse(struct soap *soap, const char *tag, struct _tds__GetCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCapabilitiesResponse, sizeof(struct _tds__GetCapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetCapabilitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Capabilities(soap, "tds:Capabilities", &a->Capabilities, "tt:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			soap_check_result(soap, "tds:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCapabilitiesResponse, SOAP_TYPE__tds__GetCapabilitiesResponse, sizeof(struct _tds__GetCapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetCapabilitiesResponse * SOAP_FMAC4 soap_new__tds__GetCapabilitiesResponse(struct soap *soap, int n)
{
	struct _tds__GetCapabilitiesResponse *p;
	struct _tds__GetCapabilitiesResponse *a = (struct _tds__GetCapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetCapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetCapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCapabilitiesResponse(struct soap *soap, const struct _tds__GetCapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetCapabilitiesResponse(soap, tag ? tag : "tds:GetCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCapabilitiesResponse * SOAP_FMAC4 soap_get__tds__GetCapabilitiesResponse(struct soap *soap, struct _tds__GetCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCapabilities(struct soap *soap, struct _tds__GetCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeCategory = 0;
	a->Category = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCapabilities(struct soap *soap, const struct _tds__GetCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Category)
	{	int i;
		for (i = 0; i < (int)a->__sizeCategory; i++)
		{
			soap_embedded(soap, a->Category + i, SOAP_TYPE_tt__CapabilityCategory);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCapabilities(struct soap *soap, const char *tag, int id, const struct _tds__GetCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCapabilities), type))
		return soap->error;
	if (a->Category)
	{	int i;
		for (i = 0; i < (int)a->__sizeCategory; i++)
			if (soap_out_tt__CapabilityCategory(soap, "tds:Category", -1, a->Category + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCapabilities * SOAP_FMAC4 soap_in__tds__GetCapabilities(struct soap *soap, const char *tag, struct _tds__GetCapabilities *a, const char *type)
{
	struct soap_blist *soap_blist_Category = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCapabilities, sizeof(struct _tds__GetCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Category", 1, NULL))
			{	if (a->Category == NULL)
				{	if (soap_blist_Category == NULL)
						soap_blist_Category = soap_alloc_block(soap);
					a->Category = (enum tt__CapabilityCategory *)soap_push_block_max(soap, soap_blist_Category, sizeof(enum tt__CapabilityCategory));
					if (a->Category == NULL)
						return NULL;
					soap_default_tt__CapabilityCategory(soap, a->Category);
				}
				soap_revert(soap);
				if (soap_in_tt__CapabilityCategory(soap, "tds:Category", a->Category, "tt:CapabilityCategory"))
				{	a->__sizeCategory++;
					a->Category = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Category)
			soap_pop_block(soap, soap_blist_Category);
		if (a->__sizeCategory)
		{	a->Category = (enum tt__CapabilityCategory *)soap_save_block(soap, soap_blist_Category, NULL, 1);
		}
		else
		{	a->Category = NULL;
			if (soap_blist_Category)
				soap_end_block(soap, soap_blist_Category);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCapabilities, SOAP_TYPE__tds__GetCapabilities, sizeof(struct _tds__GetCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetCapabilities * SOAP_FMAC4 soap_new__tds__GetCapabilities(struct soap *soap, int n)
{
	struct _tds__GetCapabilities *p;
	struct _tds__GetCapabilities *a = (struct _tds__GetCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetCapabilities));
	for (p = a; p && n--; p++)
		soap_default__tds__GetCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCapabilities(struct soap *soap, const struct _tds__GetCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetCapabilities(soap, tag ? tag : "tds:GetCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCapabilities * SOAP_FMAC4 soap_get__tds__GetCapabilities(struct soap *soap, struct _tds__GetCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetWsdlUrlResponse(struct soap *soap, struct _tds__GetWsdlUrlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->WsdlUrl);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetWsdlUrlResponse(struct soap *soap, const struct _tds__GetWsdlUrlResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anyURI(soap, (char*const*)&a->WsdlUrl);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetWsdlUrlResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetWsdlUrlResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetWsdlUrlResponse), type))
		return soap->error;
	if (a->WsdlUrl)
		soap_element_result(soap, "tds:WsdlUrl");
	if (!a->WsdlUrl)
	{	if (soap_element_nil(soap, "tds:WsdlUrl"))
			return soap->error;
	}
	else
	if (soap_out_xsd__anyURI(soap, "tds:WsdlUrl", -1, (char*const*)&a->WsdlUrl, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetWsdlUrlResponse * SOAP_FMAC4 soap_in__tds__GetWsdlUrlResponse(struct soap *soap, const char *tag, struct _tds__GetWsdlUrlResponse *a, const char *type)
{
	size_t soap_flag_WsdlUrl = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetWsdlUrlResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetWsdlUrlResponse, sizeof(struct _tds__GetWsdlUrlResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetWsdlUrlResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WsdlUrl && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tds:WsdlUrl", (char**)&a->WsdlUrl, "xsd:anyURI"))
				{	soap_flag_WsdlUrl--;
					continue;
				}
			soap_check_result(soap, "tds:WsdlUrl");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_WsdlUrl > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetWsdlUrlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetWsdlUrlResponse, SOAP_TYPE__tds__GetWsdlUrlResponse, sizeof(struct _tds__GetWsdlUrlResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetWsdlUrlResponse * SOAP_FMAC4 soap_new__tds__GetWsdlUrlResponse(struct soap *soap, int n)
{
	struct _tds__GetWsdlUrlResponse *p;
	struct _tds__GetWsdlUrlResponse *a = (struct _tds__GetWsdlUrlResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetWsdlUrlResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetWsdlUrlResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetWsdlUrlResponse(struct soap *soap, const struct _tds__GetWsdlUrlResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetWsdlUrlResponse(soap, tag ? tag : "tds:GetWsdlUrlResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetWsdlUrlResponse * SOAP_FMAC4 soap_get__tds__GetWsdlUrlResponse(struct soap *soap, struct _tds__GetWsdlUrlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetWsdlUrlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetWsdlUrl(struct soap *soap, struct _tds__GetWsdlUrl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetWsdlUrl(struct soap *soap, const struct _tds__GetWsdlUrl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetWsdlUrl(struct soap *soap, const char *tag, int id, const struct _tds__GetWsdlUrl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetWsdlUrl), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetWsdlUrl * SOAP_FMAC4 soap_in__tds__GetWsdlUrl(struct soap *soap, const char *tag, struct _tds__GetWsdlUrl *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetWsdlUrl *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetWsdlUrl, sizeof(struct _tds__GetWsdlUrl), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetWsdlUrl(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetWsdlUrl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetWsdlUrl, SOAP_TYPE__tds__GetWsdlUrl, sizeof(struct _tds__GetWsdlUrl), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetWsdlUrl * SOAP_FMAC4 soap_new__tds__GetWsdlUrl(struct soap *soap, int n)
{
	struct _tds__GetWsdlUrl *p;
	struct _tds__GetWsdlUrl *a = (struct _tds__GetWsdlUrl*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetWsdlUrl));
	for (p = a; p && n--; p++)
		soap_default__tds__GetWsdlUrl(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetWsdlUrl(struct soap *soap, const struct _tds__GetWsdlUrl *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetWsdlUrl(soap, tag ? tag : "tds:GetWsdlUrl", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetWsdlUrl * SOAP_FMAC4 soap_get__tds__GetWsdlUrl(struct soap *soap, struct _tds__GetWsdlUrl *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetWsdlUrl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetUserResponse(struct soap *soap, struct _tds__SetUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetUserResponse(struct soap *soap, const struct _tds__SetUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetUserResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetUserResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetUserResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetUserResponse * SOAP_FMAC4 soap_in__tds__SetUserResponse(struct soap *soap, const char *tag, struct _tds__SetUserResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetUserResponse, sizeof(struct _tds__SetUserResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetUserResponse, SOAP_TYPE__tds__SetUserResponse, sizeof(struct _tds__SetUserResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetUserResponse * SOAP_FMAC4 soap_new__tds__SetUserResponse(struct soap *soap, int n)
{
	struct _tds__SetUserResponse *p;
	struct _tds__SetUserResponse *a = (struct _tds__SetUserResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetUserResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetUserResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetUserResponse(struct soap *soap, const struct _tds__SetUserResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetUserResponse(soap, tag ? tag : "tds:SetUserResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetUserResponse * SOAP_FMAC4 soap_get__tds__SetUserResponse(struct soap *soap, struct _tds__SetUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetUser(struct soap *soap, struct _tds__SetUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeUser = 0;
	a->User = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetUser(struct soap *soap, const struct _tds__SetUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->User)
	{	int i;
		for (i = 0; i < (int)a->__sizeUser; i++)
		{
			soap_embedded(soap, a->User + i, SOAP_TYPE_tt__User);
			soap_serialize_tt__User(soap, a->User + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetUser(struct soap *soap, const char *tag, int id, const struct _tds__SetUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetUser), type))
		return soap->error;
	if (a->User)
	{	int i;
		for (i = 0; i < (int)a->__sizeUser; i++)
			if (soap_out_tt__User(soap, "tds:User", -1, a->User + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetUser * SOAP_FMAC4 soap_in__tds__SetUser(struct soap *soap, const char *tag, struct _tds__SetUser *a, const char *type)
{
	struct soap_blist *soap_blist_User = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetUser, sizeof(struct _tds__SetUser), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:User", 1, NULL))
			{	if (a->User == NULL)
				{	if (soap_blist_User == NULL)
						soap_blist_User = soap_alloc_block(soap);
					a->User = (struct tt__User *)soap_push_block_max(soap, soap_blist_User, sizeof(struct tt__User));
					if (a->User == NULL)
						return NULL;
					soap_default_tt__User(soap, a->User);
				}
				soap_revert(soap);
				if (soap_in_tt__User(soap, "tds:User", a->User, "tt:User"))
				{	a->__sizeUser++;
					a->User = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->User)
			soap_pop_block(soap, soap_blist_User);
		if (a->__sizeUser)
		{	a->User = (struct tt__User *)soap_save_block(soap, soap_blist_User, NULL, 1);
		}
		else
		{	a->User = NULL;
			if (soap_blist_User)
				soap_end_block(soap, soap_blist_User);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeUser < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__SetUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetUser, SOAP_TYPE__tds__SetUser, sizeof(struct _tds__SetUser), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetUser * SOAP_FMAC4 soap_new__tds__SetUser(struct soap *soap, int n)
{
	struct _tds__SetUser *p;
	struct _tds__SetUser *a = (struct _tds__SetUser*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetUser));
	for (p = a; p && n--; p++)
		soap_default__tds__SetUser(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetUser(struct soap *soap, const struct _tds__SetUser *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetUser(soap, tag ? tag : "tds:SetUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetUser * SOAP_FMAC4 soap_get__tds__SetUser(struct soap *soap, struct _tds__SetUser *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__DeleteUsersResponse(struct soap *soap, struct _tds__DeleteUsersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__DeleteUsersResponse(struct soap *soap, const struct _tds__DeleteUsersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteUsersResponse(struct soap *soap, const char *tag, int id, const struct _tds__DeleteUsersResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteUsersResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__DeleteUsersResponse * SOAP_FMAC4 soap_in__tds__DeleteUsersResponse(struct soap *soap, const char *tag, struct _tds__DeleteUsersResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__DeleteUsersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteUsersResponse, sizeof(struct _tds__DeleteUsersResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__DeleteUsersResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__DeleteUsersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteUsersResponse, SOAP_TYPE__tds__DeleteUsersResponse, sizeof(struct _tds__DeleteUsersResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__DeleteUsersResponse * SOAP_FMAC4 soap_new__tds__DeleteUsersResponse(struct soap *soap, int n)
{
	struct _tds__DeleteUsersResponse *p;
	struct _tds__DeleteUsersResponse *a = (struct _tds__DeleteUsersResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__DeleteUsersResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__DeleteUsersResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__DeleteUsersResponse(struct soap *soap, const struct _tds__DeleteUsersResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__DeleteUsersResponse(soap, tag ? tag : "tds:DeleteUsersResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteUsersResponse * SOAP_FMAC4 soap_get__tds__DeleteUsersResponse(struct soap *soap, struct _tds__DeleteUsersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__DeleteUsers(struct soap *soap, struct _tds__DeleteUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeUsername = 0;
	a->Username = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__DeleteUsers(struct soap *soap, const struct _tds__DeleteUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->Username)
	{	int i;
		for (i = 0; i < (int)a->__sizeUsername; i++)
		{
			soap_serialize_string(soap, (char*const*)(a->Username + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteUsers(struct soap *soap, const char *tag, int id, const struct _tds__DeleteUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteUsers), type))
		return soap->error;
	if (a->Username)
	{	int i;
		for (i = 0; i < (int)a->__sizeUsername; i++)
			soap_out_string(soap, "tds:Username", -1, (char*const*)(a->Username + i), "");
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__DeleteUsers * SOAP_FMAC4 soap_in__tds__DeleteUsers(struct soap *soap, const char *tag, struct _tds__DeleteUsers *a, const char *type)
{
	struct soap_blist *soap_blist_Username = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__DeleteUsers *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteUsers, sizeof(struct _tds__DeleteUsers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__DeleteUsers(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Username", 1, NULL))
			{	if (a->Username == NULL)
				{	if (soap_blist_Username == NULL)
						soap_blist_Username = soap_alloc_block(soap);
					a->Username = (char **)soap_push_block_max(soap, soap_blist_Username, sizeof(char *));
					if (a->Username == NULL)
						return NULL;
					*a->Username = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "tds:Username", (char**)a->Username, "xsd:string"))
				{	a->__sizeUsername++;
					a->Username = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Username)
			soap_pop_block(soap, soap_blist_Username);
		if (a->__sizeUsername)
		{	a->Username = (char **)soap_save_block(soap, soap_blist_Username, NULL, 1);
		}
		else
		{	a->Username = NULL;
			if (soap_blist_Username)
				soap_end_block(soap, soap_blist_Username);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeUsername < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__DeleteUsers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteUsers, SOAP_TYPE__tds__DeleteUsers, sizeof(struct _tds__DeleteUsers), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__DeleteUsers * SOAP_FMAC4 soap_new__tds__DeleteUsers(struct soap *soap, int n)
{
	struct _tds__DeleteUsers *p;
	struct _tds__DeleteUsers *a = (struct _tds__DeleteUsers*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__DeleteUsers));
	for (p = a; p && n--; p++)
		soap_default__tds__DeleteUsers(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__DeleteUsers(struct soap *soap, const struct _tds__DeleteUsers *a, const char *tag, const char *type)
{
	if (soap_out__tds__DeleteUsers(soap, tag ? tag : "tds:DeleteUsers", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteUsers * SOAP_FMAC4 soap_get__tds__DeleteUsers(struct soap *soap, struct _tds__DeleteUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__CreateUsersResponse(struct soap *soap, struct _tds__CreateUsersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__CreateUsersResponse(struct soap *soap, const struct _tds__CreateUsersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateUsersResponse(struct soap *soap, const char *tag, int id, const struct _tds__CreateUsersResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateUsersResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__CreateUsersResponse * SOAP_FMAC4 soap_in__tds__CreateUsersResponse(struct soap *soap, const char *tag, struct _tds__CreateUsersResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__CreateUsersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateUsersResponse, sizeof(struct _tds__CreateUsersResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__CreateUsersResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__CreateUsersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateUsersResponse, SOAP_TYPE__tds__CreateUsersResponse, sizeof(struct _tds__CreateUsersResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__CreateUsersResponse * SOAP_FMAC4 soap_new__tds__CreateUsersResponse(struct soap *soap, int n)
{
	struct _tds__CreateUsersResponse *p;
	struct _tds__CreateUsersResponse *a = (struct _tds__CreateUsersResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__CreateUsersResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__CreateUsersResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__CreateUsersResponse(struct soap *soap, const struct _tds__CreateUsersResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__CreateUsersResponse(soap, tag ? tag : "tds:CreateUsersResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateUsersResponse * SOAP_FMAC4 soap_get__tds__CreateUsersResponse(struct soap *soap, struct _tds__CreateUsersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__CreateUsers(struct soap *soap, struct _tds__CreateUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeUser = 0;
	a->User = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__CreateUsers(struct soap *soap, const struct _tds__CreateUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->User)
	{	int i;
		for (i = 0; i < (int)a->__sizeUser; i++)
		{
			soap_embedded(soap, a->User + i, SOAP_TYPE_tt__User);
			soap_serialize_tt__User(soap, a->User + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateUsers(struct soap *soap, const char *tag, int id, const struct _tds__CreateUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateUsers), type))
		return soap->error;
	if (a->User)
	{	int i;
		for (i = 0; i < (int)a->__sizeUser; i++)
			if (soap_out_tt__User(soap, "tds:User", -1, a->User + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__CreateUsers * SOAP_FMAC4 soap_in__tds__CreateUsers(struct soap *soap, const char *tag, struct _tds__CreateUsers *a, const char *type)
{
	struct soap_blist *soap_blist_User = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__CreateUsers *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateUsers, sizeof(struct _tds__CreateUsers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__CreateUsers(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:User", 1, NULL))
			{	if (a->User == NULL)
				{	if (soap_blist_User == NULL)
						soap_blist_User = soap_alloc_block(soap);
					a->User = (struct tt__User *)soap_push_block_max(soap, soap_blist_User, sizeof(struct tt__User));
					if (a->User == NULL)
						return NULL;
					soap_default_tt__User(soap, a->User);
				}
				soap_revert(soap);
				if (soap_in_tt__User(soap, "tds:User", a->User, "tt:User"))
				{	a->__sizeUser++;
					a->User = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->User)
			soap_pop_block(soap, soap_blist_User);
		if (a->__sizeUser)
		{	a->User = (struct tt__User *)soap_save_block(soap, soap_blist_User, NULL, 1);
		}
		else
		{	a->User = NULL;
			if (soap_blist_User)
				soap_end_block(soap, soap_blist_User);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeUser < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__CreateUsers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateUsers, SOAP_TYPE__tds__CreateUsers, sizeof(struct _tds__CreateUsers), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__CreateUsers * SOAP_FMAC4 soap_new__tds__CreateUsers(struct soap *soap, int n)
{
	struct _tds__CreateUsers *p;
	struct _tds__CreateUsers *a = (struct _tds__CreateUsers*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__CreateUsers));
	for (p = a; p && n--; p++)
		soap_default__tds__CreateUsers(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__CreateUsers(struct soap *soap, const struct _tds__CreateUsers *a, const char *tag, const char *type)
{
	if (soap_out__tds__CreateUsers(soap, tag ? tag : "tds:CreateUsers", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateUsers * SOAP_FMAC4 soap_get__tds__CreateUsers(struct soap *soap, struct _tds__CreateUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetUsersResponse(struct soap *soap, struct _tds__GetUsersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeUser = 0;
	a->User = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetUsersResponse(struct soap *soap, const struct _tds__GetUsersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->User)
	{	int i;
		for (i = 0; i < (int)a->__sizeUser; i++)
		{
			soap_embedded(soap, a->User + i, SOAP_TYPE_tt__User);
			soap_serialize_tt__User(soap, a->User + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetUsersResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetUsersResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetUsersResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeUser");
	if (a->User)
	{	int i;
		for (i = 0; i < (int)a->__sizeUser; i++)
			if (soap_out_tt__User(soap, "tds:User", -1, a->User + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetUsersResponse * SOAP_FMAC4 soap_in__tds__GetUsersResponse(struct soap *soap, const char *tag, struct _tds__GetUsersResponse *a, const char *type)
{
	struct soap_blist *soap_blist_User = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetUsersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetUsersResponse, sizeof(struct _tds__GetUsersResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetUsersResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:User", 1, NULL))
			{	if (a->User == NULL)
				{	if (soap_blist_User == NULL)
						soap_blist_User = soap_alloc_block(soap);
					a->User = (struct tt__User *)soap_push_block_max(soap, soap_blist_User, sizeof(struct tt__User));
					if (a->User == NULL)
						return NULL;
					soap_default_tt__User(soap, a->User);
				}
				soap_revert(soap);
				if (soap_in_tt__User(soap, "tds:User", a->User, "tt:User"))
				{	a->__sizeUser++;
					a->User = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeUser");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->User)
			soap_pop_block(soap, soap_blist_User);
		if (a->__sizeUser)
		{	a->User = (struct tt__User *)soap_save_block(soap, soap_blist_User, NULL, 1);
		}
		else
		{	a->User = NULL;
			if (soap_blist_User)
				soap_end_block(soap, soap_blist_User);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetUsersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetUsersResponse, SOAP_TYPE__tds__GetUsersResponse, sizeof(struct _tds__GetUsersResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetUsersResponse * SOAP_FMAC4 soap_new__tds__GetUsersResponse(struct soap *soap, int n)
{
	struct _tds__GetUsersResponse *p;
	struct _tds__GetUsersResponse *a = (struct _tds__GetUsersResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetUsersResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetUsersResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetUsersResponse(struct soap *soap, const struct _tds__GetUsersResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetUsersResponse(soap, tag ? tag : "tds:GetUsersResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetUsersResponse * SOAP_FMAC4 soap_get__tds__GetUsersResponse(struct soap *soap, struct _tds__GetUsersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetUsers(struct soap *soap, struct _tds__GetUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetUsers(struct soap *soap, const struct _tds__GetUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetUsers(struct soap *soap, const char *tag, int id, const struct _tds__GetUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetUsers), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetUsers * SOAP_FMAC4 soap_in__tds__GetUsers(struct soap *soap, const char *tag, struct _tds__GetUsers *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetUsers *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetUsers, sizeof(struct _tds__GetUsers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetUsers(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetUsers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetUsers, SOAP_TYPE__tds__GetUsers, sizeof(struct _tds__GetUsers), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetUsers * SOAP_FMAC4 soap_new__tds__GetUsers(struct soap *soap, int n)
{
	struct _tds__GetUsers *p;
	struct _tds__GetUsers *a = (struct _tds__GetUsers*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetUsers));
	for (p = a; p && n--; p++)
		soap_default__tds__GetUsers(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetUsers(struct soap *soap, const struct _tds__GetUsers *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetUsers(soap, tag ? tag : "tds:GetUsers", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetUsers * SOAP_FMAC4 soap_get__tds__GetUsers(struct soap *soap, struct _tds__GetUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRemoteUserResponse(struct soap *soap, struct _tds__SetRemoteUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRemoteUserResponse(struct soap *soap, const struct _tds__SetRemoteUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRemoteUserResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetRemoteUserResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRemoteUserResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRemoteUserResponse * SOAP_FMAC4 soap_in__tds__SetRemoteUserResponse(struct soap *soap, const char *tag, struct _tds__SetRemoteUserResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetRemoteUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRemoteUserResponse, sizeof(struct _tds__SetRemoteUserResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetRemoteUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRemoteUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRemoteUserResponse, SOAP_TYPE__tds__SetRemoteUserResponse, sizeof(struct _tds__SetRemoteUserResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetRemoteUserResponse * SOAP_FMAC4 soap_new__tds__SetRemoteUserResponse(struct soap *soap, int n)
{
	struct _tds__SetRemoteUserResponse *p;
	struct _tds__SetRemoteUserResponse *a = (struct _tds__SetRemoteUserResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetRemoteUserResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetRemoteUserResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRemoteUserResponse(struct soap *soap, const struct _tds__SetRemoteUserResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetRemoteUserResponse(soap, tag ? tag : "tds:SetRemoteUserResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRemoteUserResponse * SOAP_FMAC4 soap_get__tds__SetRemoteUserResponse(struct soap *soap, struct _tds__SetRemoteUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRemoteUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRemoteUser(struct soap *soap, struct _tds__SetRemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RemoteUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRemoteUser(struct soap *soap, const struct _tds__SetRemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RemoteUser(soap, &a->RemoteUser);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRemoteUser(struct soap *soap, const char *tag, int id, const struct _tds__SetRemoteUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRemoteUser), type))
		return soap->error;
	if (soap_out_PointerTott__RemoteUser(soap, "tds:RemoteUser", -1, &a->RemoteUser, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRemoteUser * SOAP_FMAC4 soap_in__tds__SetRemoteUser(struct soap *soap, const char *tag, struct _tds__SetRemoteUser *a, const char *type)
{
	size_t soap_flag_RemoteUser = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetRemoteUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRemoteUser, sizeof(struct _tds__SetRemoteUser), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetRemoteUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RemoteUser && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RemoteUser(soap, "tds:RemoteUser", &a->RemoteUser, "tt:RemoteUser"))
				{	soap_flag_RemoteUser--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRemoteUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRemoteUser, SOAP_TYPE__tds__SetRemoteUser, sizeof(struct _tds__SetRemoteUser), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetRemoteUser * SOAP_FMAC4 soap_new__tds__SetRemoteUser(struct soap *soap, int n)
{
	struct _tds__SetRemoteUser *p;
	struct _tds__SetRemoteUser *a = (struct _tds__SetRemoteUser*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetRemoteUser));
	for (p = a; p && n--; p++)
		soap_default__tds__SetRemoteUser(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRemoteUser(struct soap *soap, const struct _tds__SetRemoteUser *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetRemoteUser(soap, tag ? tag : "tds:SetRemoteUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRemoteUser * SOAP_FMAC4 soap_get__tds__SetRemoteUser(struct soap *soap, struct _tds__SetRemoteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetRemoteUserResponse(struct soap *soap, struct _tds__GetRemoteUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RemoteUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetRemoteUserResponse(struct soap *soap, const struct _tds__GetRemoteUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RemoteUser(soap, &a->RemoteUser);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRemoteUserResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetRemoteUserResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRemoteUserResponse), type))
		return soap->error;
	if (a->RemoteUser)
		soap_element_result(soap, "tds:RemoteUser");
	if (soap_out_PointerTott__RemoteUser(soap, "tds:RemoteUser", -1, &a->RemoteUser, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetRemoteUserResponse * SOAP_FMAC4 soap_in__tds__GetRemoteUserResponse(struct soap *soap, const char *tag, struct _tds__GetRemoteUserResponse *a, const char *type)
{
	size_t soap_flag_RemoteUser = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetRemoteUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRemoteUserResponse, sizeof(struct _tds__GetRemoteUserResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetRemoteUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RemoteUser && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RemoteUser(soap, "tds:RemoteUser", &a->RemoteUser, "tt:RemoteUser"))
				{	soap_flag_RemoteUser--;
					continue;
				}
			soap_check_result(soap, "tds:RemoteUser");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetRemoteUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRemoteUserResponse, SOAP_TYPE__tds__GetRemoteUserResponse, sizeof(struct _tds__GetRemoteUserResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetRemoteUserResponse * SOAP_FMAC4 soap_new__tds__GetRemoteUserResponse(struct soap *soap, int n)
{
	struct _tds__GetRemoteUserResponse *p;
	struct _tds__GetRemoteUserResponse *a = (struct _tds__GetRemoteUserResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetRemoteUserResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetRemoteUserResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetRemoteUserResponse(struct soap *soap, const struct _tds__GetRemoteUserResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetRemoteUserResponse(soap, tag ? tag : "tds:GetRemoteUserResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRemoteUserResponse * SOAP_FMAC4 soap_get__tds__GetRemoteUserResponse(struct soap *soap, struct _tds__GetRemoteUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRemoteUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetRemoteUser(struct soap *soap, struct _tds__GetRemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetRemoteUser(struct soap *soap, const struct _tds__GetRemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRemoteUser(struct soap *soap, const char *tag, int id, const struct _tds__GetRemoteUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRemoteUser), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetRemoteUser * SOAP_FMAC4 soap_in__tds__GetRemoteUser(struct soap *soap, const char *tag, struct _tds__GetRemoteUser *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetRemoteUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRemoteUser, sizeof(struct _tds__GetRemoteUser), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetRemoteUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetRemoteUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRemoteUser, SOAP_TYPE__tds__GetRemoteUser, sizeof(struct _tds__GetRemoteUser), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetRemoteUser * SOAP_FMAC4 soap_new__tds__GetRemoteUser(struct soap *soap, int n)
{
	struct _tds__GetRemoteUser *p;
	struct _tds__GetRemoteUser *a = (struct _tds__GetRemoteUser*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetRemoteUser));
	for (p = a; p && n--; p++)
		soap_default__tds__GetRemoteUser(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetRemoteUser(struct soap *soap, const struct _tds__GetRemoteUser *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetRemoteUser(soap, tag ? tag : "tds:GetRemoteUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRemoteUser * SOAP_FMAC4 soap_get__tds__GetRemoteUser(struct soap *soap, struct _tds__GetRemoteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetEndpointReferenceResponse(struct soap *soap, struct _tds__GetEndpointReferenceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->GUID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetEndpointReferenceResponse(struct soap *soap, const struct _tds__GetEndpointReferenceResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->GUID);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetEndpointReferenceResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetEndpointReferenceResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetEndpointReferenceResponse), type))
		return soap->error;
	if (a->GUID)
		soap_element_result(soap, "tds:GUID");
	if (!a->GUID)
	{	if (soap_element_nil(soap, "tds:GUID"))
			return soap->error;
	}
	else
	if (soap_out_string(soap, "tds:GUID", -1, (char*const*)&a->GUID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetEndpointReferenceResponse * SOAP_FMAC4 soap_in__tds__GetEndpointReferenceResponse(struct soap *soap, const char *tag, struct _tds__GetEndpointReferenceResponse *a, const char *type)
{
	size_t soap_flag_GUID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetEndpointReferenceResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetEndpointReferenceResponse, sizeof(struct _tds__GetEndpointReferenceResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetEndpointReferenceResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GUID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:GUID", (char**)&a->GUID, "xsd:string"))
				{	soap_flag_GUID--;
					continue;
				}
			soap_check_result(soap, "tds:GUID");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GUID > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tds__GetEndpointReferenceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetEndpointReferenceResponse, SOAP_TYPE__tds__GetEndpointReferenceResponse, sizeof(struct _tds__GetEndpointReferenceResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetEndpointReferenceResponse * SOAP_FMAC4 soap_new__tds__GetEndpointReferenceResponse(struct soap *soap, int n)
{
	struct _tds__GetEndpointReferenceResponse *p;
	struct _tds__GetEndpointReferenceResponse *a = (struct _tds__GetEndpointReferenceResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetEndpointReferenceResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__GetEndpointReferenceResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetEndpointReferenceResponse(struct soap *soap, const struct _tds__GetEndpointReferenceResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetEndpointReferenceResponse(soap, tag ? tag : "tds:GetEndpointReferenceResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetEndpointReferenceResponse * SOAP_FMAC4 soap_get__tds__GetEndpointReferenceResponse(struct soap *soap, struct _tds__GetEndpointReferenceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetEndpointReferenceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetEndpointReference(struct soap *soap, struct _tds__GetEndpointReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetEndpointReference(struct soap *soap, const struct _tds__GetEndpointReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetEndpointReference(struct soap *soap, const char *tag, int id, const struct _tds__GetEndpointReference *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetEndpointReference), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetEndpointReference * SOAP_FMAC4 soap_in__tds__GetEndpointReference(struct soap *soap, const char *tag, struct _tds__GetEndpointReference *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetEndpointReference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetEndpointReference, sizeof(struct _tds__GetEndpointReference), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetEndpointReference(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetEndpointReference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetEndpointReference, SOAP_TYPE__tds__GetEndpointReference, sizeof(struct _tds__GetEndpointReference), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__GetEndpointReference * SOAP_FMAC4 soap_new__tds__GetEndpointReference(struct soap *soap, int n)
{
	struct _tds__GetEndpointReference *p;
	struct _tds__GetEndpointReference *a = (struct _tds__GetEndpointReference*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__GetEndpointReference));
	for (p = a; p && n--; p++)
		soap_default__tds__GetEndpointReference(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetEndpointReference(struct soap *soap, const struct _tds__GetEndpointReference *a, const char *tag, const char *type)
{
	if (soap_out__tds__GetEndpointReference(soap, tag ? tag : "tds:GetEndpointReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetEndpointReference * SOAP_FMAC4 soap_get__tds__GetEndpointReference(struct soap *soap, struct _tds__GetEndpointReference *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetEndpointReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDPAddressesResponse(struct soap *soap, struct _tds__SetDPAddressesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDPAddressesResponse(struct soap *soap, const struct _tds__SetDPAddressesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDPAddressesResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetDPAddressesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDPAddressesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDPAddressesResponse * SOAP_FMAC4 soap_in__tds__SetDPAddressesResponse(struct soap *soap, const char *tag, struct _tds__SetDPAddressesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetDPAddressesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDPAddressesResponse, sizeof(struct _tds__SetDPAddressesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetDPAddressesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDPAddressesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDPAddressesResponse, SOAP_TYPE__tds__SetDPAddressesResponse, sizeof(struct _tds__SetDPAddressesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tds__SetDPAddressesResponse * SOAP_FMAC4 soap_new__tds__SetDPAddressesResponse(struct soap *soap, int n)
{
	struct _tds__SetDPAddressesResponse *p;
	struct _tds__SetDPAddressesResponse *a = (struct _tds__SetDPAddressesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tds__SetDPAddressesResponse));
	for (p = a; p && n--; p++)
		soap_default__tds__SetDPAddressesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDPAddressesResponse(struct soap *soap, const struct _tds__SetDPAddressesResponse *a, const char *tag, const char *type)
{
	if (soap_out__tds__SetDPAddressesResponse(soap, tag ? tag : "tds:SetDPAddressesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDPAddressesResponse * SOAP_FMAC4 soap_get__tds__SetDPAddressesResponse(struct soap *soap, struct _tds__SetDPAddressesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDPAddressesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
