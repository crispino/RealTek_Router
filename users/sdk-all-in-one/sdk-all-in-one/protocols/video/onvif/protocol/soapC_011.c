/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:58 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__DeleteAccessProfile(struct soap *soap, struct __ns3__DeleteAccessProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__DeleteAccessProfile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__DeleteAccessProfile(struct soap *soap, const struct __ns3__DeleteAccessProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__DeleteAccessProfile(soap, &a->ns3__DeleteAccessProfile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__DeleteAccessProfile(struct soap *soap, const char *tag, int id, const struct __ns3__DeleteAccessProfile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__DeleteAccessProfile(soap, "ns3:DeleteAccessProfile", -1, &a->ns3__DeleteAccessProfile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__DeleteAccessProfile * SOAP_FMAC4 soap_in___ns3__DeleteAccessProfile(struct soap *soap, const char *tag, struct __ns3__DeleteAccessProfile *a, const char *type)
{
	size_t soap_flag_ns3__DeleteAccessProfile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__DeleteAccessProfile *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__DeleteAccessProfile, sizeof(struct __ns3__DeleteAccessProfile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__DeleteAccessProfile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__DeleteAccessProfile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__DeleteAccessProfile(soap, "ns3:DeleteAccessProfile", &a->ns3__DeleteAccessProfile, ""))
				{	soap_flag_ns3__DeleteAccessProfile--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__DeleteAccessProfile * SOAP_FMAC4 soap_new___ns3__DeleteAccessProfile(struct soap *soap, int n)
{
	struct __ns3__DeleteAccessProfile *p;
	struct __ns3__DeleteAccessProfile *a = (struct __ns3__DeleteAccessProfile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns3__DeleteAccessProfile));
	for (p = a; p && n--; p++)
		soap_default___ns3__DeleteAccessProfile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__DeleteAccessProfile(struct soap *soap, const struct __ns3__DeleteAccessProfile *a, const char *tag, const char *type)
{
	if (soap_out___ns3__DeleteAccessProfile(soap, tag ? tag : "-ns3:DeleteAccessProfile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__DeleteAccessProfile * SOAP_FMAC4 soap_get___ns3__DeleteAccessProfile(struct soap *soap, struct __ns3__DeleteAccessProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__DeleteAccessProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__ModifyAccessProfile(struct soap *soap, struct __ns3__ModifyAccessProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__ModifyAccessProfile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__ModifyAccessProfile(struct soap *soap, const struct __ns3__ModifyAccessProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__ModifyAccessProfile(soap, &a->ns3__ModifyAccessProfile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__ModifyAccessProfile(struct soap *soap, const char *tag, int id, const struct __ns3__ModifyAccessProfile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__ModifyAccessProfile(soap, "ns3:ModifyAccessProfile", -1, &a->ns3__ModifyAccessProfile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__ModifyAccessProfile * SOAP_FMAC4 soap_in___ns3__ModifyAccessProfile(struct soap *soap, const char *tag, struct __ns3__ModifyAccessProfile *a, const char *type)
{
	size_t soap_flag_ns3__ModifyAccessProfile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__ModifyAccessProfile *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__ModifyAccessProfile, sizeof(struct __ns3__ModifyAccessProfile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__ModifyAccessProfile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__ModifyAccessProfile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__ModifyAccessProfile(soap, "ns3:ModifyAccessProfile", &a->ns3__ModifyAccessProfile, ""))
				{	soap_flag_ns3__ModifyAccessProfile--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__ModifyAccessProfile * SOAP_FMAC4 soap_new___ns3__ModifyAccessProfile(struct soap *soap, int n)
{
	struct __ns3__ModifyAccessProfile *p;
	struct __ns3__ModifyAccessProfile *a = (struct __ns3__ModifyAccessProfile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns3__ModifyAccessProfile));
	for (p = a; p && n--; p++)
		soap_default___ns3__ModifyAccessProfile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__ModifyAccessProfile(struct soap *soap, const struct __ns3__ModifyAccessProfile *a, const char *tag, const char *type)
{
	if (soap_out___ns3__ModifyAccessProfile(soap, tag ? tag : "-ns3:ModifyAccessProfile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__ModifyAccessProfile * SOAP_FMAC4 soap_get___ns3__ModifyAccessProfile(struct soap *soap, struct __ns3__ModifyAccessProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__ModifyAccessProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__CreateAccessProfile(struct soap *soap, struct __ns3__CreateAccessProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__CreateAccessProfile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__CreateAccessProfile(struct soap *soap, const struct __ns3__CreateAccessProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__CreateAccessProfile(soap, &a->ns3__CreateAccessProfile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__CreateAccessProfile(struct soap *soap, const char *tag, int id, const struct __ns3__CreateAccessProfile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__CreateAccessProfile(soap, "ns3:CreateAccessProfile", -1, &a->ns3__CreateAccessProfile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__CreateAccessProfile * SOAP_FMAC4 soap_in___ns3__CreateAccessProfile(struct soap *soap, const char *tag, struct __ns3__CreateAccessProfile *a, const char *type)
{
	size_t soap_flag_ns3__CreateAccessProfile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__CreateAccessProfile *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__CreateAccessProfile, sizeof(struct __ns3__CreateAccessProfile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__CreateAccessProfile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__CreateAccessProfile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__CreateAccessProfile(soap, "ns3:CreateAccessProfile", &a->ns3__CreateAccessProfile, ""))
				{	soap_flag_ns3__CreateAccessProfile--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__CreateAccessProfile * SOAP_FMAC4 soap_new___ns3__CreateAccessProfile(struct soap *soap, int n)
{
	struct __ns3__CreateAccessProfile *p;
	struct __ns3__CreateAccessProfile *a = (struct __ns3__CreateAccessProfile*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns3__CreateAccessProfile));
	for (p = a; p && n--; p++)
		soap_default___ns3__CreateAccessProfile(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__CreateAccessProfile(struct soap *soap, const struct __ns3__CreateAccessProfile *a, const char *tag, const char *type)
{
	if (soap_out___ns3__CreateAccessProfile(soap, tag ? tag : "-ns3:CreateAccessProfile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__CreateAccessProfile * SOAP_FMAC4 soap_get___ns3__CreateAccessProfile(struct soap *soap, struct __ns3__CreateAccessProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__CreateAccessProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__GetAccessProfileList(struct soap *soap, struct __ns3__GetAccessProfileList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetAccessProfileList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__GetAccessProfileList(struct soap *soap, const struct __ns3__GetAccessProfileList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__GetAccessProfileList(soap, &a->ns3__GetAccessProfileList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__GetAccessProfileList(struct soap *soap, const char *tag, int id, const struct __ns3__GetAccessProfileList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__GetAccessProfileList(soap, "ns3:GetAccessProfileList", -1, &a->ns3__GetAccessProfileList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetAccessProfileList * SOAP_FMAC4 soap_in___ns3__GetAccessProfileList(struct soap *soap, const char *tag, struct __ns3__GetAccessProfileList *a, const char *type)
{
	size_t soap_flag_ns3__GetAccessProfileList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__GetAccessProfileList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__GetAccessProfileList, sizeof(struct __ns3__GetAccessProfileList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__GetAccessProfileList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetAccessProfileList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__GetAccessProfileList(soap, "ns3:GetAccessProfileList", &a->ns3__GetAccessProfileList, ""))
				{	soap_flag_ns3__GetAccessProfileList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__GetAccessProfileList * SOAP_FMAC4 soap_new___ns3__GetAccessProfileList(struct soap *soap, int n)
{
	struct __ns3__GetAccessProfileList *p;
	struct __ns3__GetAccessProfileList *a = (struct __ns3__GetAccessProfileList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns3__GetAccessProfileList));
	for (p = a; p && n--; p++)
		soap_default___ns3__GetAccessProfileList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__GetAccessProfileList(struct soap *soap, const struct __ns3__GetAccessProfileList *a, const char *tag, const char *type)
{
	if (soap_out___ns3__GetAccessProfileList(soap, tag ? tag : "-ns3:GetAccessProfileList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetAccessProfileList * SOAP_FMAC4 soap_get___ns3__GetAccessProfileList(struct soap *soap, struct __ns3__GetAccessProfileList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__GetAccessProfileList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__GetAccessProfiles(struct soap *soap, struct __ns3__GetAccessProfiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetAccessProfiles = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__GetAccessProfiles(struct soap *soap, const struct __ns3__GetAccessProfiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__GetAccessProfiles(soap, &a->ns3__GetAccessProfiles);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__GetAccessProfiles(struct soap *soap, const char *tag, int id, const struct __ns3__GetAccessProfiles *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__GetAccessProfiles(soap, "ns3:GetAccessProfiles", -1, &a->ns3__GetAccessProfiles, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetAccessProfiles * SOAP_FMAC4 soap_in___ns3__GetAccessProfiles(struct soap *soap, const char *tag, struct __ns3__GetAccessProfiles *a, const char *type)
{
	size_t soap_flag_ns3__GetAccessProfiles = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__GetAccessProfiles *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__GetAccessProfiles, sizeof(struct __ns3__GetAccessProfiles), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__GetAccessProfiles(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetAccessProfiles && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__GetAccessProfiles(soap, "ns3:GetAccessProfiles", &a->ns3__GetAccessProfiles, ""))
				{	soap_flag_ns3__GetAccessProfiles--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__GetAccessProfiles * SOAP_FMAC4 soap_new___ns3__GetAccessProfiles(struct soap *soap, int n)
{
	struct __ns3__GetAccessProfiles *p;
	struct __ns3__GetAccessProfiles *a = (struct __ns3__GetAccessProfiles*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns3__GetAccessProfiles));
	for (p = a; p && n--; p++)
		soap_default___ns3__GetAccessProfiles(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__GetAccessProfiles(struct soap *soap, const struct __ns3__GetAccessProfiles *a, const char *tag, const char *type)
{
	if (soap_out___ns3__GetAccessProfiles(soap, tag ? tag : "-ns3:GetAccessProfiles", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetAccessProfiles * SOAP_FMAC4 soap_get___ns3__GetAccessProfiles(struct soap *soap, struct __ns3__GetAccessProfiles *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__GetAccessProfiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__GetAccessProfileInfoList(struct soap *soap, struct __ns3__GetAccessProfileInfoList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetAccessProfileInfoList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__GetAccessProfileInfoList(struct soap *soap, const struct __ns3__GetAccessProfileInfoList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__GetAccessProfileInfoList(soap, &a->ns3__GetAccessProfileInfoList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__GetAccessProfileInfoList(struct soap *soap, const char *tag, int id, const struct __ns3__GetAccessProfileInfoList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__GetAccessProfileInfoList(soap, "ns3:GetAccessProfileInfoList", -1, &a->ns3__GetAccessProfileInfoList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetAccessProfileInfoList * SOAP_FMAC4 soap_in___ns3__GetAccessProfileInfoList(struct soap *soap, const char *tag, struct __ns3__GetAccessProfileInfoList *a, const char *type)
{
	size_t soap_flag_ns3__GetAccessProfileInfoList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__GetAccessProfileInfoList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__GetAccessProfileInfoList, sizeof(struct __ns3__GetAccessProfileInfoList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__GetAccessProfileInfoList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetAccessProfileInfoList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__GetAccessProfileInfoList(soap, "ns3:GetAccessProfileInfoList", &a->ns3__GetAccessProfileInfoList, ""))
				{	soap_flag_ns3__GetAccessProfileInfoList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__GetAccessProfileInfoList * SOAP_FMAC4 soap_new___ns3__GetAccessProfileInfoList(struct soap *soap, int n)
{
	struct __ns3__GetAccessProfileInfoList *p;
	struct __ns3__GetAccessProfileInfoList *a = (struct __ns3__GetAccessProfileInfoList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns3__GetAccessProfileInfoList));
	for (p = a; p && n--; p++)
		soap_default___ns3__GetAccessProfileInfoList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__GetAccessProfileInfoList(struct soap *soap, const struct __ns3__GetAccessProfileInfoList *a, const char *tag, const char *type)
{
	if (soap_out___ns3__GetAccessProfileInfoList(soap, tag ? tag : "-ns3:GetAccessProfileInfoList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetAccessProfileInfoList * SOAP_FMAC4 soap_get___ns3__GetAccessProfileInfoList(struct soap *soap, struct __ns3__GetAccessProfileInfoList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__GetAccessProfileInfoList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__GetAccessProfileInfo(struct soap *soap, struct __ns3__GetAccessProfileInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetAccessProfileInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__GetAccessProfileInfo(struct soap *soap, const struct __ns3__GetAccessProfileInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__GetAccessProfileInfo(soap, &a->ns3__GetAccessProfileInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__GetAccessProfileInfo(struct soap *soap, const char *tag, int id, const struct __ns3__GetAccessProfileInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__GetAccessProfileInfo(soap, "ns3:GetAccessProfileInfo", -1, &a->ns3__GetAccessProfileInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetAccessProfileInfo * SOAP_FMAC4 soap_in___ns3__GetAccessProfileInfo(struct soap *soap, const char *tag, struct __ns3__GetAccessProfileInfo *a, const char *type)
{
	size_t soap_flag_ns3__GetAccessProfileInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__GetAccessProfileInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__GetAccessProfileInfo, sizeof(struct __ns3__GetAccessProfileInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__GetAccessProfileInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetAccessProfileInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__GetAccessProfileInfo(soap, "ns3:GetAccessProfileInfo", &a->ns3__GetAccessProfileInfo, ""))
				{	soap_flag_ns3__GetAccessProfileInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__GetAccessProfileInfo * SOAP_FMAC4 soap_new___ns3__GetAccessProfileInfo(struct soap *soap, int n)
{
	struct __ns3__GetAccessProfileInfo *p;
	struct __ns3__GetAccessProfileInfo *a = (struct __ns3__GetAccessProfileInfo*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns3__GetAccessProfileInfo));
	for (p = a; p && n--; p++)
		soap_default___ns3__GetAccessProfileInfo(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__GetAccessProfileInfo(struct soap *soap, const struct __ns3__GetAccessProfileInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns3__GetAccessProfileInfo(soap, tag ? tag : "-ns3:GetAccessProfileInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetAccessProfileInfo * SOAP_FMAC4 soap_get___ns3__GetAccessProfileInfo(struct soap *soap, struct __ns3__GetAccessProfileInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__GetAccessProfileInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns3__GetServiceCapabilities(struct soap *soap, struct __ns3__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns3__GetServiceCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns3__GetServiceCapabilities(struct soap *soap, const struct __ns3__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns3__GetServiceCapabilities(soap, &a->ns3__GetServiceCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns3__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct __ns3__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns3__GetServiceCapabilities(soap, "ns3:GetServiceCapabilities", -1, &a->ns3__GetServiceCapabilities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetServiceCapabilities * SOAP_FMAC4 soap_in___ns3__GetServiceCapabilities(struct soap *soap, const char *tag, struct __ns3__GetServiceCapabilities *a, const char *type)
{
	size_t soap_flag_ns3__GetServiceCapabilities = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns3__GetServiceCapabilities *)soap_id_enter(soap, "", a, SOAP_TYPE___ns3__GetServiceCapabilities, sizeof(struct __ns3__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns3__GetServiceCapabilities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns3__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns3__GetServiceCapabilities(soap, "ns3:GetServiceCapabilities", &a->ns3__GetServiceCapabilities, ""))
				{	soap_flag_ns3__GetServiceCapabilities--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns3__GetServiceCapabilities * SOAP_FMAC4 soap_new___ns3__GetServiceCapabilities(struct soap *soap, int n)
{
	struct __ns3__GetServiceCapabilities *p;
	struct __ns3__GetServiceCapabilities *a = (struct __ns3__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns3__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default___ns3__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns3__GetServiceCapabilities(struct soap *soap, const struct __ns3__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out___ns3__GetServiceCapabilities(soap, tag ? tag : "-ns3:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns3__GetServiceCapabilities * SOAP_FMAC4 soap_get___ns3__GetServiceCapabilities(struct soap *soap, struct __ns3__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns3__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ExternalAuthorization(struct soap *soap, struct __ns1__ExternalAuthorization *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ExternalAuthorization = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ExternalAuthorization(struct soap *soap, const struct __ns1__ExternalAuthorization *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ExternalAuthorization(soap, &a->ns1__ExternalAuthorization);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ExternalAuthorization(struct soap *soap, const char *tag, int id, const struct __ns1__ExternalAuthorization *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ExternalAuthorization(soap, "ns1:ExternalAuthorization", -1, &a->ns1__ExternalAuthorization, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExternalAuthorization * SOAP_FMAC4 soap_in___ns1__ExternalAuthorization(struct soap *soap, const char *tag, struct __ns1__ExternalAuthorization *a, const char *type)
{
	size_t soap_flag_ns1__ExternalAuthorization = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ExternalAuthorization *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ExternalAuthorization, sizeof(struct __ns1__ExternalAuthorization), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ExternalAuthorization(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ExternalAuthorization && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ExternalAuthorization(soap, "ns1:ExternalAuthorization", &a->ns1__ExternalAuthorization, ""))
				{	soap_flag_ns1__ExternalAuthorization--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__ExternalAuthorization * SOAP_FMAC4 soap_new___ns1__ExternalAuthorization(struct soap *soap, int n)
{
	struct __ns1__ExternalAuthorization *p;
	struct __ns1__ExternalAuthorization *a = (struct __ns1__ExternalAuthorization*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__ExternalAuthorization));
	for (p = a; p && n--; p++)
		soap_default___ns1__ExternalAuthorization(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ExternalAuthorization(struct soap *soap, const struct __ns1__ExternalAuthorization *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ExternalAuthorization(soap, tag ? tag : "-ns1:ExternalAuthorization", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExternalAuthorization * SOAP_FMAC4 soap_get___ns1__ExternalAuthorization(struct soap *soap, struct __ns1__ExternalAuthorization *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ExternalAuthorization(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DisableAccessPoint(struct soap *soap, struct __ns1__DisableAccessPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DisableAccessPoint = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DisableAccessPoint(struct soap *soap, const struct __ns1__DisableAccessPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__DisableAccessPoint(soap, &a->ns1__DisableAccessPoint);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DisableAccessPoint(struct soap *soap, const char *tag, int id, const struct __ns1__DisableAccessPoint *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__DisableAccessPoint(soap, "ns1:DisableAccessPoint", -1, &a->ns1__DisableAccessPoint, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DisableAccessPoint * SOAP_FMAC4 soap_in___ns1__DisableAccessPoint(struct soap *soap, const char *tag, struct __ns1__DisableAccessPoint *a, const char *type)
{
	size_t soap_flag_ns1__DisableAccessPoint = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__DisableAccessPoint *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DisableAccessPoint, sizeof(struct __ns1__DisableAccessPoint), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DisableAccessPoint(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DisableAccessPoint && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__DisableAccessPoint(soap, "ns1:DisableAccessPoint", &a->ns1__DisableAccessPoint, ""))
				{	soap_flag_ns1__DisableAccessPoint--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__DisableAccessPoint * SOAP_FMAC4 soap_new___ns1__DisableAccessPoint(struct soap *soap, int n)
{
	struct __ns1__DisableAccessPoint *p;
	struct __ns1__DisableAccessPoint *a = (struct __ns1__DisableAccessPoint*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__DisableAccessPoint));
	for (p = a; p && n--; p++)
		soap_default___ns1__DisableAccessPoint(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DisableAccessPoint(struct soap *soap, const struct __ns1__DisableAccessPoint *a, const char *tag, const char *type)
{
	if (soap_out___ns1__DisableAccessPoint(soap, tag ? tag : "-ns1:DisableAccessPoint", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DisableAccessPoint * SOAP_FMAC4 soap_get___ns1__DisableAccessPoint(struct soap *soap, struct __ns1__DisableAccessPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DisableAccessPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__EnableAccessPoint(struct soap *soap, struct __ns1__EnableAccessPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__EnableAccessPoint = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__EnableAccessPoint(struct soap *soap, const struct __ns1__EnableAccessPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__EnableAccessPoint(soap, &a->ns1__EnableAccessPoint);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__EnableAccessPoint(struct soap *soap, const char *tag, int id, const struct __ns1__EnableAccessPoint *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__EnableAccessPoint(soap, "ns1:EnableAccessPoint", -1, &a->ns1__EnableAccessPoint, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__EnableAccessPoint * SOAP_FMAC4 soap_in___ns1__EnableAccessPoint(struct soap *soap, const char *tag, struct __ns1__EnableAccessPoint *a, const char *type)
{
	size_t soap_flag_ns1__EnableAccessPoint = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__EnableAccessPoint *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__EnableAccessPoint, sizeof(struct __ns1__EnableAccessPoint), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__EnableAccessPoint(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__EnableAccessPoint && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__EnableAccessPoint(soap, "ns1:EnableAccessPoint", &a->ns1__EnableAccessPoint, ""))
				{	soap_flag_ns1__EnableAccessPoint--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__EnableAccessPoint * SOAP_FMAC4 soap_new___ns1__EnableAccessPoint(struct soap *soap, int n)
{
	struct __ns1__EnableAccessPoint *p;
	struct __ns1__EnableAccessPoint *a = (struct __ns1__EnableAccessPoint*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__EnableAccessPoint));
	for (p = a; p && n--; p++)
		soap_default___ns1__EnableAccessPoint(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__EnableAccessPoint(struct soap *soap, const struct __ns1__EnableAccessPoint *a, const char *tag, const char *type)
{
	if (soap_out___ns1__EnableAccessPoint(soap, tag ? tag : "-ns1:EnableAccessPoint", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__EnableAccessPoint * SOAP_FMAC4 soap_get___ns1__EnableAccessPoint(struct soap *soap, struct __ns1__EnableAccessPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__EnableAccessPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetAccessPointState(struct soap *soap, struct __ns1__GetAccessPointState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAccessPointState = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetAccessPointState(struct soap *soap, const struct __ns1__GetAccessPointState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetAccessPointState(soap, &a->ns1__GetAccessPointState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetAccessPointState(struct soap *soap, const char *tag, int id, const struct __ns1__GetAccessPointState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetAccessPointState(soap, "ns1:GetAccessPointState", -1, &a->ns1__GetAccessPointState, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAccessPointState * SOAP_FMAC4 soap_in___ns1__GetAccessPointState(struct soap *soap, const char *tag, struct __ns1__GetAccessPointState *a, const char *type)
{
	size_t soap_flag_ns1__GetAccessPointState = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetAccessPointState *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetAccessPointState, sizeof(struct __ns1__GetAccessPointState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetAccessPointState(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAccessPointState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetAccessPointState(soap, "ns1:GetAccessPointState", &a->ns1__GetAccessPointState, ""))
				{	soap_flag_ns1__GetAccessPointState--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__GetAccessPointState * SOAP_FMAC4 soap_new___ns1__GetAccessPointState(struct soap *soap, int n)
{
	struct __ns1__GetAccessPointState *p;
	struct __ns1__GetAccessPointState *a = (struct __ns1__GetAccessPointState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__GetAccessPointState));
	for (p = a; p && n--; p++)
		soap_default___ns1__GetAccessPointState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetAccessPointState(struct soap *soap, const struct __ns1__GetAccessPointState *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetAccessPointState(soap, tag ? tag : "-ns1:GetAccessPointState", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAccessPointState * SOAP_FMAC4 soap_get___ns1__GetAccessPointState(struct soap *soap, struct __ns1__GetAccessPointState *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetAccessPointState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetAreaInfo(struct soap *soap, struct __ns1__GetAreaInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAreaInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetAreaInfo(struct soap *soap, const struct __ns1__GetAreaInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetAreaInfo(soap, &a->ns1__GetAreaInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetAreaInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetAreaInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetAreaInfo(soap, "ns1:GetAreaInfo", -1, &a->ns1__GetAreaInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAreaInfo * SOAP_FMAC4 soap_in___ns1__GetAreaInfo(struct soap *soap, const char *tag, struct __ns1__GetAreaInfo *a, const char *type)
{
	size_t soap_flag_ns1__GetAreaInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetAreaInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetAreaInfo, sizeof(struct __ns1__GetAreaInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetAreaInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAreaInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetAreaInfo(soap, "ns1:GetAreaInfo", &a->ns1__GetAreaInfo, ""))
				{	soap_flag_ns1__GetAreaInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__GetAreaInfo * SOAP_FMAC4 soap_new___ns1__GetAreaInfo(struct soap *soap, int n)
{
	struct __ns1__GetAreaInfo *p;
	struct __ns1__GetAreaInfo *a = (struct __ns1__GetAreaInfo*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__GetAreaInfo));
	for (p = a; p && n--; p++)
		soap_default___ns1__GetAreaInfo(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetAreaInfo(struct soap *soap, const struct __ns1__GetAreaInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetAreaInfo(soap, tag ? tag : "-ns1:GetAreaInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAreaInfo * SOAP_FMAC4 soap_get___ns1__GetAreaInfo(struct soap *soap, struct __ns1__GetAreaInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetAreaInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetAreaInfoList(struct soap *soap, struct __ns1__GetAreaInfoList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAreaInfoList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetAreaInfoList(struct soap *soap, const struct __ns1__GetAreaInfoList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetAreaInfoList(soap, &a->ns1__GetAreaInfoList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetAreaInfoList(struct soap *soap, const char *tag, int id, const struct __ns1__GetAreaInfoList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetAreaInfoList(soap, "ns1:GetAreaInfoList", -1, &a->ns1__GetAreaInfoList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAreaInfoList * SOAP_FMAC4 soap_in___ns1__GetAreaInfoList(struct soap *soap, const char *tag, struct __ns1__GetAreaInfoList *a, const char *type)
{
	size_t soap_flag_ns1__GetAreaInfoList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetAreaInfoList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetAreaInfoList, sizeof(struct __ns1__GetAreaInfoList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetAreaInfoList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAreaInfoList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetAreaInfoList(soap, "ns1:GetAreaInfoList", &a->ns1__GetAreaInfoList, ""))
				{	soap_flag_ns1__GetAreaInfoList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__GetAreaInfoList * SOAP_FMAC4 soap_new___ns1__GetAreaInfoList(struct soap *soap, int n)
{
	struct __ns1__GetAreaInfoList *p;
	struct __ns1__GetAreaInfoList *a = (struct __ns1__GetAreaInfoList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__GetAreaInfoList));
	for (p = a; p && n--; p++)
		soap_default___ns1__GetAreaInfoList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetAreaInfoList(struct soap *soap, const struct __ns1__GetAreaInfoList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetAreaInfoList(soap, tag ? tag : "-ns1:GetAreaInfoList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAreaInfoList * SOAP_FMAC4 soap_get___ns1__GetAreaInfoList(struct soap *soap, struct __ns1__GetAreaInfoList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetAreaInfoList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetAccessPointInfo(struct soap *soap, struct __ns1__GetAccessPointInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAccessPointInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetAccessPointInfo(struct soap *soap, const struct __ns1__GetAccessPointInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetAccessPointInfo(soap, &a->ns1__GetAccessPointInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetAccessPointInfo(struct soap *soap, const char *tag, int id, const struct __ns1__GetAccessPointInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetAccessPointInfo(soap, "ns1:GetAccessPointInfo", -1, &a->ns1__GetAccessPointInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAccessPointInfo * SOAP_FMAC4 soap_in___ns1__GetAccessPointInfo(struct soap *soap, const char *tag, struct __ns1__GetAccessPointInfo *a, const char *type)
{
	size_t soap_flag_ns1__GetAccessPointInfo = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetAccessPointInfo *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetAccessPointInfo, sizeof(struct __ns1__GetAccessPointInfo), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetAccessPointInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAccessPointInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetAccessPointInfo(soap, "ns1:GetAccessPointInfo", &a->ns1__GetAccessPointInfo, ""))
				{	soap_flag_ns1__GetAccessPointInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__GetAccessPointInfo * SOAP_FMAC4 soap_new___ns1__GetAccessPointInfo(struct soap *soap, int n)
{
	struct __ns1__GetAccessPointInfo *p;
	struct __ns1__GetAccessPointInfo *a = (struct __ns1__GetAccessPointInfo*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__GetAccessPointInfo));
	for (p = a; p && n--; p++)
		soap_default___ns1__GetAccessPointInfo(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetAccessPointInfo(struct soap *soap, const struct __ns1__GetAccessPointInfo *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetAccessPointInfo(soap, tag ? tag : "-ns1:GetAccessPointInfo", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAccessPointInfo * SOAP_FMAC4 soap_get___ns1__GetAccessPointInfo(struct soap *soap, struct __ns1__GetAccessPointInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetAccessPointInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetAccessPointInfoList(struct soap *soap, struct __ns1__GetAccessPointInfoList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAccessPointInfoList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetAccessPointInfoList(struct soap *soap, const struct __ns1__GetAccessPointInfoList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetAccessPointInfoList(soap, &a->ns1__GetAccessPointInfoList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetAccessPointInfoList(struct soap *soap, const char *tag, int id, const struct __ns1__GetAccessPointInfoList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetAccessPointInfoList(soap, "ns1:GetAccessPointInfoList", -1, &a->ns1__GetAccessPointInfoList, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAccessPointInfoList * SOAP_FMAC4 soap_in___ns1__GetAccessPointInfoList(struct soap *soap, const char *tag, struct __ns1__GetAccessPointInfoList *a, const char *type)
{
	size_t soap_flag_ns1__GetAccessPointInfoList = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetAccessPointInfoList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetAccessPointInfoList, sizeof(struct __ns1__GetAccessPointInfoList), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetAccessPointInfoList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAccessPointInfoList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetAccessPointInfoList(soap, "ns1:GetAccessPointInfoList", &a->ns1__GetAccessPointInfoList, ""))
				{	soap_flag_ns1__GetAccessPointInfoList--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__GetAccessPointInfoList * SOAP_FMAC4 soap_new___ns1__GetAccessPointInfoList(struct soap *soap, int n)
{
	struct __ns1__GetAccessPointInfoList *p;
	struct __ns1__GetAccessPointInfoList *a = (struct __ns1__GetAccessPointInfoList*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__GetAccessPointInfoList));
	for (p = a; p && n--; p++)
		soap_default___ns1__GetAccessPointInfoList(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetAccessPointInfoList(struct soap *soap, const struct __ns1__GetAccessPointInfoList *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetAccessPointInfoList(soap, tag ? tag : "-ns1:GetAccessPointInfoList", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAccessPointInfoList * SOAP_FMAC4 soap_get___ns1__GetAccessPointInfoList(struct soap *soap, struct __ns1__GetAccessPointInfoList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetAccessPointInfoList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetServiceCapabilities(struct soap *soap, struct __ns1__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetServiceCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetServiceCapabilities(struct soap *soap, const struct __ns1__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetServiceCapabilities(soap, &a->ns1__GetServiceCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct __ns1__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetServiceCapabilities(soap, "ns1:GetServiceCapabilities", -1, &a->ns1__GetServiceCapabilities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetServiceCapabilities * SOAP_FMAC4 soap_in___ns1__GetServiceCapabilities(struct soap *soap, const char *tag, struct __ns1__GetServiceCapabilities *a, const char *type)
{
	size_t soap_flag_ns1__GetServiceCapabilities = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetServiceCapabilities *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetServiceCapabilities, sizeof(struct __ns1__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetServiceCapabilities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetServiceCapabilities(soap, "ns1:GetServiceCapabilities", &a->ns1__GetServiceCapabilities, ""))
				{	soap_flag_ns1__GetServiceCapabilities--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 struct __ns1__GetServiceCapabilities * SOAP_FMAC4 soap_new___ns1__GetServiceCapabilities(struct soap *soap, int n)
{
	struct __ns1__GetServiceCapabilities *p;
	struct __ns1__GetServiceCapabilities *a = (struct __ns1__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct __ns1__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default___ns1__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetServiceCapabilities(struct soap *soap, const struct __ns1__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetServiceCapabilities(soap, tag ? tag : "-ns1:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetServiceCapabilities * SOAP_FMAC4 soap_get___ns1__GetServiceCapabilities(struct soap *soap, struct __ns1__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrfr__ResourceUnavailableFaultType_FaultCause(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrfr__ResourceUnavailableFaultType_FaultCause(struct soap *soap, const struct _wsrfr__ResourceUnavailableFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfr__ResourceUnavailableFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsrfr__ResourceUnavailableFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_FaultCause), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_FaultCause * SOAP_FMAC4 soap_in__wsrfr__ResourceUnavailableFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsrfr__ResourceUnavailableFaultType_FaultCause *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsrfr__ResourceUnavailableFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_FaultCause, sizeof(struct _wsrfr__ResourceUnavailableFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsrfr__ResourceUnavailableFaultType_FaultCause(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsrfr__ResourceUnavailableFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_FaultCause, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_FaultCause, sizeof(struct _wsrfr__ResourceUnavailableFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_FaultCause * SOAP_FMAC4 soap_new__wsrfr__ResourceUnavailableFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsrfr__ResourceUnavailableFaultType_FaultCause *p;
	struct _wsrfr__ResourceUnavailableFaultType_FaultCause *a = (struct _wsrfr__ResourceUnavailableFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsrfr__ResourceUnavailableFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsrfr__ResourceUnavailableFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrfr__ResourceUnavailableFaultType_FaultCause(struct soap *soap, const struct _wsrfr__ResourceUnavailableFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsrfr__ResourceUnavailableFaultType_FaultCause(soap, tag ? tag : "wsrfr:ResourceUnavailableFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_FaultCause * SOAP_FMAC4 soap_get__wsrfr__ResourceUnavailableFaultType_FaultCause(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfr__ResourceUnavailableFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrfr__ResourceUnavailableFaultType_Description(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrfr__ResourceUnavailableFaultType_Description(struct soap *soap, const struct _wsrfr__ResourceUnavailableFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfr__ResourceUnavailableFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsrfr__ResourceUnavailableFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_Description * SOAP_FMAC4 soap_in__wsrfr__ResourceUnavailableFaultType_Description(struct soap *soap, const char *tag, struct _wsrfr__ResourceUnavailableFaultType_Description *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsrfr__ResourceUnavailableFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_Description, sizeof(struct _wsrfr__ResourceUnavailableFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsrfr__ResourceUnavailableFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_Description * SOAP_FMAC4 soap_new__wsrfr__ResourceUnavailableFaultType_Description(struct soap *soap, int n)
{
	struct _wsrfr__ResourceUnavailableFaultType_Description *p;
	struct _wsrfr__ResourceUnavailableFaultType_Description *a = (struct _wsrfr__ResourceUnavailableFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsrfr__ResourceUnavailableFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsrfr__ResourceUnavailableFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrfr__ResourceUnavailableFaultType_Description(struct soap *soap, const struct _wsrfr__ResourceUnavailableFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsrfr__ResourceUnavailableFaultType_Description(soap, tag ? tag : "wsrfr:ResourceUnavailableFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_Description * SOAP_FMAC4 soap_get__wsrfr__ResourceUnavailableFaultType_Description(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfr__ResourceUnavailableFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrfr__ResourceUnavailableFaultType_ErrorCode(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrfr__ResourceUnavailableFaultType_ErrorCode(struct soap *soap, const struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfr__ResourceUnavailableFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *a, const char *type)
{
	if (a->dialect)
		soap_set_attr(soap, "dialect", soap_xsd__anyURI2s(soap, a->dialect), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_ErrorCode), type))
		return soap->error;
	soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsrfr__ResourceUnavailableFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_ErrorCode, sizeof(struct _wsrfr__ResourceUnavailableFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 1), &a->dialect))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_ErrorCode, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_ErrorCode, sizeof(struct _wsrfr__ResourceUnavailableFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsrfr__ResourceUnavailableFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *p;
	struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *a = (struct _wsrfr__ResourceUnavailableFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsrfr__ResourceUnavailableFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrfr__ResourceUnavailableFaultType_ErrorCode(struct soap *soap, const struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, tag ? tag : "wsrfr:ResourceUnavailableFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsrfr__ResourceUnavailableFaultType_ErrorCode(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrfr__ResourceUnavailableFaultType(struct soap *soap, struct wsrfr__ResourceUnavailableFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrfr__ResourceUnavailableFaultType(struct soap *soap, const struct wsrfr__ResourceUnavailableFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_Description);
			soap_serialize__wsrfr__ResourceUnavailableFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsrfr__ResourceUnavailableFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrfr__ResourceUnavailableFaultType(struct soap *soap, const char *tag, int id, const struct wsrfr__ResourceUnavailableFaultType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrfr__ResourceUnavailableFaultType), type))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsrfr__ResourceUnavailableFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsrfr__ResourceUnavailableFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrfr__ResourceUnavailableFaultType * SOAP_FMAC4 soap_in_wsrfr__ResourceUnavailableFaultType(struct soap *soap, const char *tag, struct wsrfr__ResourceUnavailableFaultType *a, const char *type)
{
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsrfr__ResourceUnavailableFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrfr__ResourceUnavailableFaultType, sizeof(struct wsrfr__ResourceUnavailableFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrfr__ResourceUnavailableFaultType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsrfr__ResourceUnavailableFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsrfr__ResourceUnavailableFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsrfr__ResourceUnavailableFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsrfr__ResourceUnavailableFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfr__ResourceUnavailableFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsrfr__ResourceUnavailableFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsrfr__ResourceUnavailableFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrfr__ResourceUnavailableFaultType, SOAP_TYPE_wsrfr__ResourceUnavailableFaultType, sizeof(struct wsrfr__ResourceUnavailableFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsrfr__ResourceUnavailableFaultType * SOAP_FMAC4 soap_new_wsrfr__ResourceUnavailableFaultType(struct soap *soap, int n)
{
	struct wsrfr__ResourceUnavailableFaultType *p;
	struct wsrfr__ResourceUnavailableFaultType *a = (struct wsrfr__ResourceUnavailableFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsrfr__ResourceUnavailableFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsrfr__ResourceUnavailableFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrfr__ResourceUnavailableFaultType(struct soap *soap, const struct wsrfr__ResourceUnavailableFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsrfr__ResourceUnavailableFaultType(soap, tag ? tag : "wsrfr:ResourceUnavailableFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrfr__ResourceUnavailableFaultType * SOAP_FMAC4 soap_get_wsrfr__ResourceUnavailableFaultType(struct soap *soap, struct wsrfr__ResourceUnavailableFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrfr__ResourceUnavailableFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrfr__ResourceUnknownFaultType_FaultCause(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrfr__ResourceUnknownFaultType_FaultCause(struct soap *soap, const struct _wsrfr__ResourceUnknownFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfr__ResourceUnknownFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsrfr__ResourceUnknownFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_FaultCause), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_FaultCause * SOAP_FMAC4 soap_in__wsrfr__ResourceUnknownFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsrfr__ResourceUnknownFaultType_FaultCause *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsrfr__ResourceUnknownFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_FaultCause, sizeof(struct _wsrfr__ResourceUnknownFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsrfr__ResourceUnknownFaultType_FaultCause(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsrfr__ResourceUnknownFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_FaultCause, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_FaultCause, sizeof(struct _wsrfr__ResourceUnknownFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_FaultCause * SOAP_FMAC4 soap_new__wsrfr__ResourceUnknownFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsrfr__ResourceUnknownFaultType_FaultCause *p;
	struct _wsrfr__ResourceUnknownFaultType_FaultCause *a = (struct _wsrfr__ResourceUnknownFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsrfr__ResourceUnknownFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsrfr__ResourceUnknownFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrfr__ResourceUnknownFaultType_FaultCause(struct soap *soap, const struct _wsrfr__ResourceUnknownFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsrfr__ResourceUnknownFaultType_FaultCause(soap, tag ? tag : "wsrfr:ResourceUnknownFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_FaultCause * SOAP_FMAC4 soap_get__wsrfr__ResourceUnknownFaultType_FaultCause(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfr__ResourceUnknownFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrfr__ResourceUnknownFaultType_Description(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrfr__ResourceUnknownFaultType_Description(struct soap *soap, const struct _wsrfr__ResourceUnknownFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfr__ResourceUnknownFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsrfr__ResourceUnknownFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_Description * SOAP_FMAC4 soap_in__wsrfr__ResourceUnknownFaultType_Description(struct soap *soap, const char *tag, struct _wsrfr__ResourceUnknownFaultType_Description *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsrfr__ResourceUnknownFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_Description, sizeof(struct _wsrfr__ResourceUnknownFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsrfr__ResourceUnknownFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_Description * SOAP_FMAC4 soap_new__wsrfr__ResourceUnknownFaultType_Description(struct soap *soap, int n)
{
	struct _wsrfr__ResourceUnknownFaultType_Description *p;
	struct _wsrfr__ResourceUnknownFaultType_Description *a = (struct _wsrfr__ResourceUnknownFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsrfr__ResourceUnknownFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsrfr__ResourceUnknownFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrfr__ResourceUnknownFaultType_Description(struct soap *soap, const struct _wsrfr__ResourceUnknownFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsrfr__ResourceUnknownFaultType_Description(soap, tag ? tag : "wsrfr:ResourceUnknownFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_Description * SOAP_FMAC4 soap_get__wsrfr__ResourceUnknownFaultType_Description(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfr__ResourceUnknownFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsrfr__ResourceUnknownFaultType_ErrorCode(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsrfr__ResourceUnknownFaultType_ErrorCode(struct soap *soap, const struct _wsrfr__ResourceUnknownFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsrfr__ResourceUnknownFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsrfr__ResourceUnknownFaultType_ErrorCode *a, const char *type)
{
	if (a->dialect)
		soap_set_attr(soap, "dialect", soap_xsd__anyURI2s(soap, a->dialect), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_ErrorCode), type))
		return soap->error;
	soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsrfr__ResourceUnknownFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsrfr__ResourceUnknownFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsrfr__ResourceUnknownFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_ErrorCode, sizeof(struct _wsrfr__ResourceUnknownFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsrfr__ResourceUnknownFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 1), &a->dialect))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsrfr__ResourceUnknownFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_ErrorCode, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_ErrorCode, sizeof(struct _wsrfr__ResourceUnknownFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsrfr__ResourceUnknownFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsrfr__ResourceUnknownFaultType_ErrorCode *p;
	struct _wsrfr__ResourceUnknownFaultType_ErrorCode *a = (struct _wsrfr__ResourceUnknownFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsrfr__ResourceUnknownFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsrfr__ResourceUnknownFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsrfr__ResourceUnknownFaultType_ErrorCode(struct soap *soap, const struct _wsrfr__ResourceUnknownFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsrfr__ResourceUnknownFaultType_ErrorCode(soap, tag ? tag : "wsrfr:ResourceUnknownFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsrfr__ResourceUnknownFaultType_ErrorCode(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsrfr__ResourceUnknownFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsrfr__ResourceUnknownFaultType(struct soap *soap, struct wsrfr__ResourceUnknownFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsrfr__ResourceUnknownFaultType(struct soap *soap, const struct wsrfr__ResourceUnknownFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsrfr__ResourceUnknownFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_Description);
			soap_serialize__wsrfr__ResourceUnknownFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsrfr__ResourceUnknownFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsrfr__ResourceUnknownFaultType(struct soap *soap, const char *tag, int id, const struct wsrfr__ResourceUnknownFaultType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsrfr__ResourceUnknownFaultType), type))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsrfr__ResourceUnknownFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsrfr__ResourceUnknownFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsrfr__ResourceUnknownFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsrfr__ResourceUnknownFaultType * SOAP_FMAC4 soap_in_wsrfr__ResourceUnknownFaultType(struct soap *soap, const char *tag, struct wsrfr__ResourceUnknownFaultType *a, const char *type)
{
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsrfr__ResourceUnknownFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsrfr__ResourceUnknownFaultType, sizeof(struct wsrfr__ResourceUnknownFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsrfr__ResourceUnknownFaultType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfr__ResourceUnknownFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsrfr__ResourceUnknownFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsrfr__ResourceUnknownFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsrfr__ResourceUnknownFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsrfr__ResourceUnknownFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsrfr__ResourceUnknownFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsrfr__ResourceUnknownFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsrfr__ResourceUnknownFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsrfr__ResourceUnknownFaultType, SOAP_TYPE_wsrfr__ResourceUnknownFaultType, sizeof(struct wsrfr__ResourceUnknownFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsrfr__ResourceUnknownFaultType * SOAP_FMAC4 soap_new_wsrfr__ResourceUnknownFaultType(struct soap *soap, int n)
{
	struct wsrfr__ResourceUnknownFaultType *p;
	struct wsrfr__ResourceUnknownFaultType *a = (struct wsrfr__ResourceUnknownFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsrfr__ResourceUnknownFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsrfr__ResourceUnknownFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsrfr__ResourceUnknownFaultType(struct soap *soap, const struct wsrfr__ResourceUnknownFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsrfr__ResourceUnknownFaultType(soap, tag ? tag : "wsrfr:ResourceUnknownFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrfr__ResourceUnknownFaultType * SOAP_FMAC4 soap_get_wsrfr__ResourceUnknownFaultType(struct soap *soap, struct wsrfr__ResourceUnknownFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsrfr__ResourceUnknownFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns5__DoorInfoBase(struct soap *soap, struct ns5__DoorInfoBase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->token);
	soap_default_ns2__Name(soap, &a->Name);
	soap_default_ns2__Description(soap, &a->Description);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns5__DoorInfoBase(struct soap *soap, const struct ns5__DoorInfoBase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__Name(soap, (char*const*)&a->Name);
	soap_serialize_ns2__Description(soap, (char*const*)&a->Description);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__DoorInfoBase(struct soap *soap, const char *tag, int id, const struct ns5__DoorInfoBase *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_ns2__ReferenceToken2s(soap, a->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns5__DoorInfoBase), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "ns5:Name"))
			return soap->error;
	}
	else
	if (soap_out_ns2__Name(soap, "ns5:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_ns2__Description(soap, "ns5:Description", -1, (char*const*)&a->Description, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns5__DoorInfoBase * SOAP_FMAC4 soap_in_ns5__DoorInfoBase(struct soap *soap, const char *tag, struct ns5__DoorInfoBase *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_Description = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns5__DoorInfoBase *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__DoorInfoBase, sizeof(struct ns5__DoorInfoBase), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns5__DoorInfoBase(soap, a);
	if (soap_s2ns2__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Name(soap, "ns5:Name", (char**)&a->Name, "ns2:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Description(soap, "ns5:Description", (char**)&a->Description, "ns2:Description"))
				{	soap_flag_Description--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns5__DoorInfoBase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns5__DoorInfoBase, SOAP_TYPE_ns5__DoorInfoBase, sizeof(struct ns5__DoorInfoBase), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns5__DoorInfoBase * SOAP_FMAC4 soap_new_ns5__DoorInfoBase(struct soap *soap, int n)
{
	struct ns5__DoorInfoBase *p;
	struct ns5__DoorInfoBase *a = (struct ns5__DoorInfoBase*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns5__DoorInfoBase));
	for (p = a; p && n--; p++)
		soap_default_ns5__DoorInfoBase(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns5__DoorInfoBase(struct soap *soap, const struct ns5__DoorInfoBase *a, const char *tag, const char *type)
{
	if (soap_out_ns5__DoorInfoBase(soap, tag ? tag : "ns5:DoorInfoBase", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns5__DoorInfoBase * SOAP_FMAC4 soap_get_ns5__DoorInfoBase(struct soap *soap, struct ns5__DoorInfoBase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__DoorInfoBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wstop__TopicType(struct soap *soap, struct wstop__TopicType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->documentation = NULL;
	a->MessagePattern = NULL;
	a->__sizeTopic = 0;
	a->Topic = NULL;
	soap_default_xsd__NCName(soap, &a->name);
	a->messageTypes = NULL;
	soap_default_xsd__boolean(soap, &a->final_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstop__TopicType(struct soap *soap, const struct wstop__TopicType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowstop__Documentation(soap, &a->documentation);
	soap_serialize_PointerTowstop__QueryExpressionType(soap, &a->MessagePattern);
	if (a->Topic)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopic; i++)
		{
			soap_embedded(soap, a->Topic + i, SOAP_TYPE_wstop__TopicType);
			soap_serialize_wstop__TopicType(soap, a->Topic + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__TopicType(struct soap *soap, const char *tag, int id, const struct wstop__TopicType *a, const char *type)
{
	if (a->name)
		soap_set_attr(soap, "name", soap_xsd__NCName2s(soap, a->name), 1);
	if (a->messageTypes)
		if (*a->messageTypes)
			soap_set_attr(soap, "messageTypes", soap__QName2s(soap, *a->messageTypes), 1);
	soap_set_attr(soap, "final", soap_xsd__boolean2s(soap, a->final_), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__TopicType), type))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &a->documentation, ""))
		return soap->error;
	if (soap_out_PointerTowstop__QueryExpressionType(soap, "wstop:MessagePattern", -1, &a->MessagePattern, ""))
		return soap->error;
	if (a->Topic)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopic; i++)
			if (soap_out_wstop__TopicType(soap, "wstop:Topic", -1, a->Topic + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wstop__TopicType * SOAP_FMAC4 soap_in_wstop__TopicType(struct soap *soap, const char *tag, struct wstop__TopicType *a, const char *type)
{
	size_t soap_flag_documentation = 1;
	size_t soap_flag_MessagePattern = 1;
	struct soap_blist *soap_blist_Topic = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wstop__TopicType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__TopicType, sizeof(struct wstop__TopicType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wstop__TopicType(soap, a);
	if (soap_s2xsd__NCName(soap, soap_attr_value(soap, "name", 1), &a->name))
		return NULL;
	{	const char *t = soap_attr_value(soap, "messageTypes", 0);
		if (t)
		{
			if (!(a->messageTypes = (char **)soap_malloc(soap, sizeof(char *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2_QName(soap, t, a->messageTypes))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "final", 0), &a->final_))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &a->documentation, "wstop:Documentation"))
				{	soap_flag_documentation--;
					continue;
				}
			if (soap_flag_MessagePattern && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowstop__QueryExpressionType(soap, "wstop:MessagePattern", &a->MessagePattern, "wstop:QueryExpressionType"))
				{	soap_flag_MessagePattern--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wstop:Topic", 1, NULL))
			{	if (a->Topic == NULL)
				{	if (soap_blist_Topic == NULL)
						soap_blist_Topic = soap_alloc_block(soap);
					a->Topic = (struct wstop__TopicType *)soap_push_block_max(soap, soap_blist_Topic, sizeof(struct wstop__TopicType));
					if (a->Topic == NULL)
						return NULL;
					soap_default_wstop__TopicType(soap, a->Topic);
				}
				soap_revert(soap);
				if (soap_in_wstop__TopicType(soap, "wstop:Topic", a->Topic, "wstop:TopicType"))
				{	a->__sizeTopic++;
					a->Topic = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Topic)
			soap_pop_block(soap, soap_blist_Topic);
		if (a->__sizeTopic)
		{	a->Topic = (struct wstop__TopicType *)soap_save_block(soap, soap_blist_Topic, NULL, 1);
		}
		else
		{	a->Topic = NULL;
			if (soap_blist_Topic)
				soap_end_block(soap, soap_blist_Topic);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wstop__TopicType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__TopicType, SOAP_TYPE_wstop__TopicType, sizeof(struct wstop__TopicType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wstop__TopicType * SOAP_FMAC4 soap_new_wstop__TopicType(struct soap *soap, int n)
{
	struct wstop__TopicType *p;
	struct wstop__TopicType *a = (struct wstop__TopicType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wstop__TopicType));
	for (p = a; p && n--; p++)
		soap_default_wstop__TopicType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__TopicType(struct soap *soap, const struct wstop__TopicType *a, const char *tag, const char *type)
{
	if (soap_out_wstop__TopicType(soap, tag ? tag : "wstop:TopicType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__TopicType * SOAP_FMAC4 soap_get_wstop__TopicType(struct soap *soap, struct wstop__TopicType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__TopicType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wstop__TopicNamespaceType_Topic(struct soap *soap, struct _wstop__TopicNamespaceType_Topic *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->documentation = NULL;
	a->MessagePattern = NULL;
	a->__sizeTopic = 0;
	a->Topic = NULL;
	soap_default_xsd__NCName(soap, &a->name);
	a->messageTypes = NULL;
	soap_default_xsd__boolean(soap, &a->final_);
	soap_default_wstop__ConcreteTopicExpression(soap, &a->parent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wstop__TopicNamespaceType_Topic(struct soap *soap, const struct _wstop__TopicNamespaceType_Topic *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowstop__Documentation(soap, &a->documentation);
	soap_serialize_PointerTowstop__QueryExpressionType(soap, &a->MessagePattern);
	if (a->Topic)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopic; i++)
		{
			soap_embedded(soap, a->Topic + i, SOAP_TYPE_wstop__TopicType);
			soap_serialize_wstop__TopicType(soap, a->Topic + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, int id, const struct _wstop__TopicNamespaceType_Topic *a, const char *type)
{
	if (a->name)
		soap_set_attr(soap, "name", soap_xsd__NCName2s(soap, a->name), 1);
	if (a->messageTypes)
		if (*a->messageTypes)
			soap_set_attr(soap, "messageTypes", soap__QName2s(soap, *a->messageTypes), 1);
	soap_set_attr(soap, "final", soap_xsd__boolean2s(soap, a->final_), 1);
	if (a->parent)
		soap_set_attr(soap, "parent", soap_wstop__ConcreteTopicExpression2s(soap, a->parent), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wstop__TopicNamespaceType_Topic), type))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &a->documentation, ""))
		return soap->error;
	if (soap_out_PointerTowstop__QueryExpressionType(soap, "wstop:MessagePattern", -1, &a->MessagePattern, ""))
		return soap->error;
	if (a->Topic)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopic; i++)
			if (soap_out_wstop__TopicType(soap, "wstop:Topic", -1, a->Topic + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wstop__TopicNamespaceType_Topic * SOAP_FMAC4 soap_in__wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, struct _wstop__TopicNamespaceType_Topic *a, const char *type)
{
	size_t soap_flag_documentation = 1;
	size_t soap_flag_MessagePattern = 1;
	struct soap_blist *soap_blist_Topic = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wstop__TopicNamespaceType_Topic *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wstop__TopicNamespaceType_Topic, sizeof(struct _wstop__TopicNamespaceType_Topic), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wstop__TopicNamespaceType_Topic(soap, a);
	if (soap_s2xsd__NCName(soap, soap_attr_value(soap, "name", 1), &a->name))
		return NULL;
	{	const char *t = soap_attr_value(soap, "messageTypes", 0);
		if (t)
		{
			if (!(a->messageTypes = (char **)soap_malloc(soap, sizeof(char *))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2_QName(soap, t, a->messageTypes))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "final", 0), &a->final_))
		return NULL;
	if (soap_s2wstop__ConcreteTopicExpression(soap, soap_attr_value(soap, "parent", 0), &a->parent))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &a->documentation, "wstop:Documentation"))
				{	soap_flag_documentation--;
					continue;
				}
			if (soap_flag_MessagePattern && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowstop__QueryExpressionType(soap, "wstop:MessagePattern", &a->MessagePattern, "wstop:QueryExpressionType"))
				{	soap_flag_MessagePattern--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wstop:Topic", 1, NULL))
			{	if (a->Topic == NULL)
				{	if (soap_blist_Topic == NULL)
						soap_blist_Topic = soap_alloc_block(soap);
					a->Topic = (struct wstop__TopicType *)soap_push_block_max(soap, soap_blist_Topic, sizeof(struct wstop__TopicType));
					if (a->Topic == NULL)
						return NULL;
					soap_default_wstop__TopicType(soap, a->Topic);
				}
				soap_revert(soap);
				if (soap_in_wstop__TopicType(soap, "wstop:Topic", a->Topic, "wstop:TopicType"))
				{	a->__sizeTopic++;
					a->Topic = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Topic)
			soap_pop_block(soap, soap_blist_Topic);
		if (a->__sizeTopic)
		{	a->Topic = (struct wstop__TopicType *)soap_save_block(soap, soap_blist_Topic, NULL, 1);
		}
		else
		{	a->Topic = NULL;
			if (soap_blist_Topic)
				soap_end_block(soap, soap_blist_Topic);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wstop__TopicNamespaceType_Topic *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wstop__TopicNamespaceType_Topic, SOAP_TYPE__wstop__TopicNamespaceType_Topic, sizeof(struct _wstop__TopicNamespaceType_Topic), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wstop__TopicNamespaceType_Topic * SOAP_FMAC4 soap_new__wstop__TopicNamespaceType_Topic(struct soap *soap, int n)
{
	struct _wstop__TopicNamespaceType_Topic *p;
	struct _wstop__TopicNamespaceType_Topic *a = (struct _wstop__TopicNamespaceType_Topic*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wstop__TopicNamespaceType_Topic));
	for (p = a; p && n--; p++)
		soap_default__wstop__TopicNamespaceType_Topic(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wstop__TopicNamespaceType_Topic(struct soap *soap, const struct _wstop__TopicNamespaceType_Topic *a, const char *tag, const char *type)
{
	if (soap_out__wstop__TopicNamespaceType_Topic(soap, tag ? tag : "wstop:TopicNamespaceType-Topic", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wstop__TopicNamespaceType_Topic * SOAP_FMAC4 soap_get__wstop__TopicNamespaceType_Topic(struct soap *soap, struct _wstop__TopicNamespaceType_Topic *p, const char *tag, const char *type)
{
	if ((p = soap_in__wstop__TopicNamespaceType_Topic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wstop__TopicNamespaceType(struct soap *soap, struct wstop__TopicNamespaceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->documentation = NULL;
	a->__sizeTopic = 0;
	a->Topic = NULL;
	soap_default_xsd__NCName(soap, &a->name);
	soap_default_xsd__anyURI(soap, &a->targetNamespace);
	soap_default_xsd__boolean(soap, &a->final_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstop__TopicNamespaceType(struct soap *soap, const struct wstop__TopicNamespaceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowstop__Documentation(soap, &a->documentation);
	if (a->Topic)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopic; i++)
		{
			soap_embedded(soap, a->Topic + i, SOAP_TYPE__wstop__TopicNamespaceType_Topic);
			soap_serialize__wstop__TopicNamespaceType_Topic(soap, a->Topic + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__TopicNamespaceType(struct soap *soap, const char *tag, int id, const struct wstop__TopicNamespaceType *a, const char *type)
{
	if (a->name)
		soap_set_attr(soap, "name", soap_xsd__NCName2s(soap, a->name), 1);
	if (a->targetNamespace)
		soap_set_attr(soap, "targetNamespace", soap_xsd__anyURI2s(soap, a->targetNamespace), 1);
	soap_set_attr(soap, "final", soap_xsd__boolean2s(soap, a->final_), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wstop__TopicNamespaceType), type))
		return soap->error;
	if (soap_out_PointerTowstop__Documentation(soap, "wstop:documentation", -1, &a->documentation, ""))
		return soap->error;
	if (a->Topic)
	{	int i;
		for (i = 0; i < (int)a->__sizeTopic; i++)
			if (soap_out__wstop__TopicNamespaceType_Topic(soap, "wstop:Topic", -1, a->Topic + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wstop__TopicNamespaceType * SOAP_FMAC4 soap_in_wstop__TopicNamespaceType(struct soap *soap, const char *tag, struct wstop__TopicNamespaceType *a, const char *type)
{
	size_t soap_flag_documentation = 1;
	struct soap_blist *soap_blist_Topic = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wstop__TopicNamespaceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wstop__TopicNamespaceType, sizeof(struct wstop__TopicNamespaceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wstop__TopicNamespaceType(soap, a);
	if (soap_s2xsd__NCName(soap, soap_attr_value(soap, "name", 0), &a->name))
		return NULL;
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "targetNamespace", 1), &a->targetNamespace))
		return NULL;
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "final", 0), &a->final_))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_documentation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowstop__Documentation(soap, "wstop:documentation", &a->documentation, "wstop:Documentation"))
				{	soap_flag_documentation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wstop:Topic", 1, NULL))
			{	if (a->Topic == NULL)
				{	if (soap_blist_Topic == NULL)
						soap_blist_Topic = soap_alloc_block(soap);
					a->Topic = (struct _wstop__TopicNamespaceType_Topic *)soap_push_block_max(soap, soap_blist_Topic, sizeof(struct _wstop__TopicNamespaceType_Topic));
					if (a->Topic == NULL)
						return NULL;
					soap_default__wstop__TopicNamespaceType_Topic(soap, a->Topic);
				}
				soap_revert(soap);
				if (soap_in__wstop__TopicNamespaceType_Topic(soap, "wstop:Topic", a->Topic, ""))
				{	a->__sizeTopic++;
					a->Topic = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Topic)
			soap_pop_block(soap, soap_blist_Topic);
		if (a->__sizeTopic)
		{	a->Topic = (struct _wstop__TopicNamespaceType_Topic *)soap_save_block(soap, soap_blist_Topic, NULL, 1);
		}
		else
		{	a->Topic = NULL;
			if (soap_blist_Topic)
				soap_end_block(soap, soap_blist_Topic);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wstop__TopicNamespaceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wstop__TopicNamespaceType, SOAP_TYPE_wstop__TopicNamespaceType, sizeof(struct wstop__TopicNamespaceType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wstop__TopicNamespaceType * SOAP_FMAC4 soap_new_wstop__TopicNamespaceType(struct soap *soap, int n)
{
	struct wstop__TopicNamespaceType *p;
	struct wstop__TopicNamespaceType *a = (struct wstop__TopicNamespaceType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wstop__TopicNamespaceType));
	for (p = a; p && n--; p++)
		soap_default_wstop__TopicNamespaceType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__TopicNamespaceType(struct soap *soap, const struct wstop__TopicNamespaceType *a, const char *tag, const char *type)
{
	if (soap_out_wstop__TopicNamespaceType(soap, tag ? tag : "wstop:TopicNamespaceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__TopicNamespaceType * SOAP_FMAC4 soap_get_wstop__TopicNamespaceType(struct soap *soap, struct wstop__TopicNamespaceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__TopicNamespaceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__ResumeFailedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, const struct _wsnt__ResumeFailedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__ResumeFailedFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__ResumeFailedFaultType_FaultCause *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__ResumeFailedFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause, sizeof(struct _wsnt__ResumeFailedFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__ResumeFailedFaultType_FaultCause(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__ResumeFailedFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause, SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause, sizeof(struct _wsnt__ResumeFailedFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__ResumeFailedFaultType_FaultCause *p;
	struct _wsnt__ResumeFailedFaultType_FaultCause *a = (struct _wsnt__ResumeFailedFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__ResumeFailedFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__ResumeFailedFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, const struct _wsnt__ResumeFailedFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__ResumeFailedFaultType_FaultCause(soap, tag ? tag : "wsnt:ResumeFailedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__ResumeFailedFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__ResumeFailedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__ResumeFailedFaultType_Description(struct soap *soap, struct _wsnt__ResumeFailedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__ResumeFailedFaultType_Description(struct soap *soap, const struct _wsnt__ResumeFailedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__ResumeFailedFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__ResumeFailedFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_Description * SOAP_FMAC4 soap_in__wsnt__ResumeFailedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__ResumeFailedFaultType_Description *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsnt__ResumeFailedFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__ResumeFailedFaultType_Description, sizeof(struct _wsnt__ResumeFailedFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__ResumeFailedFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_Description * SOAP_FMAC4 soap_new__wsnt__ResumeFailedFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__ResumeFailedFaultType_Description *p;
	struct _wsnt__ResumeFailedFaultType_Description *a = (struct _wsnt__ResumeFailedFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__ResumeFailedFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__ResumeFailedFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__ResumeFailedFaultType_Description(struct soap *soap, const struct _wsnt__ResumeFailedFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__ResumeFailedFaultType_Description(soap, tag ? tag : "wsnt:ResumeFailedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_Description * SOAP_FMAC4 soap_get__wsnt__ResumeFailedFaultType_Description(struct soap *soap, struct _wsnt__ResumeFailedFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__ResumeFailedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__ResumeFailedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__ResumeFailedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__ResumeFailedFaultType_ErrorCode *a, const char *type)
{
	if (a->dialect)
		soap_set_attr(soap, "dialect", soap_xsd__anyURI2s(soap, a->dialect), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode), type))
		return soap->error;
	soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__ResumeFailedFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__ResumeFailedFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode, sizeof(struct _wsnt__ResumeFailedFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__ResumeFailedFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 1), &a->dialect))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__ResumeFailedFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode, SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode, sizeof(struct _wsnt__ResumeFailedFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__ResumeFailedFaultType_ErrorCode *p;
	struct _wsnt__ResumeFailedFaultType_ErrorCode *a = (struct _wsnt__ResumeFailedFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__ResumeFailedFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__ResumeFailedFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__ResumeFailedFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__ResumeFailedFaultType_ErrorCode(soap, tag ? tag : "wsnt:ResumeFailedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__ResumeFailedFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__ResumeFailedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__ResumeFailedFaultType(struct soap *soap, struct wsnt__ResumeFailedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__ResumeFailedFaultType(struct soap *soap, const struct wsnt__ResumeFailedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__ResumeFailedFaultType_Description);
			soap_serialize__wsnt__ResumeFailedFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__ResumeFailedFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__ResumeFailedFaultType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__ResumeFailedFaultType), type))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__ResumeFailedFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__ResumeFailedFaultType * SOAP_FMAC4 soap_in_wsnt__ResumeFailedFaultType(struct soap *soap, const char *tag, struct wsnt__ResumeFailedFaultType *a, const char *type)
{
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsnt__ResumeFailedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__ResumeFailedFaultType, sizeof(struct wsnt__ResumeFailedFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__ResumeFailedFaultType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__ResumeFailedFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__ResumeFailedFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__ResumeFailedFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__ResumeFailedFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__ResumeFailedFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__ResumeFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__ResumeFailedFaultType, SOAP_TYPE_wsnt__ResumeFailedFaultType, sizeof(struct wsnt__ResumeFailedFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__ResumeFailedFaultType * SOAP_FMAC4 soap_new_wsnt__ResumeFailedFaultType(struct soap *soap, int n)
{
	struct wsnt__ResumeFailedFaultType *p;
	struct wsnt__ResumeFailedFaultType *a = (struct wsnt__ResumeFailedFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__ResumeFailedFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__ResumeFailedFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__ResumeFailedFaultType(struct soap *soap, const struct wsnt__ResumeFailedFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__ResumeFailedFaultType(soap, tag ? tag : "wsnt:ResumeFailedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__ResumeFailedFaultType * SOAP_FMAC4 soap_get_wsnt__ResumeFailedFaultType(struct soap *soap, struct wsnt__ResumeFailedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__ResumeFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__PauseFailedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, const struct _wsnt__PauseFailedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__PauseFailedFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__PauseFailedFaultType_FaultCause *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__PauseFailedFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause, sizeof(struct _wsnt__PauseFailedFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__PauseFailedFaultType_FaultCause(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__PauseFailedFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause, SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause, sizeof(struct _wsnt__PauseFailedFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__PauseFailedFaultType_FaultCause *p;
	struct _wsnt__PauseFailedFaultType_FaultCause *a = (struct _wsnt__PauseFailedFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__PauseFailedFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__PauseFailedFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, const struct _wsnt__PauseFailedFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__PauseFailedFaultType_FaultCause(soap, tag ? tag : "wsnt:PauseFailedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__PauseFailedFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__PauseFailedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__PauseFailedFaultType_Description(struct soap *soap, struct _wsnt__PauseFailedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__PauseFailedFaultType_Description(struct soap *soap, const struct _wsnt__PauseFailedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__PauseFailedFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__PauseFailedFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_Description * SOAP_FMAC4 soap_in__wsnt__PauseFailedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__PauseFailedFaultType_Description *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsnt__PauseFailedFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__PauseFailedFaultType_Description, sizeof(struct _wsnt__PauseFailedFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__PauseFailedFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_Description * SOAP_FMAC4 soap_new__wsnt__PauseFailedFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__PauseFailedFaultType_Description *p;
	struct _wsnt__PauseFailedFaultType_Description *a = (struct _wsnt__PauseFailedFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__PauseFailedFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__PauseFailedFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__PauseFailedFaultType_Description(struct soap *soap, const struct _wsnt__PauseFailedFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__PauseFailedFaultType_Description(soap, tag ? tag : "wsnt:PauseFailedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_Description * SOAP_FMAC4 soap_get__wsnt__PauseFailedFaultType_Description(struct soap *soap, struct _wsnt__PauseFailedFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__PauseFailedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__PauseFailedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__PauseFailedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__PauseFailedFaultType_ErrorCode *a, const char *type)
{
	if (a->dialect)
		soap_set_attr(soap, "dialect", soap_xsd__anyURI2s(soap, a->dialect), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode), type))
		return soap->error;
	soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__PauseFailedFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__PauseFailedFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode, sizeof(struct _wsnt__PauseFailedFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__PauseFailedFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 1), &a->dialect))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__PauseFailedFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode, SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode, sizeof(struct _wsnt__PauseFailedFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__PauseFailedFaultType_ErrorCode *p;
	struct _wsnt__PauseFailedFaultType_ErrorCode *a = (struct _wsnt__PauseFailedFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__PauseFailedFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__PauseFailedFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__PauseFailedFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__PauseFailedFaultType_ErrorCode(soap, tag ? tag : "wsnt:PauseFailedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__PauseFailedFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__PauseFailedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__PauseFailedFaultType(struct soap *soap, struct wsnt__PauseFailedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__PauseFailedFaultType(struct soap *soap, const struct wsnt__PauseFailedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__PauseFailedFaultType_Description);
			soap_serialize__wsnt__PauseFailedFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__PauseFailedFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__PauseFailedFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__PauseFailedFaultType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__PauseFailedFaultType), type))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__PauseFailedFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__PauseFailedFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__PauseFailedFaultType * SOAP_FMAC4 soap_in_wsnt__PauseFailedFaultType(struct soap *soap, const char *tag, struct wsnt__PauseFailedFaultType *a, const char *type)
{
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsnt__PauseFailedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__PauseFailedFaultType, sizeof(struct wsnt__PauseFailedFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__PauseFailedFaultType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__PauseFailedFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__PauseFailedFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__PauseFailedFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__PauseFailedFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsnt__PauseFailedFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__PauseFailedFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__PauseFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__PauseFailedFaultType, SOAP_TYPE_wsnt__PauseFailedFaultType, sizeof(struct wsnt__PauseFailedFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__PauseFailedFaultType * SOAP_FMAC4 soap_new_wsnt__PauseFailedFaultType(struct soap *soap, int n)
{
	struct wsnt__PauseFailedFaultType *p;
	struct wsnt__PauseFailedFaultType *a = (struct wsnt__PauseFailedFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__PauseFailedFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__PauseFailedFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__PauseFailedFaultType(struct soap *soap, const struct wsnt__PauseFailedFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__PauseFailedFaultType(soap, tag ? tag : "wsnt:PauseFailedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__PauseFailedFaultType * SOAP_FMAC4 soap_get_wsnt__PauseFailedFaultType(struct soap *soap, struct wsnt__PauseFailedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__PauseFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *p;
	struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *a = (struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, tag ? tag : "wsnt:UnableToDestroySubscriptionFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, const struct _wsnt__UnableToDestroySubscriptionFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToDestroySubscriptionFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_Description * SOAP_FMAC4 soap_in__wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroySubscriptionFaultType_Description *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsnt__UnableToDestroySubscriptionFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_Description, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_Description * SOAP_FMAC4 soap_new__wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__UnableToDestroySubscriptionFaultType_Description *p;
	struct _wsnt__UnableToDestroySubscriptionFaultType_Description *a = (struct _wsnt__UnableToDestroySubscriptionFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, const struct _wsnt__UnableToDestroySubscriptionFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, tag ? tag : "wsnt:UnableToDestroySubscriptionFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_Description * SOAP_FMAC4 soap_get__wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *a, const char *type)
{
	if (a->dialect)
		soap_set_attr(soap, "dialect", soap_xsd__anyURI2s(soap, a->dialect), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode), type))
		return soap->error;
	soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 1), &a->dialect))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *p;
	struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *a = (struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnableToDestroySubscriptionFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, struct wsnt__UnableToDestroySubscriptionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, const struct wsnt__UnableToDestroySubscriptionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_Description);
			soap_serialize__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__UnableToDestroySubscriptionFaultType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType), type))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__UnableToDestroySubscriptionFaultType * SOAP_FMAC4 soap_in_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, const char *tag, struct wsnt__UnableToDestroySubscriptionFaultType *a, const char *type)
{
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsnt__UnableToDestroySubscriptionFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, sizeof(struct wsnt__UnableToDestroySubscriptionFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__UnableToDestroySubscriptionFaultType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__UnableToDestroySubscriptionFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__UnableToDestroySubscriptionFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__UnableToDestroySubscriptionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, sizeof(struct wsnt__UnableToDestroySubscriptionFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__UnableToDestroySubscriptionFaultType * SOAP_FMAC4 soap_new_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, int n)
{
	struct wsnt__UnableToDestroySubscriptionFaultType *p;
	struct wsnt__UnableToDestroySubscriptionFaultType *a = (struct wsnt__UnableToDestroySubscriptionFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__UnableToDestroySubscriptionFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__UnableToDestroySubscriptionFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, const struct wsnt__UnableToDestroySubscriptionFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__UnableToDestroySubscriptionFaultType(soap, tag ? tag : "wsnt:UnableToDestroySubscriptionFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnableToDestroySubscriptionFaultType * SOAP_FMAC4 soap_get_wsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, struct wsnt__UnableToDestroySubscriptionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnableToDestroySubscriptionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *p;
	struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *a = (struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, tag ? tag : "wsnt:UnacceptableTerminationTimeFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, const struct _wsnt__UnacceptableTerminationTimeFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__UnacceptableTerminationTimeFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_Description * SOAP_FMAC4 soap_in__wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnacceptableTerminationTimeFaultType_Description *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsnt__UnacceptableTerminationTimeFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_Description, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_Description * SOAP_FMAC4 soap_new__wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__UnacceptableTerminationTimeFaultType_Description *p;
	struct _wsnt__UnacceptableTerminationTimeFaultType_Description *a = (struct _wsnt__UnacceptableTerminationTimeFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, const struct _wsnt__UnacceptableTerminationTimeFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, tag ? tag : "wsnt:UnacceptableTerminationTimeFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_Description * SOAP_FMAC4 soap_get__wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *a, const char *type)
{
	if (a->dialect)
		soap_set_attr(soap, "dialect", soap_xsd__anyURI2s(soap, a->dialect), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode), type))
		return soap->error;
	soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 1), &a->dialect))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *p;
	struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *a = (struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnacceptableTerminationTimeFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, struct wsnt__UnacceptableTerminationTimeFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	soap_default_dateTime(soap, &a->MinimumTime);
	a->MaximumTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, const struct wsnt__UnacceptableTerminationTimeFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_Description);
			soap_serialize__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
	soap_embedded(soap, &a->MinimumTime, SOAP_TYPE_dateTime);
	soap_serialize_PointerTodateTime(soap, &a->MaximumTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__UnacceptableTerminationTimeFaultType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType), type))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "wsnt:MinimumTime", -1, &a->MinimumTime, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "wsnt:MaximumTime", -1, &a->MaximumTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__UnacceptableTerminationTimeFaultType * SOAP_FMAC4 soap_in_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, const char *tag, struct wsnt__UnacceptableTerminationTimeFaultType *a, const char *type)
{
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	size_t soap_flag_MinimumTime = 1;
	size_t soap_flag_MaximumTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsnt__UnacceptableTerminationTimeFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, sizeof(struct wsnt__UnacceptableTerminationTimeFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__UnacceptableTerminationTimeFaultType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__UnacceptableTerminationTimeFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			if (soap_flag_MinimumTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "wsnt:MinimumTime", &a->MinimumTime, "xsd:dateTime"))
				{	soap_flag_MinimumTime--;
					continue;
				}
			if (soap_flag_MaximumTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodateTime(soap, "wsnt:MaximumTime", &a->MaximumTime, "xsd:dateTime"))
				{	soap_flag_MaximumTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__UnacceptableTerminationTimeFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0 || soap_flag_MinimumTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__UnacceptableTerminationTimeFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, sizeof(struct wsnt__UnacceptableTerminationTimeFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__UnacceptableTerminationTimeFaultType * SOAP_FMAC4 soap_new_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, int n)
{
	struct wsnt__UnacceptableTerminationTimeFaultType *p;
	struct wsnt__UnacceptableTerminationTimeFaultType *a = (struct wsnt__UnacceptableTerminationTimeFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__UnacceptableTerminationTimeFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__UnacceptableTerminationTimeFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, const struct wsnt__UnacceptableTerminationTimeFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__UnacceptableTerminationTimeFaultType(soap, tag ? tag : "wsnt:UnacceptableTerminationTimeFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnacceptableTerminationTimeFaultType * SOAP_FMAC4 soap_get_wsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, struct wsnt__UnacceptableTerminationTimeFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnacceptableTerminationTimeFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *p;
	struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *a = (struct _wsnt__UnableToCreatePullPointFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToCreatePullPointFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, tag ? tag : "wsnt:UnableToCreatePullPointFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, const struct _wsnt__UnableToCreatePullPointFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToCreatePullPointFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_Description * SOAP_FMAC4 soap_in__wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnableToCreatePullPointFaultType_Description *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsnt__UnableToCreatePullPointFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_Description, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__UnableToCreatePullPointFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_Description * SOAP_FMAC4 soap_new__wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__UnableToCreatePullPointFaultType_Description *p;
	struct _wsnt__UnableToCreatePullPointFaultType_Description *a = (struct _wsnt__UnableToCreatePullPointFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToCreatePullPointFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToCreatePullPointFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, const struct _wsnt__UnableToCreatePullPointFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToCreatePullPointFaultType_Description(soap, tag ? tag : "wsnt:UnableToCreatePullPointFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_Description * SOAP_FMAC4 soap_get__wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToCreatePullPointFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *a, const char *type)
{
	if (a->dialect)
		soap_set_attr(soap, "dialect", soap_xsd__anyURI2s(soap, a->dialect), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode), type))
		return soap->error;
	soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 1), &a->dialect))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *p;
	struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *a = (struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, const struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, tag ? tag : "wsnt:UnableToCreatePullPointFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, struct wsnt__UnableToCreatePullPointFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, const struct wsnt__UnableToCreatePullPointFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_Description);
			soap_serialize__wsnt__UnableToCreatePullPointFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__UnableToCreatePullPointFaultType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType), type))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__UnableToCreatePullPointFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__UnableToCreatePullPointFaultType * SOAP_FMAC4 soap_in_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, const char *tag, struct wsnt__UnableToCreatePullPointFaultType *a, const char *type)
{
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsnt__UnableToCreatePullPointFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, sizeof(struct wsnt__UnableToCreatePullPointFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__UnableToCreatePullPointFaultType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__UnableToCreatePullPointFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__UnableToCreatePullPointFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__UnableToCreatePullPointFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__UnableToCreatePullPointFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__UnableToCreatePullPointFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, sizeof(struct wsnt__UnableToCreatePullPointFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__UnableToCreatePullPointFaultType * SOAP_FMAC4 soap_new_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, int n)
{
	struct wsnt__UnableToCreatePullPointFaultType *p;
	struct wsnt__UnableToCreatePullPointFaultType *a = (struct wsnt__UnableToCreatePullPointFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__UnableToCreatePullPointFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__UnableToCreatePullPointFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, const struct wsnt__UnableToCreatePullPointFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__UnableToCreatePullPointFaultType(soap, tag ? tag : "wsnt:UnableToCreatePullPointFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnableToCreatePullPointFaultType * SOAP_FMAC4 soap_get_wsnt__UnableToCreatePullPointFaultType(struct soap *soap, struct wsnt__UnableToCreatePullPointFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__UnableToCreatePullPointFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *p;
	struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *a = (struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, const struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, tag ? tag : "wsnt:UnableToDestroyPullPointFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
