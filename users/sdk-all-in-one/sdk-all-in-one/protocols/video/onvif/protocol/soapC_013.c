/* soapC_nnn.c
   Generated by gSOAP 2.8.35 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC_nnn.c ver 2.8.35 2016-12-16 01:34:58 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, struct wsnt__TopicExpressionDialectUnknownFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const struct wsnt__TopicExpressionDialectUnknownFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description);
			soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__TopicExpressionDialectUnknownFaultType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType), type))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC4 soap_in_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, struct wsnt__TopicExpressionDialectUnknownFaultType *a, const char *type)
{
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsnt__TopicExpressionDialectUnknownFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, sizeof(struct wsnt__TopicExpressionDialectUnknownFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__TopicExpressionDialectUnknownFaultType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__TopicExpressionDialectUnknownFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, sizeof(struct wsnt__TopicExpressionDialectUnknownFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC4 soap_new_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, int n)
{
	struct wsnt__TopicExpressionDialectUnknownFaultType *p;
	struct wsnt__TopicExpressionDialectUnknownFaultType *a = (struct wsnt__TopicExpressionDialectUnknownFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__TopicExpressionDialectUnknownFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__TopicExpressionDialectUnknownFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const struct wsnt__TopicExpressionDialectUnknownFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag ? tag : "wsnt:TopicExpressionDialectUnknownFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC4 soap_get_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, struct wsnt__TopicExpressionDialectUnknownFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidFilterFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidFilterFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidFilterFaultType_FaultCause *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__InvalidFilterFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause, sizeof(struct _wsnt__InvalidFilterFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidFilterFaultType_FaultCause(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidFilterFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause, sizeof(struct _wsnt__InvalidFilterFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__InvalidFilterFaultType_FaultCause *p;
	struct _wsnt__InvalidFilterFaultType_FaultCause *a = (struct _wsnt__InvalidFilterFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidFilterFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidFilterFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidFilterFaultType_FaultCause(soap, tag ? tag : "wsnt:InvalidFilterFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidFilterFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidFilterFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidFilterFaultType_Description(struct soap *soap, struct _wsnt__InvalidFilterFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidFilterFaultType_Description(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidFilterFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidFilterFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_Description * SOAP_FMAC4 soap_in__wsnt__InvalidFilterFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidFilterFaultType_Description *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsnt__InvalidFilterFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidFilterFaultType_Description, sizeof(struct _wsnt__InvalidFilterFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__InvalidFilterFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_Description * SOAP_FMAC4 soap_new__wsnt__InvalidFilterFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__InvalidFilterFaultType_Description *p;
	struct _wsnt__InvalidFilterFaultType_Description *a = (struct _wsnt__InvalidFilterFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidFilterFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidFilterFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidFilterFaultType_Description(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidFilterFaultType_Description(soap, tag ? tag : "wsnt:InvalidFilterFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_Description * SOAP_FMAC4 soap_get__wsnt__InvalidFilterFaultType_Description(struct soap *soap, struct _wsnt__InvalidFilterFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidFilterFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidFilterFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidFilterFaultType_ErrorCode *a, const char *type)
{
	if (a->dialect)
		soap_set_attr(soap, "dialect", soap_xsd__anyURI2s(soap, a->dialect), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode), type))
		return soap->error;
	soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidFilterFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__InvalidFilterFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode, sizeof(struct _wsnt__InvalidFilterFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidFilterFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 1), &a->dialect))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidFilterFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode, sizeof(struct _wsnt__InvalidFilterFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__InvalidFilterFaultType_ErrorCode *p;
	struct _wsnt__InvalidFilterFaultType_ErrorCode *a = (struct _wsnt__InvalidFilterFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__InvalidFilterFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__InvalidFilterFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__InvalidFilterFaultType_ErrorCode(soap, tag ? tag : "wsnt:InvalidFilterFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidFilterFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidFilterFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__InvalidFilterFaultType(struct soap *soap, struct wsnt__InvalidFilterFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
	a->__sizeUnknownFilter = 0;
	a->UnknownFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__InvalidFilterFaultType(struct soap *soap, const struct wsnt__InvalidFilterFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__InvalidFilterFaultType_Description);
			soap_serialize__wsnt__InvalidFilterFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
	if (a->UnknownFilter)
	{	int i;
		for (i = 0; i < (int)a->__sizeUnknownFilter; i++)
		{
			soap_serialize__QName(soap, (char*const*)(a->UnknownFilter + i));
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidFilterFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__InvalidFilterFaultType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__InvalidFilterFaultType), type))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__InvalidFilterFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	if (a->UnknownFilter)
	{	int i;
		for (i = 0; i < (int)a->__sizeUnknownFilter; i++)
		{	const char *soap_tmp_UnknownFilter = soap_QName2s(soap, a->UnknownFilter[i]);
			if (soap_out__QName(soap, "wsnt:UnknownFilter", -1, (char*const*)(void*)&soap_tmp_UnknownFilter, ""))
				return soap->error;
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__InvalidFilterFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidFilterFaultType(struct soap *soap, const char *tag, struct wsnt__InvalidFilterFaultType *a, const char *type)
{
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	struct soap_blist *soap_blist_UnknownFilter = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsnt__InvalidFilterFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidFilterFaultType, sizeof(struct wsnt__InvalidFilterFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__InvalidFilterFaultType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__InvalidFilterFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__InvalidFilterFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__InvalidFilterFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__InvalidFilterFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:UnknownFilter", 1, NULL))
			{	if (a->UnknownFilter == NULL)
				{	if (soap_blist_UnknownFilter == NULL)
						soap_blist_UnknownFilter = soap_alloc_block(soap);
					a->UnknownFilter = (char **)soap_push_block_max(soap, soap_blist_UnknownFilter, sizeof(char *));
					if (a->UnknownFilter == NULL)
						return NULL;
					*a->UnknownFilter = NULL;
				}
				soap_revert(soap);
				if (soap_in__QName(soap, "wsnt:UnknownFilter", (char**)a->UnknownFilter, "xsd:QName"))
				{	a->__sizeUnknownFilter++;
					a->UnknownFilter = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__InvalidFilterFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (a->UnknownFilter)
			soap_pop_block(soap, soap_blist_UnknownFilter);
		if (a->__sizeUnknownFilter)
		{	a->UnknownFilter = (char **)soap_save_block(soap, soap_blist_UnknownFilter, NULL, 1);
		}
		else
		{	a->UnknownFilter = NULL;
			if (soap_blist_UnknownFilter)
				soap_end_block(soap, soap_blist_UnknownFilter);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0 || a->__sizeUnknownFilter < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__InvalidFilterFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidFilterFaultType, SOAP_TYPE_wsnt__InvalidFilterFaultType, sizeof(struct wsnt__InvalidFilterFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__InvalidFilterFaultType * SOAP_FMAC4 soap_new_wsnt__InvalidFilterFaultType(struct soap *soap, int n)
{
	struct wsnt__InvalidFilterFaultType *p;
	struct wsnt__InvalidFilterFaultType *a = (struct wsnt__InvalidFilterFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__InvalidFilterFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__InvalidFilterFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__InvalidFilterFaultType(struct soap *soap, const struct wsnt__InvalidFilterFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__InvalidFilterFaultType(soap, tag ? tag : "wsnt:InvalidFilterFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__InvalidFilterFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidFilterFaultType(struct soap *soap, struct wsnt__InvalidFilterFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__InvalidFilterFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_FaultCause), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_FaultCause), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_FaultCause * SOAP_FMAC4 soap_new__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, int n)
{
	struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *p;
	struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a = (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__SubscribeCreationFailedFaultType_FaultCause));
	for (p = a; p && n--; p++)
		soap_default__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__SubscribeCreationFailedFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", soap__xml__lang2s(soap, a->xml__lang), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_Description * SOAP_FMAC4 soap_in__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_Description *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsnt__SubscribeCreationFailedFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_Description), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__SubscribeCreationFailedFaultType_Description(soap, a);
	if (soap_s2_xml__lang(soap, soap_attr_value(soap, "xml:lang", 0), &a->xml__lang))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_Description * SOAP_FMAC4 soap_new__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, int n)
{
	struct _wsnt__SubscribeCreationFailedFaultType_Description *p;
	struct _wsnt__SubscribeCreationFailedFaultType_Description *a = (struct _wsnt__SubscribeCreationFailedFaultType_Description*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__SubscribeCreationFailedFaultType_Description));
	for (p = a; p && n--; p++)
		soap_default__wsnt__SubscribeCreationFailedFaultType_Description(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_Description *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__SubscribeCreationFailedFaultType_Description(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType-Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_Description * SOAP_FMAC4 soap_get__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__SubscribeCreationFailedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a, const char *type)
{
	if (a->dialect)
		soap_set_attr(soap, "dialect", soap_xsd__anyURI2s(soap, a->dialect), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode), type))
		return soap->error;
	soap_outliteral(soap, "-mixed", (char*const*)&a->__mixed, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a, const char *type)
{
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, a);
	if (soap_s2xsd__anyURI(soap, soap_attr_value(soap, "dialect", 1), &a->dialect))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", (char**)&a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode * SOAP_FMAC4 soap_new__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, int n)
{
	struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *p;
	struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a = (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode));
	for (p = a; p && n--; p++)
		soap_default__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a, const char *tag, const char *type)
{
	if (soap_out__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, struct wsnt__SubscribeCreationFailedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->wsrfbf__Timestamp);
	a->wsrfbf__Originator = NULL;
	a->wsrfbf__ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->wsrfbf__Description = NULL;
	a->wsrfbf__FaultCause = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, const struct wsnt__SubscribeCreationFailedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->wsrfbf__Timestamp, SOAP_TYPE_dateTime);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->wsrfbf__Originator);
	soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, &a->wsrfbf__ErrorCode);
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->wsrfbf__Description + i, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description);
			soap_serialize__wsnt__SubscribeCreationFailedFaultType_Description(soap, a->wsrfbf__Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, &a->wsrfbf__FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__SubscribeCreationFailedFaultType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType), type))
		return soap->error;
	if (soap_out_dateTime(soap, "wsrfbf:Timestamp", -1, &a->wsrfbf__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", -1, &a->wsrfbf__Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", -1, &a->wsrfbf__ErrorCode, ""))
		return soap->error;
	if (a->wsrfbf__Description)
	{	int i;
		for (i = 0; i < (int)a->__sizeDescription; i++)
			if (soap_out__wsnt__SubscribeCreationFailedFaultType_Description(soap, "wsrfbf:Description", -1, a->wsrfbf__Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, "wsrfbf:FaultCause", -1, &a->wsrfbf__FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC4 soap_in_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, const char *tag, struct wsnt__SubscribeCreationFailedFaultType *a, const char *type)
{
	size_t soap_flag_wsrfbf__Timestamp = 1;
	size_t soap_flag_wsrfbf__Originator = 1;
	size_t soap_flag_wsrfbf__ErrorCode = 1;
	struct soap_blist *soap_blist_wsrfbf__Description = NULL;
	size_t soap_flag_wsrfbf__FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsnt__SubscribeCreationFailedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, sizeof(struct wsnt__SubscribeCreationFailedFaultType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__SubscribeCreationFailedFaultType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsrfbf__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "wsrfbf:Timestamp", &a->wsrfbf__Timestamp, "xsd:dateTime"))
				{	soap_flag_wsrfbf__Timestamp--;
					continue;
				}
			if (soap_flag_wsrfbf__Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsrfbf:Originator", &a->wsrfbf__Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_wsrfbf__Originator--;
					continue;
				}
			if (soap_flag_wsrfbf__ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, "wsrfbf:ErrorCode", &a->wsrfbf__ErrorCode, ""))
				{	soap_flag_wsrfbf__ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsrfbf:Description", 1, NULL))
			{	if (a->wsrfbf__Description == NULL)
				{	if (soap_blist_wsrfbf__Description == NULL)
						soap_blist_wsrfbf__Description = soap_alloc_block(soap);
					a->wsrfbf__Description = (struct _wsnt__SubscribeCreationFailedFaultType_Description *)soap_push_block_max(soap, soap_blist_wsrfbf__Description, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_Description));
					if (a->wsrfbf__Description == NULL)
						return NULL;
					soap_default__wsnt__SubscribeCreationFailedFaultType_Description(soap, a->wsrfbf__Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__SubscribeCreationFailedFaultType_Description(soap, "wsrfbf:Description", a->wsrfbf__Description, ""))
				{	a->__sizeDescription++;
					a->wsrfbf__Description = NULL;
					continue;
				}
			}
			if (soap_flag_wsrfbf__FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, "wsrfbf:FaultCause", &a->wsrfbf__FaultCause, ""))
				{	soap_flag_wsrfbf__FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsrfbf__Description)
			soap_pop_block(soap, soap_blist_wsrfbf__Description);
		if (a->__sizeDescription)
		{	a->wsrfbf__Description = (struct _wsnt__SubscribeCreationFailedFaultType_Description *)soap_save_block(soap, soap_blist_wsrfbf__Description, NULL, 1);
		}
		else
		{	a->wsrfbf__Description = NULL;
			if (soap_blist_wsrfbf__Description)
				soap_end_block(soap, soap_blist_wsrfbf__Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsrfbf__Timestamp > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsnt__SubscribeCreationFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, sizeof(struct wsnt__SubscribeCreationFailedFaultType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC4 soap_new_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, int n)
{
	struct wsnt__SubscribeCreationFailedFaultType *p;
	struct wsnt__SubscribeCreationFailedFaultType *a = (struct wsnt__SubscribeCreationFailedFaultType*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct wsnt__SubscribeCreationFailedFaultType));
	for (p = a; p && n--; p++)
		soap_default_wsnt__SubscribeCreationFailedFaultType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, const struct wsnt__SubscribeCreationFailedFaultType *a, const char *tag, const char *type)
{
	if (soap_out_wsnt__SubscribeCreationFailedFaultType(soap, tag ? tag : "wsnt:SubscribeCreationFailedFaultType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC4 soap_get_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, struct wsnt__SubscribeCreationFailedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__SubscribeCreationFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__OSDReference(struct soap *soap, struct tt__OSDReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->__item);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__OSDReference(struct soap *soap, const struct tt__OSDReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDReference(struct soap *soap, const char *tag, int id, const struct tt__OSDReference *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__ReferenceToken(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct tt__OSDReference * SOAP_FMAC4 soap_in_tt__OSDReference(struct soap *soap, const char *tag, struct tt__OSDReference *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct tt__OSDReference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDReference, sizeof(struct tt__OSDReference), NULL, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_tt__OSDReference(soap, a);
	if (!soap_in_tt__ReferenceToken(soap, tag, (char**)&a->__item, "tt:OSDReference"))
		return NULL;
	return a;
}

SOAP_FMAC3 struct tt__OSDReference * SOAP_FMAC4 soap_new_tt__OSDReference(struct soap *soap, int n)
{
	struct tt__OSDReference *p;
	struct tt__OSDReference *a = (struct tt__OSDReference*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__OSDReference));
	for (p = a; p && n--; p++)
		soap_default_tt__OSDReference(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__OSDReference(struct soap *soap, const struct tt__OSDReference *a, const char *tag, const char *type)
{
	if (soap_out_tt__OSDReference(soap, tag ? tag : "tt:OSDReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OSDReference * SOAP_FMAC4 soap_get_tt__OSDReference(struct soap *soap, struct tt__OSDReference *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__DigitalInput(struct soap *soap, struct tt__DigitalInput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->IdleState = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DigitalInput(struct soap *soap, const struct tt__DigitalInput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DigitalInput(struct soap *soap, const char *tag, int id, const struct tt__DigitalInput *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, a->token), 1);
	if (a->IdleState)
		soap_set_attr(soap, "IdleState", soap_tt__DigitalIdleState2s(soap, *a->IdleState), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DigitalInput), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__DigitalInput * SOAP_FMAC4 soap_in_tt__DigitalInput(struct soap *soap, const char *tag, struct tt__DigitalInput *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__DigitalInput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DigitalInput, sizeof(struct tt__DigitalInput), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__DigitalInput(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	{	const char *t = soap_attr_value(soap, "IdleState", 0);
		if (t)
		{
			if (!(a->IdleState = (enum tt__DigitalIdleState *)soap_malloc(soap, sizeof(enum tt__DigitalIdleState))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2tt__DigitalIdleState(soap, t, a->IdleState))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__DigitalInput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DigitalInput, SOAP_TYPE_tt__DigitalInput, sizeof(struct tt__DigitalInput), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__DigitalInput * SOAP_FMAC4 soap_new_tt__DigitalInput(struct soap *soap, int n)
{
	struct tt__DigitalInput *p;
	struct tt__DigitalInput *a = (struct tt__DigitalInput*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__DigitalInput));
	for (p = a; p && n--; p++)
		soap_default_tt__DigitalInput(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DigitalInput(struct soap *soap, const struct tt__DigitalInput *a, const char *tag, const char *type)
{
	if (soap_out_tt__DigitalInput(soap, tag ? tag : "tt:DigitalInput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DigitalInput * SOAP_FMAC4 soap_get_tt__DigitalInput(struct soap *soap, struct tt__DigitalInput *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DigitalInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoOutputConfiguration(struct soap *soap, struct tt__VideoOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_int(soap, &a->UseCount);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_tt__ReferenceToken(soap, &a->OutputToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoOutputConfiguration(struct soap *soap, const struct tt__VideoOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
	soap_embedded(soap, &a->UseCount, SOAP_TYPE_int);
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->OutputToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoOutputConfiguration(struct soap *soap, const char *tag, int id, const struct tt__VideoOutputConfiguration *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, a->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoOutputConfiguration), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "tt:Name"))
			return soap->error;
	}
	else
	if (soap_out_tt__Name(soap, "tt:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->UseCount, ""))
		return soap->error;
	if (!a->OutputToken)
	{	if (soap_element_nil(soap, "tt:OutputToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "tt:OutputToken", -1, (char*const*)&a->OutputToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoOutputConfiguration * SOAP_FMAC4 soap_in_tt__VideoOutputConfiguration(struct soap *soap, const char *tag, struct tt__VideoOutputConfiguration *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_UseCount = 1;
	size_t soap_flag_OutputToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoOutputConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoOutputConfiguration, sizeof(struct tt__VideoOutputConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoOutputConfiguration(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_UseCount && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &a->UseCount, "xsd:int"))
				{	soap_flag_UseCount--;
					continue;
				}
			if (soap_flag_OutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:OutputToken", (char**)&a->OutputToken, "tt:ReferenceToken"))
				{	soap_flag_OutputToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_UseCount > 0 || soap_flag_OutputToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__VideoOutputConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoOutputConfiguration, SOAP_TYPE_tt__VideoOutputConfiguration, sizeof(struct tt__VideoOutputConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoOutputConfiguration * SOAP_FMAC4 soap_new_tt__VideoOutputConfiguration(struct soap *soap, int n)
{
	struct tt__VideoOutputConfiguration *p;
	struct tt__VideoOutputConfiguration *a = (struct tt__VideoOutputConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoOutputConfiguration));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoOutputConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoOutputConfiguration(struct soap *soap, const struct tt__VideoOutputConfiguration *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoOutputConfiguration(soap, tag ? tag : "tt:VideoOutputConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoOutputConfiguration * SOAP_FMAC4 soap_get_tt__VideoOutputConfiguration(struct soap *soap, struct tt__VideoOutputConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__VideoOutput(struct soap *soap, struct tt__VideoOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->Layout = NULL;
	a->Resolution = NULL;
	a->RefreshRate = NULL;
	a->AspectRatio = NULL;
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__VideoOutput(struct soap *soap, const struct tt__VideoOutput *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Layout(soap, &a->Layout);
	soap_serialize_PointerTott__VideoResolution(soap, &a->Resolution);
	soap_serialize_PointerTofloat(soap, &a->RefreshRate);
	soap_serialize_PointerTofloat(soap, &a->AspectRatio);
	soap_serialize_PointerTott__VideoOutputExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoOutput(struct soap *soap, const char *tag, int id, const struct tt__VideoOutput *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, a->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoOutput), type))
		return soap->error;
	if (!a->Layout)
	{	if (soap_element_nil(soap, "tt:Layout"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__Layout(soap, "tt:Layout", -1, &a->Layout, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoResolution(soap, "tt:Resolution", -1, &a->Resolution, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:RefreshRate", -1, &a->RefreshRate, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:AspectRatio", -1, &a->AspectRatio, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoOutputExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__VideoOutput * SOAP_FMAC4 soap_in_tt__VideoOutput(struct soap *soap, const char *tag, struct tt__VideoOutput *a, const char *type)
{
	size_t soap_flag_Layout = 1;
	size_t soap_flag_Resolution = 1;
	size_t soap_flag_RefreshRate = 1;
	size_t soap_flag_AspectRatio = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__VideoOutput *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoOutput, sizeof(struct tt__VideoOutput), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__VideoOutput(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Layout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Layout(soap, "tt:Layout", &a->Layout, "tt:Layout"))
				{	soap_flag_Layout--;
					continue;
				}
			if (soap_flag_Resolution && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoResolution(soap, "tt:Resolution", &a->Resolution, "tt:VideoResolution"))
				{	soap_flag_Resolution--;
					continue;
				}
			if (soap_flag_RefreshRate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:RefreshRate", &a->RefreshRate, "xsd:float"))
				{	soap_flag_RefreshRate--;
					continue;
				}
			if (soap_flag_AspectRatio && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "tt:AspectRatio", &a->AspectRatio, "xsd:float"))
				{	soap_flag_AspectRatio--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoOutputExtension(soap, "tt:Extension", &a->Extension, "tt:VideoOutputExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Layout > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct tt__VideoOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoOutput, SOAP_TYPE_tt__VideoOutput, sizeof(struct tt__VideoOutput), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__VideoOutput * SOAP_FMAC4 soap_new_tt__VideoOutput(struct soap *soap, int n)
{
	struct tt__VideoOutput *p;
	struct tt__VideoOutput *a = (struct tt__VideoOutput*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__VideoOutput));
	for (p = a; p && n--; p++)
		soap_default_tt__VideoOutput(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__VideoOutput(struct soap *soap, const struct tt__VideoOutput *a, const char *tag, const char *type)
{
	if (soap_out_tt__VideoOutput(soap, tag ? tag : "tt:VideoOutput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoOutput * SOAP_FMAC4 soap_get_tt__VideoOutput(struct soap *soap, struct tt__VideoOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__AreaInfoBase(struct soap *soap, struct ns1__AreaInfoBase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->token);
	soap_default_ns2__Name(soap, &a->Name);
	soap_default_ns2__Description(soap, &a->Description);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__AreaInfoBase(struct soap *soap, const struct ns1__AreaInfoBase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__Name(soap, (char*const*)&a->Name);
	soap_serialize_ns2__Description(soap, (char*const*)&a->Description);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AreaInfoBase(struct soap *soap, const char *tag, int id, const struct ns1__AreaInfoBase *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_ns2__ReferenceToken2s(soap, a->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AreaInfoBase), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "ns1:Name"))
			return soap->error;
	}
	else
	if (soap_out_ns2__Name(soap, "ns1:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_ns2__Description(soap, "ns1:Description", -1, (char*const*)&a->Description, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__AreaInfoBase * SOAP_FMAC4 soap_in_ns1__AreaInfoBase(struct soap *soap, const char *tag, struct ns1__AreaInfoBase *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_Description = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__AreaInfoBase *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AreaInfoBase, sizeof(struct ns1__AreaInfoBase), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__AreaInfoBase(soap, a);
	if (soap_s2ns2__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Name(soap, "ns1:Name", (char**)&a->Name, "ns2:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Description(soap, "ns1:Description", (char**)&a->Description, "ns2:Description"))
				{	soap_flag_Description--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__AreaInfoBase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AreaInfoBase, SOAP_TYPE_ns1__AreaInfoBase, sizeof(struct ns1__AreaInfoBase), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__AreaInfoBase * SOAP_FMAC4 soap_new_ns1__AreaInfoBase(struct soap *soap, int n)
{
	struct ns1__AreaInfoBase *p;
	struct ns1__AreaInfoBase *a = (struct ns1__AreaInfoBase*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__AreaInfoBase));
	for (p = a; p && n--; p++)
		soap_default_ns1__AreaInfoBase(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__AreaInfoBase(struct soap *soap, const struct ns1__AreaInfoBase *a, const char *tag, const char *type)
{
	if (soap_out_ns1__AreaInfoBase(soap, tag ? tag : "ns1:AreaInfoBase", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__AreaInfoBase * SOAP_FMAC4 soap_get_ns1__AreaInfoBase(struct soap *soap, struct ns1__AreaInfoBase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AreaInfoBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__AccessPointInfoBase(struct soap *soap, struct ns1__AccessPointInfoBase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_ns2__ReferenceToken(soap, &a->token);
	soap_default_ns2__Name(soap, &a->Name);
	soap_default_ns2__Description(soap, &a->Description);
	soap_default_ns2__ReferenceToken(soap, &a->AreaFrom);
	soap_default_ns2__ReferenceToken(soap, &a->AreaTo);
	soap_default__QName(soap, &a->EntityType);
	soap_default_ns2__ReferenceToken(soap, &a->Entity);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__AccessPointInfoBase(struct soap *soap, const struct ns1__AccessPointInfoBase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_ns2__Name(soap, (char*const*)&a->Name);
	soap_serialize_ns2__Description(soap, (char*const*)&a->Description);
	soap_serialize_ns2__ReferenceToken(soap, (char*const*)&a->AreaFrom);
	soap_serialize_ns2__ReferenceToken(soap, (char*const*)&a->AreaTo);
	soap_serialize__QName(soap, (char*const*)&a->EntityType);
	soap_serialize_ns2__ReferenceToken(soap, (char*const*)&a->Entity);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AccessPointInfoBase(struct soap *soap, const char *tag, int id, const struct ns1__AccessPointInfoBase *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_ns2__ReferenceToken2s(soap, a->token), 1);
	 char *soap_tmp_EntityType = soap_QName2s(soap, a->EntityType);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AccessPointInfoBase), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "ns1:Name"))
			return soap->error;
	}
	else
	if (soap_out_ns2__Name(soap, "ns1:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	if (soap_out_ns2__Description(soap, "ns1:Description", -1, (char*const*)&a->Description, ""))
		return soap->error;
	if (soap_out_ns2__ReferenceToken(soap, "ns1:AreaFrom", -1, (char*const*)&a->AreaFrom, ""))
		return soap->error;
	if (soap_out_ns2__ReferenceToken(soap, "ns1:AreaTo", -1, (char*const*)&a->AreaTo, ""))
		return soap->error;
	if (soap_out__QName(soap, "ns1:EntityType", -1, (char*const*)(void*)&soap_tmp_EntityType, ""))
		return soap->error;
	if (!a->Entity)
	{	if (soap_element_nil(soap, "ns1:Entity"))
			return soap->error;
	}
	else
	if (soap_out_ns2__ReferenceToken(soap, "ns1:Entity", -1, (char*const*)&a->Entity, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__AccessPointInfoBase * SOAP_FMAC4 soap_in_ns1__AccessPointInfoBase(struct soap *soap, const char *tag, struct ns1__AccessPointInfoBase *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_Description = 1;
	size_t soap_flag_AreaFrom = 1;
	size_t soap_flag_AreaTo = 1;
	size_t soap_flag_EntityType = 1;
	size_t soap_flag_Entity = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__AccessPointInfoBase *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AccessPointInfoBase, sizeof(struct ns1__AccessPointInfoBase), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__AccessPointInfoBase(soap, a);
	if (soap_s2ns2__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Name(soap, "ns1:Name", (char**)&a->Name, "ns2:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_Description && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__Description(soap, "ns1:Description", (char**)&a->Description, "ns2:Description"))
				{	soap_flag_Description--;
					continue;
				}
			if (soap_flag_AreaFrom && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns1:AreaFrom", (char**)&a->AreaFrom, "ns2:ReferenceToken"))
				{	soap_flag_AreaFrom--;
					continue;
				}
			if (soap_flag_AreaTo && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns1:AreaTo", (char**)&a->AreaTo, "ns2:ReferenceToken"))
				{	soap_flag_AreaTo--;
					continue;
				}
			if (soap_flag_EntityType && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "ns1:EntityType", (char**)&a->EntityType, "xsd:QName"))
				{	soap_flag_EntityType--;
					continue;
				}
			if (soap_flag_Entity && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_ns2__ReferenceToken(soap, "ns1:Entity", (char**)&a->Entity, "ns2:ReferenceToken"))
				{	soap_flag_Entity--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0 || soap_flag_Entity > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns1__AccessPointInfoBase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AccessPointInfoBase, SOAP_TYPE_ns1__AccessPointInfoBase, sizeof(struct ns1__AccessPointInfoBase), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__AccessPointInfoBase * SOAP_FMAC4 soap_new_ns1__AccessPointInfoBase(struct soap *soap, int n)
{
	struct ns1__AccessPointInfoBase *p;
	struct ns1__AccessPointInfoBase *a = (struct ns1__AccessPointInfoBase*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__AccessPointInfoBase));
	for (p = a; p && n--; p++)
		soap_default_ns1__AccessPointInfoBase(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__AccessPointInfoBase(struct soap *soap, const struct ns1__AccessPointInfoBase *a, const char *tag, const char *type)
{
	if (soap_out_ns1__AccessPointInfoBase(soap, tag ? tag : "ns1:AccessPointInfoBase", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__AccessPointInfoBase * SOAP_FMAC4 soap_get_ns1__AccessPointInfoBase(struct soap *soap, struct ns1__AccessPointInfoBase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AccessPointInfoBase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns8__SetConfigurationResponse(struct soap *soap, struct _ns8__SetConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns8__SetConfigurationResponse(struct soap *soap, const struct _ns8__SetConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns8__SetConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _ns8__SetConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__SetConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns8__SetConfigurationResponse * SOAP_FMAC4 soap_in__ns8__SetConfigurationResponse(struct soap *soap, const char *tag, struct _ns8__SetConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns8__SetConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__SetConfigurationResponse, sizeof(struct _ns8__SetConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns8__SetConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns8__SetConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__SetConfigurationResponse, SOAP_TYPE__ns8__SetConfigurationResponse, sizeof(struct _ns8__SetConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns8__SetConfigurationResponse * SOAP_FMAC4 soap_new__ns8__SetConfigurationResponse(struct soap *soap, int n)
{
	struct _ns8__SetConfigurationResponse *p;
	struct _ns8__SetConfigurationResponse *a = (struct _ns8__SetConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns8__SetConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__ns8__SetConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns8__SetConfigurationResponse(struct soap *soap, const struct _ns8__SetConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns8__SetConfigurationResponse(soap, tag ? tag : "ns8:SetConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns8__SetConfigurationResponse * SOAP_FMAC4 soap_get__ns8__SetConfigurationResponse(struct soap *soap, struct _ns8__SetConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns8__SetConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns8__SetConfiguration(struct soap *soap, struct _ns8__SetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns8__SetConfiguration(struct soap *soap, const struct _ns8__SetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoSourceToken);
	soap_serialize_PointerTons8__Configuration(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns8__SetConfiguration(struct soap *soap, const char *tag, int id, const struct _ns8__SetConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__SetConfiguration), type))
		return soap->error;
	if (!a->VideoSourceToken)
	{	if (soap_element_nil(soap, "ns8:VideoSourceToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "ns8:VideoSourceToken", -1, (char*const*)&a->VideoSourceToken, ""))
		return soap->error;
	if (!a->Configuration)
	{	if (soap_element_nil(soap, "ns8:Configuration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons8__Configuration(soap, "ns8:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns8__SetConfiguration * SOAP_FMAC4 soap_in__ns8__SetConfiguration(struct soap *soap, const char *tag, struct _ns8__SetConfiguration *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns8__SetConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__SetConfiguration, sizeof(struct _ns8__SetConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns8__SetConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "ns8:VideoSourceToken", (char**)&a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons8__Configuration(soap, "ns8:Configuration", &a->Configuration, "ns8:Configuration"))
				{	soap_flag_Configuration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoSourceToken > 0 || soap_flag_Configuration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns8__SetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__SetConfiguration, SOAP_TYPE__ns8__SetConfiguration, sizeof(struct _ns8__SetConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns8__SetConfiguration * SOAP_FMAC4 soap_new__ns8__SetConfiguration(struct soap *soap, int n)
{
	struct _ns8__SetConfiguration *p;
	struct _ns8__SetConfiguration *a = (struct _ns8__SetConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns8__SetConfiguration));
	for (p = a; p && n--; p++)
		soap_default__ns8__SetConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns8__SetConfiguration(struct soap *soap, const struct _ns8__SetConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__ns8__SetConfiguration(soap, tag ? tag : "ns8:SetConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns8__SetConfiguration * SOAP_FMAC4 soap_get__ns8__SetConfiguration(struct soap *soap, struct _ns8__SetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns8__SetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns8__GetConfigurationResponse(struct soap *soap, struct _ns8__GetConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns8__GetConfigurationResponse(struct soap *soap, const struct _ns8__GetConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons8__Configuration(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns8__GetConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _ns8__GetConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__GetConfigurationResponse), type))
		return soap->error;
	if (a->Configuration)
		soap_element_result(soap, "ns8:Configuration");
	if (!a->Configuration)
	{	if (soap_element_nil(soap, "ns8:Configuration"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons8__Configuration(soap, "ns8:Configuration", -1, &a->Configuration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns8__GetConfigurationResponse * SOAP_FMAC4 soap_in__ns8__GetConfigurationResponse(struct soap *soap, const char *tag, struct _ns8__GetConfigurationResponse *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns8__GetConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__GetConfigurationResponse, sizeof(struct _ns8__GetConfigurationResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns8__GetConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons8__Configuration(soap, "ns8:Configuration", &a->Configuration, "ns8:Configuration"))
				{	soap_flag_Configuration--;
					continue;
				}
			soap_check_result(soap, "ns8:Configuration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns8__GetConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__GetConfigurationResponse, SOAP_TYPE__ns8__GetConfigurationResponse, sizeof(struct _ns8__GetConfigurationResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns8__GetConfigurationResponse * SOAP_FMAC4 soap_new__ns8__GetConfigurationResponse(struct soap *soap, int n)
{
	struct _ns8__GetConfigurationResponse *p;
	struct _ns8__GetConfigurationResponse *a = (struct _ns8__GetConfigurationResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns8__GetConfigurationResponse));
	for (p = a; p && n--; p++)
		soap_default__ns8__GetConfigurationResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns8__GetConfigurationResponse(struct soap *soap, const struct _ns8__GetConfigurationResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns8__GetConfigurationResponse(soap, tag ? tag : "ns8:GetConfigurationResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns8__GetConfigurationResponse * SOAP_FMAC4 soap_get__ns8__GetConfigurationResponse(struct soap *soap, struct _ns8__GetConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns8__GetConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns8__GetConfiguration(struct soap *soap, struct _ns8__GetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns8__GetConfiguration(struct soap *soap, const struct _ns8__GetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoSourceToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns8__GetConfiguration(struct soap *soap, const char *tag, int id, const struct _ns8__GetConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__GetConfiguration), type))
		return soap->error;
	if (!a->VideoSourceToken)
	{	if (soap_element_nil(soap, "ns8:VideoSourceToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "ns8:VideoSourceToken", -1, (char*const*)&a->VideoSourceToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns8__GetConfiguration * SOAP_FMAC4 soap_in__ns8__GetConfiguration(struct soap *soap, const char *tag, struct _ns8__GetConfiguration *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns8__GetConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__GetConfiguration, sizeof(struct _ns8__GetConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns8__GetConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "ns8:VideoSourceToken", (char**)&a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoSourceToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns8__GetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__GetConfiguration, SOAP_TYPE__ns8__GetConfiguration, sizeof(struct _ns8__GetConfiguration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns8__GetConfiguration * SOAP_FMAC4 soap_new__ns8__GetConfiguration(struct soap *soap, int n)
{
	struct _ns8__GetConfiguration *p;
	struct _ns8__GetConfiguration *a = (struct _ns8__GetConfiguration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns8__GetConfiguration));
	for (p = a; p && n--; p++)
		soap_default__ns8__GetConfiguration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns8__GetConfiguration(struct soap *soap, const struct _ns8__GetConfiguration *a, const char *tag, const char *type)
{
	if (soap_out__ns8__GetConfiguration(soap, tag ? tag : "ns8:GetConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns8__GetConfiguration * SOAP_FMAC4 soap_get__ns8__GetConfiguration(struct soap *soap, struct _ns8__GetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns8__GetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns8__GetConfigurationOptionsResponse(struct soap *soap, struct _ns8__GetConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ConfigurationOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns8__GetConfigurationOptionsResponse(struct soap *soap, const struct _ns8__GetConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons8__ConfigurationOptions(soap, &a->ConfigurationOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns8__GetConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, const struct _ns8__GetConfigurationOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__GetConfigurationOptionsResponse), type))
		return soap->error;
	if (a->ConfigurationOptions)
		soap_element_result(soap, "ns8:ConfigurationOptions");
	if (!a->ConfigurationOptions)
	{	if (soap_element_nil(soap, "ns8:ConfigurationOptions"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons8__ConfigurationOptions(soap, "ns8:ConfigurationOptions", -1, &a->ConfigurationOptions, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns8__GetConfigurationOptionsResponse * SOAP_FMAC4 soap_in__ns8__GetConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _ns8__GetConfigurationOptionsResponse *a, const char *type)
{
	size_t soap_flag_ConfigurationOptions = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns8__GetConfigurationOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__GetConfigurationOptionsResponse, sizeof(struct _ns8__GetConfigurationOptionsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns8__GetConfigurationOptionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons8__ConfigurationOptions(soap, "ns8:ConfigurationOptions", &a->ConfigurationOptions, "ns8:ConfigurationOptions"))
				{	soap_flag_ConfigurationOptions--;
					continue;
				}
			soap_check_result(soap, "ns8:ConfigurationOptions");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationOptions > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns8__GetConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__GetConfigurationOptionsResponse, SOAP_TYPE__ns8__GetConfigurationOptionsResponse, sizeof(struct _ns8__GetConfigurationOptionsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns8__GetConfigurationOptionsResponse * SOAP_FMAC4 soap_new__ns8__GetConfigurationOptionsResponse(struct soap *soap, int n)
{
	struct _ns8__GetConfigurationOptionsResponse *p;
	struct _ns8__GetConfigurationOptionsResponse *a = (struct _ns8__GetConfigurationOptionsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns8__GetConfigurationOptionsResponse));
	for (p = a; p && n--; p++)
		soap_default__ns8__GetConfigurationOptionsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns8__GetConfigurationOptionsResponse(struct soap *soap, const struct _ns8__GetConfigurationOptionsResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns8__GetConfigurationOptionsResponse(soap, tag ? tag : "ns8:GetConfigurationOptionsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns8__GetConfigurationOptionsResponse * SOAP_FMAC4 soap_get__ns8__GetConfigurationOptionsResponse(struct soap *soap, struct _ns8__GetConfigurationOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns8__GetConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns8__GetConfigurationOptions(struct soap *soap, struct _ns8__GetConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns8__GetConfigurationOptions(struct soap *soap, const struct _ns8__GetConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__ReferenceToken(soap, (char*const*)&a->VideoSourceToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns8__GetConfigurationOptions(struct soap *soap, const char *tag, int id, const struct _ns8__GetConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__GetConfigurationOptions), type))
		return soap->error;
	if (!a->VideoSourceToken)
	{	if (soap_element_nil(soap, "ns8:VideoSourceToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__ReferenceToken(soap, "ns8:VideoSourceToken", -1, (char*const*)&a->VideoSourceToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns8__GetConfigurationOptions * SOAP_FMAC4 soap_in__ns8__GetConfigurationOptions(struct soap *soap, const char *tag, struct _ns8__GetConfigurationOptions *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns8__GetConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__GetConfigurationOptions, sizeof(struct _ns8__GetConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns8__GetConfigurationOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "ns8:VideoSourceToken", (char**)&a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoSourceToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns8__GetConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__GetConfigurationOptions, SOAP_TYPE__ns8__GetConfigurationOptions, sizeof(struct _ns8__GetConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns8__GetConfigurationOptions * SOAP_FMAC4 soap_new__ns8__GetConfigurationOptions(struct soap *soap, int n)
{
	struct _ns8__GetConfigurationOptions *p;
	struct _ns8__GetConfigurationOptions *a = (struct _ns8__GetConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns8__GetConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default__ns8__GetConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns8__GetConfigurationOptions(struct soap *soap, const struct _ns8__GetConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out__ns8__GetConfigurationOptions(soap, tag ? tag : "ns8:GetConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns8__GetConfigurationOptions * SOAP_FMAC4 soap_get__ns8__GetConfigurationOptions(struct soap *soap, struct _ns8__GetConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns8__GetConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns8__GetServiceCapabilitiesResponse(struct soap *soap, struct _ns8__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns8__GetServiceCapabilitiesResponse(struct soap *soap, const struct _ns8__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons8__Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns8__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _ns8__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "ns8:Capabilities");
	if (!a->Capabilities)
	{	if (soap_element_nil(soap, "ns8:Capabilities"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons8__Capabilities(soap, "ns8:Capabilities", -1, &a->Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns8__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__ns8__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _ns8__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns8__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__GetServiceCapabilitiesResponse, sizeof(struct _ns8__GetServiceCapabilitiesResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns8__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons8__Capabilities(soap, "ns8:Capabilities", &a->Capabilities, "ns8:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			soap_check_result(soap, "ns8:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _ns8__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__GetServiceCapabilitiesResponse, SOAP_TYPE__ns8__GetServiceCapabilitiesResponse, sizeof(struct _ns8__GetServiceCapabilitiesResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns8__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_new__ns8__GetServiceCapabilitiesResponse(struct soap *soap, int n)
{
	struct _ns8__GetServiceCapabilitiesResponse *p;
	struct _ns8__GetServiceCapabilitiesResponse *a = (struct _ns8__GetServiceCapabilitiesResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns8__GetServiceCapabilitiesResponse));
	for (p = a; p && n--; p++)
		soap_default__ns8__GetServiceCapabilitiesResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns8__GetServiceCapabilitiesResponse(struct soap *soap, const struct _ns8__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	if (soap_out__ns8__GetServiceCapabilitiesResponse(soap, tag ? tag : "ns8:GetServiceCapabilitiesResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns8__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__ns8__GetServiceCapabilitiesResponse(struct soap *soap, struct _ns8__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns8__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__ns8__GetServiceCapabilities(struct soap *soap, struct _ns8__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns8__GetServiceCapabilities(struct soap *soap, const struct _ns8__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns8__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _ns8__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns8__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _ns8__GetServiceCapabilities * SOAP_FMAC4 soap_in__ns8__GetServiceCapabilities(struct soap *soap, const char *tag, struct _ns8__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _ns8__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns8__GetServiceCapabilities, sizeof(struct _ns8__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__ns8__GetServiceCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _ns8__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns8__GetServiceCapabilities, SOAP_TYPE__ns8__GetServiceCapabilities, sizeof(struct _ns8__GetServiceCapabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _ns8__GetServiceCapabilities * SOAP_FMAC4 soap_new__ns8__GetServiceCapabilities(struct soap *soap, int n)
{
	struct _ns8__GetServiceCapabilities *p;
	struct _ns8__GetServiceCapabilities *a = (struct _ns8__GetServiceCapabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _ns8__GetServiceCapabilities));
	for (p = a; p && n--; p++)
		soap_default__ns8__GetServiceCapabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__ns8__GetServiceCapabilities(struct soap *soap, const struct _ns8__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out__ns8__GetServiceCapabilities(soap, tag ? tag : "ns8:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns8__GetServiceCapabilities * SOAP_FMAC4 soap_get__ns8__GetServiceCapabilities(struct soap *soap, struct _ns8__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns8__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns8__Capabilities(struct soap *soap, struct ns8__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Radiometry = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns8__Capabilities(struct soap *soap, const struct ns8__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__Capabilities(struct soap *soap, const char *tag, int id, const struct ns8__Capabilities *a, const char *type)
{
	if (a->Radiometry)
		soap_set_attr(soap, "Radiometry", soap_xsd__boolean2s(soap, *a->Radiometry), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns8__Capabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns8__Capabilities * SOAP_FMAC4 soap_in_ns8__Capabilities(struct soap *soap, const char *tag, struct ns8__Capabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns8__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__Capabilities, sizeof(struct ns8__Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns8__Capabilities(soap, a);
	{	const char *t = soap_attr_value(soap, "Radiometry", 0);
		if (t)
		{
			if (!(a->Radiometry = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->Radiometry))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns8__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns8__Capabilities, SOAP_TYPE_ns8__Capabilities, sizeof(struct ns8__Capabilities), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns8__Capabilities * SOAP_FMAC4 soap_new_ns8__Capabilities(struct soap *soap, int n)
{
	struct ns8__Capabilities *p;
	struct ns8__Capabilities *a = (struct ns8__Capabilities*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns8__Capabilities));
	for (p = a; p && n--; p++)
		soap_default_ns8__Capabilities(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns8__Capabilities(struct soap *soap, const struct ns8__Capabilities *a, const char *tag, const char *type)
{
	if (soap_out_ns8__Capabilities(soap, tag ? tag : "ns8:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__Capabilities * SOAP_FMAC4 soap_get_ns8__Capabilities(struct soap *soap, struct ns8__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns8__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns8__ConfigurationOptions(struct soap *soap, struct ns8__ConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeColorPalette = 0;
	a->ColorPalette = NULL;
	a->__sizeNUCTable = 0;
	a->NUCTable = NULL;
	a->CoolerOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns8__ConfigurationOptions(struct soap *soap, const struct ns8__ConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ColorPalette)
	{	int i;
		for (i = 0; i < (int)a->__sizeColorPalette; i++)
		{
			soap_embedded(soap, a->ColorPalette + i, SOAP_TYPE_ns8__ColorPalette);
			soap_serialize_ns8__ColorPalette(soap, a->ColorPalette + i);
		}
	}
	if (a->NUCTable)
	{	int i;
		for (i = 0; i < (int)a->__sizeNUCTable; i++)
		{
			soap_embedded(soap, a->NUCTable + i, SOAP_TYPE_ns8__NUCTable);
			soap_serialize_ns8__NUCTable(soap, a->NUCTable + i);
		}
	}
	soap_serialize_PointerTons8__CoolerOptions(soap, &a->CoolerOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__ConfigurationOptions(struct soap *soap, const char *tag, int id, const struct ns8__ConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns8__ConfigurationOptions), type))
		return soap->error;
	if (a->ColorPalette)
	{	int i;
		for (i = 0; i < (int)a->__sizeColorPalette; i++)
			if (soap_out_ns8__ColorPalette(soap, "ns8:ColorPalette", -1, a->ColorPalette + i, ""))
				return soap->error;
	}
	if (a->NUCTable)
	{	int i;
		for (i = 0; i < (int)a->__sizeNUCTable; i++)
			if (soap_out_ns8__NUCTable(soap, "ns8:NUCTable", -1, a->NUCTable + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTons8__CoolerOptions(soap, "ns8:CoolerOptions", -1, &a->CoolerOptions, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns8__ConfigurationOptions * SOAP_FMAC4 soap_in_ns8__ConfigurationOptions(struct soap *soap, const char *tag, struct ns8__ConfigurationOptions *a, const char *type)
{
	struct soap_blist *soap_blist_ColorPalette = NULL;
	struct soap_blist *soap_blist_NUCTable = NULL;
	size_t soap_flag_CoolerOptions = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns8__ConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__ConfigurationOptions, sizeof(struct ns8__ConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns8__ConfigurationOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns8:ColorPalette", 1, NULL))
			{	if (a->ColorPalette == NULL)
				{	if (soap_blist_ColorPalette == NULL)
						soap_blist_ColorPalette = soap_alloc_block(soap);
					a->ColorPalette = (struct ns8__ColorPalette *)soap_push_block_max(soap, soap_blist_ColorPalette, sizeof(struct ns8__ColorPalette));
					if (a->ColorPalette == NULL)
						return NULL;
					soap_default_ns8__ColorPalette(soap, a->ColorPalette);
				}
				soap_revert(soap);
				if (soap_in_ns8__ColorPalette(soap, "ns8:ColorPalette", a->ColorPalette, "ns8:ColorPalette"))
				{	a->__sizeColorPalette++;
					a->ColorPalette = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ns8:NUCTable", 1, NULL))
			{	if (a->NUCTable == NULL)
				{	if (soap_blist_NUCTable == NULL)
						soap_blist_NUCTable = soap_alloc_block(soap);
					a->NUCTable = (struct ns8__NUCTable *)soap_push_block_max(soap, soap_blist_NUCTable, sizeof(struct ns8__NUCTable));
					if (a->NUCTable == NULL)
						return NULL;
					soap_default_ns8__NUCTable(soap, a->NUCTable);
				}
				soap_revert(soap);
				if (soap_in_ns8__NUCTable(soap, "ns8:NUCTable", a->NUCTable, "ns8:NUCTable"))
				{	a->__sizeNUCTable++;
					a->NUCTable = NULL;
					continue;
				}
			}
			if (soap_flag_CoolerOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons8__CoolerOptions(soap, "ns8:CoolerOptions", &a->CoolerOptions, "ns8:CoolerOptions"))
				{	soap_flag_CoolerOptions--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ColorPalette)
			soap_pop_block(soap, soap_blist_ColorPalette);
		if (a->__sizeColorPalette)
		{	a->ColorPalette = (struct ns8__ColorPalette *)soap_save_block(soap, soap_blist_ColorPalette, NULL, 1);
		}
		else
		{	a->ColorPalette = NULL;
			if (soap_blist_ColorPalette)
				soap_end_block(soap, soap_blist_ColorPalette);
		}
		if (a->NUCTable)
			soap_pop_block(soap, soap_blist_NUCTable);
		if (a->__sizeNUCTable)
		{	a->NUCTable = (struct ns8__NUCTable *)soap_save_block(soap, soap_blist_NUCTable, NULL, 1);
		}
		else
		{	a->NUCTable = NULL;
			if (soap_blist_NUCTable)
				soap_end_block(soap, soap_blist_NUCTable);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeColorPalette < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns8__ConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns8__ConfigurationOptions, SOAP_TYPE_ns8__ConfigurationOptions, sizeof(struct ns8__ConfigurationOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns8__ConfigurationOptions * SOAP_FMAC4 soap_new_ns8__ConfigurationOptions(struct soap *soap, int n)
{
	struct ns8__ConfigurationOptions *p;
	struct ns8__ConfigurationOptions *a = (struct ns8__ConfigurationOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns8__ConfigurationOptions));
	for (p = a; p && n--; p++)
		soap_default_ns8__ConfigurationOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns8__ConfigurationOptions(struct soap *soap, const struct ns8__ConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out_ns8__ConfigurationOptions(soap, tag ? tag : "ns8:ConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__ConfigurationOptions * SOAP_FMAC4 soap_get_ns8__ConfigurationOptions(struct soap *soap, struct ns8__ConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns8__ConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns8__Configuration(struct soap *soap, struct ns8__Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ColorPalette = NULL;
	soap_default_ns8__Polarity(soap, &a->Polarity);
	a->NUCTable = NULL;
	a->Cooler = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns8__Configuration(struct soap *soap, const struct ns8__Configuration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons8__ColorPalette(soap, &a->ColorPalette);
	soap_serialize_PointerTons8__NUCTable(soap, &a->NUCTable);
	soap_serialize_PointerTons8__Cooler(soap, &a->Cooler);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__Configuration(struct soap *soap, const char *tag, int id, const struct ns8__Configuration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns8__Configuration), type))
		return soap->error;
	if (!a->ColorPalette)
	{	if (soap_element_nil(soap, "ns8:ColorPalette"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons8__ColorPalette(soap, "ns8:ColorPalette", -1, &a->ColorPalette, ""))
		return soap->error;
	if (soap_out_ns8__Polarity(soap, "ns8:Polarity", -1, &a->Polarity, ""))
		return soap->error;
	if (soap_out_PointerTons8__NUCTable(soap, "ns8:NUCTable", -1, &a->NUCTable, ""))
		return soap->error;
	if (soap_out_PointerTons8__Cooler(soap, "ns8:Cooler", -1, &a->Cooler, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns8__Configuration * SOAP_FMAC4 soap_in_ns8__Configuration(struct soap *soap, const char *tag, struct ns8__Configuration *a, const char *type)
{
	size_t soap_flag_ColorPalette = 1;
	size_t soap_flag_Polarity = 1;
	size_t soap_flag_NUCTable = 1;
	size_t soap_flag_Cooler = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns8__Configuration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__Configuration, sizeof(struct ns8__Configuration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns8__Configuration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ColorPalette && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons8__ColorPalette(soap, "ns8:ColorPalette", &a->ColorPalette, "ns8:ColorPalette"))
				{	soap_flag_ColorPalette--;
					continue;
				}
			if (soap_flag_Polarity && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns8__Polarity(soap, "ns8:Polarity", &a->Polarity, "ns8:Polarity"))
				{	soap_flag_Polarity--;
					continue;
				}
			if (soap_flag_NUCTable && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons8__NUCTable(soap, "ns8:NUCTable", &a->NUCTable, "ns8:NUCTable"))
				{	soap_flag_NUCTable--;
					continue;
				}
			if (soap_flag_Cooler && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons8__Cooler(soap, "ns8:Cooler", &a->Cooler, "ns8:Cooler"))
				{	soap_flag_Cooler--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ColorPalette > 0 || soap_flag_Polarity > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns8__Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns8__Configuration, SOAP_TYPE_ns8__Configuration, sizeof(struct ns8__Configuration), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns8__Configuration * SOAP_FMAC4 soap_new_ns8__Configuration(struct soap *soap, int n)
{
	struct ns8__Configuration *p;
	struct ns8__Configuration *a = (struct ns8__Configuration*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns8__Configuration));
	for (p = a; p && n--; p++)
		soap_default_ns8__Configuration(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns8__Configuration(struct soap *soap, const struct ns8__Configuration *a, const char *tag, const char *type)
{
	if (soap_out_ns8__Configuration(soap, tag ? tag : "ns8:Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__Configuration * SOAP_FMAC4 soap_get_ns8__Configuration(struct soap *soap, struct ns8__Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns8__Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns8__CoolerOptions(struct soap *soap, struct ns8__CoolerOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Enabled = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns8__CoolerOptions(struct soap *soap, const struct ns8__CoolerOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__boolean(soap, &a->Enabled);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__CoolerOptions(struct soap *soap, const char *tag, int id, const struct ns8__CoolerOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns8__CoolerOptions), type))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "ns8:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns8__CoolerOptions * SOAP_FMAC4 soap_in_ns8__CoolerOptions(struct soap *soap, const char *tag, struct ns8__CoolerOptions *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns8__CoolerOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__CoolerOptions, sizeof(struct ns8__CoolerOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns8__CoolerOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "ns8:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns8__CoolerOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns8__CoolerOptions, SOAP_TYPE_ns8__CoolerOptions, sizeof(struct ns8__CoolerOptions), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns8__CoolerOptions * SOAP_FMAC4 soap_new_ns8__CoolerOptions(struct soap *soap, int n)
{
	struct ns8__CoolerOptions *p;
	struct ns8__CoolerOptions *a = (struct ns8__CoolerOptions*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns8__CoolerOptions));
	for (p = a; p && n--; p++)
		soap_default_ns8__CoolerOptions(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns8__CoolerOptions(struct soap *soap, const struct ns8__CoolerOptions *a, const char *tag, const char *type)
{
	if (soap_out_ns8__CoolerOptions(soap, tag ? tag : "ns8:CoolerOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__CoolerOptions * SOAP_FMAC4 soap_get_ns8__CoolerOptions(struct soap *soap, struct ns8__CoolerOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns8__CoolerOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns8__Cooler(struct soap *soap, struct ns8__Cooler *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->Enabled);
	a->RunTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns8__Cooler(struct soap *soap, const struct ns8__Cooler *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Enabled, SOAP_TYPE_xsd__boolean);
	soap_serialize_PointerTofloat(soap, &a->RunTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__Cooler(struct soap *soap, const char *tag, int id, const struct ns8__Cooler *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns8__Cooler), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "ns8:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "ns8:RunTime", -1, &a->RunTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns8__Cooler * SOAP_FMAC4 soap_in_ns8__Cooler(struct soap *soap, const char *tag, struct ns8__Cooler *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	size_t soap_flag_RunTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns8__Cooler *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__Cooler, sizeof(struct ns8__Cooler), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns8__Cooler(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "ns8:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap_flag_RunTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTofloat(soap, "ns8:RunTime", &a->RunTime, "xsd:float"))
				{	soap_flag_RunTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns8__Cooler *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns8__Cooler, SOAP_TYPE_ns8__Cooler, sizeof(struct ns8__Cooler), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns8__Cooler * SOAP_FMAC4 soap_new_ns8__Cooler(struct soap *soap, int n)
{
	struct ns8__Cooler *p;
	struct ns8__Cooler *a = (struct ns8__Cooler*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns8__Cooler));
	for (p = a; p && n--; p++)
		soap_default_ns8__Cooler(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns8__Cooler(struct soap *soap, const struct ns8__Cooler *a, const char *tag, const char *type)
{
	if (soap_out_ns8__Cooler(soap, tag ? tag : "ns8:Cooler", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__Cooler * SOAP_FMAC4 soap_get_ns8__Cooler(struct soap *soap, struct ns8__Cooler *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns8__Cooler(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns8__NUCTable(struct soap *soap, struct ns8__NUCTable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_tt__ReferenceToken(soap, &a->token);
	a->LowTemperature = NULL;
	a->HighTemperature = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns8__NUCTable(struct soap *soap, const struct ns8__NUCTable *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__NUCTable(struct soap *soap, const char *tag, int id, const struct ns8__NUCTable *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, a->token), 1);
	if (a->LowTemperature)
		soap_set_attr(soap, "LowTemperature", soap_float2s(soap, *a->LowTemperature), 1);
	if (a->HighTemperature)
		soap_set_attr(soap, "HighTemperature", soap_float2s(soap, *a->HighTemperature), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns8__NUCTable), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "ns8:Name"))
			return soap->error;
	}
	else
	if (soap_out_tt__Name(soap, "ns8:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns8__NUCTable * SOAP_FMAC4 soap_in_ns8__NUCTable(struct soap *soap, const char *tag, struct ns8__NUCTable *a, const char *type)
{
	size_t soap_flag_Name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns8__NUCTable *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__NUCTable, sizeof(struct ns8__NUCTable), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns8__NUCTable(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	{	const char *t = soap_attr_value(soap, "LowTemperature", 0);
		if (t)
		{
			if (!(a->LowTemperature = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->LowTemperature))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "HighTemperature", 0);
		if (t)
		{
			if (!(a->HighTemperature = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->HighTemperature))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "ns8:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns8__NUCTable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns8__NUCTable, SOAP_TYPE_ns8__NUCTable, sizeof(struct ns8__NUCTable), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns8__NUCTable * SOAP_FMAC4 soap_new_ns8__NUCTable(struct soap *soap, int n)
{
	struct ns8__NUCTable *p;
	struct ns8__NUCTable *a = (struct ns8__NUCTable*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns8__NUCTable));
	for (p = a; p && n--; p++)
		soap_default_ns8__NUCTable(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns8__NUCTable(struct soap *soap, const struct ns8__NUCTable *a, const char *tag, const char *type)
{
	if (soap_out_ns8__NUCTable(soap, tag ? tag : "ns8:NUCTable", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__NUCTable * SOAP_FMAC4 soap_get_ns8__NUCTable(struct soap *soap, struct ns8__NUCTable *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns8__NUCTable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns8__ColorPalette(struct soap *soap, struct ns8__ColorPalette *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__Name(soap, &a->Name);
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns8__ColorPalette(struct soap *soap, const struct ns8__ColorPalette *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, (char*const*)&a->Name);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns8__ColorPalette(struct soap *soap, const char *tag, int id, const struct ns8__ColorPalette *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, a->token), 1);
	if (a->Type)
		soap_set_attr(soap, "Type", soap_string2s(soap, a->Type), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns8__ColorPalette), type))
		return soap->error;
	if (!a->Name)
	{	if (soap_element_nil(soap, "ns8:Name"))
			return soap->error;
	}
	else
	if (soap_out_tt__Name(soap, "ns8:Name", -1, (char*const*)&a->Name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns8__ColorPalette * SOAP_FMAC4 soap_in_ns8__ColorPalette(struct soap *soap, const char *tag, struct ns8__ColorPalette *a, const char *type)
{
	size_t soap_flag_Name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns8__ColorPalette *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns8__ColorPalette, sizeof(struct ns8__ColorPalette), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns8__ColorPalette(soap, a);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1), &a->token))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 1), &a->Type))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "ns8:Name", (char**)&a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct ns8__ColorPalette *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns8__ColorPalette, SOAP_TYPE_ns8__ColorPalette, sizeof(struct ns8__ColorPalette), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns8__ColorPalette * SOAP_FMAC4 soap_new_ns8__ColorPalette(struct soap *soap, int n)
{
	struct ns8__ColorPalette *p;
	struct ns8__ColorPalette *a = (struct ns8__ColorPalette*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns8__ColorPalette));
	for (p = a; p && n--; p++)
		soap_default_ns8__ColorPalette(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns8__ColorPalette(struct soap *soap, const struct ns8__ColorPalette *a, const char *tag, const char *type)
{
	if (soap_out_ns8__ColorPalette(soap, tag ? tag : "ns8:ColorPalette", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns8__ColorPalette * SOAP_FMAC4 soap_get_ns8__ColorPalette(struct soap *soap, struct ns8__ColorPalette *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns8__ColorPalette(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__EndSearchResponse(struct soap *soap, struct _tse__EndSearchResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->Endpoint);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__EndSearchResponse(struct soap *soap, const struct _tse__EndSearchResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->Endpoint, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__EndSearchResponse(struct soap *soap, const char *tag, int id, const struct _tse__EndSearchResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__EndSearchResponse), type))
		return soap->error;
	soap_element_result(soap, "tse:Endpoint");
	if (soap_out_dateTime(soap, "tse:Endpoint", -1, &a->Endpoint, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__EndSearchResponse * SOAP_FMAC4 soap_in__tse__EndSearchResponse(struct soap *soap, const char *tag, struct _tse__EndSearchResponse *a, const char *type)
{
	size_t soap_flag_Endpoint = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__EndSearchResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__EndSearchResponse, sizeof(struct _tse__EndSearchResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__EndSearchResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Endpoint && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "tse:Endpoint", &a->Endpoint, "xsd:dateTime"))
				{	soap_flag_Endpoint--;
					continue;
				}
			soap_check_result(soap, "tse:Endpoint");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Endpoint > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__EndSearchResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__EndSearchResponse, SOAP_TYPE__tse__EndSearchResponse, sizeof(struct _tse__EndSearchResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__EndSearchResponse * SOAP_FMAC4 soap_new__tse__EndSearchResponse(struct soap *soap, int n)
{
	struct _tse__EndSearchResponse *p;
	struct _tse__EndSearchResponse *a = (struct _tse__EndSearchResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__EndSearchResponse));
	for (p = a; p && n--; p++)
		soap_default__tse__EndSearchResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__EndSearchResponse(struct soap *soap, const struct _tse__EndSearchResponse *a, const char *tag, const char *type)
{
	if (soap_out__tse__EndSearchResponse(soap, tag ? tag : "tse:EndSearchResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__EndSearchResponse * SOAP_FMAC4 soap_get__tse__EndSearchResponse(struct soap *soap, struct _tse__EndSearchResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__EndSearchResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__EndSearch(struct soap *soap, struct _tse__EndSearch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__JobToken(soap, &a->SearchToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__EndSearch(struct soap *soap, const struct _tse__EndSearch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__JobToken(soap, (char*const*)&a->SearchToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__EndSearch(struct soap *soap, const char *tag, int id, const struct _tse__EndSearch *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__EndSearch), type))
		return soap->error;
	if (!a->SearchToken)
	{	if (soap_element_nil(soap, "tse:SearchToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__JobToken(soap, "tse:SearchToken", -1, (char*const*)&a->SearchToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__EndSearch * SOAP_FMAC4 soap_in__tse__EndSearch(struct soap *soap, const char *tag, struct _tse__EndSearch *a, const char *type)
{
	size_t soap_flag_SearchToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__EndSearch *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__EndSearch, sizeof(struct _tse__EndSearch), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__EndSearch(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__JobToken(soap, "tse:SearchToken", (char**)&a->SearchToken, "tt:JobToken"))
				{	soap_flag_SearchToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__EndSearch *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__EndSearch, SOAP_TYPE__tse__EndSearch, sizeof(struct _tse__EndSearch), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__EndSearch * SOAP_FMAC4 soap_new__tse__EndSearch(struct soap *soap, int n)
{
	struct _tse__EndSearch *p;
	struct _tse__EndSearch *a = (struct _tse__EndSearch*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__EndSearch));
	for (p = a; p && n--; p++)
		soap_default__tse__EndSearch(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__EndSearch(struct soap *soap, const struct _tse__EndSearch *a, const char *tag, const char *type)
{
	if (soap_out__tse__EndSearch(soap, tag ? tag : "tse:EndSearch", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__EndSearch * SOAP_FMAC4 soap_get__tse__EndSearch(struct soap *soap, struct _tse__EndSearch *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__EndSearch(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetSearchStateResponse(struct soap *soap, struct _tse__GetSearchStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__SearchState(soap, &a->State);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetSearchStateResponse(struct soap *soap, const struct _tse__GetSearchStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetSearchStateResponse(struct soap *soap, const char *tag, int id, const struct _tse__GetSearchStateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetSearchStateResponse), type))
		return soap->error;
	soap_element_result(soap, "tse:State");
	if (soap_out_tt__SearchState(soap, "tse:State", -1, &a->State, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetSearchStateResponse * SOAP_FMAC4 soap_in__tse__GetSearchStateResponse(struct soap *soap, const char *tag, struct _tse__GetSearchStateResponse *a, const char *type)
{
	size_t soap_flag_State = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetSearchStateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetSearchStateResponse, sizeof(struct _tse__GetSearchStateResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetSearchStateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_State && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__SearchState(soap, "tse:State", &a->State, "tt:SearchState"))
				{	soap_flag_State--;
					continue;
				}
			soap_check_result(soap, "tse:State");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_State > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__GetSearchStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetSearchStateResponse, SOAP_TYPE__tse__GetSearchStateResponse, sizeof(struct _tse__GetSearchStateResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetSearchStateResponse * SOAP_FMAC4 soap_new__tse__GetSearchStateResponse(struct soap *soap, int n)
{
	struct _tse__GetSearchStateResponse *p;
	struct _tse__GetSearchStateResponse *a = (struct _tse__GetSearchStateResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetSearchStateResponse));
	for (p = a; p && n--; p++)
		soap_default__tse__GetSearchStateResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetSearchStateResponse(struct soap *soap, const struct _tse__GetSearchStateResponse *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetSearchStateResponse(soap, tag ? tag : "tse:GetSearchStateResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetSearchStateResponse * SOAP_FMAC4 soap_get__tse__GetSearchStateResponse(struct soap *soap, struct _tse__GetSearchStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetSearchStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetSearchState(struct soap *soap, struct _tse__GetSearchState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__JobToken(soap, &a->SearchToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetSearchState(struct soap *soap, const struct _tse__GetSearchState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__JobToken(soap, (char*const*)&a->SearchToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetSearchState(struct soap *soap, const char *tag, int id, const struct _tse__GetSearchState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetSearchState), type))
		return soap->error;
	if (!a->SearchToken)
	{	if (soap_element_nil(soap, "tse:SearchToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__JobToken(soap, "tse:SearchToken", -1, (char*const*)&a->SearchToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetSearchState * SOAP_FMAC4 soap_in__tse__GetSearchState(struct soap *soap, const char *tag, struct _tse__GetSearchState *a, const char *type)
{
	size_t soap_flag_SearchToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetSearchState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetSearchState, sizeof(struct _tse__GetSearchState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetSearchState(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__JobToken(soap, "tse:SearchToken", (char**)&a->SearchToken, "tt:JobToken"))
				{	soap_flag_SearchToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__GetSearchState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetSearchState, SOAP_TYPE__tse__GetSearchState, sizeof(struct _tse__GetSearchState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetSearchState * SOAP_FMAC4 soap_new__tse__GetSearchState(struct soap *soap, int n)
{
	struct _tse__GetSearchState *p;
	struct _tse__GetSearchState *a = (struct _tse__GetSearchState*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetSearchState));
	for (p = a; p && n--; p++)
		soap_default__tse__GetSearchState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetSearchState(struct soap *soap, const struct _tse__GetSearchState *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetSearchState(soap, tag ? tag : "tse:GetSearchState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetSearchState * SOAP_FMAC4 soap_get__tse__GetSearchState(struct soap *soap, struct _tse__GetSearchState *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetSearchState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetMetadataSearchResultsResponse(struct soap *soap, struct _tse__GetMetadataSearchResultsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ResultList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetMetadataSearchResultsResponse(struct soap *soap, const struct _tse__GetMetadataSearchResultsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__FindMetadataResultList(soap, &a->ResultList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetMetadataSearchResultsResponse(struct soap *soap, const char *tag, int id, const struct _tse__GetMetadataSearchResultsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetMetadataSearchResultsResponse), type))
		return soap->error;
	if (a->ResultList)
		soap_element_result(soap, "tse:ResultList");
	if (!a->ResultList)
	{	if (soap_element_nil(soap, "tse:ResultList"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__FindMetadataResultList(soap, "tse:ResultList", -1, &a->ResultList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetMetadataSearchResultsResponse * SOAP_FMAC4 soap_in__tse__GetMetadataSearchResultsResponse(struct soap *soap, const char *tag, struct _tse__GetMetadataSearchResultsResponse *a, const char *type)
{
	size_t soap_flag_ResultList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetMetadataSearchResultsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetMetadataSearchResultsResponse, sizeof(struct _tse__GetMetadataSearchResultsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetMetadataSearchResultsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FindMetadataResultList(soap, "tse:ResultList", &a->ResultList, "tt:FindMetadataResultList"))
				{	soap_flag_ResultList--;
					continue;
				}
			soap_check_result(soap, "tse:ResultList");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ResultList > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__GetMetadataSearchResultsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetMetadataSearchResultsResponse, SOAP_TYPE__tse__GetMetadataSearchResultsResponse, sizeof(struct _tse__GetMetadataSearchResultsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetMetadataSearchResultsResponse * SOAP_FMAC4 soap_new__tse__GetMetadataSearchResultsResponse(struct soap *soap, int n)
{
	struct _tse__GetMetadataSearchResultsResponse *p;
	struct _tse__GetMetadataSearchResultsResponse *a = (struct _tse__GetMetadataSearchResultsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetMetadataSearchResultsResponse));
	for (p = a; p && n--; p++)
		soap_default__tse__GetMetadataSearchResultsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetMetadataSearchResultsResponse(struct soap *soap, const struct _tse__GetMetadataSearchResultsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetMetadataSearchResultsResponse(soap, tag ? tag : "tse:GetMetadataSearchResultsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetMetadataSearchResultsResponse * SOAP_FMAC4 soap_get__tse__GetMetadataSearchResultsResponse(struct soap *soap, struct _tse__GetMetadataSearchResultsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetMetadataSearchResultsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetMetadataSearchResults(struct soap *soap, struct _tse__GetMetadataSearchResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__JobToken(soap, &a->SearchToken);
	a->MinResults = NULL;
	a->MaxResults = NULL;
	a->WaitTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetMetadataSearchResults(struct soap *soap, const struct _tse__GetMetadataSearchResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__JobToken(soap, (char*const*)&a->SearchToken);
	soap_serialize_PointerToint(soap, &a->MinResults);
	soap_serialize_PointerToint(soap, &a->MaxResults);
	soap_serialize_PointerToxsd__duration(soap, &a->WaitTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetMetadataSearchResults(struct soap *soap, const char *tag, int id, const struct _tse__GetMetadataSearchResults *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetMetadataSearchResults), type))
		return soap->error;
	if (!a->SearchToken)
	{	if (soap_element_nil(soap, "tse:SearchToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__JobToken(soap, "tse:SearchToken", -1, (char*const*)&a->SearchToken, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MinResults", -1, &a->MinResults, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MaxResults", -1, &a->MaxResults, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tse:WaitTime", -1, &a->WaitTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetMetadataSearchResults * SOAP_FMAC4 soap_in__tse__GetMetadataSearchResults(struct soap *soap, const char *tag, struct _tse__GetMetadataSearchResults *a, const char *type)
{
	size_t soap_flag_SearchToken = 1;
	size_t soap_flag_MinResults = 1;
	size_t soap_flag_MaxResults = 1;
	size_t soap_flag_WaitTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetMetadataSearchResults *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetMetadataSearchResults, sizeof(struct _tse__GetMetadataSearchResults), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetMetadataSearchResults(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__JobToken(soap, "tse:SearchToken", (char**)&a->SearchToken, "tt:JobToken"))
				{	soap_flag_SearchToken--;
					continue;
				}
			if (soap_flag_MinResults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tse:MinResults", &a->MinResults, "xsd:int"))
				{	soap_flag_MinResults--;
					continue;
				}
			if (soap_flag_MaxResults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tse:MaxResults", &a->MaxResults, "xsd:int"))
				{	soap_flag_MaxResults--;
					continue;
				}
			if (soap_flag_WaitTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__duration(soap, "tse:WaitTime", &a->WaitTime, "xsd:duration"))
				{	soap_flag_WaitTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__GetMetadataSearchResults *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetMetadataSearchResults, SOAP_TYPE__tse__GetMetadataSearchResults, sizeof(struct _tse__GetMetadataSearchResults), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetMetadataSearchResults * SOAP_FMAC4 soap_new__tse__GetMetadataSearchResults(struct soap *soap, int n)
{
	struct _tse__GetMetadataSearchResults *p;
	struct _tse__GetMetadataSearchResults *a = (struct _tse__GetMetadataSearchResults*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetMetadataSearchResults));
	for (p = a; p && n--; p++)
		soap_default__tse__GetMetadataSearchResults(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetMetadataSearchResults(struct soap *soap, const struct _tse__GetMetadataSearchResults *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetMetadataSearchResults(soap, tag ? tag : "tse:GetMetadataSearchResults", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetMetadataSearchResults * SOAP_FMAC4 soap_get__tse__GetMetadataSearchResults(struct soap *soap, struct _tse__GetMetadataSearchResults *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetMetadataSearchResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__FindMetadataResponse(struct soap *soap, struct _tse__FindMetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__JobToken(soap, &a->SearchToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__FindMetadataResponse(struct soap *soap, const struct _tse__FindMetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__JobToken(soap, (char*const*)&a->SearchToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__FindMetadataResponse(struct soap *soap, const char *tag, int id, const struct _tse__FindMetadataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__FindMetadataResponse), type))
		return soap->error;
	if (a->SearchToken)
		soap_element_result(soap, "tse:SearchToken");
	if (!a->SearchToken)
	{	if (soap_element_nil(soap, "tse:SearchToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__JobToken(soap, "tse:SearchToken", -1, (char*const*)&a->SearchToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__FindMetadataResponse * SOAP_FMAC4 soap_in__tse__FindMetadataResponse(struct soap *soap, const char *tag, struct _tse__FindMetadataResponse *a, const char *type)
{
	size_t soap_flag_SearchToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__FindMetadataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__FindMetadataResponse, sizeof(struct _tse__FindMetadataResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__FindMetadataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__JobToken(soap, "tse:SearchToken", (char**)&a->SearchToken, "tt:JobToken"))
				{	soap_flag_SearchToken--;
					continue;
				}
			soap_check_result(soap, "tse:SearchToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__FindMetadataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__FindMetadataResponse, SOAP_TYPE__tse__FindMetadataResponse, sizeof(struct _tse__FindMetadataResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__FindMetadataResponse * SOAP_FMAC4 soap_new__tse__FindMetadataResponse(struct soap *soap, int n)
{
	struct _tse__FindMetadataResponse *p;
	struct _tse__FindMetadataResponse *a = (struct _tse__FindMetadataResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__FindMetadataResponse));
	for (p = a; p && n--; p++)
		soap_default__tse__FindMetadataResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__FindMetadataResponse(struct soap *soap, const struct _tse__FindMetadataResponse *a, const char *tag, const char *type)
{
	if (soap_out__tse__FindMetadataResponse(soap, tag ? tag : "tse:FindMetadataResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindMetadataResponse * SOAP_FMAC4 soap_get__tse__FindMetadataResponse(struct soap *soap, struct _tse__FindMetadataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__FindMetadataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__FindMetadata(struct soap *soap, struct _tse__FindMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->StartPoint);
	a->EndPoint = NULL;
	a->Scope = NULL;
	a->MetadataFilter = NULL;
	a->MaxMatches = NULL;
	soap_default_xsd__duration(soap, &a->KeepAliveTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__FindMetadata(struct soap *soap, const struct _tse__FindMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->StartPoint, SOAP_TYPE_dateTime);
	soap_serialize_PointerTodateTime(soap, &a->EndPoint);
	soap_serialize_PointerTott__SearchScope(soap, &a->Scope);
	soap_serialize_PointerTott__MetadataFilter(soap, &a->MetadataFilter);
	soap_serialize_PointerToint(soap, &a->MaxMatches);
	soap_embedded(soap, &a->KeepAliveTime, SOAP_TYPE_xsd__duration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__FindMetadata(struct soap *soap, const char *tag, int id, const struct _tse__FindMetadata *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__FindMetadata), type))
		return soap->error;
	if (soap_out_dateTime(soap, "tse:StartPoint", -1, &a->StartPoint, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "tse:EndPoint", -1, &a->EndPoint, ""))
		return soap->error;
	if (!a->Scope)
	{	if (soap_element_nil(soap, "tse:Scope"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__SearchScope(soap, "tse:Scope", -1, &a->Scope, ""))
		return soap->error;
	if (!a->MetadataFilter)
	{	if (soap_element_nil(soap, "tse:MetadataFilter"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__MetadataFilter(soap, "tse:MetadataFilter", -1, &a->MetadataFilter, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MaxMatches", -1, &a->MaxMatches, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tse:KeepAliveTime", -1, &a->KeepAliveTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__FindMetadata * SOAP_FMAC4 soap_in__tse__FindMetadata(struct soap *soap, const char *tag, struct _tse__FindMetadata *a, const char *type)
{
	size_t soap_flag_StartPoint = 1;
	size_t soap_flag_EndPoint = 1;
	size_t soap_flag_Scope = 1;
	size_t soap_flag_MetadataFilter = 1;
	size_t soap_flag_MaxMatches = 1;
	size_t soap_flag_KeepAliveTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__FindMetadata *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__FindMetadata, sizeof(struct _tse__FindMetadata), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__FindMetadata(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StartPoint && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "tse:StartPoint", &a->StartPoint, "xsd:dateTime"))
				{	soap_flag_StartPoint--;
					continue;
				}
			if (soap_flag_EndPoint && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodateTime(soap, "tse:EndPoint", &a->EndPoint, "xsd:dateTime"))
				{	soap_flag_EndPoint--;
					continue;
				}
			if (soap_flag_Scope && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SearchScope(soap, "tse:Scope", &a->Scope, "tt:SearchScope"))
				{	soap_flag_Scope--;
					continue;
				}
			if (soap_flag_MetadataFilter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MetadataFilter(soap, "tse:MetadataFilter", &a->MetadataFilter, "tt:MetadataFilter"))
				{	soap_flag_MetadataFilter--;
					continue;
				}
			if (soap_flag_MaxMatches && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tse:MaxMatches", &a->MaxMatches, "xsd:int"))
				{	soap_flag_MaxMatches--;
					continue;
				}
			if (soap_flag_KeepAliveTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tse:KeepAliveTime", &a->KeepAliveTime, "xsd:duration"))
				{	soap_flag_KeepAliveTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StartPoint > 0 || soap_flag_Scope > 0 || soap_flag_MetadataFilter > 0 || soap_flag_KeepAliveTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__FindMetadata *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__FindMetadata, SOAP_TYPE__tse__FindMetadata, sizeof(struct _tse__FindMetadata), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__FindMetadata * SOAP_FMAC4 soap_new__tse__FindMetadata(struct soap *soap, int n)
{
	struct _tse__FindMetadata *p;
	struct _tse__FindMetadata *a = (struct _tse__FindMetadata*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__FindMetadata));
	for (p = a; p && n--; p++)
		soap_default__tse__FindMetadata(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__FindMetadata(struct soap *soap, const struct _tse__FindMetadata *a, const char *tag, const char *type)
{
	if (soap_out__tse__FindMetadata(soap, tag ? tag : "tse:FindMetadata", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindMetadata * SOAP_FMAC4 soap_get__tse__FindMetadata(struct soap *soap, struct _tse__FindMetadata *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__FindMetadata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetPTZPositionSearchResultsResponse(struct soap *soap, struct _tse__GetPTZPositionSearchResultsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ResultList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetPTZPositionSearchResultsResponse(struct soap *soap, const struct _tse__GetPTZPositionSearchResultsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__FindPTZPositionResultList(soap, &a->ResultList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetPTZPositionSearchResultsResponse(struct soap *soap, const char *tag, int id, const struct _tse__GetPTZPositionSearchResultsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetPTZPositionSearchResultsResponse), type))
		return soap->error;
	if (a->ResultList)
		soap_element_result(soap, "tse:ResultList");
	if (!a->ResultList)
	{	if (soap_element_nil(soap, "tse:ResultList"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__FindPTZPositionResultList(soap, "tse:ResultList", -1, &a->ResultList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetPTZPositionSearchResultsResponse * SOAP_FMAC4 soap_in__tse__GetPTZPositionSearchResultsResponse(struct soap *soap, const char *tag, struct _tse__GetPTZPositionSearchResultsResponse *a, const char *type)
{
	size_t soap_flag_ResultList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetPTZPositionSearchResultsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetPTZPositionSearchResultsResponse, sizeof(struct _tse__GetPTZPositionSearchResultsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetPTZPositionSearchResultsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FindPTZPositionResultList(soap, "tse:ResultList", &a->ResultList, "tt:FindPTZPositionResultList"))
				{	soap_flag_ResultList--;
					continue;
				}
			soap_check_result(soap, "tse:ResultList");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ResultList > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__GetPTZPositionSearchResultsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetPTZPositionSearchResultsResponse, SOAP_TYPE__tse__GetPTZPositionSearchResultsResponse, sizeof(struct _tse__GetPTZPositionSearchResultsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetPTZPositionSearchResultsResponse * SOAP_FMAC4 soap_new__tse__GetPTZPositionSearchResultsResponse(struct soap *soap, int n)
{
	struct _tse__GetPTZPositionSearchResultsResponse *p;
	struct _tse__GetPTZPositionSearchResultsResponse *a = (struct _tse__GetPTZPositionSearchResultsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetPTZPositionSearchResultsResponse));
	for (p = a; p && n--; p++)
		soap_default__tse__GetPTZPositionSearchResultsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetPTZPositionSearchResultsResponse(struct soap *soap, const struct _tse__GetPTZPositionSearchResultsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetPTZPositionSearchResultsResponse(soap, tag ? tag : "tse:GetPTZPositionSearchResultsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetPTZPositionSearchResultsResponse * SOAP_FMAC4 soap_get__tse__GetPTZPositionSearchResultsResponse(struct soap *soap, struct _tse__GetPTZPositionSearchResultsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetPTZPositionSearchResultsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetPTZPositionSearchResults(struct soap *soap, struct _tse__GetPTZPositionSearchResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__JobToken(soap, &a->SearchToken);
	a->MinResults = NULL;
	a->MaxResults = NULL;
	a->WaitTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetPTZPositionSearchResults(struct soap *soap, const struct _tse__GetPTZPositionSearchResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__JobToken(soap, (char*const*)&a->SearchToken);
	soap_serialize_PointerToint(soap, &a->MinResults);
	soap_serialize_PointerToint(soap, &a->MaxResults);
	soap_serialize_PointerToxsd__duration(soap, &a->WaitTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetPTZPositionSearchResults(struct soap *soap, const char *tag, int id, const struct _tse__GetPTZPositionSearchResults *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetPTZPositionSearchResults), type))
		return soap->error;
	if (!a->SearchToken)
	{	if (soap_element_nil(soap, "tse:SearchToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__JobToken(soap, "tse:SearchToken", -1, (char*const*)&a->SearchToken, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MinResults", -1, &a->MinResults, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MaxResults", -1, &a->MaxResults, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tse:WaitTime", -1, &a->WaitTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetPTZPositionSearchResults * SOAP_FMAC4 soap_in__tse__GetPTZPositionSearchResults(struct soap *soap, const char *tag, struct _tse__GetPTZPositionSearchResults *a, const char *type)
{
	size_t soap_flag_SearchToken = 1;
	size_t soap_flag_MinResults = 1;
	size_t soap_flag_MaxResults = 1;
	size_t soap_flag_WaitTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetPTZPositionSearchResults *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetPTZPositionSearchResults, sizeof(struct _tse__GetPTZPositionSearchResults), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetPTZPositionSearchResults(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__JobToken(soap, "tse:SearchToken", (char**)&a->SearchToken, "tt:JobToken"))
				{	soap_flag_SearchToken--;
					continue;
				}
			if (soap_flag_MinResults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tse:MinResults", &a->MinResults, "xsd:int"))
				{	soap_flag_MinResults--;
					continue;
				}
			if (soap_flag_MaxResults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tse:MaxResults", &a->MaxResults, "xsd:int"))
				{	soap_flag_MaxResults--;
					continue;
				}
			if (soap_flag_WaitTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__duration(soap, "tse:WaitTime", &a->WaitTime, "xsd:duration"))
				{	soap_flag_WaitTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__GetPTZPositionSearchResults *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetPTZPositionSearchResults, SOAP_TYPE__tse__GetPTZPositionSearchResults, sizeof(struct _tse__GetPTZPositionSearchResults), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetPTZPositionSearchResults * SOAP_FMAC4 soap_new__tse__GetPTZPositionSearchResults(struct soap *soap, int n)
{
	struct _tse__GetPTZPositionSearchResults *p;
	struct _tse__GetPTZPositionSearchResults *a = (struct _tse__GetPTZPositionSearchResults*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetPTZPositionSearchResults));
	for (p = a; p && n--; p++)
		soap_default__tse__GetPTZPositionSearchResults(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetPTZPositionSearchResults(struct soap *soap, const struct _tse__GetPTZPositionSearchResults *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetPTZPositionSearchResults(soap, tag ? tag : "tse:GetPTZPositionSearchResults", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetPTZPositionSearchResults * SOAP_FMAC4 soap_get__tse__GetPTZPositionSearchResults(struct soap *soap, struct _tse__GetPTZPositionSearchResults *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetPTZPositionSearchResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__FindPTZPositionResponse(struct soap *soap, struct _tse__FindPTZPositionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__JobToken(soap, &a->SearchToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__FindPTZPositionResponse(struct soap *soap, const struct _tse__FindPTZPositionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__JobToken(soap, (char*const*)&a->SearchToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__FindPTZPositionResponse(struct soap *soap, const char *tag, int id, const struct _tse__FindPTZPositionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__FindPTZPositionResponse), type))
		return soap->error;
	if (a->SearchToken)
		soap_element_result(soap, "tse:SearchToken");
	if (!a->SearchToken)
	{	if (soap_element_nil(soap, "tse:SearchToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__JobToken(soap, "tse:SearchToken", -1, (char*const*)&a->SearchToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__FindPTZPositionResponse * SOAP_FMAC4 soap_in__tse__FindPTZPositionResponse(struct soap *soap, const char *tag, struct _tse__FindPTZPositionResponse *a, const char *type)
{
	size_t soap_flag_SearchToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__FindPTZPositionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__FindPTZPositionResponse, sizeof(struct _tse__FindPTZPositionResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__FindPTZPositionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__JobToken(soap, "tse:SearchToken", (char**)&a->SearchToken, "tt:JobToken"))
				{	soap_flag_SearchToken--;
					continue;
				}
			soap_check_result(soap, "tse:SearchToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__FindPTZPositionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__FindPTZPositionResponse, SOAP_TYPE__tse__FindPTZPositionResponse, sizeof(struct _tse__FindPTZPositionResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__FindPTZPositionResponse * SOAP_FMAC4 soap_new__tse__FindPTZPositionResponse(struct soap *soap, int n)
{
	struct _tse__FindPTZPositionResponse *p;
	struct _tse__FindPTZPositionResponse *a = (struct _tse__FindPTZPositionResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__FindPTZPositionResponse));
	for (p = a; p && n--; p++)
		soap_default__tse__FindPTZPositionResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__FindPTZPositionResponse(struct soap *soap, const struct _tse__FindPTZPositionResponse *a, const char *tag, const char *type)
{
	if (soap_out__tse__FindPTZPositionResponse(soap, tag ? tag : "tse:FindPTZPositionResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindPTZPositionResponse * SOAP_FMAC4 soap_get__tse__FindPTZPositionResponse(struct soap *soap, struct _tse__FindPTZPositionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__FindPTZPositionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__FindPTZPosition(struct soap *soap, struct _tse__FindPTZPosition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->StartPoint);
	a->EndPoint = NULL;
	a->Scope = NULL;
	a->SearchFilter = NULL;
	a->MaxMatches = NULL;
	soap_default_xsd__duration(soap, &a->KeepAliveTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__FindPTZPosition(struct soap *soap, const struct _tse__FindPTZPosition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->StartPoint, SOAP_TYPE_dateTime);
	soap_serialize_PointerTodateTime(soap, &a->EndPoint);
	soap_serialize_PointerTott__SearchScope(soap, &a->Scope);
	soap_serialize_PointerTott__PTZPositionFilter(soap, &a->SearchFilter);
	soap_serialize_PointerToint(soap, &a->MaxMatches);
	soap_embedded(soap, &a->KeepAliveTime, SOAP_TYPE_xsd__duration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__FindPTZPosition(struct soap *soap, const char *tag, int id, const struct _tse__FindPTZPosition *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__FindPTZPosition), type))
		return soap->error;
	if (soap_out_dateTime(soap, "tse:StartPoint", -1, &a->StartPoint, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "tse:EndPoint", -1, &a->EndPoint, ""))
		return soap->error;
	if (!a->Scope)
	{	if (soap_element_nil(soap, "tse:Scope"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__SearchScope(soap, "tse:Scope", -1, &a->Scope, ""))
		return soap->error;
	if (!a->SearchFilter)
	{	if (soap_element_nil(soap, "tse:SearchFilter"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__PTZPositionFilter(soap, "tse:SearchFilter", -1, &a->SearchFilter, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MaxMatches", -1, &a->MaxMatches, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tse:KeepAliveTime", -1, &a->KeepAliveTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__FindPTZPosition * SOAP_FMAC4 soap_in__tse__FindPTZPosition(struct soap *soap, const char *tag, struct _tse__FindPTZPosition *a, const char *type)
{
	size_t soap_flag_StartPoint = 1;
	size_t soap_flag_EndPoint = 1;
	size_t soap_flag_Scope = 1;
	size_t soap_flag_SearchFilter = 1;
	size_t soap_flag_MaxMatches = 1;
	size_t soap_flag_KeepAliveTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__FindPTZPosition *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__FindPTZPosition, sizeof(struct _tse__FindPTZPosition), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__FindPTZPosition(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StartPoint && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "tse:StartPoint", &a->StartPoint, "xsd:dateTime"))
				{	soap_flag_StartPoint--;
					continue;
				}
			if (soap_flag_EndPoint && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodateTime(soap, "tse:EndPoint", &a->EndPoint, "xsd:dateTime"))
				{	soap_flag_EndPoint--;
					continue;
				}
			if (soap_flag_Scope && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SearchScope(soap, "tse:Scope", &a->Scope, "tt:SearchScope"))
				{	soap_flag_Scope--;
					continue;
				}
			if (soap_flag_SearchFilter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZPositionFilter(soap, "tse:SearchFilter", &a->SearchFilter, "tt:PTZPositionFilter"))
				{	soap_flag_SearchFilter--;
					continue;
				}
			if (soap_flag_MaxMatches && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tse:MaxMatches", &a->MaxMatches, "xsd:int"))
				{	soap_flag_MaxMatches--;
					continue;
				}
			if (soap_flag_KeepAliveTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tse:KeepAliveTime", &a->KeepAliveTime, "xsd:duration"))
				{	soap_flag_KeepAliveTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StartPoint > 0 || soap_flag_Scope > 0 || soap_flag_SearchFilter > 0 || soap_flag_KeepAliveTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__FindPTZPosition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__FindPTZPosition, SOAP_TYPE__tse__FindPTZPosition, sizeof(struct _tse__FindPTZPosition), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__FindPTZPosition * SOAP_FMAC4 soap_new__tse__FindPTZPosition(struct soap *soap, int n)
{
	struct _tse__FindPTZPosition *p;
	struct _tse__FindPTZPosition *a = (struct _tse__FindPTZPosition*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__FindPTZPosition));
	for (p = a; p && n--; p++)
		soap_default__tse__FindPTZPosition(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__FindPTZPosition(struct soap *soap, const struct _tse__FindPTZPosition *a, const char *tag, const char *type)
{
	if (soap_out__tse__FindPTZPosition(soap, tag ? tag : "tse:FindPTZPosition", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindPTZPosition * SOAP_FMAC4 soap_get__tse__FindPTZPosition(struct soap *soap, struct _tse__FindPTZPosition *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__FindPTZPosition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetEventSearchResultsResponse(struct soap *soap, struct _tse__GetEventSearchResultsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ResultList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetEventSearchResultsResponse(struct soap *soap, const struct _tse__GetEventSearchResultsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__FindEventResultList(soap, &a->ResultList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetEventSearchResultsResponse(struct soap *soap, const char *tag, int id, const struct _tse__GetEventSearchResultsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetEventSearchResultsResponse), type))
		return soap->error;
	if (a->ResultList)
		soap_element_result(soap, "tse:ResultList");
	if (!a->ResultList)
	{	if (soap_element_nil(soap, "tse:ResultList"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__FindEventResultList(soap, "tse:ResultList", -1, &a->ResultList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetEventSearchResultsResponse * SOAP_FMAC4 soap_in__tse__GetEventSearchResultsResponse(struct soap *soap, const char *tag, struct _tse__GetEventSearchResultsResponse *a, const char *type)
{
	size_t soap_flag_ResultList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetEventSearchResultsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetEventSearchResultsResponse, sizeof(struct _tse__GetEventSearchResultsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetEventSearchResultsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FindEventResultList(soap, "tse:ResultList", &a->ResultList, "tt:FindEventResultList"))
				{	soap_flag_ResultList--;
					continue;
				}
			soap_check_result(soap, "tse:ResultList");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ResultList > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__GetEventSearchResultsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetEventSearchResultsResponse, SOAP_TYPE__tse__GetEventSearchResultsResponse, sizeof(struct _tse__GetEventSearchResultsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetEventSearchResultsResponse * SOAP_FMAC4 soap_new__tse__GetEventSearchResultsResponse(struct soap *soap, int n)
{
	struct _tse__GetEventSearchResultsResponse *p;
	struct _tse__GetEventSearchResultsResponse *a = (struct _tse__GetEventSearchResultsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetEventSearchResultsResponse));
	for (p = a; p && n--; p++)
		soap_default__tse__GetEventSearchResultsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetEventSearchResultsResponse(struct soap *soap, const struct _tse__GetEventSearchResultsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetEventSearchResultsResponse(soap, tag ? tag : "tse:GetEventSearchResultsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetEventSearchResultsResponse * SOAP_FMAC4 soap_get__tse__GetEventSearchResultsResponse(struct soap *soap, struct _tse__GetEventSearchResultsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetEventSearchResultsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetEventSearchResults(struct soap *soap, struct _tse__GetEventSearchResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__JobToken(soap, &a->SearchToken);
	a->MinResults = NULL;
	a->MaxResults = NULL;
	a->WaitTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetEventSearchResults(struct soap *soap, const struct _tse__GetEventSearchResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__JobToken(soap, (char*const*)&a->SearchToken);
	soap_serialize_PointerToint(soap, &a->MinResults);
	soap_serialize_PointerToint(soap, &a->MaxResults);
	soap_serialize_PointerToxsd__duration(soap, &a->WaitTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetEventSearchResults(struct soap *soap, const char *tag, int id, const struct _tse__GetEventSearchResults *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetEventSearchResults), type))
		return soap->error;
	if (!a->SearchToken)
	{	if (soap_element_nil(soap, "tse:SearchToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__JobToken(soap, "tse:SearchToken", -1, (char*const*)&a->SearchToken, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MinResults", -1, &a->MinResults, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MaxResults", -1, &a->MaxResults, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tse:WaitTime", -1, &a->WaitTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetEventSearchResults * SOAP_FMAC4 soap_in__tse__GetEventSearchResults(struct soap *soap, const char *tag, struct _tse__GetEventSearchResults *a, const char *type)
{
	size_t soap_flag_SearchToken = 1;
	size_t soap_flag_MinResults = 1;
	size_t soap_flag_MaxResults = 1;
	size_t soap_flag_WaitTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetEventSearchResults *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetEventSearchResults, sizeof(struct _tse__GetEventSearchResults), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetEventSearchResults(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__JobToken(soap, "tse:SearchToken", (char**)&a->SearchToken, "tt:JobToken"))
				{	soap_flag_SearchToken--;
					continue;
				}
			if (soap_flag_MinResults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tse:MinResults", &a->MinResults, "xsd:int"))
				{	soap_flag_MinResults--;
					continue;
				}
			if (soap_flag_MaxResults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tse:MaxResults", &a->MaxResults, "xsd:int"))
				{	soap_flag_MaxResults--;
					continue;
				}
			if (soap_flag_WaitTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__duration(soap, "tse:WaitTime", &a->WaitTime, "xsd:duration"))
				{	soap_flag_WaitTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__GetEventSearchResults *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetEventSearchResults, SOAP_TYPE__tse__GetEventSearchResults, sizeof(struct _tse__GetEventSearchResults), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetEventSearchResults * SOAP_FMAC4 soap_new__tse__GetEventSearchResults(struct soap *soap, int n)
{
	struct _tse__GetEventSearchResults *p;
	struct _tse__GetEventSearchResults *a = (struct _tse__GetEventSearchResults*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetEventSearchResults));
	for (p = a; p && n--; p++)
		soap_default__tse__GetEventSearchResults(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetEventSearchResults(struct soap *soap, const struct _tse__GetEventSearchResults *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetEventSearchResults(soap, tag ? tag : "tse:GetEventSearchResults", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetEventSearchResults * SOAP_FMAC4 soap_get__tse__GetEventSearchResults(struct soap *soap, struct _tse__GetEventSearchResults *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetEventSearchResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__FindEventsResponse(struct soap *soap, struct _tse__FindEventsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__JobToken(soap, &a->SearchToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__FindEventsResponse(struct soap *soap, const struct _tse__FindEventsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__JobToken(soap, (char*const*)&a->SearchToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__FindEventsResponse(struct soap *soap, const char *tag, int id, const struct _tse__FindEventsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__FindEventsResponse), type))
		return soap->error;
	if (a->SearchToken)
		soap_element_result(soap, "tse:SearchToken");
	if (!a->SearchToken)
	{	if (soap_element_nil(soap, "tse:SearchToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__JobToken(soap, "tse:SearchToken", -1, (char*const*)&a->SearchToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__FindEventsResponse * SOAP_FMAC4 soap_in__tse__FindEventsResponse(struct soap *soap, const char *tag, struct _tse__FindEventsResponse *a, const char *type)
{
	size_t soap_flag_SearchToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__FindEventsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__FindEventsResponse, sizeof(struct _tse__FindEventsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__FindEventsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__JobToken(soap, "tse:SearchToken", (char**)&a->SearchToken, "tt:JobToken"))
				{	soap_flag_SearchToken--;
					continue;
				}
			soap_check_result(soap, "tse:SearchToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__FindEventsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__FindEventsResponse, SOAP_TYPE__tse__FindEventsResponse, sizeof(struct _tse__FindEventsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__FindEventsResponse * SOAP_FMAC4 soap_new__tse__FindEventsResponse(struct soap *soap, int n)
{
	struct _tse__FindEventsResponse *p;
	struct _tse__FindEventsResponse *a = (struct _tse__FindEventsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__FindEventsResponse));
	for (p = a; p && n--; p++)
		soap_default__tse__FindEventsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__FindEventsResponse(struct soap *soap, const struct _tse__FindEventsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tse__FindEventsResponse(soap, tag ? tag : "tse:FindEventsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindEventsResponse * SOAP_FMAC4 soap_get__tse__FindEventsResponse(struct soap *soap, struct _tse__FindEventsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__FindEventsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__EventFilter(struct soap *soap, struct tt__EventFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__EventFilter(struct soap *soap, const struct tt__EventFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EventFilter(struct soap *soap, const char *tag, int id, const struct tt__EventFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EventFilter), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__EventFilter * SOAP_FMAC4 soap_in_tt__EventFilter(struct soap *soap, const char *tag, struct tt__EventFilter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__EventFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EventFilter, sizeof(struct tt__EventFilter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__EventFilter(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__EventFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EventFilter, SOAP_TYPE_tt__EventFilter, sizeof(struct tt__EventFilter), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct tt__EventFilter * SOAP_FMAC4 soap_new_tt__EventFilter(struct soap *soap, int n)
{
	struct tt__EventFilter *p;
	struct tt__EventFilter *a = (struct tt__EventFilter*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct tt__EventFilter));
	for (p = a; p && n--; p++)
		soap_default_tt__EventFilter(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EventFilter(struct soap *soap, const struct tt__EventFilter *a, const char *tag, const char *type)
{
	if (soap_out_tt__EventFilter(soap, tag ? tag : "tt:EventFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EventFilter * SOAP_FMAC4 soap_get_tt__EventFilter(struct soap *soap, struct tt__EventFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EventFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__FindEvents(struct soap *soap, struct _tse__FindEvents *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_dateTime(soap, &a->StartPoint);
	a->EndPoint = NULL;
	a->Scope = NULL;
	a->SearchFilter = NULL;
	soap_default_xsd__boolean(soap, &a->IncludeStartState);
	a->MaxMatches = NULL;
	soap_default_xsd__duration(soap, &a->KeepAliveTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__FindEvents(struct soap *soap, const struct _tse__FindEvents *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->StartPoint, SOAP_TYPE_dateTime);
	soap_serialize_PointerTodateTime(soap, &a->EndPoint);
	soap_serialize_PointerTott__SearchScope(soap, &a->Scope);
	soap_serialize_PointerTott__EventFilter(soap, &a->SearchFilter);
	soap_embedded(soap, &a->IncludeStartState, SOAP_TYPE_xsd__boolean);
	soap_serialize_PointerToint(soap, &a->MaxMatches);
	soap_embedded(soap, &a->KeepAliveTime, SOAP_TYPE_xsd__duration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__FindEvents(struct soap *soap, const char *tag, int id, const struct _tse__FindEvents *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__FindEvents), type))
		return soap->error;
	if (soap_out_dateTime(soap, "tse:StartPoint", -1, &a->StartPoint, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "tse:EndPoint", -1, &a->EndPoint, ""))
		return soap->error;
	if (!a->Scope)
	{	if (soap_element_nil(soap, "tse:Scope"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__SearchScope(soap, "tse:Scope", -1, &a->Scope, ""))
		return soap->error;
	if (!a->SearchFilter)
	{	if (soap_element_nil(soap, "tse:SearchFilter"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__EventFilter(soap, "tse:SearchFilter", -1, &a->SearchFilter, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tse:IncludeStartState", -1, &a->IncludeStartState, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MaxMatches", -1, &a->MaxMatches, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tse:KeepAliveTime", -1, &a->KeepAliveTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__FindEvents * SOAP_FMAC4 soap_in__tse__FindEvents(struct soap *soap, const char *tag, struct _tse__FindEvents *a, const char *type)
{
	size_t soap_flag_StartPoint = 1;
	size_t soap_flag_EndPoint = 1;
	size_t soap_flag_Scope = 1;
	size_t soap_flag_SearchFilter = 1;
	size_t soap_flag_IncludeStartState = 1;
	size_t soap_flag_MaxMatches = 1;
	size_t soap_flag_KeepAliveTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__FindEvents *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__FindEvents, sizeof(struct _tse__FindEvents), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__FindEvents(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StartPoint && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_dateTime(soap, "tse:StartPoint", &a->StartPoint, "xsd:dateTime"))
				{	soap_flag_StartPoint--;
					continue;
				}
			if (soap_flag_EndPoint && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodateTime(soap, "tse:EndPoint", &a->EndPoint, "xsd:dateTime"))
				{	soap_flag_EndPoint--;
					continue;
				}
			if (soap_flag_Scope && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SearchScope(soap, "tse:Scope", &a->Scope, "tt:SearchScope"))
				{	soap_flag_Scope--;
					continue;
				}
			if (soap_flag_SearchFilter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__EventFilter(soap, "tse:SearchFilter", &a->SearchFilter, "tt:EventFilter"))
				{	soap_flag_SearchFilter--;
					continue;
				}
			if (soap_flag_IncludeStartState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tse:IncludeStartState", &a->IncludeStartState, "xsd:boolean"))
				{	soap_flag_IncludeStartState--;
					continue;
				}
			if (soap_flag_MaxMatches && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tse:MaxMatches", &a->MaxMatches, "xsd:int"))
				{	soap_flag_MaxMatches--;
					continue;
				}
			if (soap_flag_KeepAliveTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tse:KeepAliveTime", &a->KeepAliveTime, "xsd:duration"))
				{	soap_flag_KeepAliveTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StartPoint > 0 || soap_flag_Scope > 0 || soap_flag_SearchFilter > 0 || soap_flag_IncludeStartState > 0 || soap_flag_KeepAliveTime > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__FindEvents *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__FindEvents, SOAP_TYPE__tse__FindEvents, sizeof(struct _tse__FindEvents), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__FindEvents * SOAP_FMAC4 soap_new__tse__FindEvents(struct soap *soap, int n)
{
	struct _tse__FindEvents *p;
	struct _tse__FindEvents *a = (struct _tse__FindEvents*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__FindEvents));
	for (p = a; p && n--; p++)
		soap_default__tse__FindEvents(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__FindEvents(struct soap *soap, const struct _tse__FindEvents *a, const char *tag, const char *type)
{
	if (soap_out__tse__FindEvents(soap, tag ? tag : "tse:FindEvents", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindEvents * SOAP_FMAC4 soap_get__tse__FindEvents(struct soap *soap, struct _tse__FindEvents *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__FindEvents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetRecordingSearchResultsResponse(struct soap *soap, struct _tse__GetRecordingSearchResultsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ResultList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetRecordingSearchResultsResponse(struct soap *soap, const struct _tse__GetRecordingSearchResultsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__FindRecordingResultList(soap, &a->ResultList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetRecordingSearchResultsResponse(struct soap *soap, const char *tag, int id, const struct _tse__GetRecordingSearchResultsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetRecordingSearchResultsResponse), type))
		return soap->error;
	if (a->ResultList)
		soap_element_result(soap, "tse:ResultList");
	if (!a->ResultList)
	{	if (soap_element_nil(soap, "tse:ResultList"))
			return soap->error;
	}
	else
	if (soap_out_PointerTott__FindRecordingResultList(soap, "tse:ResultList", -1, &a->ResultList, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetRecordingSearchResultsResponse * SOAP_FMAC4 soap_in__tse__GetRecordingSearchResultsResponse(struct soap *soap, const char *tag, struct _tse__GetRecordingSearchResultsResponse *a, const char *type)
{
	size_t soap_flag_ResultList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetRecordingSearchResultsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetRecordingSearchResultsResponse, sizeof(struct _tse__GetRecordingSearchResultsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetRecordingSearchResultsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FindRecordingResultList(soap, "tse:ResultList", &a->ResultList, "tt:FindRecordingResultList"))
				{	soap_flag_ResultList--;
					continue;
				}
			soap_check_result(soap, "tse:ResultList");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ResultList > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingSearchResultsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetRecordingSearchResultsResponse, SOAP_TYPE__tse__GetRecordingSearchResultsResponse, sizeof(struct _tse__GetRecordingSearchResultsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetRecordingSearchResultsResponse * SOAP_FMAC4 soap_new__tse__GetRecordingSearchResultsResponse(struct soap *soap, int n)
{
	struct _tse__GetRecordingSearchResultsResponse *p;
	struct _tse__GetRecordingSearchResultsResponse *a = (struct _tse__GetRecordingSearchResultsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetRecordingSearchResultsResponse));
	for (p = a; p && n--; p++)
		soap_default__tse__GetRecordingSearchResultsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetRecordingSearchResultsResponse(struct soap *soap, const struct _tse__GetRecordingSearchResultsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetRecordingSearchResultsResponse(soap, tag ? tag : "tse:GetRecordingSearchResultsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingSearchResultsResponse * SOAP_FMAC4 soap_get__tse__GetRecordingSearchResultsResponse(struct soap *soap, struct _tse__GetRecordingSearchResultsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetRecordingSearchResultsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetRecordingSearchResults(struct soap *soap, struct _tse__GetRecordingSearchResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__JobToken(soap, &a->SearchToken);
	a->MinResults = NULL;
	a->MaxResults = NULL;
	a->WaitTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetRecordingSearchResults(struct soap *soap, const struct _tse__GetRecordingSearchResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__JobToken(soap, (char*const*)&a->SearchToken);
	soap_serialize_PointerToint(soap, &a->MinResults);
	soap_serialize_PointerToint(soap, &a->MaxResults);
	soap_serialize_PointerToxsd__duration(soap, &a->WaitTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetRecordingSearchResults(struct soap *soap, const char *tag, int id, const struct _tse__GetRecordingSearchResults *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetRecordingSearchResults), type))
		return soap->error;
	if (!a->SearchToken)
	{	if (soap_element_nil(soap, "tse:SearchToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__JobToken(soap, "tse:SearchToken", -1, (char*const*)&a->SearchToken, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MinResults", -1, &a->MinResults, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MaxResults", -1, &a->MaxResults, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tse:WaitTime", -1, &a->WaitTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetRecordingSearchResults * SOAP_FMAC4 soap_in__tse__GetRecordingSearchResults(struct soap *soap, const char *tag, struct _tse__GetRecordingSearchResults *a, const char *type)
{
	size_t soap_flag_SearchToken = 1;
	size_t soap_flag_MinResults = 1;
	size_t soap_flag_MaxResults = 1;
	size_t soap_flag_WaitTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetRecordingSearchResults *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetRecordingSearchResults, sizeof(struct _tse__GetRecordingSearchResults), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetRecordingSearchResults(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__JobToken(soap, "tse:SearchToken", (char**)&a->SearchToken, "tt:JobToken"))
				{	soap_flag_SearchToken--;
					continue;
				}
			if (soap_flag_MinResults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tse:MinResults", &a->MinResults, "xsd:int"))
				{	soap_flag_MinResults--;
					continue;
				}
			if (soap_flag_MaxResults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tse:MaxResults", &a->MaxResults, "xsd:int"))
				{	soap_flag_MaxResults--;
					continue;
				}
			if (soap_flag_WaitTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__duration(soap, "tse:WaitTime", &a->WaitTime, "xsd:duration"))
				{	soap_flag_WaitTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingSearchResults *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetRecordingSearchResults, SOAP_TYPE__tse__GetRecordingSearchResults, sizeof(struct _tse__GetRecordingSearchResults), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__GetRecordingSearchResults * SOAP_FMAC4 soap_new__tse__GetRecordingSearchResults(struct soap *soap, int n)
{
	struct _tse__GetRecordingSearchResults *p;
	struct _tse__GetRecordingSearchResults *a = (struct _tse__GetRecordingSearchResults*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__GetRecordingSearchResults));
	for (p = a; p && n--; p++)
		soap_default__tse__GetRecordingSearchResults(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetRecordingSearchResults(struct soap *soap, const struct _tse__GetRecordingSearchResults *a, const char *tag, const char *type)
{
	if (soap_out__tse__GetRecordingSearchResults(soap, tag ? tag : "tse:GetRecordingSearchResults", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingSearchResults * SOAP_FMAC4 soap_get__tse__GetRecordingSearchResults(struct soap *soap, struct _tse__GetRecordingSearchResults *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetRecordingSearchResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__FindRecordingsResponse(struct soap *soap, struct _tse__FindRecordingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__JobToken(soap, &a->SearchToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__FindRecordingsResponse(struct soap *soap, const struct _tse__FindRecordingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__JobToken(soap, (char*const*)&a->SearchToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__FindRecordingsResponse(struct soap *soap, const char *tag, int id, const struct _tse__FindRecordingsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__FindRecordingsResponse), type))
		return soap->error;
	if (a->SearchToken)
		soap_element_result(soap, "tse:SearchToken");
	if (!a->SearchToken)
	{	if (soap_element_nil(soap, "tse:SearchToken"))
			return soap->error;
	}
	else
	if (soap_out_tt__JobToken(soap, "tse:SearchToken", -1, (char*const*)&a->SearchToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__FindRecordingsResponse * SOAP_FMAC4 soap_in__tse__FindRecordingsResponse(struct soap *soap, const char *tag, struct _tse__FindRecordingsResponse *a, const char *type)
{
	size_t soap_flag_SearchToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__FindRecordingsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__FindRecordingsResponse, sizeof(struct _tse__FindRecordingsResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__FindRecordingsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__JobToken(soap, "tse:SearchToken", (char**)&a->SearchToken, "tt:JobToken"))
				{	soap_flag_SearchToken--;
					continue;
				}
			soap_check_result(soap, "tse:SearchToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchToken > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct _tse__FindRecordingsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__FindRecordingsResponse, SOAP_TYPE__tse__FindRecordingsResponse, sizeof(struct _tse__FindRecordingsResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct _tse__FindRecordingsResponse * SOAP_FMAC4 soap_new__tse__FindRecordingsResponse(struct soap *soap, int n)
{
	struct _tse__FindRecordingsResponse *p;
	struct _tse__FindRecordingsResponse *a = (struct _tse__FindRecordingsResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct _tse__FindRecordingsResponse));
	for (p = a; p && n--; p++)
		soap_default__tse__FindRecordingsResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__FindRecordingsResponse(struct soap *soap, const struct _tse__FindRecordingsResponse *a, const char *tag, const char *type)
{
	if (soap_out__tse__FindRecordingsResponse(soap, tag ? tag : "tse:FindRecordingsResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindRecordingsResponse * SOAP_FMAC4 soap_get__tse__FindRecordingsResponse(struct soap *soap, struct _tse__FindRecordingsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__FindRecordingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.c */
